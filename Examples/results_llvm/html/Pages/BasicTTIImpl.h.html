<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>BasicTTIImpl.h</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- BasicTTIImpl.h -------------------------------------------*- C++ -*-===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">/// \file</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">/// This file provides a helper that implements much of the TTI interface in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">/// terms of the target-independent code generator and TargetLowering</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">/// interfaces.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#ifndef LLVM_CODEGEN_BASICTTIIMPL_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#define LLVM_CODEGEN_BASICTTIIMPL_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/ADT/APInt.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/ADT/ArrayRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/ADT/BitVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/Analysis/LoopInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/Analysis/TargetTransformInfoImpl.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/CodeGen/ISDOpcodes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/CodeGen/MachineValueType.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/IR/BasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/IR/Constant.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/IR/Constants.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/IR/DataLayout.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/IR/DerivedTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include "llvm/IR/InstrTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include "llvm/IR/Instruction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include "llvm/IR/Intrinsics.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include "llvm/IR/Operator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">#include "llvm/IR/Type.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#include "llvm/IR/Value.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">#include "llvm/Support/Casting.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">#include "llvm/Support/ErrorHandling.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">#include "llvm/Support/MathExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">#include "llvm/Target/TargetMachine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">#include "llvm/Target/TargetOptions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">#include <limits></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">#include <optional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">class Function;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">class GlobalValue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">class LLVMContext;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">class ScalarEvolution;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">class SCEV;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">class TargetMachine;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">extern cl::opt<unsigned> PartialUnrollingThreshold;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">/// Base class which can be used to help build a TTI implementation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">/// This class provides as much implementation of the TTI interface as is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">/// possible using the target independent parts of the code generator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">/// In order to subclass it, your class must implement a getST() method to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">/// return the subtarget, and a getTLI() method to return the target lowering.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">/// We need these methods implemented in the derived class so that this class</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">/// doesn't have to duplicate storage for them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">class BasicTTIImplBase : public TargetTransformInfoImplCRTPBase<T> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">  using BaseT = TargetTransformInfoImplCRTPBase<T>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">  using TTI = TargetTransformInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">  /// Helper function to access this as a T.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="uncoveredLine">  T *thisT() { return static_cast<T *>(this); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">  /// Estimate a cost of Broadcast as an extract and sequence of insert</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">  /// operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="uncoveredLine">  InstructionCost getBroadcastShuffleOverhead(FixedVectorType *VTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">                                              TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="uncoveredLine">    InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">    // Broadcast cost is equal to the cost of extracting the zero'th element</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">    // plus the cost of inserting it into every element of the result vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="uncoveredLine">    Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">                                        CostKind, 0, nullptr, nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="uncoveredLine">    for (int i = 0, e = VTy->getNumElements(); i < e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="uncoveredLine">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, VTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">                                          CostKind, i, nullptr, nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="uncoveredLine">    return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">  /// Estimate a cost of shuffle as a sequence of extract and insert</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">  /// operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="uncoveredLine">  InstructionCost getPermuteShuffleOverhead(FixedVectorType *VTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">                                            TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="uncoveredLine">    InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">    // Shuffle cost is equal to the cost of extracting element from its argument</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">    // plus the cost of inserting them onto the result vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">    // e.g. <4 x float> has a mask of <0,5,2,7> i.e we need to extract from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">    // index 0 of first vector, index 1 of second vector,index 2 of first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">    // vector and finally index 3 of second vector and insert them at index</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">    // <0,1,2,3> of result vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="uncoveredLine">    for (int i = 0, e = VTy->getNumElements(); i < e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="uncoveredLine">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, VTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">                                          CostKind, i, nullptr, nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="uncoveredLine">      Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">                                          CostKind, i, nullptr, nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="uncoveredLine">    return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">  /// Estimate a cost of subvector extraction as a sequence of extract and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">  /// insert operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="uncoveredLine">  InstructionCost getExtractSubvectorOverhead(VectorType *VTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">                                              TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">                                              int Index,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">                                              FixedVectorType *SubVTy) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="uncoveredLine">    assert(VTy && SubVTy &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">           "Can only extract subvectors from vectors");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="uncoveredLine">    int NumSubElts = SubVTy->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="uncoveredLine">    assert((!isa<FixedVectorType>(VTy) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">            (Index + NumSubElts) <=</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">                (int)cast<FixedVectorType>(VTy)->getNumElements()) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">           "SK_ExtractSubvector index out of range");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="uncoveredLine">    InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">    // Subvector extraction cost is equal to the cost of extracting element from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">    // the source type plus the cost of inserting them into the result vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">    // type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="uncoveredLine">    for (int i = 0; i != NumSubElts; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="uncoveredLine">      Cost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="uncoveredLine">          thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="uncoveredLine">                                      CostKind, i + Index, nullptr, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="uncoveredLine">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, SubVTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="">                                          CostKind, i, nullptr, nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="uncoveredLine">    return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">  /// Estimate a cost of subvector insertion as a sequence of extract and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">  /// insert operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="uncoveredLine">  InstructionCost getInsertSubvectorOverhead(VectorType *VTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">                                             TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">                                             int Index,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">                                             FixedVectorType *SubVTy) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="uncoveredLine">    assert(VTy && SubVTy &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="">           "Can only insert subvectors into vectors");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="uncoveredLine">    int NumSubElts = SubVTy->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="uncoveredLine">    assert((!isa<FixedVectorType>(VTy) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">            (Index + NumSubElts) <=</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">                (int)cast<FixedVectorType>(VTy)->getNumElements()) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">           "SK_InsertSubvector index out of range");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="uncoveredLine">    InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">    // Subvector insertion cost is equal to the cost of extracting element from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">    // the source type plus the cost of inserting them into the result vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">    // type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="uncoveredLine">    for (int i = 0; i != NumSubElts; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="uncoveredLine">      Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, SubVTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">                                          CostKind, i, nullptr, nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="uncoveredLine">      Cost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="uncoveredLine">          thisT()->getVectorInstrCost(Instruction::InsertElement, VTy, CostKind,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="uncoveredLine">                                      i + Index, nullptr, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="uncoveredLine">    return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">  /// Local query method delegates up to T which *must* implement this!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="uncoveredLine">  const TargetSubtargetInfo *getST() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="uncoveredLine">    return static_cast<const T *>(this)->getST();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">  /// Local query method delegates up to T which *must* implement this!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="uncoveredLine">  const TargetLoweringBase *getTLI() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="uncoveredLine">    return static_cast<const T *>(this)->getTLI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="uncoveredLine">  static ISD::MemIndexedMode getISDIndexedMode(TTI::MemIndexedMode M) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="uncoveredLine">    switch (M) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="uncoveredLine">      case TTI::MIM_Unindexed:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="uncoveredLine">        return ISD::UNINDEXED;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="uncoveredLine">      case TTI::MIM_PreInc:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="uncoveredLine">        return ISD::PRE_INC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="uncoveredLine">      case TTI::MIM_PreDec:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="uncoveredLine">        return ISD::PRE_DEC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="uncoveredLine">      case TTI::MIM_PostInc:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="uncoveredLine">        return ISD::POST_INC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="uncoveredLine">      case TTI::MIM_PostDec:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="uncoveredLine">        return ISD::POST_DEC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="uncoveredLine">    llvm_unreachable("Unexpected MemIndexedMode");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="uncoveredLine">  InstructionCost getCommonMaskedMemoryOpCost(unsigned Opcode, Type *DataTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">                                              Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">                                              bool VariableMask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">                                              bool IsGatherScatter,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="">                                              TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">    // We cannot scalarize scalable vectors, so return Invalid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="uncoveredLine">    if (isa<ScalableVectorType>(DataTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="uncoveredLine">      return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="uncoveredLine">    auto *VT = cast<FixedVectorType>(DataTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">    // Assume the target does not have support for gather/scatter operations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">    // and provide a rough estimate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="">    // First, compute the cost of the individual memory operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="uncoveredLine">    InstructionCost AddrExtractCost =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">        IsGatherScatter</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="uncoveredLine">            ? getVectorInstrCost(Instruction::ExtractElement,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="uncoveredLine">                                 FixedVectorType::get(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="uncoveredLine">                                     PointerType::get(VT->getElementType(), 0),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">                                     VT->getNumElements()),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">                                 CostKind, -1, nullptr, nullptr)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">            : 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">    InstructionCost LoadCost =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="uncoveredLine">        VT->getNumElements() *</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="uncoveredLine">        (AddrExtractCost +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="uncoveredLine">         getMemoryOpCost(Opcode, VT->getElementType(), Alignment, 0, CostKind));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">    // Next, compute the cost of packing the result in a vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">    InstructionCost PackingCost =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">        getScalarizationOverhead(VT, Opcode != Instruction::Store,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">                                 Opcode == Instruction::Store, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="uncoveredLine">    InstructionCost ConditionalCost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="uncoveredLine">    if (VariableMask) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="">      // Compute the cost of conditionally executing the memory operations with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="">      // variable masks. This includes extracting the individual conditions, a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">      // branches and PHIs to combine the results.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">      // NOTE: Estimating the cost of conditionally executing the memory</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">      // operations accurately is quite difficult and the current solution</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">      // provides a very rough estimate only.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">      ConditionalCost =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="uncoveredLine">          VT->getNumElements() *</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">          (getVectorInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">               Instruction::ExtractElement,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="uncoveredLine">               FixedVectorType::get(Type::getInt1Ty(DataTy->getContext()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">                                    VT->getNumElements()),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="uncoveredLine">               CostKind, -1, nullptr, nullptr) +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="uncoveredLine">           getCFInstrCost(Instruction::Br, CostKind) +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">           getCFInstrCost(Instruction::PHI, CostKind));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="uncoveredLine">    return LoadCost + PackingCost + ConditionalCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="coveredLine">  explicit BasicTTIImplBase(const TargetMachine *TM, const DataLayout &DL)</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="coveredLine">      : BaseT(DL) {}</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="coveredLine">  virtual ~BasicTTIImplBase() = default;</td>
    <td>54</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">  using TargetTransformInfoImplBase::DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">  /// \name Scalar TTI Implementations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">  /// @{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="uncoveredLine">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="">                                      unsigned AddressSpace, Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">                                      unsigned *Fast) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="uncoveredLine">    EVT E = EVT::getIntegerVT(Context, BitWidth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="uncoveredLine">    return getTLI()->allowsMisalignedMemoryAccesses(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="uncoveredLine">        E, AddressSpace, Alignment, MachineMemOperand::MONone, Fast);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="coveredLine">  bool hasBranchDivergence(const Function *F = nullptr) { return false; }</td>
    <td>42</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="uncoveredLine">  bool isSourceOfDivergence(const Value *V) { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="uncoveredLine">  bool isAlwaysUniform(const Value *V) { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="uncoveredLine">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="uncoveredLine">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="uncoveredLine">  unsigned getFlatAddressSpace() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">    // Return an invalid address space.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="uncoveredLine">    return -1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="uncoveredLine">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">                                  Intrinsic::ID IID) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="uncoveredLine">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">    return getTLI()->getTargetMachine().isNoopAddrSpaceCast(FromAS, ToAS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="uncoveredLine">  unsigned getAssumedAddrSpace(const Value *V) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="uncoveredLine">    return getTLI()->getTargetMachine().getAssumedAddrSpace(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="uncoveredLine">  bool isSingleThreaded() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="uncoveredLine">    return getTLI()->getTargetMachine().Options.ThreadModel ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="uncoveredLine">           ThreadModel::Single;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">  std::pair<const Value *, unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="uncoveredLine">  getPredicatedAddrSpace(const Value *V) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="uncoveredLine">    return getTLI()->getTargetMachine().getPredicatedAddrSpace(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="uncoveredLine">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">                                          Value *NewV) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="uncoveredLine">  bool isLegalAddImmediate(int64_t imm) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="uncoveredLine">    return getTLI()->isLegalAddImmediate(imm);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="uncoveredLine">  bool isLegalICmpImmediate(int64_t imm) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">    return getTLI()->isLegalICmpImmediate(imm);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="uncoveredLine">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">                             bool HasBaseReg, int64_t Scale,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">                             unsigned AddrSpace, Instruction *I = nullptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="uncoveredLine">    TargetLoweringBase::AddrMode AM;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="uncoveredLine">    AM.BaseGV = BaseGV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="uncoveredLine">    AM.BaseOffs = BaseOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="uncoveredLine">    AM.HasBaseReg = HasBaseReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="uncoveredLine">    AM.Scale = Scale;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="uncoveredLine">    return getTLI()->isLegalAddressingMode(DL, AM, Ty, AddrSpace, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="uncoveredLine">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">                             Type *ScalarValTy) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="uncoveredLine">    auto &&IsSupportedByTarget = [this, ScalarMemTy, ScalarValTy](unsigned VF) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="uncoveredLine">      auto *SrcTy = FixedVectorType::get(ScalarMemTy, VF / 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="uncoveredLine">      EVT VT = getTLI()->getValueType(DL, SrcTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">      if (getTLI()->isOperationLegal(ISD::STORE, VT) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="uncoveredLine">          getTLI()->isOperationCustom(ISD::STORE, VT))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">      EVT ValVT =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="uncoveredLine">          getTLI()->getValueType(DL, FixedVectorType::get(ScalarValTy, VF / 2));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">      EVT LegalizedVT =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">          getTLI()->getTypeToTransformTo(ScalarMemTy->getContext(), VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">      return getTLI()->isTruncStoreLegal(LegalizedVT, ValVT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">    };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">    while (VF > 2 && IsSupportedByTarget(VF))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">      VF /= 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="uncoveredLine">    return VF;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="uncoveredLine">  bool isIndexedLoadLegal(TTI::MemIndexedMode M, Type *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">                          const DataLayout &DL) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="uncoveredLine">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="uncoveredLine">    return getTLI()->isIndexedLoadLegal(getISDIndexedMode(M), VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="uncoveredLine">  bool isIndexedStoreLegal(TTI::MemIndexedMode M, Type *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">                           const DataLayout &DL) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="uncoveredLine">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">    return getTLI()->isIndexedStoreLegal(getISDIndexedMode(M), VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">  bool isLSRCostLess(TTI::LSRCost C1, TTI::LSRCost C2) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="uncoveredLine">    return TargetTransformInfoImplBase::isLSRCostLess(C1, C2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="uncoveredLine">  bool isNumRegsMajorCostOfLSR() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="uncoveredLine">    return TargetTransformInfoImplBase::isNumRegsMajorCostOfLSR();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">  bool isProfitableLSRChainElement(Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="uncoveredLine">    return TargetTransformInfoImplBase::isProfitableLSRChainElement(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">                                       int64_t BaseOffset, bool HasBaseReg,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">                                       int64_t Scale, unsigned AddrSpace) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="uncoveredLine">    TargetLoweringBase::AddrMode AM;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="uncoveredLine">    AM.BaseGV = BaseGV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="uncoveredLine">    AM.BaseOffs = BaseOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="uncoveredLine">    AM.HasBaseReg = HasBaseReg;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="uncoveredLine">    AM.Scale = Scale;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="uncoveredLine">    if (getTLI()->isLegalAddressingMode(DL, AM, Ty, AddrSpace))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="uncoveredLine">      return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="uncoveredLine">    return -1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="uncoveredLine">  bool isTruncateFree(Type *Ty1, Type *Ty2) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="uncoveredLine">    return getTLI()->isTruncateFree(Ty1, Ty2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">  bool isProfitableToHoist(Instruction *I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="uncoveredLine">    return getTLI()->isProfitableToHoist(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="uncoveredLine">  bool useAA() const { return getST()->useAA(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="uncoveredLine">  bool isTypeLegal(Type *Ty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="uncoveredLine">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="uncoveredLine">    return getTLI()->isTypeLegal(VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="uncoveredLine">  unsigned getRegUsageForType(Type *Ty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="uncoveredLine">    EVT ETy = getTLI()->getValueType(DL, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="uncoveredLine">    return getTLI()->getNumRegisters(Ty->getContext(), ETy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="uncoveredLine">  InstructionCost getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">                             ArrayRef<const Value *> Operands, Type *AccessType,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">                             TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="uncoveredLine">    return BaseT::getGEPCost(PointeeType, Ptr, Operands, AccessType, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="uncoveredLine">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">                                            unsigned &JumpTableSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">                                            ProfileSummaryInfo *PSI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">                                            BlockFrequencyInfo *BFI) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">    /// Try to find the estimated number of clusters. Note that the number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">    /// clusters identified in this function could be different from the actual</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">    /// numbers found in lowering. This function ignore switches that are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">    /// lowered with a mix of jump table / bit test / BTree. This function was</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">    /// initially intended to be used when estimating the cost of switch in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">    /// inline cost heuristic, but it's a generic cost model to be used in other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">    /// places (e.g., in loop unrolling).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">    unsigned N = SI.getNumCases();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">    const DataLayout &DL = this->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">    JumpTableSize = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="uncoveredLine">    bool IsJTAllowed = TLI->areJTsAllowed(SI.getParent()->getParent());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">    // Early exit if both a jump table and bit test are not allowed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="uncoveredLine">    if (N < 1 || (!IsJTAllowed && DL.getIndexSizeInBits(0u) < N))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="uncoveredLine">      return N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="uncoveredLine">    APInt MaxCaseVal = SI.case_begin()->getCaseValue()->getValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="uncoveredLine">    APInt MinCaseVal = MaxCaseVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="uncoveredLine">    for (auto CI : SI.cases()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="uncoveredLine">      const APInt &CaseVal = CI.getCaseValue()->getValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="uncoveredLine">      if (CaseVal.sgt(MaxCaseVal))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="uncoveredLine">        MaxCaseVal = CaseVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="uncoveredLine">      if (CaseVal.slt(MinCaseVal))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="uncoveredLine">        MinCaseVal = CaseVal;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">    // Check if suitable for a bit test</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">    if (N <= DL.getIndexSizeInBits(0u)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">      SmallPtrSet<const BasicBlock *, 4> Dests;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="uncoveredLine">      for (auto I : SI.cases())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="uncoveredLine">        Dests.insert(I.getCaseSuccessor());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="uncoveredLine">      if (TLI->isSuitableForBitTests(Dests.size(), N, MinCaseVal, MaxCaseVal,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">                                     DL))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="uncoveredLine">        return 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">    // Check if suitable for a jump table.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="uncoveredLine">    if (IsJTAllowed) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="uncoveredLine">      if (N < 2 || N < TLI->getMinimumJumpTableEntries())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">        return N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="uncoveredLine">      uint64_t Range =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">          (MaxCaseVal - MinCaseVal)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="uncoveredLine">              .getLimitedValue(std::numeric_limits<uint64_t>::max() - 1) + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">      // Check whether a range of clusters is dense enough for a jump table</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="uncoveredLine">      if (TLI->isSuitableForJumpTable(&SI, N, Range, PSI, BFI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="uncoveredLine">        JumpTableSize = Range;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="uncoveredLine">        return 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="uncoveredLine">    return N;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="uncoveredLine">  bool shouldBuildLookupTables() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="uncoveredLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="uncoveredLine">    return TLI->isOperationLegalOrCustom(ISD::BR_JT, MVT::Other) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="uncoveredLine">           TLI->isOperationLegalOrCustom(ISD::BRIND, MVT::Other);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="uncoveredLine">  bool shouldBuildRelLookupTables() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="uncoveredLine">    const TargetMachine &TM = getTLI()->getTargetMachine();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="">    // If non-PIC mode, do not generate a relative lookup table.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="uncoveredLine">    if (!TM.isPositionIndependent())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">    /// Relative lookup table entries consist of 32-bit offsets.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">    /// Do not generate relative lookup tables for large code models</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="">    /// in 64-bit achitectures where 32-bit offsets might not be enough.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="uncoveredLine">    if (TM.getCodeModel() == CodeModel::Medium ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="uncoveredLine">        TM.getCodeModel() == CodeModel::Large)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="uncoveredLine">    Triple TargetTriple = TM.getTargetTriple();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="uncoveredLine">    if (!TargetTriple.isArch64Bit())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">    // TODO: Triggers issues on aarch64 on darwin, so temporarily disable it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">    // there.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="uncoveredLine">    if (TargetTriple.getArch() == Triple::aarch64 && TargetTriple.isOSDarwin())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="uncoveredLine">  bool haveFastSqrt(Type *Ty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="uncoveredLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="uncoveredLine">    EVT VT = TLI->getValueType(DL, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="uncoveredLine">    return TLI->isTypeLegal(VT) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="uncoveredLine">           TLI->isOperationLegalOrCustom(ISD::FSQRT, VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="uncoveredLine">  InstructionCost getFPOpCost(Type *Ty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">    // Check whether FADD is available, as a proxy for floating-point in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="">    // general.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="uncoveredLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">    EVT VT = TLI->getValueType(DL, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="uncoveredLine">    if (TLI->isOperationLegalOrCustomOrPromote(ISD::FADD, VT))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="uncoveredLine">      return TargetTransformInfo::TCC_Basic;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="uncoveredLine">    return TargetTransformInfo::TCC_Expensive;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="uncoveredLine">  unsigned getInliningThresholdMultiplier() const { return 1; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="uncoveredLine">  unsigned adjustInliningThreshold(const CallBase *CB) { return 0; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="uncoveredLine">  unsigned getCallerAllocaCost(const CallBase *CB, const AllocaInst *AI) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="uncoveredLine">  int getInlinerVectorBonusPercent() const { return 150; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="uncoveredLine">  void getUnrollingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">                               TTI::UnrollingPreferences &UP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">                               OptimizationRemarkEmitter *ORE) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">    // This unrolling functionality is target independent, but to provide some</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">    // motivation for its intended use, for x86:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">    // According to the Intel 64 and IA-32 Architectures Optimization Reference</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">    // Manual, Intel Core models and later have a loop stream detector (and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">    // associated uop queue) that can benefit from partial unrolling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">    // The relevant requirements are:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">    //  - The loop must have no more than 4 (8 for Nehalem and later) branches</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">    //    taken, and none of them may be calls.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">    //  - The loop can have no more than 18 (28 for Nehalem and later) uops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">    // According to the Software Optimization Guide for AMD Family 15h</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">    // Processors, models 30h-4fh (Steamroller and later) have a loop predictor</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">    // and loop buffer which can benefit from partial unrolling.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">    // The relevant requirements are:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">    //  - The loop must have fewer than 16 branches</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">    //  - The loop must have less than 40 uops in all executed loop branches</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">    // The number of taken branches in a loop is hard to estimate here, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">    // benchmarking has revealed that it is better not to be conservative when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">    // estimating the branch count. As a result, we'll ignore the branch limits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">    // until someone finds a case where it matters in practice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">    unsigned MaxOps;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="uncoveredLine">    const TargetSubtargetInfo *ST = getST();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="uncoveredLine">    if (PartialUnrollingThreshold.getNumOccurrences() > 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="uncoveredLine">      MaxOps = PartialUnrollingThreshold;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">    else if (ST->getSchedModel().LoopMicroOpBufferSize > 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="uncoveredLine">      MaxOps = ST->getSchedModel().LoopMicroOpBufferSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="">    // Scan the loop: don't unroll loops with calls.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="uncoveredLine">    for (BasicBlock *BB : L->blocks()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="uncoveredLine">      for (Instruction &I : *BB) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="uncoveredLine">        if (isa<CallInst>(I) || isa<InvokeInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="uncoveredLine">          if (const Function *F = cast<CallBase>(I).getCalledFunction()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="uncoveredLine">            if (!thisT()->isLoweredToCall(F))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="uncoveredLine">              continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">          if (ORE) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="uncoveredLine">            ORE->emit([&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="uncoveredLine">              return OptimizationRemark("TTI", "DontUnroll", L->getStartLoc(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="uncoveredLine">                                        L->getHeader())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="uncoveredLine">                     << "advising against unrolling the loop because it "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">                        "contains a "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="uncoveredLine">                     << ore::NV("Call", &I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">            });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="uncoveredLine">          return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="">    // Enable runtime and partial unrolling up to the specified size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">    // Enable using trip count upper bound to unroll loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">    UP.Partial = UP.Runtime = UP.UpperBound = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">    UP.PartialThreshold = MaxOps;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">    // Avoid unrolling when optimizing for size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="uncoveredLine">    UP.OptSizeThreshold = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="uncoveredLine">    UP.PartialOptSizeThreshold = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">    // Set number of instructions optimized when "back edge"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">    // becomes "fall through" to default value of 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="uncoveredLine">    UP.BEInsns = 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="uncoveredLine">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="">                             TTI::PeelingPreferences &PP) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="uncoveredLine">    PP.PeelCount = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="uncoveredLine">    PP.AllowPeeling = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="uncoveredLine">    PP.AllowLoopNestsPeeling = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="uncoveredLine">    PP.PeelProfiledIterations = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="uncoveredLine">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="">                                AssumptionCache &AC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">                                TargetLibraryInfo *LibInfo,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">                                HardwareLoopInfo &HWLoopInfo) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="uncoveredLine">    return BaseT::isHardwareLoopProfitable(L, SE, AC, LibInfo, HWLoopInfo);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="uncoveredLine">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="uncoveredLine">    return BaseT::preferPredicateOverEpilogue(TFI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">  TailFoldingStyle</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="uncoveredLine">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="uncoveredLine">    return BaseT::getPreferredTailFoldingStyle(IVUpdateMayOverflow);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="uncoveredLine">  std::optional<Instruction *> instCombineIntrinsic(InstCombiner &IC,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">                                               IntrinsicInst &II) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="uncoveredLine">    return BaseT::instCombineIntrinsic(IC, II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">  std::optional<Value *></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="uncoveredLine">  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">                                   APInt DemandedMask, KnownBits &Known,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">                                   bool &KnownBitsComputed) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="uncoveredLine">    return BaseT::simplifyDemandedUseBitsIntrinsic(IC, II, DemandedMask, Known,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="uncoveredLine">                                                   KnownBitsComputed);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="uncoveredLine">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">      APInt &UndefElts2, APInt &UndefElts3,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">          SimplifyAndSetOp) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="uncoveredLine">    return BaseT::simplifyDemandedVectorEltsIntrinsic(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">        IC, II, DemandedElts, UndefElts, UndefElts2, UndefElts3,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="uncoveredLine">        SimplifyAndSetOp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">  virtual std::optional<unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="uncoveredLine">  getCacheSize(TargetTransformInfo::CacheLevel Level) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">    return std::optional<unsigned>(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="uncoveredLine">        getST()->getCacheSize(static_cast<unsigned>(Level)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="">  virtual std::optional<unsigned></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="uncoveredLine">  getCacheAssociativity(TargetTransformInfo::CacheLevel Level) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">    std::optional<unsigned> TargetResult =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">        getST()->getCacheAssociativity(static_cast<unsigned>(Level));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="uncoveredLine">    if (TargetResult)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">      return TargetResult;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="uncoveredLine">    return BaseT::getCacheAssociativity(Level);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="uncoveredLine">  virtual unsigned getCacheLineSize() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="uncoveredLine">    return getST()->getCacheLineSize();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="uncoveredLine">  virtual unsigned getPrefetchDistance() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="uncoveredLine">    return getST()->getPrefetchDistance();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="uncoveredLine">  virtual unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">                                        unsigned NumStridedMemAccesses,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">                                        unsigned NumPrefetches,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">                                        bool HasCall) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="uncoveredLine">    return getST()->getMinPrefetchStride(NumMemAccesses, NumStridedMemAccesses,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="uncoveredLine">                                         NumPrefetches, HasCall);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="uncoveredLine">  virtual unsigned getMaxPrefetchIterationsAhead() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">    return getST()->getMaxPrefetchIterationsAhead();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="uncoveredLine">  virtual bool enableWritePrefetching() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="uncoveredLine">    return getST()->enableWritePrefetching();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="uncoveredLine">  virtual bool shouldPrefetchAddressSpace(unsigned AS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="uncoveredLine">    return getST()->shouldPrefetchAddressSpace(AS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">  /// @}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">  /// \name Vector TTI Implementations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">  /// @{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="uncoveredLine">  TypeSize getRegisterBitWidth(TargetTransformInfo::RegisterKind K) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="uncoveredLine">    return TypeSize::getFixed(32);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="uncoveredLine">  std::optional<unsigned> getMaxVScale() const { return std::nullopt; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="uncoveredLine">  std::optional<unsigned> getVScaleForTuning() const { return std::nullopt; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="uncoveredLine">  bool isVScaleKnownToBeAPowerOfTwo() const { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="">  /// Estimate the overhead of scalarizing an instruction. Insert and Extract</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">  /// are set if the demanded result elements need to be inserted and/or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="">  /// extracted from vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="uncoveredLine">  InstructionCost getScalarizationOverhead(VectorType *InTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="">                                           const APInt &DemandedElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">                                           bool Insert, bool Extract,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="">                                           TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">    /// FIXME: a bitfield is not a reasonable abstraction for talking about</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="">    /// which elements are needed from a scalable vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="uncoveredLine">    if (isa<ScalableVectorType>(InTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="uncoveredLine">      return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="uncoveredLine">    auto *Ty = cast<FixedVectorType>(InTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="uncoveredLine">    assert(DemandedElts.getBitWidth() == Ty->getNumElements() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">           "Vector size mismatch");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">    InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="uncoveredLine">    for (int i = 0, e = Ty->getNumElements(); i < e; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">      if (!DemandedElts[i])</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="uncoveredLine">      if (Insert)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="uncoveredLine">        Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">                                            CostKind, i, nullptr, nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="uncoveredLine">      if (Extract)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="uncoveredLine">        Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">                                            CostKind, i, nullptr, nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="uncoveredLine">    return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">  /// Helper wrapper for the DemandedElts variant of getScalarizationOverhead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="uncoveredLine">  InstructionCost getScalarizationOverhead(VectorType *InTy, bool Insert,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">                                           bool Extract,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">                                           TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="uncoveredLine">    if (isa<ScalableVectorType>(InTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="uncoveredLine">      return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="uncoveredLine">    auto *Ty = cast<FixedVectorType>(InTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="uncoveredLine">    APInt DemandedElts = APInt::getAllOnes(Ty->getNumElements());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="uncoveredLine">    return thisT()->getScalarizationOverhead(Ty, DemandedElts, Insert, Extract,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="uncoveredLine">                                             CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">  /// Estimate the overhead of scalarizing an instructions unique</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="">  /// non-constant operands. The (potentially vector) types to use for each of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="">  /// argument are passes via Tys.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="uncoveredLine">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">                                   ArrayRef<Type *> Tys,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="">                                   TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">    assert(Args.size() == Tys.size() && "Expected matching Args and Tys");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="uncoveredLine">    InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="uncoveredLine">    SmallPtrSet<const Value*, 4> UniqueOperands;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">    for (int I = 0, E = Args.size(); I != E; I++) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">      // Disregard things like metadata arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="uncoveredLine">      const Value *A = Args[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">      Type *Ty = Tys[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="uncoveredLine">      if (!Ty->isIntOrIntVectorTy() && !Ty->isFPOrFPVectorTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="uncoveredLine">          !Ty->isPtrOrPtrVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="uncoveredLine">      if (!isa<Constant>(A) && UniqueOperands.insert(A).second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">        if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="uncoveredLine">          Cost += getScalarizationOverhead(VecTy, /*Insert*/ false,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">                                           /*Extract*/ true, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">    return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">  /// Estimate the overhead of scalarizing the inputs and outputs of an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">  /// instruction, with return type RetTy and arguments Args of type Tys. If</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">  /// Args are unknown (empty), then the cost associated with one argument is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="">  /// added as a heuristic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">  InstructionCost getScalarizationOverhead(VectorType *RetTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">                                           ArrayRef<const Value *> Args,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">                                           ArrayRef<Type *> Tys,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">                                           TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">    InstructionCost Cost = getScalarizationOverhead(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="">        RetTy, /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="uncoveredLine">    if (!Args.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">      Cost += getOperandsScalarizationOverhead(Args, Tys, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">      // When no information on arguments is provided, we add the cost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">      // associated with one argument as a heuristic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="uncoveredLine">      Cost += getScalarizationOverhead(RetTy, /*Insert*/ false,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="">                                       /*Extract*/ true, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="uncoveredLine">    return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">  /// Estimate the cost of type-legalization and the legalized type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="uncoveredLine">  std::pair<InstructionCost, MVT> getTypeLegalizationCost(Type *Ty) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="uncoveredLine">    LLVMContext &C = Ty->getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="uncoveredLine">    EVT MTy = getTLI()->getValueType(DL, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">    InstructionCost Cost = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">    // We keep legalizing the type until we find a legal kind. We assume that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">    // the only operation that costs anything is the split. After splitting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">    // we need to handle two types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="uncoveredLine">    while (true) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">      TargetLoweringBase::LegalizeKind LK = getTLI()->getTypeConversion(C, MTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">      if (LK.first == TargetLoweringBase::TypeScalarizeScalableVector) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">        // Ensure we return a sensible simple VT here, since many callers of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="">        // this function require it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">        MVT VT = MTy.isSimple() ? MTy.getSimpleVT() : MVT::i64;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">        return std::make_pair(InstructionCost::getInvalid(), VT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="uncoveredLine">      if (LK.first == TargetLoweringBase::TypeLegal)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="uncoveredLine">        return std::make_pair(Cost, MTy.getSimpleVT());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="uncoveredLine">      if (LK.first == TargetLoweringBase::TypeSplitVector ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">          LK.first == TargetLoweringBase::TypeExpandInteger)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="uncoveredLine">        Cost *= 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="">      // Do not loop with f128 type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="uncoveredLine">      if (MTy == LK.second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="uncoveredLine">        return std::make_pair(Cost, MTy.getSimpleVT());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="">      // Keep legalizing the type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="uncoveredLine">      MTy = LK.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="uncoveredLine">  unsigned getMaxInterleaveFactor(ElementCount VF) { return 1; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">  InstructionCost getArithmeticInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">      TTI::OperandValueInfo Opd1Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="">      TTI::OperandValueInfo Opd2Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">      ArrayRef<const Value *> Args = ArrayRef<const Value *>(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">      const Instruction *CxtI = nullptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">    // Check if any of the operands are vector operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="uncoveredLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="uncoveredLine">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="uncoveredLine">    assert(ISD && "Invalid opcode");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="">    // TODO: Handle more cost kinds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="uncoveredLine">    if (CostKind != TTI::TCK_RecipThroughput)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="uncoveredLine">      return BaseT::getArithmeticInstrCost(Opcode, Ty, CostKind,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">                                           Opd1Info, Opd2Info,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="uncoveredLine">                                           Args, CxtI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="uncoveredLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="uncoveredLine">    bool IsFloat = Ty->isFPOrFPVectorTy();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">    // Assume that floating point arithmetic operations cost twice as much as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="">    // integer operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">    InstructionCost OpCost = (IsFloat ? 2 : 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="uncoveredLine">    if (TLI->isOperationLegalOrPromote(ISD, LT.second)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="">      // The operation is legal. Assume it costs 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="">      // TODO: Once we have extract/insert subvector cost we need to use them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="uncoveredLine">      return LT.first * OpCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="uncoveredLine">    if (!TLI->isOperationExpand(ISD, LT.second)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">      // If the operation is custom lowered, then assume that the code is twice</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">      // as expensive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="uncoveredLine">      return LT.first * 2 * OpCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">    // An 'Expand' of URem and SRem is special because it may default</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">    // to expanding the operation into a sequence of sub-operations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="">    // i.e. X % Y -> X-(X/Y)*Y.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="uncoveredLine">    if (ISD == ISD::UREM || ISD == ISD::SREM) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="uncoveredLine">      bool IsSigned = ISD == ISD::SREM;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="uncoveredLine">      if (TLI->isOperationLegalOrCustom(IsSigned ? ISD::SDIVREM : ISD::UDIVREM,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="uncoveredLine">                                        LT.second) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="uncoveredLine">          TLI->isOperationLegalOrCustom(IsSigned ? ISD::SDIV : ISD::UDIV,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="">                                        LT.second)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="uncoveredLine">        unsigned DivOpc = IsSigned ? Instruction::SDiv : Instruction::UDiv;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="uncoveredLine">        InstructionCost DivCost = thisT()->getArithmeticInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">            DivOpc, Ty, CostKind, Opd1Info, Opd2Info);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="">        InstructionCost MulCost =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="uncoveredLine">            thisT()->getArithmeticInstrCost(Instruction::Mul, Ty, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">        InstructionCost SubCost =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="uncoveredLine">            thisT()->getArithmeticInstrCost(Instruction::Sub, Ty, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="uncoveredLine">        return DivCost + MulCost + SubCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">    // We cannot scalarize scalable vectors, so return Invalid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="uncoveredLine">    if (isa<ScalableVectorType>(Ty))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="uncoveredLine">      return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="">    // Else, assume that we need to scalarize this op.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="">    // TODO: If one of the types get legalized by splitting, handle this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="">    // similarly to what getCastInstrCost() does.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">    if (auto *VTy = dyn_cast<FixedVectorType>(Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="uncoveredLine">      InstructionCost Cost = thisT()->getArithmeticInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="">          Opcode, VTy->getScalarType(), CostKind, Opd1Info, Opd2Info,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">          Args, CxtI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="">      // Return the cost of multiple scalar invocation plus the cost of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="">      // inserting and extracting the values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">      SmallVector<Type *> Tys(Args.size(), Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="uncoveredLine">      return getScalarizationOverhead(VTy, Args, Tys, CostKind) +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="uncoveredLine">             VTy->getNumElements() * Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">    // We don't know anything about this scalar instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="uncoveredLine">    return OpCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="uncoveredLine">  TTI::ShuffleKind improveShuffleKindFromMask(TTI::ShuffleKind Kind,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">                                              ArrayRef<int> Mask) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="uncoveredLine">    int Limit = Mask.size() * 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="uncoveredLine">    if (Mask.empty() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">        // Extra check required by isSingleSourceMaskImpl function (called by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">        // ShuffleVectorInst::isSingleSourceMask).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="uncoveredLine">        any_of(Mask, [Limit](int I) { return I >= Limit; }))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="uncoveredLine">      return Kind;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">    int Index;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="uncoveredLine">    switch (Kind) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="uncoveredLine">    case TTI::SK_PermuteSingleSrc:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="uncoveredLine">      if (ShuffleVectorInst::isReverseMask(Mask))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">        return TTI::SK_Reverse;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="uncoveredLine">      if (ShuffleVectorInst::isZeroEltSplatMask(Mask))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="uncoveredLine">        return TTI::SK_Broadcast;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="uncoveredLine">    case TTI::SK_PermuteTwoSrc:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="uncoveredLine">      if (ShuffleVectorInst::isSelectMask(Mask))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="uncoveredLine">        return TTI::SK_Select;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="uncoveredLine">      if (ShuffleVectorInst::isTransposeMask(Mask))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="uncoveredLine">        return TTI::SK_Transpose;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="uncoveredLine">      if (ShuffleVectorInst::isSpliceMask(Mask, Index))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="uncoveredLine">        return TTI::SK_Splice;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="uncoveredLine">    case TTI::SK_Select:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="">    case TTI::SK_Reverse:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="">    case TTI::SK_Broadcast:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="">    case TTI::SK_Transpose:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">    case TTI::SK_InsertSubvector:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">    case TTI::SK_ExtractSubvector:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="">    case TTI::SK_Splice:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="uncoveredLine">    return Kind;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="uncoveredLine">  InstructionCost getShuffleCost(TTI::ShuffleKind Kind, VectorType *Tp,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="">                                 ArrayRef<int> Mask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="">                                 TTI::TargetCostKind CostKind, int Index,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="">                                 VectorType *SubTp,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="">                                 ArrayRef<const Value *> Args = std::nullopt) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="uncoveredLine">    switch (improveShuffleKindFromMask(Kind, Mask)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="uncoveredLine">    case TTI::SK_Broadcast:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="uncoveredLine">      if (auto *FVT = dyn_cast<FixedVectorType>(Tp))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="uncoveredLine">        return getBroadcastShuffleOverhead(FVT, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="uncoveredLine">      return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="uncoveredLine">    case TTI::SK_Select:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="">    case TTI::SK_Splice:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">    case TTI::SK_Reverse:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="">    case TTI::SK_Transpose:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="">    case TTI::SK_PermuteSingleSrc:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">    case TTI::SK_PermuteTwoSrc:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="uncoveredLine">      if (auto *FVT = dyn_cast<FixedVectorType>(Tp))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="uncoveredLine">        return getPermuteShuffleOverhead(FVT, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="uncoveredLine">      return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">    case TTI::SK_ExtractSubvector:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="uncoveredLine">      return getExtractSubvectorOverhead(Tp, CostKind, Index,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="uncoveredLine">                                         cast<FixedVectorType>(SubTp));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="uncoveredLine">    case TTI::SK_InsertSubvector:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="uncoveredLine">      return getInsertSubvectorOverhead(Tp, CostKind, Index,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="uncoveredLine">                                        cast<FixedVectorType>(SubTp));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="uncoveredLine">    llvm_unreachable("Unknown TTI::ShuffleKind");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="uncoveredLine">  InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="">                                   TTI::CastContextHint CCH,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">                                   TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">                                   const Instruction *I = nullptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="uncoveredLine">    if (BaseT::getCastInstrCost(Opcode, Dst, Src, CCH, CostKind, I) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="uncoveredLine">      return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="uncoveredLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="uncoveredLine">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="uncoveredLine">    assert(ISD && "Invalid opcode");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="uncoveredLine">    std::pair<InstructionCost, MVT> SrcLT = getTypeLegalizationCost(Src);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="uncoveredLine">    std::pair<InstructionCost, MVT> DstLT = getTypeLegalizationCost(Dst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="uncoveredLine">    TypeSize SrcSize = SrcLT.second.getSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="uncoveredLine">    TypeSize DstSize = DstLT.second.getSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="uncoveredLine">    bool IntOrPtrSrc = Src->isIntegerTy() || Src->isPointerTy();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="uncoveredLine">    bool IntOrPtrDst = Dst->isIntegerTy() || Dst->isPointerTy();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="uncoveredLine">    switch (Opcode) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="uncoveredLine">    default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="uncoveredLine">    case Instruction::Trunc:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">      // Check for NOOP conversions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="uncoveredLine">      if (TLI->isTruncateFree(SrcLT.second, DstLT.second))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="uncoveredLine">        return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">      [[fallthrough]];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">    case Instruction::BitCast:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">      // Bitcast between types that are legalized to the same type are free and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">      // assume int to/from ptr of the same size is also free.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="uncoveredLine">      if (SrcLT.first == DstLT.first && IntOrPtrSrc == IntOrPtrDst &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="uncoveredLine">          SrcSize == DstSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">        return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="uncoveredLine">    case Instruction::FPExt:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="uncoveredLine">      if (I && getTLI()->isExtFree(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="uncoveredLine">        return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="uncoveredLine">    case Instruction::ZExt:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="uncoveredLine">      if (TLI->isZExtFree(SrcLT.second, DstLT.second))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="uncoveredLine">        return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">      [[fallthrough]];</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="">    case Instruction::SExt:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="uncoveredLine">      if (I && getTLI()->isExtFree(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="uncoveredLine">        return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="">      // If this is a zext/sext of a load, return 0 if the corresponding</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">      // extending load exists on target and the result type is legal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="uncoveredLine">      if (CCH == TTI::CastContextHint::Normal) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="uncoveredLine">        EVT ExtVT = EVT::getEVT(Dst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="uncoveredLine">        EVT LoadVT = EVT::getEVT(Src);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="uncoveredLine">        unsigned LType =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="uncoveredLine">          ((Opcode == Instruction::ZExt) ? ISD::ZEXTLOAD : ISD::SEXTLOAD);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="uncoveredLine">        if (DstLT.first == SrcLT.first &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="uncoveredLine">            TLI->isLoadExtLegal(LType, ExtVT, LoadVT))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="uncoveredLine">          return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="uncoveredLine">    case Instruction::AddrSpaceCast:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="uncoveredLine">      if (TLI->isFreeAddrSpaceCast(Src->getPointerAddressSpace(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">                                   Dst->getPointerAddressSpace()))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="uncoveredLine">        return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="uncoveredLine">    auto *SrcVTy = dyn_cast<VectorType>(Src);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="uncoveredLine">    auto *DstVTy = dyn_cast<VectorType>(Dst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">    // If the cast is marked as legal (or promote) then assume low cost.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="uncoveredLine">    if (SrcLT.first == DstLT.first &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="uncoveredLine">        TLI->isOperationLegalOrPromote(ISD, DstLT.second))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="uncoveredLine">      return SrcLT.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="">    // Handle scalar conversions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="uncoveredLine">    if (!SrcVTy && !DstVTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="">      // Just check the op cost. If the operation is legal then assume it costs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">      // 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="uncoveredLine">      if (!TLI->isOperationExpand(ISD, DstLT.second))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">        return 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">      // Assume that illegal scalar instruction are expensive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="uncoveredLine">      return 4;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="">    // Check vector-to-vector casts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="uncoveredLine">    if (DstVTy && SrcVTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="">      // If the cast is between same-sized registers, then the check is simple.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="uncoveredLine">      if (SrcLT.first == DstLT.first && SrcSize == DstSize) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">        // Assume that Zext is done using AND.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="uncoveredLine">        if (Opcode == Instruction::ZExt)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="uncoveredLine">          return SrcLT.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="">        // Assume that sext is done using SHL and SRA.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="uncoveredLine">        if (Opcode == Instruction::SExt)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="uncoveredLine">          return SrcLT.first * 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="">        // Just check the op cost. If the operation is legal then assume it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">        // costs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="">        // 1 and multiply by the type-legalization overhead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="uncoveredLine">        if (!TLI->isOperationExpand(ISD, DstLT.second))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="uncoveredLine">          return SrcLT.first * 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="">      // If we are legalizing by splitting, query the concrete TTI for the cost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="">      // of casting the original vector twice. We also need to factor in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="">      // cost of the split itself. Count that as 1, to be consistent with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="">      // getTypeLegalizationCost().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">      bool SplitSrc =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="uncoveredLine">          TLI->getTypeAction(Src->getContext(), TLI->getValueType(DL, Src)) ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="">          TargetLowering::TypeSplitVector;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="uncoveredLine">      bool SplitDst =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="uncoveredLine">          TLI->getTypeAction(Dst->getContext(), TLI->getValueType(DL, Dst)) ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">          TargetLowering::TypeSplitVector;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="uncoveredLine">      if ((SplitSrc || SplitDst) && SrcVTy->getElementCount().isVector() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="uncoveredLine">          DstVTy->getElementCount().isVector()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="uncoveredLine">        Type *SplitDstTy = VectorType::getHalfElementsVectorType(DstVTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="uncoveredLine">        Type *SplitSrcTy = VectorType::getHalfElementsVectorType(SrcVTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="uncoveredLine">        T *TTI = static_cast<T *>(this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="">        // If both types need to be split then the split is free.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="uncoveredLine">        InstructionCost SplitCost =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="uncoveredLine">            (!SplitSrc || !SplitDst) ? TTI->getVectorSplitCost() : 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="uncoveredLine">        return SplitCost +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="uncoveredLine">               (2 * TTI->getCastInstrCost(Opcode, SplitDstTy, SplitSrcTy, CCH,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="uncoveredLine">                                          CostKind, I));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">      // Scalarization cost is Invalid, can't assume any num elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="uncoveredLine">      if (isa<ScalableVectorType>(DstVTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="uncoveredLine">        return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="">      // In other cases where the source or destination are illegal, assume</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="">      // the operation will get scalarized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="uncoveredLine">      unsigned Num = cast<FixedVectorType>(DstVTy)->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="uncoveredLine">      InstructionCost Cost = thisT()->getCastInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="">          Opcode, Dst->getScalarType(), Src->getScalarType(), CCH, CostKind, I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">      // Return the cost of multiple scalar invocation plus the cost of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="">      // inserting and extracting the values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="uncoveredLine">      return getScalarizationOverhead(DstVTy, /*Insert*/ true, /*Extract*/ true,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="uncoveredLine">                                      CostKind) +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="uncoveredLine">             Num * Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">    // We already handled vector-to-vector and scalar-to-scalar conversions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="">    // This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">    // is where we handle bitcast between vectors and scalars. We need to assume</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">    //  that the conversion is scalarized in one way or another.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="uncoveredLine">    if (Opcode == Instruction::BitCast) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="">      // Illegal bitcasts are done by storing and loading from a stack slot.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="uncoveredLine">      return (SrcVTy ? getScalarizationOverhead(SrcVTy, /*Insert*/ false,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="">                                                /*Extract*/ true, CostKind)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">                     : 0) +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="uncoveredLine">             (DstVTy ? getScalarizationOverhead(DstVTy, /*Insert*/ true,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="">                                                /*Extract*/ false, CostKind)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="uncoveredLine">                     : 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="uncoveredLine">    llvm_unreachable("Unhandled cast");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="uncoveredLine">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="">                                           VectorType *VecTy, unsigned Index) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="uncoveredLine">    TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="uncoveredLine">    return thisT()->getVectorInstrCost(Instruction::ExtractElement, VecTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="uncoveredLine">                                       CostKind, Index, nullptr, nullptr) +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="uncoveredLine">           thisT()->getCastInstrCost(Opcode, Dst, VecTy->getElementType(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">                                     TTI::CastContextHint::None, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">  InstructionCost getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="">                                 const Instruction *I = nullptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="uncoveredLine">    return BaseT::getCFInstrCost(Opcode, CostKind, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">  InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="">                                     CmpInst::Predicate VecPred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="">                                     TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">                                     const Instruction *I = nullptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="uncoveredLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="uncoveredLine">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="uncoveredLine">    assert(ISD && "Invalid opcode");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">    // TODO: Handle other cost kinds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="uncoveredLine">    if (CostKind != TTI::TCK_RecipThroughput)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="uncoveredLine">      return BaseT::getCmpSelInstrCost(Opcode, ValTy, CondTy, VecPred, CostKind,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="uncoveredLine">                                       I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="">    // Selects on vectors are actually vector selects.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="uncoveredLine">    if (ISD == ISD::SELECT) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="uncoveredLine">      assert(CondTy && "CondTy must exist");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="uncoveredLine">      if (CondTy->isVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="uncoveredLine">        ISD = ISD::VSELECT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="uncoveredLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(ValTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="uncoveredLine">    if (!(ValTy->isVectorTy() && !LT.second.isVector()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">        !TLI->isOperationExpand(ISD, LT.second)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">      // The operation is legal. Assume it costs 1. Multiply</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">      // by the type-legalization overhead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="uncoveredLine">      return LT.first * 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">    // Otherwise, assume that the cast is scalarized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">    // TODO: If one of the types get legalized by splitting, handle this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="">    // similarly to what getCastInstrCost() does.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="uncoveredLine">    if (auto *ValVTy = dyn_cast<VectorType>(ValTy)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="uncoveredLine">      if (isa<ScalableVectorType>(ValTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="uncoveredLine">        return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="uncoveredLine">      unsigned Num = cast<FixedVectorType>(ValVTy)->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="uncoveredLine">      if (CondTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="uncoveredLine">        CondTy = CondTy->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="uncoveredLine">      InstructionCost Cost = thisT()->getCmpSelInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="">          Opcode, ValVTy->getScalarType(), CondTy, VecPred, CostKind, I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">      // Return the cost of multiple scalar invocation plus the cost of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">      // inserting and extracting the values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="uncoveredLine">      return getScalarizationOverhead(ValVTy, /*Insert*/ true,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="uncoveredLine">                                      /*Extract*/ false, CostKind) +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="uncoveredLine">             Num * Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="">    // Unknown scalar opcode.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="uncoveredLine">    return 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="uncoveredLine">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">                                     TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">                                     unsigned Index, Value *Op0, Value *Op1) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="uncoveredLine">    return getRegUsageForType(Val->getScalarType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="uncoveredLine">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="">                                     TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="">                                     unsigned Index) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="uncoveredLine">    Value *Op0 = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="uncoveredLine">    Value *Op1 = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="uncoveredLine">    if (auto *IE = dyn_cast<InsertElementInst>(&I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="uncoveredLine">      Op0 = IE->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="uncoveredLine">      Op1 = IE->getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="uncoveredLine">    return thisT()->getVectorInstrCost(I.getOpcode(), Val, CostKind, Index, Op0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="uncoveredLine">                                       Op1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="uncoveredLine">  InstructionCost getReplicationShuffleCost(Type *EltTy, int ReplicationFactor,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">                                            int VF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">                                            const APInt &DemandedDstElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">                                            TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="uncoveredLine">    assert(DemandedDstElts.getBitWidth() == (unsigned)VF * ReplicationFactor &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">           "Unexpected size of DemandedDstElts.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="uncoveredLine">    InstructionCost Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="uncoveredLine">    auto *SrcVT = FixedVectorType::get(EltTy, VF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="uncoveredLine">    auto *ReplicatedVT = FixedVectorType::get(EltTy, VF * ReplicationFactor);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">    // The Mask shuffling cost is extract all the elements of the Mask</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">    // and insert each of them Factor times into the wide vector:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">    // E.g. an interleaved group with factor 3:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="">    //    %mask = icmp ult <8 x i32> %vec1, %vec2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="">    //    %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="">    //        <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">    // The cost is estimated as extract all mask elements from the <8xi1> mask</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="">    // vector and insert them factor times into the <24xi1> shuffled mask</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="">    // vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="uncoveredLine">    APInt DemandedSrcElts = APIntOps::ScaleBitMask(DemandedDstElts, VF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="uncoveredLine">    Cost += thisT()->getScalarizationOverhead(SrcVT, DemandedSrcElts,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="">                                              /*Insert*/ false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="">                                              /*Extract*/ true, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="uncoveredLine">    Cost += thisT()->getScalarizationOverhead(ReplicatedVT, DemandedDstElts,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="">                                              /*Insert*/ true,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="">                                              /*Extract*/ false, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="uncoveredLine">    return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="uncoveredLine">  getMemoryOpCost(unsigned Opcode, Type *Src, MaybeAlign Alignment,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">                  unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">                  TTI::OperandValueInfo OpInfo = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">                  const Instruction *I = nullptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="uncoveredLine">    assert(!Src->isVoidTy() && "Invalid type");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">    // Assume types, such as structs, are expensive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="uncoveredLine">    if (getTLI()->getValueType(DL, Src,  true) == MVT::Other)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="uncoveredLine">      return 4;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="uncoveredLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Src);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="">    // Assuming that all loads of legal types cost 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="uncoveredLine">    InstructionCost Cost = LT.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="uncoveredLine">    if (CostKind != TTI::TCK_RecipThroughput)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="uncoveredLine">      return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="uncoveredLine">    const DataLayout &DL = this->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="uncoveredLine">    if (Src->isVectorTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">        // In practice it's not currently possible to have a change in lane</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">        // length for extending loads or truncating stores so both types should</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">        // have the same scalable property.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="uncoveredLine">        TypeSize::isKnownLT(DL.getTypeStoreSizeInBits(Src),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="uncoveredLine">                            LT.second.getSizeInBits())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">      // This is a vector load that legalizes to a larger type than the vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="">      // itself. Unless the corresponding extending load or truncating store is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">      // legal, then this will scalarize.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="uncoveredLine">      TargetLowering::LegalizeAction LA = TargetLowering::Expand;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="uncoveredLine">      EVT MemVT = getTLI()->getValueType(DL, Src);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="uncoveredLine">      if (Opcode == Instruction::Store)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="uncoveredLine">        LA = getTLI()->getTruncStoreAction(LT.second, MemVT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="uncoveredLine">        LA = getTLI()->getLoadExtAction(ISD::EXTLOAD, LT.second, MemVT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="uncoveredLine">      if (LA != TargetLowering::Legal && LA != TargetLowering::Custom) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="">        // This is a vector load/store for some illegal type that is scalarized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="">        // We must account for the cost of building or decomposing the vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="uncoveredLine">        Cost += getScalarizationOverhead(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="">            cast<VectorType>(Src), Opcode != Instruction::Store,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="">            Opcode == Instruction::Store, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="uncoveredLine">    return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="uncoveredLine">  InstructionCost getMaskedMemoryOpCost(unsigned Opcode, Type *DataTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">                                        Align Alignment, unsigned AddressSpace,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="">                                        TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="uncoveredLine">    return getCommonMaskedMemoryOpCost(Opcode, DataTy, Alignment, true, false,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="uncoveredLine">                                       CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="uncoveredLine">  InstructionCost getGatherScatterOpCost(unsigned Opcode, Type *DataTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="">                                         const Value *Ptr, bool VariableMask,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">                                         Align Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">                                         TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="">                                         const Instruction *I = nullptr) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="uncoveredLine">    return getCommonMaskedMemoryOpCost(Opcode, DataTy, Alignment, VariableMask,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="uncoveredLine">                                       true, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="uncoveredLine">  InstructionCost getInterleavedMemoryOpCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">      bool UseMaskForCond = false, bool UseMaskForGaps = false) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">    // We cannot scalarize scalable vectors, so return Invalid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="uncoveredLine">    if (isa<ScalableVectorType>(VecTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="uncoveredLine">      return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="uncoveredLine">    auto *VT = cast<FixedVectorType>(VecTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">    unsigned NumElts = VT->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="uncoveredLine">    assert(Factor > 1 && NumElts % Factor == 0 && "Invalid interleave factor");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="uncoveredLine">    unsigned NumSubElts = NumElts / Factor;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="uncoveredLine">    auto *SubVT = FixedVectorType::get(VT->getElementType(), NumSubElts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="">    // Firstly, the cost of load/store operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="uncoveredLine">    InstructionCost Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="uncoveredLine">    if (UseMaskForCond || UseMaskForGaps)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="uncoveredLine">      Cost = thisT()->getMaskedMemoryOpCost(Opcode, VecTy, Alignment,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="">                                            AddressSpace, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="uncoveredLine">      Cost = thisT()->getMemoryOpCost(Opcode, VecTy, Alignment, AddressSpace,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">                                      CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">    // Legalize the vector type, and get the legalized and unlegalized type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="">    // sizes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="uncoveredLine">    MVT VecTyLT = getTypeLegalizationCost(VecTy).second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="uncoveredLine">    unsigned VecTySize = thisT()->getDataLayout().getTypeStoreSize(VecTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="uncoveredLine">    unsigned VecTyLTSize = VecTyLT.getStoreSize();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="">    // Scale the cost of the memory operation by the fraction of legalized</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="">    // instructions that will actually be used. We shouldn't account for the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="">    // cost of dead instructions since they will be removed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="">    // E.g., An interleaved load of factor 8:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="">    //       %vec = load <16 x i64>, <16 x i64>* %ptr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="">    //       %v0 = shufflevector %vec, undef, <0, 8></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="">    // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="">    // used (those corresponding to elements [0:1] and [8:9] of the unlegalized</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">    // type). The other loads are unused.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="">    //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="">    // TODO: Note that legalization can turn masked loads/stores into unmasked</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="">    // (legalized) loads/stores. This can be reflected in the cost.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="uncoveredLine">    if (Cost.isValid() && VecTySize > VecTyLTSize) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="">      // The number of loads of a legal type it will take to represent a load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">      // of the unlegalized vector type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="uncoveredLine">      unsigned NumLegalInsts = divideCeil(VecTySize, VecTyLTSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="">      // The number of elements of the unlegalized type that correspond to a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">      // single legal instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="uncoveredLine">      unsigned NumEltsPerLegalInst = divideCeil(NumElts, NumLegalInsts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">      // Determine which legal instructions will be used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="uncoveredLine">      BitVector UsedInsts(NumLegalInsts, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="uncoveredLine">      for (unsigned Index : Indices)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="uncoveredLine">        for (unsigned Elt = 0; Elt < NumSubElts; ++Elt)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="uncoveredLine">          UsedInsts.set((Index + Elt * Factor) / NumEltsPerLegalInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="">      // Scale the cost of the load by the fraction of legal instructions that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="">      // will be used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="uncoveredLine">      Cost = divideCeil(UsedInsts.count() * *Cost.getValue(), NumLegalInsts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="">    // Then plus the cost of interleave operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="uncoveredLine">    assert(Indices.size() <= Factor &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="">           "Interleaved memory op has too many members");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="uncoveredLine">    const APInt DemandedAllSubElts = APInt::getAllOnes(NumSubElts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="uncoveredLine">    const APInt DemandedAllResultElts = APInt::getAllOnes(NumElts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="uncoveredLine">    APInt DemandedLoadStoreElts = APInt::getZero(NumElts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="uncoveredLine">    for (unsigned Index : Indices) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="uncoveredLine">      assert(Index < Factor && "Invalid index for interleaved memory op");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="uncoveredLine">      for (unsigned Elm = 0; Elm < NumSubElts; Elm++)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="uncoveredLine">        DemandedLoadStoreElts.setBit(Index + Elm * Factor);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="uncoveredLine">    if (Opcode == Instruction::Load) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="">      // The interleave cost is similar to extract sub vectors' elements</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="">      // from the wide vector, and insert them into sub vectors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="">      // E.g. An interleaved load of factor 2 (with one member of index 0):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="">      //      %vec = load <8 x i32>, <8 x i32>* %ptr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="">      //      %v0 = shuffle %vec, undef, <0, 2, 4, 6>         ; Index 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">      // The cost is estimated as extract elements at 0, 2, 4, 6 from the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="">      // <8 x i32> vector and insert them into a <4 x i32> vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="uncoveredLine">      InstructionCost InsSubCost = thisT()->getScalarizationOverhead(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="">          SubVT, DemandedAllSubElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">          /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="uncoveredLine">      Cost += Indices.size() * InsSubCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="uncoveredLine">      Cost += thisT()->getScalarizationOverhead(VT, DemandedLoadStoreElts,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="">                                                /*Insert*/ false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="">                                                /*Extract*/ true, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="">      // The interleave cost is extract elements from sub vectors, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="">      // insert them into the wide vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="">      // E.g. An interleaved store of factor 3 with 2 members at indices 0,1:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="">      // (using VF=4):</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="">      //    %v0_v1 = shuffle %v0, %v1, <0,4,undef,1,5,undef,2,6,undef,3,7,undef></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="">      //    %gaps.mask = <true, true, false, true, true, false,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="">      //                  true, true, false, true, true, false></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="">      //    call llvm.masked.store <12 x i32> %v0_v1, <12 x i32>* %ptr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="">      //                           i32 Align, <12 x i1> %gaps.mask</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="">      // The cost is estimated as extract all elements (of actual members,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="">      // excluding gaps) from both <4 x i32> vectors and insert into the <12 x</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="">      // i32> vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="uncoveredLine">      InstructionCost ExtSubCost = thisT()->getScalarizationOverhead(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="">          SubVT, DemandedAllSubElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="">          /*Insert*/ false, /*Extract*/ true, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="uncoveredLine">      Cost += ExtSubCost * Indices.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="uncoveredLine">      Cost += thisT()->getScalarizationOverhead(VT, DemandedLoadStoreElts,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="">                                                /*Insert*/ true,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="">                                                /*Extract*/ false, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="uncoveredLine">    if (!UseMaskForCond)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="uncoveredLine">      return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="uncoveredLine">    Type *I8Type = Type::getInt8Ty(VT->getContext());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="uncoveredLine">    Cost += thisT()->getReplicationShuffleCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">        I8Type, Factor, NumSubElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="">        UseMaskForGaps ? DemandedLoadStoreElts : DemandedAllResultElts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="">        CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="">    // The Gaps mask is invariant and created outside the loop, therefore the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="">    // cost of creating it is not accounted for here. However if we have both</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="">    // a MaskForGaps and some other mask that guards the execution of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="">    // memory access, we need to account for the cost of And-ing the two masks</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="">    // inside the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="uncoveredLine">    if (UseMaskForGaps) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="uncoveredLine">      auto *MaskVT = FixedVectorType::get(I8Type, NumElts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="uncoveredLine">      Cost += thisT()->getArithmeticInstrCost(BinaryOperator::And, MaskVT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="">                                              CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="uncoveredLine">    return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="">  /// Get intrinsic cost based on arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="uncoveredLine">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="">                                        TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="">    // Check for generically free intrinsics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="uncoveredLine">    if (BaseT::getIntrinsicInstrCost(ICA, CostKind) == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="uncoveredLine">      return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">    // Assume that target intrinsics are cheap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="uncoveredLine">    Intrinsic::ID IID = ICA.getID();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="uncoveredLine">    if (Function::isTargetIntrinsic(IID))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="uncoveredLine">      return TargetTransformInfo::TCC_Basic;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="uncoveredLine">    if (ICA.isTypeBasedOnly())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="uncoveredLine">      return getTypeBasedIntrinsicInstrCost(ICA, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="uncoveredLine">    Type *RetTy = ICA.getReturnType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="uncoveredLine">    ElementCount RetVF =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="uncoveredLine">        (RetTy->isVectorTy() ? cast<VectorType>(RetTy)->getElementCount()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="uncoveredLine">                             : ElementCount::getFixed(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="uncoveredLine">    const IntrinsicInst *I = ICA.getInst();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="uncoveredLine">    const SmallVectorImpl<const Value *> &Args = ICA.getArgs();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="uncoveredLine">    FastMathFlags FMF = ICA.getFlags();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="uncoveredLine">    switch (IID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="uncoveredLine">    default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="uncoveredLine">    case Intrinsic::powi:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="uncoveredLine">      if (auto *RHSC = dyn_cast<ConstantInt>(Args[1])) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="uncoveredLine">        bool ShouldOptForSize = I->getParent()->getParent()->hasOptSize();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="uncoveredLine">        if (getTLI()->isBeneficialToExpandPowI(RHSC->getSExtValue(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="">                                               ShouldOptForSize)) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="">          // The cost is modeled on the expansion performed by ExpandPowI in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">          // SelectionDAGBuilder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="uncoveredLine">          APInt Exponent = RHSC->getValue().abs();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="uncoveredLine">          unsigned ActiveBits = Exponent.getActiveBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="uncoveredLine">          unsigned PopCount = Exponent.popcount();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="uncoveredLine">          InstructionCost Cost = (ActiveBits + PopCount - 2) *</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="uncoveredLine">                                 thisT()->getArithmeticInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="">                                     Instruction::FMul, RetTy, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="uncoveredLine">          if (RHSC->isNegative())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="uncoveredLine">            Cost += thisT()->getArithmeticInstrCost(Instruction::FDiv, RetTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="">                                                    CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="uncoveredLine">          return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="uncoveredLine">        }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="uncoveredLine">    case Intrinsic::cttz:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="">      // FIXME: If necessary, this should go in target-specific overrides.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="uncoveredLine">      if (RetVF.isScalar() && getTLI()->isCheapToSpeculateCttz(RetTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="uncoveredLine">        return TargetTransformInfo::TCC_Basic;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="uncoveredLine">    case Intrinsic::ctlz:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="">      // FIXME: If necessary, this should go in target-specific overrides.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="uncoveredLine">      if (RetVF.isScalar() && getTLI()->isCheapToSpeculateCtlz(RetTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="uncoveredLine">        return TargetTransformInfo::TCC_Basic;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="uncoveredLine">    case Intrinsic::memcpy:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="uncoveredLine">      return thisT()->getMemcpyCost(ICA.getInst());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="uncoveredLine">    case Intrinsic::masked_scatter: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="uncoveredLine">      const Value *Mask = Args[3];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="uncoveredLine">      bool VarMask = !isa<Constant>(Mask);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="uncoveredLine">      Align Alignment = cast<ConstantInt>(Args[2])->getAlignValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="uncoveredLine">      return thisT()->getGatherScatterOpCost(Instruction::Store,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="uncoveredLine">                                             ICA.getArgTypes()[0], Args[1],</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="uncoveredLine">                                             VarMask, Alignment, CostKind, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="uncoveredLine">    case Intrinsic::masked_gather: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="uncoveredLine">      const Value *Mask = Args[2];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="uncoveredLine">      bool VarMask = !isa<Constant>(Mask);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="uncoveredLine">      Align Alignment = cast<ConstantInt>(Args[1])->getAlignValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="uncoveredLine">      return thisT()->getGatherScatterOpCost(Instruction::Load, RetTy, Args[0],</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="uncoveredLine">                                             VarMask, Alignment, CostKind, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="uncoveredLine">    case Intrinsic::experimental_stepvector: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="uncoveredLine">      if (isa<ScalableVectorType>(RetTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="uncoveredLine">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="">      // The cost of materialising a constant integer vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="uncoveredLine">      return TargetTransformInfo::TCC_Basic;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="uncoveredLine">    case Intrinsic::vector_extract: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="">      // FIXME: Handle case where a scalable vector is extracted from a scalable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="">      // vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="uncoveredLine">      if (isa<ScalableVectorType>(RetTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="uncoveredLine">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="uncoveredLine">      unsigned Index = cast<ConstantInt>(Args[1])->getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="uncoveredLine">      return thisT()->getShuffleCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="uncoveredLine">          TTI::SK_ExtractSubvector, cast<VectorType>(Args[0]->getType()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="uncoveredLine">          std::nullopt, CostKind, Index, cast<VectorType>(RetTy));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="uncoveredLine">    case Intrinsic::vector_insert: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="">      // FIXME: Handle case where a scalable vector is inserted into a scalable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">      // vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="uncoveredLine">      if (isa<ScalableVectorType>(Args[1]->getType()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="uncoveredLine">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="uncoveredLine">      unsigned Index = cast<ConstantInt>(Args[2])->getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="uncoveredLine">      return thisT()->getShuffleCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="uncoveredLine">          TTI::SK_InsertSubvector, cast<VectorType>(Args[0]->getType()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="uncoveredLine">          std::nullopt, CostKind, Index, cast<VectorType>(Args[1]->getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="uncoveredLine">    case Intrinsic::experimental_vector_reverse: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="uncoveredLine">      return thisT()->getShuffleCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="uncoveredLine">          TTI::SK_Reverse, cast<VectorType>(Args[0]->getType()), std::nullopt,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="uncoveredLine">          CostKind, 0, cast<VectorType>(RetTy));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="uncoveredLine">    case Intrinsic::experimental_vector_splice: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="uncoveredLine">      unsigned Index = cast<ConstantInt>(Args[2])->getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="uncoveredLine">      return thisT()->getShuffleCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="uncoveredLine">          TTI::SK_Splice, cast<VectorType>(Args[0]->getType()), std::nullopt,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="uncoveredLine">          CostKind, Index, cast<VectorType>(RetTy));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_add:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="">    case Intrinsic::vector_reduce_mul:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="">    case Intrinsic::vector_reduce_and:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="">    case Intrinsic::vector_reduce_or:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="">    case Intrinsic::vector_reduce_xor:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="">    case Intrinsic::vector_reduce_smax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="">    case Intrinsic::vector_reduce_smin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="">    case Intrinsic::vector_reduce_fmax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="">    case Intrinsic::vector_reduce_fmin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="">    case Intrinsic::vector_reduce_fmaximum:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="">    case Intrinsic::vector_reduce_fminimum:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="">    case Intrinsic::vector_reduce_umax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="">    case Intrinsic::vector_reduce_umin: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="uncoveredLine">      IntrinsicCostAttributes Attrs(IID, RetTy, Args[0]->getType(), FMF, I, 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="uncoveredLine">      return getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_fadd:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="">    case Intrinsic::vector_reduce_fmul: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="uncoveredLine">      IntrinsicCostAttributes Attrs(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="uncoveredLine">          IID, RetTy, {Args[0]->getType(), Args[1]->getType()}, FMF, I, 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="uncoveredLine">      return getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="uncoveredLine">    case Intrinsic::fshl:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="">    case Intrinsic::fshr: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="uncoveredLine">      const Value *X = Args[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="uncoveredLine">      const Value *Y = Args[1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="uncoveredLine">      const Value *Z = Args[2];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="uncoveredLine">      const TTI::OperandValueInfo OpInfoX = TTI::getOperandInfo(X);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="uncoveredLine">      const TTI::OperandValueInfo OpInfoY = TTI::getOperandInfo(Y);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="uncoveredLine">      const TTI::OperandValueInfo OpInfoZ = TTI::getOperandInfo(Z);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="uncoveredLine">      const TTI::OperandValueInfo OpInfoBW =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="">        {TTI::OK_UniformConstantValue,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="uncoveredLine">         isPowerOf2_32(RetTy->getScalarSizeInBits()) ? TTI::OP_PowerOf2</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="">         : TTI::OP_None};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="">      // fshl: (X << (Z % BW)) | (Y >> (BW - (Z % BW)))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="">      // fshr: (X << (BW - (Z % BW))) | (Y >> (Z % BW))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="uncoveredLine">      InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="uncoveredLine">      Cost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="uncoveredLine">          thisT()->getArithmeticInstrCost(BinaryOperator::Or, RetTy, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="uncoveredLine">      Cost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="uncoveredLine">          thisT()->getArithmeticInstrCost(BinaryOperator::Sub, RetTy, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="uncoveredLine">      Cost += thisT()->getArithmeticInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="">          BinaryOperator::Shl, RetTy, CostKind, OpInfoX,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="uncoveredLine">          {OpInfoZ.Kind, TTI::OP_None});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="uncoveredLine">      Cost += thisT()->getArithmeticInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="">          BinaryOperator::LShr, RetTy, CostKind, OpInfoY,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="uncoveredLine">          {OpInfoZ.Kind, TTI::OP_None});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="">      // Non-constant shift amounts requires a modulo.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="uncoveredLine">      if (!OpInfoZ.isConstant())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="uncoveredLine">        Cost += thisT()->getArithmeticInstrCost(BinaryOperator::URem, RetTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="">                                                CostKind, OpInfoZ, OpInfoBW);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="">      // For non-rotates (X != Y) we must add shift-by-zero handling costs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="uncoveredLine">      if (X != Y) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="uncoveredLine">        Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="uncoveredLine">        Cost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="uncoveredLine">            thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="">                                        CmpInst::ICMP_EQ, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="uncoveredLine">        Cost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="uncoveredLine">            thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="">                                        CmpInst::ICMP_EQ, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="uncoveredLine">      return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="uncoveredLine">    case Intrinsic::get_active_lane_mask: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="uncoveredLine">      EVT ResVT = getTLI()->getValueType(DL, RetTy, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="uncoveredLine">      EVT ArgType = getTLI()->getValueType(DL, ICA.getArgTypes()[0], true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="">      // If we're not expanding the intrinsic then we assume this is cheap</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="">      // to implement.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="uncoveredLine">      if (!getTLI()->shouldExpandGetActiveLaneMask(ResVT, ArgType)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="uncoveredLine">        return getTypeLegalizationCost(RetTy).first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="">      // Create the expanded types that will be used to calculate the uadd_sat</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="">      // operation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="uncoveredLine">      Type *ExpRetTy = VectorType::get(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="uncoveredLine">          ICA.getArgTypes()[0], cast<VectorType>(RetTy)->getElementCount());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="uncoveredLine">      IntrinsicCostAttributes Attrs(Intrinsic::uadd_sat, ExpRetTy, {}, FMF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="">      InstructionCost Cost =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="uncoveredLine">          thisT()->getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="uncoveredLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, ExpRetTy, RetTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="">                                          CmpInst::ICMP_ULT, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="uncoveredLine">      return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="">    // Assume that we need to scalarize this intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="">    // Compute the scalarization overhead based on Args for a vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="">    // intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="uncoveredLine">    InstructionCost ScalarizationCost = InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="uncoveredLine">    if (RetVF.isVector() && !RetVF.isScalable()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="uncoveredLine">      ScalarizationCost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="uncoveredLine">      if (!RetTy->isVoidTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="uncoveredLine">        ScalarizationCost += getScalarizationOverhead(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="">            cast<VectorType>(RetTy),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="">            /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="uncoveredLine">      ScalarizationCost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="uncoveredLine">          getOperandsScalarizationOverhead(Args, ICA.getArgTypes(), CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="uncoveredLine">    IntrinsicCostAttributes Attrs(IID, RetTy, ICA.getArgTypes(), FMF, I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="">                                  ScalarizationCost);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="uncoveredLine">    return thisT()->getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="">  /// Get intrinsic cost based on argument types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="">  /// If ScalarizationCostPassed is std::numeric_limits<unsigned>::max(), the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="">  /// cost of scalarizing the arguments and the return value will be computed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="">  /// based on types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="">  InstructionCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="uncoveredLine">  getTypeBasedIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="">                                 TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="uncoveredLine">    Intrinsic::ID IID = ICA.getID();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="uncoveredLine">    Type *RetTy = ICA.getReturnType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="uncoveredLine">    const SmallVectorImpl<Type *> &Tys = ICA.getArgTypes();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="uncoveredLine">    FastMathFlags FMF = ICA.getFlags();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="uncoveredLine">    InstructionCost ScalarizationCostPassed = ICA.getScalarizationCost();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="uncoveredLine">    bool SkipScalarizationCost = ICA.skipScalarizationCost();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="uncoveredLine">    VectorType *VecOpTy = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="uncoveredLine">    if (!Tys.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="">      // The vector reduction operand is operand 0 except for fadd/fmul.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="">      // Their operand 0 is a scalar start value, so the vector op is operand 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="uncoveredLine">      unsigned VecTyIndex = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="uncoveredLine">      if (IID == Intrinsic::vector_reduce_fadd ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="">          IID == Intrinsic::vector_reduce_fmul)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="uncoveredLine">        VecTyIndex = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="uncoveredLine">      assert(Tys.size() > VecTyIndex && "Unexpected IntrinsicCostAttributes");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="uncoveredLine">      VecOpTy = dyn_cast<VectorType>(Tys[VecTyIndex]);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="">    // Library call cost - other than size, make it expensive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="uncoveredLine">    unsigned SingleCallCost = CostKind == TTI::TCK_CodeSize ? 1 : 10;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="uncoveredLine">    unsigned ISD = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="uncoveredLine">    switch (IID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="uncoveredLine">    default: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="">      // Scalable vectors cannot be scalarized, so return Invalid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="uncoveredLine">      if (isa<ScalableVectorType>(RetTy) || any_of(Tys, [](const Type *Ty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="uncoveredLine">            return isa<ScalableVectorType>(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="">          }))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="uncoveredLine">        return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="">      // Assume that we need to scalarize this intrinsic.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="uncoveredLine">      InstructionCost ScalarizationCost =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="">          SkipScalarizationCost ? ScalarizationCostPassed : 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="uncoveredLine">      unsigned ScalarCalls = 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="uncoveredLine">      Type *ScalarRetTy = RetTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="uncoveredLine">      if (auto *RetVTy = dyn_cast<VectorType>(RetTy)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="uncoveredLine">        if (!SkipScalarizationCost)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="uncoveredLine">          ScalarizationCost = getScalarizationOverhead(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="">              RetVTy, /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="uncoveredLine">        ScalarCalls = std::max(ScalarCalls,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="uncoveredLine">                               cast<FixedVectorType>(RetVTy)->getNumElements());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="uncoveredLine">        ScalarRetTy = RetTy->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="uncoveredLine">      SmallVector<Type *, 4> ScalarTys;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="uncoveredLine">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="uncoveredLine">        Type *Ty = Tys[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="uncoveredLine">        if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="uncoveredLine">          if (!SkipScalarizationCost)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="uncoveredLine">            ScalarizationCost += getScalarizationOverhead(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="">                VTy, /*Insert*/ false, /*Extract*/ true, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="uncoveredLine">          ScalarCalls = std::max(ScalarCalls,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="uncoveredLine">                                 cast<FixedVectorType>(VTy)->getNumElements());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="uncoveredLine">          Ty = Ty->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="uncoveredLine">        ScalarTys.push_back(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="uncoveredLine">      if (ScalarCalls == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="uncoveredLine">        return 1; // Return cost of a scalar intrinsic. Assume it to be cheap.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="uncoveredLine">      IntrinsicCostAttributes ScalarAttrs(IID, ScalarRetTy, ScalarTys, FMF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="">      InstructionCost ScalarCost =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="uncoveredLine">          thisT()->getIntrinsicInstrCost(ScalarAttrs, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="uncoveredLine">      return ScalarCalls * ScalarCost + ScalarizationCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="">    // Look for intrinsics that can be lowered directly or turned into a scalar</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="">    // intrinsic call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="uncoveredLine">    case Intrinsic::sqrt:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="uncoveredLine">      ISD = ISD::FSQRT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="uncoveredLine">    case Intrinsic::sin:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="uncoveredLine">      ISD = ISD::FSIN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="uncoveredLine">    case Intrinsic::cos:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="uncoveredLine">      ISD = ISD::FCOS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="uncoveredLine">    case Intrinsic::exp:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="uncoveredLine">      ISD = ISD::FEXP;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="uncoveredLine">    case Intrinsic::exp2:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="uncoveredLine">      ISD = ISD::FEXP2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="uncoveredLine">    case Intrinsic::log:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="uncoveredLine">      ISD = ISD::FLOG;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="uncoveredLine">    case Intrinsic::log10:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="uncoveredLine">      ISD = ISD::FLOG10;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="uncoveredLine">    case Intrinsic::log2:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="uncoveredLine">      ISD = ISD::FLOG2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="uncoveredLine">    case Intrinsic::fabs:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="uncoveredLine">      ISD = ISD::FABS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="uncoveredLine">    case Intrinsic::canonicalize:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="uncoveredLine">      ISD = ISD::FCANONICALIZE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="uncoveredLine">    case Intrinsic::minnum:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="uncoveredLine">      ISD = ISD::FMINNUM;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="uncoveredLine">    case Intrinsic::maxnum:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="uncoveredLine">      ISD = ISD::FMAXNUM;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="uncoveredLine">    case Intrinsic::minimum:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="uncoveredLine">      ISD = ISD::FMINIMUM;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="uncoveredLine">    case Intrinsic::maximum:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="uncoveredLine">      ISD = ISD::FMAXIMUM;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="uncoveredLine">    case Intrinsic::copysign:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="uncoveredLine">      ISD = ISD::FCOPYSIGN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="uncoveredLine">    case Intrinsic::floor:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="uncoveredLine">      ISD = ISD::FFLOOR;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="uncoveredLine">    case Intrinsic::ceil:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="uncoveredLine">      ISD = ISD::FCEIL;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="uncoveredLine">    case Intrinsic::trunc:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="uncoveredLine">      ISD = ISD::FTRUNC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="uncoveredLine">    case Intrinsic::nearbyint:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="uncoveredLine">      ISD = ISD::FNEARBYINT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="uncoveredLine">    case Intrinsic::rint:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="uncoveredLine">      ISD = ISD::FRINT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="uncoveredLine">    case Intrinsic::round:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="uncoveredLine">      ISD = ISD::FROUND;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="uncoveredLine">    case Intrinsic::roundeven:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="uncoveredLine">      ISD = ISD::FROUNDEVEN;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="uncoveredLine">    case Intrinsic::pow:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="uncoveredLine">      ISD = ISD::FPOW;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="uncoveredLine">    case Intrinsic::fma:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="uncoveredLine">      ISD = ISD::FMA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="uncoveredLine">    case Intrinsic::fmuladd:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="uncoveredLine">      ISD = ISD::FMA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="uncoveredLine">    case Intrinsic::experimental_constrained_fmuladd:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="uncoveredLine">      ISD = ISD::STRICT_FMA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="">    // FIXME: We should return 0 whenever getIntrinsicCost == TCC_Free.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="uncoveredLine">    case Intrinsic::lifetime_start:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">    case Intrinsic::lifetime_end:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="">    case Intrinsic::sideeffect:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="">    case Intrinsic::pseudoprobe:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="">    case Intrinsic::arithmetic_fence:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="uncoveredLine">      return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="uncoveredLine">    case Intrinsic::masked_store: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="uncoveredLine">      Type *Ty = Tys[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="uncoveredLine">      Align TyAlign = thisT()->DL.getABITypeAlign(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="uncoveredLine">      return thisT()->getMaskedMemoryOpCost(Instruction::Store, Ty, TyAlign, 0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="uncoveredLine">                                            CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="uncoveredLine">    case Intrinsic::masked_load: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="uncoveredLine">      Type *Ty = RetTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="uncoveredLine">      Align TyAlign = thisT()->DL.getABITypeAlign(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="uncoveredLine">      return thisT()->getMaskedMemoryOpCost(Instruction::Load, Ty, TyAlign, 0,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="uncoveredLine">                                            CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_add:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="uncoveredLine">      return thisT()->getArithmeticReductionCost(Instruction::Add, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="uncoveredLine">                                                 std::nullopt, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_mul:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="uncoveredLine">      return thisT()->getArithmeticReductionCost(Instruction::Mul, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="uncoveredLine">                                                 std::nullopt, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_and:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="uncoveredLine">      return thisT()->getArithmeticReductionCost(Instruction::And, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="uncoveredLine">                                                 std::nullopt, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_or:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="uncoveredLine">      return thisT()->getArithmeticReductionCost(Instruction::Or, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="uncoveredLine">                                                 std::nullopt, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_xor:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="uncoveredLine">      return thisT()->getArithmeticReductionCost(Instruction::Xor, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="uncoveredLine">                                                 std::nullopt, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_fadd:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="uncoveredLine">      return thisT()->getArithmeticReductionCost(Instruction::FAdd, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="uncoveredLine">                                                 FMF, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_fmul:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="uncoveredLine">      return thisT()->getArithmeticReductionCost(Instruction::FMul, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="uncoveredLine">                                                 FMF, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_smax:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="uncoveredLine">      return thisT()->getMinMaxReductionCost(Intrinsic::smax, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="uncoveredLine">                                             ICA.getFlags(), CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_smin:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="uncoveredLine">      return thisT()->getMinMaxReductionCost(Intrinsic::smin, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="uncoveredLine">                                             ICA.getFlags(), CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_umax:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="uncoveredLine">      return thisT()->getMinMaxReductionCost(Intrinsic::umax, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="uncoveredLine">                                             ICA.getFlags(), CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_umin:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="uncoveredLine">      return thisT()->getMinMaxReductionCost(Intrinsic::umin, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="uncoveredLine">                                             ICA.getFlags(), CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_fmax:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="uncoveredLine">      return thisT()->getMinMaxReductionCost(Intrinsic::maxnum, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="uncoveredLine">                                             ICA.getFlags(), CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_fmin:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="uncoveredLine">      return thisT()->getMinMaxReductionCost(Intrinsic::minnum, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="uncoveredLine">                                             ICA.getFlags(), CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_fmaximum:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="uncoveredLine">      return thisT()->getMinMaxReductionCost(Intrinsic::maximum, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="uncoveredLine">                                             ICA.getFlags(), CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="uncoveredLine">    case Intrinsic::vector_reduce_fminimum:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="uncoveredLine">      return thisT()->getMinMaxReductionCost(Intrinsic::minimum, VecOpTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="uncoveredLine">                                             ICA.getFlags(), CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="uncoveredLine">    case Intrinsic::abs: {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="">      // abs(X) = select(icmp(X,0),X,sub(0,X))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="uncoveredLine">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="uncoveredLine">      CmpInst::Predicate Pred = CmpInst::ICMP_SGT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="uncoveredLine">      InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="uncoveredLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="">                                          Pred, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="uncoveredLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="">                                          Pred, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="">      // TODO: Should we add an OperandValueProperties::OP_Zero property?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="uncoveredLine">      Cost += thisT()->getArithmeticInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="">         BinaryOperator::Sub, RetTy, CostKind, {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="uncoveredLine">      return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="uncoveredLine">    case Intrinsic::smax:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="">    case Intrinsic::smin:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="">    case Intrinsic::umax:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="">    case Intrinsic::umin: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="">      // minmax(X,Y) = select(icmp(X,Y),X,Y)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="uncoveredLine">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="uncoveredLine">      bool IsUnsigned = IID == Intrinsic::umax || IID == Intrinsic::umin;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="uncoveredLine">      CmpInst::Predicate Pred =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="uncoveredLine">          IsUnsigned ? CmpInst::ICMP_UGT : CmpInst::ICMP_SGT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="uncoveredLine">      InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="uncoveredLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="">                                          Pred, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="uncoveredLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="">                                          Pred, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="uncoveredLine">      return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="uncoveredLine">    case Intrinsic::sadd_sat:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="">    case Intrinsic::ssub_sat: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="uncoveredLine">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="uncoveredLine">      Type *OpTy = StructType::create({RetTy, CondTy});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="uncoveredLine">      Intrinsic::ID OverflowOp = IID == Intrinsic::sadd_sat</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="uncoveredLine">                                     ? Intrinsic::sadd_with_overflow</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">                                     : Intrinsic::ssub_with_overflow;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="uncoveredLine">      CmpInst::Predicate Pred = CmpInst::ICMP_SGT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="">      // SatMax -> Overflow && SumDiff < 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="">      // SatMin -> Overflow && SumDiff >= 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="uncoveredLine">      InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="uncoveredLine">      IntrinsicCostAttributes Attrs(OverflowOp, OpTy, {RetTy, RetTy}, FMF,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="">                                    nullptr, ScalarizationCostPassed);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="uncoveredLine">      Cost += thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="uncoveredLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="">                                          Pred, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="uncoveredLine">      Cost += 2 * thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="">                                              CondTy, Pred, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="uncoveredLine">      return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="uncoveredLine">    case Intrinsic::uadd_sat:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="">    case Intrinsic::usub_sat: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="uncoveredLine">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="uncoveredLine">      Type *OpTy = StructType::create({RetTy, CondTy});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="uncoveredLine">      Intrinsic::ID OverflowOp = IID == Intrinsic::uadd_sat</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="uncoveredLine">                                     ? Intrinsic::uadd_with_overflow</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="">                                     : Intrinsic::usub_with_overflow;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="uncoveredLine">      InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="uncoveredLine">      IntrinsicCostAttributes Attrs(OverflowOp, OpTy, {RetTy, RetTy}, FMF,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="">                                    nullptr, ScalarizationCostPassed);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="uncoveredLine">      Cost += thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="uncoveredLine">      Cost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="uncoveredLine">          thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">                                      CmpInst::BAD_ICMP_PREDICATE, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="uncoveredLine">      return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="uncoveredLine">    case Intrinsic::smul_fix:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="">    case Intrinsic::umul_fix: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="uncoveredLine">      unsigned ExtSize = RetTy->getScalarSizeInBits() * 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="uncoveredLine">      Type *ExtTy = RetTy->getWithNewBitWidth(ExtSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="uncoveredLine">      unsigned ExtOp =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="uncoveredLine">          IID == Intrinsic::smul_fix ? Instruction::SExt : Instruction::ZExt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="uncoveredLine">      TTI::CastContextHint CCH = TTI::CastContextHint::None;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="uncoveredLine">      InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="uncoveredLine">      Cost += 2 * thisT()->getCastInstrCost(ExtOp, ExtTy, RetTy, CCH, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="uncoveredLine">      Cost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="uncoveredLine">          thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="uncoveredLine">      Cost += 2 * thisT()->getCastInstrCost(Instruction::Trunc, RetTy, ExtTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="">                                            CCH, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="uncoveredLine">      Cost += thisT()->getArithmeticInstrCost(Instruction::LShr, RetTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="">                                              CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="uncoveredLine">      Cost += thisT()->getArithmeticInstrCost(Instruction::Shl, RetTy, CostKind,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="uncoveredLine">      Cost += thisT()->getArithmeticInstrCost(Instruction::Or, RetTy, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="uncoveredLine">      return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="uncoveredLine">    case Intrinsic::sadd_with_overflow:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="">    case Intrinsic::ssub_with_overflow: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="uncoveredLine">      Type *SumTy = RetTy->getContainedType(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="uncoveredLine">      Type *OverflowTy = RetTy->getContainedType(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="uncoveredLine">      unsigned Opcode = IID == Intrinsic::sadd_with_overflow</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="uncoveredLine">                            ? BinaryOperator::Add</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="">                            : BinaryOperator::Sub;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="">      //   Add:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="">      //   Overflow -> (Result < LHS) ^ (RHS < 0)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="">      //   Sub:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="">      //   Overflow -> (Result < LHS) ^ (RHS > 0)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="uncoveredLine">      InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="uncoveredLine">      Cost += thisT()->getArithmeticInstrCost(Opcode, SumTy, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="uncoveredLine">      Cost += 2 * thisT()->getCmpSelInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="">                      Instruction::ICmp, SumTy, OverflowTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="">                      CmpInst::ICMP_SGT, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="uncoveredLine">      Cost += thisT()->getArithmeticInstrCost(BinaryOperator::Xor, OverflowTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="">                                              CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="uncoveredLine">      return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="uncoveredLine">    case Intrinsic::uadd_with_overflow:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="">    case Intrinsic::usub_with_overflow: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="uncoveredLine">      Type *SumTy = RetTy->getContainedType(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="uncoveredLine">      Type *OverflowTy = RetTy->getContainedType(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="uncoveredLine">      unsigned Opcode = IID == Intrinsic::uadd_with_overflow</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="uncoveredLine">                            ? BinaryOperator::Add</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="">                            : BinaryOperator::Sub;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="uncoveredLine">      CmpInst::Predicate Pred = IID == Intrinsic::uadd_with_overflow</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="uncoveredLine">                                    ? CmpInst::ICMP_ULT</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="">                                    : CmpInst::ICMP_UGT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="uncoveredLine">      InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="uncoveredLine">      Cost += thisT()->getArithmeticInstrCost(Opcode, SumTy, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="uncoveredLine">      Cost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="uncoveredLine">          thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, SumTy, OverflowTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="">                                      Pred, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="uncoveredLine">      return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="uncoveredLine">    case Intrinsic::smul_with_overflow:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="">    case Intrinsic::umul_with_overflow: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="uncoveredLine">      Type *MulTy = RetTy->getContainedType(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="uncoveredLine">      Type *OverflowTy = RetTy->getContainedType(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="uncoveredLine">      unsigned ExtSize = MulTy->getScalarSizeInBits() * 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="uncoveredLine">      Type *ExtTy = MulTy->getWithNewBitWidth(ExtSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="uncoveredLine">      bool IsSigned = IID == Intrinsic::smul_with_overflow;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="uncoveredLine">      unsigned ExtOp = IsSigned ? Instruction::SExt : Instruction::ZExt;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="uncoveredLine">      TTI::CastContextHint CCH = TTI::CastContextHint::None;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="uncoveredLine">      InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="uncoveredLine">      Cost += 2 * thisT()->getCastInstrCost(ExtOp, ExtTy, MulTy, CCH, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="uncoveredLine">      Cost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="uncoveredLine">          thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="uncoveredLine">      Cost += 2 * thisT()->getCastInstrCost(Instruction::Trunc, MulTy, ExtTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="">                                            CCH, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="uncoveredLine">      Cost += thisT()->getArithmeticInstrCost(Instruction::LShr, ExtTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="">                                              CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="uncoveredLine">      if (IsSigned)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="uncoveredLine">        Cost += thisT()->getArithmeticInstrCost(Instruction::AShr, MulTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="">                                                CostKind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="">                                                {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="">                                                {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="uncoveredLine">      Cost += thisT()->getCmpSelInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="">          BinaryOperator::ICmp, MulTy, OverflowTy, CmpInst::ICMP_NE, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="uncoveredLine">      return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="uncoveredLine">    case Intrinsic::fptosi_sat:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="">    case Intrinsic::fptoui_sat: {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="uncoveredLine">      if (Tys.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="uncoveredLine">      Type *FromTy = Tys[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="uncoveredLine">      bool IsSigned = IID == Intrinsic::fptosi_sat;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="uncoveredLine">      InstructionCost Cost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="uncoveredLine">      IntrinsicCostAttributes Attrs1(Intrinsic::minnum, FromTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="">                                     {FromTy, FromTy});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="uncoveredLine">      Cost += thisT()->getIntrinsicInstrCost(Attrs1, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="uncoveredLine">      IntrinsicCostAttributes Attrs2(Intrinsic::maxnum, FromTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="">                                     {FromTy, FromTy});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="uncoveredLine">      Cost += thisT()->getIntrinsicInstrCost(Attrs2, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="uncoveredLine">      Cost += thisT()->getCastInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="">          IsSigned ? Instruction::FPToSI : Instruction::FPToUI, RetTy, FromTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="">          TTI::CastContextHint::None, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="uncoveredLine">      if (IsSigned) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="uncoveredLine">        Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="uncoveredLine">        Cost += thisT()->getCmpSelInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="">            BinaryOperator::FCmp, FromTy, CondTy, CmpInst::FCMP_UNO, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="uncoveredLine">        Cost += thisT()->getCmpSelInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="">            BinaryOperator::Select, RetTy, CondTy, CmpInst::FCMP_UNO, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="uncoveredLine">      return Cost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="uncoveredLine">    case Intrinsic::ctpop:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="uncoveredLine">      ISD = ISD::CTPOP;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="">      // In case of legalization use TCC_Expensive. This is cheaper than a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="">      // library call but still not a cheap instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="uncoveredLine">      SingleCallCost = TargetTransformInfo::TCC_Expensive;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="uncoveredLine">    case Intrinsic::ctlz:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="uncoveredLine">      ISD = ISD::CTLZ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="uncoveredLine">    case Intrinsic::cttz:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="uncoveredLine">      ISD = ISD::CTTZ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="uncoveredLine">    case Intrinsic::bswap:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="uncoveredLine">      ISD = ISD::BSWAP;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="uncoveredLine">    case Intrinsic::bitreverse:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="uncoveredLine">      ISD = ISD::BITREVERSE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="uncoveredLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="uncoveredLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(RetTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="uncoveredLine">    if (TLI->isOperationLegalOrPromote(ISD, LT.second)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="uncoveredLine">      if (IID == Intrinsic::fabs && LT.second.isFloatingPoint() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="uncoveredLine">          TLI->isFAbsFree(LT.second)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="uncoveredLine">        return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="">      // The operation is legal. Assume it costs 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="">      // If the type is split to multiple registers, assume that there is some</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="">      // overhead to this.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="">      // TODO: Once we have extract/insert subvector cost we need to use them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="uncoveredLine">      if (LT.first > 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="uncoveredLine">        return (LT.first * 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="uncoveredLine">        return (LT.first * 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="uncoveredLine">    } else if (!TLI->isOperationExpand(ISD, LT.second)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="">      // If the operation is custom lowered then assume</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="">      // that the code is twice as expensive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="uncoveredLine">      return (LT.first * 2);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="">    // If we can't lower fmuladd into an FMA estimate the cost as a floating</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="">    // point mul followed by an add.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="uncoveredLine">    if (IID == Intrinsic::fmuladd)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="uncoveredLine">      return thisT()->getArithmeticInstrCost(BinaryOperator::FMul, RetTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="uncoveredLine">                                             CostKind) +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="uncoveredLine">             thisT()->getArithmeticInstrCost(BinaryOperator::FAdd, RetTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="uncoveredLine">                                             CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="uncoveredLine">    if (IID == Intrinsic::experimental_constrained_fmuladd) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="uncoveredLine">      IntrinsicCostAttributes FMulAttrs(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="">        Intrinsic::experimental_constrained_fmul, RetTy, Tys);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="uncoveredLine">      IntrinsicCostAttributes FAddAttrs(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="">        Intrinsic::experimental_constrained_fadd, RetTy, Tys);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="uncoveredLine">      return thisT()->getIntrinsicInstrCost(FMulAttrs, CostKind) +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="uncoveredLine">             thisT()->getIntrinsicInstrCost(FAddAttrs, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="">    // Else, assume that we need to scalarize this intrinsic. For math builtins</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="">    // this will emit a costly libcall, adding call overhead and spills. Make it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="">    // very expensive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="uncoveredLine">    if (auto *RetVTy = dyn_cast<VectorType>(RetTy)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="">      // Scalable vectors cannot be scalarized, so return Invalid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="uncoveredLine">      if (isa<ScalableVectorType>(RetTy) || any_of(Tys, [](const Type *Ty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="uncoveredLine">            return isa<ScalableVectorType>(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="">          }))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="uncoveredLine">        return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="uncoveredLine">      InstructionCost ScalarizationCost =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="">          SkipScalarizationCost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="">              ? ScalarizationCostPassed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="uncoveredLine">              : getScalarizationOverhead(RetVTy, /*Insert*/ true,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="">                                         /*Extract*/ false, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="uncoveredLine">      unsigned ScalarCalls = cast<FixedVectorType>(RetVTy)->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="uncoveredLine">      SmallVector<Type *, 4> ScalarTys;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="uncoveredLine">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="uncoveredLine">        Type *Ty = Tys[i];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="uncoveredLine">        if (Ty->isVectorTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="uncoveredLine">          Ty = Ty->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="uncoveredLine">        ScalarTys.push_back(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="uncoveredLine">      IntrinsicCostAttributes Attrs(IID, RetTy->getScalarType(), ScalarTys, FMF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="">      InstructionCost ScalarCost =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="uncoveredLine">          thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="uncoveredLine">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="uncoveredLine">        if (auto *VTy = dyn_cast<VectorType>(Tys[i])) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="uncoveredLine">          if (!ICA.skipScalarizationCost())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="uncoveredLine">            ScalarizationCost += getScalarizationOverhead(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="">                VTy, /*Insert*/ false, /*Extract*/ true, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="uncoveredLine">          ScalarCalls = std::max(ScalarCalls,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="uncoveredLine">                                 cast<FixedVectorType>(VTy)->getNumElements());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="uncoveredLine">      return ScalarCalls * ScalarCost + ScalarizationCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="">    // This is going to be turned into a library call, make it expensive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="uncoveredLine">    return SingleCallCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="">  /// Compute a cost of the given call instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="">  /// Compute the cost of calling function F with return type RetTy and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="">  /// argument types Tys. F might be nullptr, in this case the cost of an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="">  /// arbitrary call with the specified signature will be returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="">  /// This is used, for instance,  when we estimate call of a vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="">  /// counterpart of the given function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="">  /// \param F Called function, might be nullptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="">  /// \param RetTy Return value types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="">  /// \param Tys Argument types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="">  /// \returns The cost of Call instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="uncoveredLine">  InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="">                                   ArrayRef<Type *> Tys,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="">                                   TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="uncoveredLine">    return 10;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="uncoveredLine">  unsigned getNumberOfParts(Type *Tp) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="uncoveredLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Tp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="uncoveredLine">    return LT.first.isValid() ? *LT.first.getValue() : 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="uncoveredLine">  InstructionCost getAddressComputationCost(Type *Ty, ScalarEvolution *,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="">                                            const SCEV *) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="uncoveredLine">    return 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="">  /// Try to calculate arithmetic and shuffle op costs for reduction intrinsics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="">  /// We're assuming that reduction operation are performing the following way:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="">  /// %val1 = shufflevector<n x t> %val, <n x t> %undef,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="">  /// <n x i32> <i32 n/2, i32 n/2 + 1, ..., i32 n, i32 undef, ..., i32 undef></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="">  ///            \----------------v-------------/  \----------v------------/</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="">  ///                            n/2 elements               n/2 elements</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="">  /// %red1 = op <n x t> %val, <n x t> val1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="">  /// After this operation we have a vector %red1 where only the first n/2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="">  /// elements are meaningful, the second n/2 elements are undefined and can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="">  /// dropped. All other operations are actually working with the vector of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="">  /// length n/2, not n, though the real vector length is still n.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="">  /// %val2 = shufflevector<n x t> %red1, <n x t> %undef,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="">  /// <n x i32> <i32 n/4, i32 n/4 + 1, ..., i32 n/2, i32 undef, ..., i32 undef></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="">  ///            \----------------v-------------/  \----------v------------/</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="">  ///                            n/4 elements               3*n/4 elements</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="">  /// %red2 = op <n x t> %red1, <n x t> val2  - working with the vector of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="">  /// length n/2, the resulting vector has length n/4 etc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="">  /// The cost model should take into account that the actual length of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="">  /// vector is reduced on each iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="uncoveredLine">  InstructionCost getTreeReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="">                                       TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="">    // Targets must implement a default value for the scalable case, since</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="">    // we don't know how many lanes the vector has.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="uncoveredLine">    if (isa<ScalableVectorType>(Ty))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="uncoveredLine">      return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="uncoveredLine">    Type *ScalarTy = Ty->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="uncoveredLine">    unsigned NumVecElts = cast<FixedVectorType>(Ty)->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="uncoveredLine">    if ((Opcode == Instruction::Or || Opcode == Instruction::And) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="uncoveredLine">        ScalarTy == IntegerType::getInt1Ty(Ty->getContext()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="">        NumVecElts >= 2) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="">      // Or reduction for i1 is represented as:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="">      // %val = bitcast <ReduxWidth x i1> to iReduxWidth</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="">      // %res = cmp ne iReduxWidth %val, 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="">      // And reduction for i1 is represented as:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="">      // %val = bitcast <ReduxWidth x i1> to iReduxWidth</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="">      // %res = cmp eq iReduxWidth %val, 11111</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="uncoveredLine">      Type *ValTy = IntegerType::get(Ty->getContext(), NumVecElts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="uncoveredLine">      return thisT()->getCastInstrCost(Instruction::BitCast, ValTy, Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="uncoveredLine">                                       TTI::CastContextHint::None, CostKind) +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="uncoveredLine">             thisT()->getCmpSelInstrCost(Instruction::ICmp, ValTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="">                                         CmpInst::makeCmpResultType(ValTy),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="uncoveredLine">                                         CmpInst::BAD_ICMP_PREDICATE, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="uncoveredLine">    unsigned NumReduxLevels = Log2_32(NumVecElts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="uncoveredLine">    InstructionCost ArithCost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="uncoveredLine">    InstructionCost ShuffleCost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="uncoveredLine">    std::pair<InstructionCost, MVT> LT = thisT()->getTypeLegalizationCost(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="uncoveredLine">    unsigned LongVectorCount = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="uncoveredLine">    unsigned MVTLen =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="uncoveredLine">        LT.second.isVector() ? LT.second.getVectorNumElements() : 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="uncoveredLine">    while (NumVecElts > MVTLen) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="uncoveredLine">      NumVecElts /= 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="uncoveredLine">      VectorType *SubTy = FixedVectorType::get(ScalarTy, NumVecElts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="uncoveredLine">      ShuffleCost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="uncoveredLine">          thisT()->getShuffleCost(TTI::SK_ExtractSubvector, Ty, std::nullopt,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="">                                  CostKind, NumVecElts, SubTy);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="uncoveredLine">      ArithCost += thisT()->getArithmeticInstrCost(Opcode, SubTy, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="uncoveredLine">      Ty = SubTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="uncoveredLine">      ++LongVectorCount;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="uncoveredLine">    NumReduxLevels -= LongVectorCount;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="">    // The minimal length of the vector is limited by the real length of vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="">    // operations performed on the current platform. That's why several final</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="">    // reduction operations are performed on the vectors with the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="">    // architecture-dependent length.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="">    // By default reductions need one shuffle per reduction level.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="uncoveredLine">    ShuffleCost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="uncoveredLine">        NumReduxLevels * thisT()->getShuffleCost(TTI::SK_PermuteSingleSrc, Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="">                                                 std::nullopt, CostKind, 0, Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="uncoveredLine">    ArithCost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="uncoveredLine">        NumReduxLevels * thisT()->getArithmeticInstrCost(Opcode, Ty, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="uncoveredLine">    return ShuffleCost + ArithCost +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="uncoveredLine">           thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="uncoveredLine">                                       CostKind, 0, nullptr, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="">  /// Try to calculate the cost of performing strict (in-order) reductions,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="">  /// which involves doing a sequence of floating point additions in lane</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="">  /// order, starting with an initial value. For example, consider a scalar</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="">  /// initial value 'InitVal' of type float and a vector of type <4 x float>:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="">  ///   Vector = <float %v0, float %v1, float %v2, float %v3></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="">  ///   %add1 = %InitVal + %v0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="">  ///   %add2 = %add1 + %v1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="">  ///   %add3 = %add2 + %v2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="">  ///   %add4 = %add3 + %v3</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="">  /// As a simple estimate we can say the cost of such a reduction is 4 times</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="">  /// the cost of a scalar FP addition. We can only estimate the costs for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="">  /// fixed-width vectors here because for scalable vectors we do not know the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="">  /// runtime number of operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="uncoveredLine">  InstructionCost getOrderedReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="">                                          TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="">    // Targets must implement a default value for the scalable case, since</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="">    // we don't know how many lanes the vector has.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="uncoveredLine">    if (isa<ScalableVectorType>(Ty))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="uncoveredLine">      return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="uncoveredLine">    auto *VTy = cast<FixedVectorType>(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="uncoveredLine">    InstructionCost ExtractCost = getScalarizationOverhead(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="">        VTy, /*Insert=*/false, /*Extract=*/true, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="uncoveredLine">    InstructionCost ArithCost = thisT()->getArithmeticInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="">        Opcode, VTy->getElementType(), CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="uncoveredLine">    ArithCost *= VTy->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="uncoveredLine">    return ExtractCost + ArithCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="uncoveredLine">  InstructionCost getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="">                                             std::optional<FastMathFlags> FMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="">                                             TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="uncoveredLine">    assert(Ty && "Unknown reduction vector type");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="uncoveredLine">    if (TTI::requiresOrderedReduction(FMF))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="uncoveredLine">      return getOrderedReductionCost(Opcode, Ty, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="uncoveredLine">    return getTreeReductionCost(Opcode, Ty, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="">  /// Try to calculate op costs for min/max reduction operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="">  /// \param CondTy Conditional type for the Select instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="uncoveredLine">  InstructionCost getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="">                                         FastMathFlags FMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="">                                         TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="">    // Targets must implement a default value for the scalable case, since</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="">    // we don't know how many lanes the vector has.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="uncoveredLine">    if (isa<ScalableVectorType>(Ty))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="uncoveredLine">      return InstructionCost::getInvalid();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="uncoveredLine">    Type *ScalarTy = Ty->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="uncoveredLine">    unsigned NumVecElts = cast<FixedVectorType>(Ty)->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="uncoveredLine">    unsigned NumReduxLevels = Log2_32(NumVecElts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="uncoveredLine">    InstructionCost MinMaxCost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="uncoveredLine">    InstructionCost ShuffleCost = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="uncoveredLine">    std::pair<InstructionCost, MVT> LT = thisT()->getTypeLegalizationCost(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="uncoveredLine">    unsigned LongVectorCount = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="uncoveredLine">    unsigned MVTLen =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="uncoveredLine">        LT.second.isVector() ? LT.second.getVectorNumElements() : 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="uncoveredLine">    while (NumVecElts > MVTLen) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="uncoveredLine">      NumVecElts /= 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="uncoveredLine">      auto *SubTy = FixedVectorType::get(ScalarTy, NumVecElts);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="uncoveredLine">      ShuffleCost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="uncoveredLine">          thisT()->getShuffleCost(TTI::SK_ExtractSubvector, Ty, std::nullopt,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="">                                  CostKind, NumVecElts, SubTy);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="uncoveredLine">      IntrinsicCostAttributes Attrs(IID, SubTy, {SubTy, SubTy}, FMF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="uncoveredLine">      MinMaxCost += getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="uncoveredLine">      Ty = SubTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="uncoveredLine">      ++LongVectorCount;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="uncoveredLine">    NumReduxLevels -= LongVectorCount;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="">    // The minimal length of the vector is limited by the real length of vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="">    // operations performed on the current platform. That's why several final</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="">    // reduction opertions are perfomed on the vectors with the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="">    // architecture-dependent length.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="uncoveredLine">    ShuffleCost +=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="uncoveredLine">        NumReduxLevels * thisT()->getShuffleCost(TTI::SK_PermuteSingleSrc, Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="">                                                 std::nullopt, CostKind, 0, Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="uncoveredLine">    IntrinsicCostAttributes Attrs(IID, Ty, {Ty, Ty}, FMF);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="uncoveredLine">    MinMaxCost += NumReduxLevels * getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="">    // The last min/max should be in vector registers and we counted it above.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="">    // So just need a single extractelement.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="uncoveredLine">    return ShuffleCost + MinMaxCost +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="uncoveredLine">           thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="uncoveredLine">                                       CostKind, 0, nullptr, nullptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="uncoveredLine">  InstructionCost getExtendedReductionCost(unsigned Opcode, bool IsUnsigned,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="">                                           Type *ResTy, VectorType *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="">                                           FastMathFlags FMF,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="">                                           TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="">    // Without any native support, this is equivalent to the cost of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="">    // vecreduce.opcode(ext(Ty A)).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="uncoveredLine">    VectorType *ExtTy = VectorType::get(ResTy, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="">    InstructionCost RedCost =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="uncoveredLine">        thisT()->getArithmeticReductionCost(Opcode, ExtTy, FMF, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="uncoveredLine">    InstructionCost ExtCost = thisT()->getCastInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="">        IsUnsigned ? Instruction::ZExt : Instruction::SExt, ExtTy, Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="">        TTI::CastContextHint::None, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="uncoveredLine">    return RedCost + ExtCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="uncoveredLine">  InstructionCost getMulAccReductionCost(bool IsUnsigned, Type *ResTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="">                                         VectorType *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="">                                         TTI::TargetCostKind CostKind) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="">    // Without any native support, this is equivalent to the cost of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="">    // vecreduce.add(mul(ext(Ty A), ext(Ty B))) or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="">    // vecreduce.add(mul(A, B)).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="uncoveredLine">    VectorType *ExtTy = VectorType::get(ResTy, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="uncoveredLine">    InstructionCost RedCost = thisT()->getArithmeticReductionCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="">        Instruction::Add, ExtTy, std::nullopt, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="uncoveredLine">    InstructionCost ExtCost = thisT()->getCastInstrCost(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="">        IsUnsigned ? Instruction::ZExt : Instruction::SExt, ExtTy, Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="">        TTI::CastContextHint::None, CostKind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="">    InstructionCost MulCost =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="uncoveredLine">        thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="uncoveredLine">    return RedCost + MulCost + 2 * ExtCost;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="uncoveredLine">  InstructionCost getVectorSplitCost() { return 1; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="">  /// @}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="">/// Concrete BasicTTIImpl that can be used if no further customization</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="">/// is needed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="">class BasicTTIImpl : public BasicTTIImplBase<BasicTTIImpl> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="">  using BaseT = BasicTTIImplBase<BasicTTIImpl>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="">  friend class BasicTTIImplBase<BasicTTIImpl>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="">  const TargetSubtargetInfo *ST;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="">  const TargetLoweringBase *TLI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="">  const TargetSubtargetInfo *getST() const { return ST; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="">  const TargetLoweringBase *getTLI() const { return TLI; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="">  explicit BasicTTIImpl(const TargetMachine *TM, const Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="">#endif // LLVM_CODEGEN_BASICTTIIMPL_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE5thisTEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE27getBroadcastShuffleOverheadEPNS_15FixedVectorTypeENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE25getPermuteShuffleOverheadEPNS_15FixedVectorTypeENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE27getExtractSubvectorOverheadEPNS_10VectorTypeENS_19TargetTransformInfo14TargetCostKindEiPNS_15FixedVectorTypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE26getInsertSubvectorOverheadEPNS_10VectorTypeENS_19TargetTransformInfo14TargetCostKindEiPNS_15FixedVectorTypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE5getSTEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE6getTLIEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE17getISDIndexedModeENS_19TargetTransformInfo14MemIndexedModeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE27getCommonMaskedMemoryOpCostEjPNS_4TypeENS_5AlignEbbNS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEEC2EPKNS_13TargetMachineERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEED2Ev</td>
    <td class="numberOfCalls">54</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEED0Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE30allowsMisalignedMemoryAccessesERNS_11LLVMContextEjjNS_5AlignEPj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE19hasBranchDivergenceEPKNS_8FunctionE</td>
    <td class="numberOfCalls">42</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE20isSourceOfDivergenceEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE15isAlwaysUniformEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE20isValidAddrSpaceCastEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE18addrspacesMayAliasEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE19getFlatAddressSpaceEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE26collectFlatAddressOperandsERNS_15SmallVectorImplIiEEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE19isNoopAddrSpaceCastEjj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE19getAssumedAddrSpaceEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE16isSingleThreadedEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE22getPredicatedAddrSpaceEPKNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE32rewriteIntrinsicWithAddressSpaceEPNS_13IntrinsicInstEPNS_5ValueES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE19isLegalAddImmediateEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE20isLegalICmpImmediateEl</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE21isLegalAddressingModeEPNS_4TypeEPNS_11GlobalValueElbljPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE17getStoreMinimumVFEjPNS_4TypeES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE17getStoreMinimumVFEjPNS_4TypeES4_ENKUljE_clEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE18isIndexedLoadLegalENS_19TargetTransformInfo14MemIndexedModeEPNS_4TypeERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE19isIndexedStoreLegalENS_19TargetTransformInfo14MemIndexedModeEPNS_4TypeERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE13isLSRCostLessENS_19TargetTransformInfo7LSRCostES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE23isNumRegsMajorCostOfLSREv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE27isProfitableLSRChainElementEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE20getScalingFactorCostEPNS_4TypeEPNS_11GlobalValueElblj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE14isTruncateFreeEPNS_4TypeES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE19isProfitableToHoistEPNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE5useAAEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE11isTypeLegalEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE18getRegUsageForTypeEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE10getGEPCostEPNS_4TypeEPKNS_5ValueENS_8ArrayRefIS7_EES4_NS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE32getEstimatedNumberOfCaseClustersERKNS_10SwitchInstERjPNS_18ProfileSummaryInfoEPNS_18BlockFrequencyInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE23shouldBuildLookupTablesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE26shouldBuildRelLookupTablesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE12haveFastSqrtEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE28isFCmpOrdCheaperThanFCmpZeroEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE11getFPOpCostEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE30getInliningThresholdMultiplierEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE23adjustInliningThresholdEPKNS_8CallBaseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE19getCallerAllocaCostEPKNS_8CallBaseEPKNS_10AllocaInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE28getInlinerVectorBonusPercentEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE23getUnrollingPreferencesEPNS_4LoopERNS_15ScalarEvolutionERNS_19TargetTransformInfo20UnrollingPreferencesEPNS_25OptimizationRemarkEmitterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE23getUnrollingPreferencesEPNS_4LoopERNS_15ScalarEvolutionERNS_19TargetTransformInfo20UnrollingPreferencesEPNS_25OptimizationRemarkEmitterEENKUlvE_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE21getPeelingPreferencesEPNS_4LoopERNS_15ScalarEvolutionERNS_19TargetTransformInfo18PeelingPreferencesE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE24isHardwareLoopProfitableEPNS_4LoopERNS_15ScalarEvolutionERNS_15AssumptionCacheEPNS_17TargetLibraryInfoERNS_16HardwareLoopInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE27preferPredicateOverEpilogueEPNS_15TailFoldingInfoE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE28getPreferredTailFoldingStyleEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE20instCombineIntrinsicERNS_12InstCombinerERNS_13IntrinsicInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE32simplifyDemandedUseBitsIntrinsicERNS_12InstCombinerERNS_13IntrinsicInstENS_5APIntERNS_9KnownBitsERb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE35simplifyDemandedVectorEltsIntrinsicERNS_12InstCombinerERNS_13IntrinsicInstENS_5APIntERS7_S8_S8_St8functionIFvPNS_11InstructionEjS7_S8_EE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE12getCacheSizeENS_19TargetTransformInfo10CacheLevelE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE21getCacheAssociativityENS_19TargetTransformInfo10CacheLevelE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE16getCacheLineSizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE19getPrefetchDistanceEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE20getMinPrefetchStrideEjjjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE29getMaxPrefetchIterationsAheadEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE22enableWritePrefetchingEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE26shouldPrefetchAddressSpaceEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE19getRegisterBitWidthENS_19TargetTransformInfo12RegisterKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE12getMaxVScaleEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE18getVScaleForTuningEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE28isVScaleKnownToBeAPowerOfTwoEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE24getScalarizationOverheadEPNS_10VectorTypeERKNS_5APIntEbbNS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE24getScalarizationOverheadEPNS_10VectorTypeEbbNS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE32getOperandsScalarizationOverheadENS_8ArrayRefIPKNS_5ValueEEENS3_IPNS_4TypeEEENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE24getScalarizationOverheadEPNS_10VectorTypeENS_8ArrayRefIPKNS_5ValueEEENS5_IPNS_4TypeEEENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE23getTypeLegalizationCostEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE22getMaxInterleaveFactorENS_12ElementCountE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE22getArithmeticInstrCostEjPNS_4TypeENS_19TargetTransformInfo14TargetCostKindENS5_16OperandValueInfoES7_NS_8ArrayRefIPKNS_5ValueEEEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE26improveShuffleKindFromMaskENS_19TargetTransformInfo11ShuffleKindENS_8ArrayRefIiEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZNK4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE26improveShuffleKindFromMaskENS_19TargetTransformInfo11ShuffleKindENS_8ArrayRefIiEEENKUliE_clEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE14getShuffleCostENS_19TargetTransformInfo11ShuffleKindEPNS_10VectorTypeENS_8ArrayRefIiEENS3_14TargetCostKindEiS6_NS7_IPKNS_5ValueEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE16getCastInstrCostEjPNS_4TypeES4_NS_19TargetTransformInfo15CastContextHintENS5_14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE24getExtractWithExtendCostEjPNS_4TypeEPNS_10VectorTypeEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE14getCFInstrCostEjNS_19TargetTransformInfo14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE18getCmpSelInstrCostEjPNS_4TypeES4_NS_7CmpInst9PredicateENS_19TargetTransformInfo14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE18getVectorInstrCostEjPNS_4TypeENS_19TargetTransformInfo14TargetCostKindEjPNS_5ValueES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE18getVectorInstrCostERKNS_11InstructionEPNS_4TypeENS_19TargetTransformInfo14TargetCostKindEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE25getReplicationShuffleCostEPNS_4TypeEiiRKNS_5APIntENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE15getMemoryOpCostEjPNS_4TypeENS_10MaybeAlignEjNS_19TargetTransformInfo14TargetCostKindENS6_16OperandValueInfoEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE21getMaskedMemoryOpCostEjPNS_4TypeENS_5AlignEjNS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE22getGatherScatterOpCostEjPNS_4TypeEPKNS_5ValueEbNS_5AlignENS_19TargetTransformInfo14TargetCostKindEPKNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE26getInterleavedMemoryOpCostEjPNS_4TypeEjNS_8ArrayRefIjEENS_5AlignEjNS_19TargetTransformInfo14TargetCostKindEbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE21getIntrinsicInstrCostERKNS_23IntrinsicCostAttributesENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE30getTypeBasedIntrinsicInstrCostERKNS_23IntrinsicCostAttributesENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE30getTypeBasedIntrinsicInstrCostERKNS_23IntrinsicCostAttributesENS_19TargetTransformInfo14TargetCostKindEENKUlPKNS_4TypeEE_clESA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE30getTypeBasedIntrinsicInstrCostERKNS_23IntrinsicCostAttributesENS_19TargetTransformInfo14TargetCostKindEENKUlPKNS_4TypeEE0_clESA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE16getCallInstrCostEPNS_8FunctionEPNS_4TypeENS_8ArrayRefIS6_EENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE16getNumberOfPartsEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE25getAddressComputationCostEPNS_4TypeEPNS_15ScalarEvolutionEPKNS_4SCEVE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE20getTreeReductionCostEjPNS_10VectorTypeENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE23getOrderedReductionCostEjPNS_10VectorTypeENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE26getArithmeticReductionCostEjPNS_10VectorTypeESt8optionalINS_13FastMathFlagsEENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE22getMinMaxReductionCostEjPNS_10VectorTypeENS_13FastMathFlagsENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE24getExtendedReductionCostEjbPNS_4TypeEPNS_10VectorTypeENS_13FastMathFlagsENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE22getMulAccReductionCostEbPNS_4TypeEPNS_10VectorTypeENS_19TargetTransformInfo14TargetCostKindE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16BasicTTIImplBaseINS_11MipsTTIImplEE18getVectorSplitCostEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- BasicTTIImpl.h -------------------------------------------*- C++ -*-===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- BasicTTIImpl.h -------------------------------------------*- C++ -*-===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file</td>
    <td class="lineNumber">9</td>
    <td class="codeline">/// \file</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">/// This file provides a helper that implements much of the TTI interface in</td>
    <td class="lineNumber">10</td>
    <td class="codeline">/// This file provides a helper that implements much of the TTI interface in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">/// terms of the target-independent code generator and TargetLowering</td>
    <td class="lineNumber">11</td>
    <td class="codeline">/// terms of the target-independent code generator and TargetLowering</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">/// interfaces.</td>
    <td class="lineNumber">12</td>
    <td class="codeline">/// interfaces.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
    <td class="lineNumber">13</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">14</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline"></td>
    <td class="lineNumber">15</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#ifndef LLVM_CODEGEN_BASICTTIIMPL_H</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#ifndef LLVM_CODEGEN_BASICTTIIMPL_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#define LLVM_CODEGEN_BASICTTIIMPL_H</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#define LLVM_CODEGEN_BASICTTIIMPL_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline"></td>
    <td class="lineNumber">18</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/ADT/BitVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Analysis/LoopInfo.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/Analysis/LoopInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Analysis/TargetTransformInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Analysis/TargetTransformInfoImpl.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/Analysis/TargetTransformInfoImpl.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/CodeGen/ISDOpcodes.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/CodeGen/ISDOpcodes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/CodeGen/MachineValueType.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/CodeGen/MachineValueType.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/CodeGen/TargetLowering.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/CodeGen/ValueTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/Constant.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/IR/Intrinsics.h"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/IR/Intrinsics.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/IR/Operator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/Support/MathExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/Target/TargetMachine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/Target/TargetOptions.h"</td>
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/Target/TargetOptions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">51</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">52</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">53</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">#include <limits></td>
    <td class="lineNumber">54</td>
    <td class="codeline">#include <limits></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">#include <optional></td>
    <td class="lineNumber">55</td>
    <td class="codeline">#include <optional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">56</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline"></td>
    <td class="lineNumber">57</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">58</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline"></td>
    <td class="lineNumber">59</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">class Function;</td>
    <td class="lineNumber">60</td>
    <td class="codeline">class Function;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">class GlobalValue;</td>
    <td class="lineNumber">61</td>
    <td class="codeline">class GlobalValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">class LLVMContext;</td>
    <td class="lineNumber">62</td>
    <td class="codeline">class LLVMContext;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">class ScalarEvolution;</td>
    <td class="lineNumber">63</td>
    <td class="codeline">class ScalarEvolution;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">class SCEV;</td>
    <td class="lineNumber">64</td>
    <td class="codeline">class SCEV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">class TargetMachine;</td>
    <td class="lineNumber">65</td>
    <td class="codeline">class TargetMachine;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline"></td>
    <td class="lineNumber">66</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">extern cl::opt<unsigned> PartialUnrollingThreshold;</td>
    <td class="lineNumber">67</td>
    <td class="codeline">extern cl::opt<unsigned> PartialUnrollingThreshold;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline"></td>
    <td class="lineNumber">68</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">/// Base class which can be used to help build a TTI implementation.</td>
    <td class="lineNumber">69</td>
    <td class="codeline">/// Base class which can be used to help build a TTI implementation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">///</td>
    <td class="lineNumber">70</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">/// This class provides as much implementation of the TTI interface as is</td>
    <td class="lineNumber">71</td>
    <td class="codeline">/// This class provides as much implementation of the TTI interface as is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">/// possible using the target independent parts of the code generator.</td>
    <td class="lineNumber">72</td>
    <td class="codeline">/// possible using the target independent parts of the code generator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">///</td>
    <td class="lineNumber">73</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">/// In order to subclass it, your class must implement a getST() method to</td>
    <td class="lineNumber">74</td>
    <td class="codeline">/// In order to subclass it, your class must implement a getST() method to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">/// return the subtarget, and a getTLI() method to return the target lowering.</td>
    <td class="lineNumber">75</td>
    <td class="codeline">/// return the subtarget, and a getTLI() method to return the target lowering.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">/// We need these methods implemented in the derived class so that this class</td>
    <td class="lineNumber">76</td>
    <td class="codeline">/// We need these methods implemented in the derived class so that this class</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">/// doesn't have to duplicate storage for them.</td>
    <td class="lineNumber">77</td>
    <td class="codeline">/// doesn't have to duplicate storage for them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">78</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">class BasicTTIImplBase : public TargetTransformInfoImplCRTPBase<T> {</td>
    <td class="lineNumber">79</td>
    <td class="codeline">class BasicTTIImplBase : public TargetTransformInfoImplCRTPBase<T> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">80</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">  using BaseT = TargetTransformInfoImplCRTPBase<T>;</td>
    <td class="lineNumber">81</td>
    <td class="codeline">  using BaseT = TargetTransformInfoImplCRTPBase<T>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">  using TTI = TargetTransformInfo;</td>
    <td class="lineNumber">82</td>
    <td class="codeline">  using TTI = TargetTransformInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline"></td>
    <td class="lineNumber">83</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">  /// Helper function to access this as a T.</td>
    <td class="lineNumber">84</td>
    <td class="codeline">  /// Helper function to access this as a T.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">  T *thisT() { return static_cast<T *>(this); }</td>
    <td class="lineNumber">85</td>
    <td class="codeline">  T *thisT() { return static_cast<T *>(this); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline"></td>
    <td class="lineNumber">86</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">  /// Estimate a cost of Broadcast as an extract and sequence of insert</td>
    <td class="lineNumber">87</td>
    <td class="codeline">  /// Estimate a cost of Broadcast as an extract and sequence of insert</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">  /// operations.</td>
    <td class="lineNumber">88</td>
    <td class="codeline">  /// operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">  InstructionCost getBroadcastShuffleOverhead(FixedVectorType *VTy,</td>
    <td class="lineNumber">89</td>
    <td class="codeline">  InstructionCost getBroadcastShuffleOverhead(FixedVectorType *VTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">                                              TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">90</td>
    <td class="codeline">                                              TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">91</td>
    <td class="codeline">    InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">    // Broadcast cost is equal to the cost of extracting the zero'th element</td>
    <td class="lineNumber">92</td>
    <td class="codeline">    // Broadcast cost is equal to the cost of extracting the zero'th element</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">    // plus the cost of inserting it into every element of the result vector.</td>
    <td class="lineNumber">93</td>
    <td class="codeline">    // plus the cost of inserting it into every element of the result vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">    Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
    <td class="lineNumber">94</td>
    <td class="codeline">    Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">                                        CostKind, 0, nullptr, nullptr);</td>
    <td class="lineNumber">95</td>
    <td class="codeline">                                        CostKind, 0, nullptr, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline"></td>
    <td class="lineNumber">96</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">    for (int i = 0, e = VTy->getNumElements(); i < e; ++i) {</td>
    <td class="lineNumber">97</td>
    <td class="codeline">    for (int i = 0, e = VTy->getNumElements(); i < e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, VTy,</td>
    <td class="lineNumber">98</td>
    <td class="codeline">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, VTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">99</td>
    <td class="codeline">                                          CostKind, i, nullptr, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">100</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">    return Cost;</td>
    <td class="lineNumber">101</td>
    <td class="codeline">    return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline"></td>
    <td class="lineNumber">103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">  /// Estimate a cost of shuffle as a sequence of extract and insert</td>
    <td class="lineNumber">104</td>
    <td class="codeline">  /// Estimate a cost of shuffle as a sequence of extract and insert</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">  /// operations.</td>
    <td class="lineNumber">105</td>
    <td class="codeline">  /// operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">  InstructionCost getPermuteShuffleOverhead(FixedVectorType *VTy,</td>
    <td class="lineNumber">106</td>
    <td class="codeline">  InstructionCost getPermuteShuffleOverhead(FixedVectorType *VTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">                                            TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">107</td>
    <td class="codeline">                                            TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">108</td>
    <td class="codeline">    InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">    // Shuffle cost is equal to the cost of extracting element from its argument</td>
    <td class="lineNumber">109</td>
    <td class="codeline">    // Shuffle cost is equal to the cost of extracting element from its argument</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">    // plus the cost of inserting them onto the result vector.</td>
    <td class="lineNumber">110</td>
    <td class="codeline">    // plus the cost of inserting them onto the result vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
    <td class="lineNumber">111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">    // e.g. <4 x float> has a mask of <0,5,2,7> i.e we need to extract from</td>
    <td class="lineNumber">112</td>
    <td class="codeline">    // e.g. <4 x float> has a mask of <0,5,2,7> i.e we need to extract from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">    // index 0 of first vector, index 1 of second vector,index 2 of first</td>
    <td class="lineNumber">113</td>
    <td class="codeline">    // index 0 of first vector, index 1 of second vector,index 2 of first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">    // vector and finally index 3 of second vector and insert them at index</td>
    <td class="lineNumber">114</td>
    <td class="codeline">    // vector and finally index 3 of second vector and insert them at index</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">    // <0,1,2,3> of result vector.</td>
    <td class="lineNumber">115</td>
    <td class="codeline">    // <0,1,2,3> of result vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">    for (int i = 0, e = VTy->getNumElements(); i < e; ++i) {</td>
    <td class="lineNumber">116</td>
    <td class="codeline">    for (int i = 0, e = VTy->getNumElements(); i < e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, VTy,</td>
    <td class="lineNumber">117</td>
    <td class="codeline">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, VTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">118</td>
    <td class="codeline">                                          CostKind, i, nullptr, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">      Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
    <td class="lineNumber">119</td>
    <td class="codeline">      Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">120</td>
    <td class="codeline">                                          CostKind, i, nullptr, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">121</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">    return Cost;</td>
    <td class="lineNumber">122</td>
    <td class="codeline">    return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">123</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline"></td>
    <td class="lineNumber">124</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">  /// Estimate a cost of subvector extraction as a sequence of extract and</td>
    <td class="lineNumber">125</td>
    <td class="codeline">  /// Estimate a cost of subvector extraction as a sequence of extract and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">  /// insert operations.</td>
    <td class="lineNumber">126</td>
    <td class="codeline">  /// insert operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  InstructionCost getExtractSubvectorOverhead(VectorType *VTy,</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  InstructionCost getExtractSubvectorOverhead(VectorType *VTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">                                              TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">128</td>
    <td class="codeline">                                              TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">                                              int Index,</td>
    <td class="lineNumber">129</td>
    <td class="codeline">                                              int Index,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">                                              FixedVectorType *SubVTy) {</td>
    <td class="lineNumber">130</td>
    <td class="codeline">                                              FixedVectorType *SubVTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">    assert(VTy && SubVTy &&</td>
    <td class="lineNumber">131</td>
    <td class="codeline">    assert(VTy && SubVTy &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">           "Can only extract subvectors from vectors");</td>
    <td class="lineNumber">132</td>
    <td class="codeline">           "Can only extract subvectors from vectors");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">    int NumSubElts = SubVTy->getNumElements();</td>
    <td class="lineNumber">133</td>
    <td class="codeline">    int NumSubElts = SubVTy->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">    assert((!isa<FixedVectorType>(VTy) ||</td>
    <td class="lineNumber">134</td>
    <td class="codeline">    assert((!isa<FixedVectorType>(VTy) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">            (Index + NumSubElts) <=</td>
    <td class="lineNumber">135</td>
    <td class="codeline">            (Index + NumSubElts) <=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">                (int)cast<FixedVectorType>(VTy)->getNumElements()) &&</td>
    <td class="lineNumber">136</td>
    <td class="codeline">                (int)cast<FixedVectorType>(VTy)->getNumElements()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">           "SK_ExtractSubvector index out of range");</td>
    <td class="lineNumber">137</td>
    <td class="codeline">           "SK_ExtractSubvector index out of range");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
    <td class="lineNumber">138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">139</td>
    <td class="codeline">    InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">    // Subvector extraction cost is equal to the cost of extracting element from</td>
    <td class="lineNumber">140</td>
    <td class="codeline">    // Subvector extraction cost is equal to the cost of extracting element from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">    // the source type plus the cost of inserting them into the result vector</td>
    <td class="lineNumber">141</td>
    <td class="codeline">    // the source type plus the cost of inserting them into the result vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">    // type.</td>
    <td class="lineNumber">142</td>
    <td class="codeline">    // type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">    for (int i = 0; i != NumSubElts; ++i) {</td>
    <td class="lineNumber">143</td>
    <td class="codeline">    for (int i = 0; i != NumSubElts; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">      Cost +=</td>
    <td class="lineNumber">144</td>
    <td class="codeline">      Cost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">          thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
    <td class="lineNumber">145</td>
    <td class="codeline">          thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">                                      CostKind, i + Index, nullptr, nullptr);</td>
    <td class="lineNumber">146</td>
    <td class="codeline">                                      CostKind, i + Index, nullptr, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, SubVTy,</td>
    <td class="lineNumber">147</td>
    <td class="codeline">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, SubVTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">148</td>
    <td class="codeline">                                          CostKind, i, nullptr, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">149</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">    return Cost;</td>
    <td class="lineNumber">150</td>
    <td class="codeline">    return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">151</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline"></td>
    <td class="lineNumber">152</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">  /// Estimate a cost of subvector insertion as a sequence of extract and</td>
    <td class="lineNumber">153</td>
    <td class="codeline">  /// Estimate a cost of subvector insertion as a sequence of extract and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">  /// insert operations.</td>
    <td class="lineNumber">154</td>
    <td class="codeline">  /// insert operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">  InstructionCost getInsertSubvectorOverhead(VectorType *VTy,</td>
    <td class="lineNumber">155</td>
    <td class="codeline">  InstructionCost getInsertSubvectorOverhead(VectorType *VTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">                                             TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">156</td>
    <td class="codeline">                                             TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">                                             int Index,</td>
    <td class="lineNumber">157</td>
    <td class="codeline">                                             int Index,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">                                             FixedVectorType *SubVTy) {</td>
    <td class="lineNumber">158</td>
    <td class="codeline">                                             FixedVectorType *SubVTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">    assert(VTy && SubVTy &&</td>
    <td class="lineNumber">159</td>
    <td class="codeline">    assert(VTy && SubVTy &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">           "Can only insert subvectors into vectors");</td>
    <td class="lineNumber">160</td>
    <td class="codeline">           "Can only insert subvectors into vectors");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">    int NumSubElts = SubVTy->getNumElements();</td>
    <td class="lineNumber">161</td>
    <td class="codeline">    int NumSubElts = SubVTy->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">    assert((!isa<FixedVectorType>(VTy) ||</td>
    <td class="lineNumber">162</td>
    <td class="codeline">    assert((!isa<FixedVectorType>(VTy) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">            (Index + NumSubElts) <=</td>
    <td class="lineNumber">163</td>
    <td class="codeline">            (Index + NumSubElts) <=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">                (int)cast<FixedVectorType>(VTy)->getNumElements()) &&</td>
    <td class="lineNumber">164</td>
    <td class="codeline">                (int)cast<FixedVectorType>(VTy)->getNumElements()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">           "SK_InsertSubvector index out of range");</td>
    <td class="lineNumber">165</td>
    <td class="codeline">           "SK_InsertSubvector index out of range");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline"></td>
    <td class="lineNumber">166</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">167</td>
    <td class="codeline">    InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">    // Subvector insertion cost is equal to the cost of extracting element from</td>
    <td class="lineNumber">168</td>
    <td class="codeline">    // Subvector insertion cost is equal to the cost of extracting element from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">    // the source type plus the cost of inserting them into the result vector</td>
    <td class="lineNumber">169</td>
    <td class="codeline">    // the source type plus the cost of inserting them into the result vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">    // type.</td>
    <td class="lineNumber">170</td>
    <td class="codeline">    // type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">    for (int i = 0; i != NumSubElts; ++i) {</td>
    <td class="lineNumber">171</td>
    <td class="codeline">    for (int i = 0; i != NumSubElts; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">      Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, SubVTy,</td>
    <td class="lineNumber">172</td>
    <td class="codeline">      Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, SubVTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">173</td>
    <td class="codeline">                                          CostKind, i, nullptr, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">      Cost +=</td>
    <td class="lineNumber">174</td>
    <td class="codeline">      Cost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">          thisT()->getVectorInstrCost(Instruction::InsertElement, VTy, CostKind,</td>
    <td class="lineNumber">175</td>
    <td class="codeline">          thisT()->getVectorInstrCost(Instruction::InsertElement, VTy, CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">                                      i + Index, nullptr, nullptr);</td>
    <td class="lineNumber">176</td>
    <td class="codeline">                                      i + Index, nullptr, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">177</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">    return Cost;</td>
    <td class="lineNumber">178</td>
    <td class="codeline">    return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline"></td>
    <td class="lineNumber">180</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">  /// Local query method delegates up to T which *must* implement this!</td>
    <td class="lineNumber">181</td>
    <td class="codeline">  /// Local query method delegates up to T which *must* implement this!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">  const TargetSubtargetInfo *getST() const {</td>
    <td class="lineNumber">182</td>
    <td class="codeline">  const TargetSubtargetInfo *getST() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">    return static_cast<const T *>(this)->getST();</td>
    <td class="lineNumber">183</td>
    <td class="codeline">    return static_cast<const T *>(this)->getST();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">184</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
    <td class="lineNumber">185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">  /// Local query method delegates up to T which *must* implement this!</td>
    <td class="lineNumber">186</td>
    <td class="codeline">  /// Local query method delegates up to T which *must* implement this!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">  const TargetLoweringBase *getTLI() const {</td>
    <td class="lineNumber">187</td>
    <td class="codeline">  const TargetLoweringBase *getTLI() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">    return static_cast<const T *>(this)->getTLI();</td>
    <td class="lineNumber">188</td>
    <td class="codeline">    return static_cast<const T *>(this)->getTLI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">189</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline"></td>
    <td class="lineNumber">190</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">  static ISD::MemIndexedMode getISDIndexedMode(TTI::MemIndexedMode M) {</td>
    <td class="lineNumber">191</td>
    <td class="codeline">  static ISD::MemIndexedMode getISDIndexedMode(TTI::MemIndexedMode M) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">    switch (M) {</td>
    <td class="lineNumber">192</td>
    <td class="codeline">    switch (M) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">      case TTI::MIM_Unindexed:</td>
    <td class="lineNumber">193</td>
    <td class="codeline">      case TTI::MIM_Unindexed:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">        return ISD::UNINDEXED;</td>
    <td class="lineNumber">194</td>
    <td class="codeline">        return ISD::UNINDEXED;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">      case TTI::MIM_PreInc:</td>
    <td class="lineNumber">195</td>
    <td class="codeline">      case TTI::MIM_PreInc:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">        return ISD::PRE_INC;</td>
    <td class="lineNumber">196</td>
    <td class="codeline">        return ISD::PRE_INC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">      case TTI::MIM_PreDec:</td>
    <td class="lineNumber">197</td>
    <td class="codeline">      case TTI::MIM_PreDec:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">        return ISD::PRE_DEC;</td>
    <td class="lineNumber">198</td>
    <td class="codeline">        return ISD::PRE_DEC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">      case TTI::MIM_PostInc:</td>
    <td class="lineNumber">199</td>
    <td class="codeline">      case TTI::MIM_PostInc:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">        return ISD::POST_INC;</td>
    <td class="lineNumber">200</td>
    <td class="codeline">        return ISD::POST_INC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">      case TTI::MIM_PostDec:</td>
    <td class="lineNumber">201</td>
    <td class="codeline">      case TTI::MIM_PostDec:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">        return ISD::POST_DEC;</td>
    <td class="lineNumber">202</td>
    <td class="codeline">        return ISD::POST_DEC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">203</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">    llvm_unreachable("Unexpected MemIndexedMode");</td>
    <td class="lineNumber">204</td>
    <td class="codeline">    llvm_unreachable("Unexpected MemIndexedMode");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
    <td class="lineNumber">206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  InstructionCost getCommonMaskedMemoryOpCost(unsigned Opcode, Type *DataTy,</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  InstructionCost getCommonMaskedMemoryOpCost(unsigned Opcode, Type *DataTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">                                              Align Alignment,</td>
    <td class="lineNumber">208</td>
    <td class="codeline">                                              Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">                                              bool VariableMask,</td>
    <td class="lineNumber">209</td>
    <td class="codeline">                                              bool VariableMask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">                                              bool IsGatherScatter,</td>
    <td class="lineNumber">210</td>
    <td class="codeline">                                              bool IsGatherScatter,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">                                              TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">211</td>
    <td class="codeline">                                              TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">    // We cannot scalarize scalable vectors, so return Invalid.</td>
    <td class="lineNumber">212</td>
    <td class="codeline">    // We cannot scalarize scalable vectors, so return Invalid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">    if (isa<ScalableVectorType>(DataTy))</td>
    <td class="lineNumber">213</td>
    <td class="codeline">    if (isa<ScalableVectorType>(DataTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">214</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">    auto *VT = cast<FixedVectorType>(DataTy);</td>
    <td class="lineNumber">216</td>
    <td class="codeline">    auto *VT = cast<FixedVectorType>(DataTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">    // Assume the target does not have support for gather/scatter operations</td>
    <td class="lineNumber">217</td>
    <td class="codeline">    // Assume the target does not have support for gather/scatter operations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">    // and provide a rough estimate.</td>
    <td class="lineNumber">218</td>
    <td class="codeline">    // and provide a rough estimate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">219</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">    // First, compute the cost of the individual memory operations.</td>
    <td class="lineNumber">220</td>
    <td class="codeline">    // First, compute the cost of the individual memory operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">    InstructionCost AddrExtractCost =</td>
    <td class="lineNumber">221</td>
    <td class="codeline">    InstructionCost AddrExtractCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">        IsGatherScatter</td>
    <td class="lineNumber">222</td>
    <td class="codeline">        IsGatherScatter</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">            ? getVectorInstrCost(Instruction::ExtractElement,</td>
    <td class="lineNumber">223</td>
    <td class="codeline">            ? getVectorInstrCost(Instruction::ExtractElement,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">                                 FixedVectorType::get(</td>
    <td class="lineNumber">224</td>
    <td class="codeline">                                 FixedVectorType::get(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">                                     PointerType::get(VT->getElementType(), 0),</td>
    <td class="lineNumber">225</td>
    <td class="codeline">                                     PointerType::get(VT->getElementType(), 0),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">                                     VT->getNumElements()),</td>
    <td class="lineNumber">226</td>
    <td class="codeline">                                     VT->getNumElements()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">                                 CostKind, -1, nullptr, nullptr)</td>
    <td class="lineNumber">227</td>
    <td class="codeline">                                 CostKind, -1, nullptr, nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">            : 0;</td>
    <td class="lineNumber">228</td>
    <td class="codeline">            : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">    InstructionCost LoadCost =</td>
    <td class="lineNumber">229</td>
    <td class="codeline">    InstructionCost LoadCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">        VT->getNumElements() *</td>
    <td class="lineNumber">230</td>
    <td class="codeline">        VT->getNumElements() *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">        (AddrExtractCost +</td>
    <td class="lineNumber">231</td>
    <td class="codeline">        (AddrExtractCost +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">         getMemoryOpCost(Opcode, VT->getElementType(), Alignment, 0, CostKind));</td>
    <td class="lineNumber">232</td>
    <td class="codeline">         getMemoryOpCost(Opcode, VT->getElementType(), Alignment, 0, CostKind));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">    // Next, compute the cost of packing the result in a vector.</td>
    <td class="lineNumber">234</td>
    <td class="codeline">    // Next, compute the cost of packing the result in a vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">    InstructionCost PackingCost =</td>
    <td class="lineNumber">235</td>
    <td class="codeline">    InstructionCost PackingCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">        getScalarizationOverhead(VT, Opcode != Instruction::Store,</td>
    <td class="lineNumber">236</td>
    <td class="codeline">        getScalarizationOverhead(VT, Opcode != Instruction::Store,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">                                 Opcode == Instruction::Store, CostKind);</td>
    <td class="lineNumber">237</td>
    <td class="codeline">                                 Opcode == Instruction::Store, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline"></td>
    <td class="lineNumber">238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">    InstructionCost ConditionalCost = 0;</td>
    <td class="lineNumber">239</td>
    <td class="codeline">    InstructionCost ConditionalCost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">    if (VariableMask) {</td>
    <td class="lineNumber">240</td>
    <td class="codeline">    if (VariableMask) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">      // Compute the cost of conditionally executing the memory operations with</td>
    <td class="lineNumber">241</td>
    <td class="codeline">      // Compute the cost of conditionally executing the memory operations with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">      // variable masks. This includes extracting the individual conditions, a</td>
    <td class="lineNumber">242</td>
    <td class="codeline">      // variable masks. This includes extracting the individual conditions, a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">      // branches and PHIs to combine the results.</td>
    <td class="lineNumber">243</td>
    <td class="codeline">      // branches and PHIs to combine the results.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">      // NOTE: Estimating the cost of conditionally executing the memory</td>
    <td class="lineNumber">244</td>
    <td class="codeline">      // NOTE: Estimating the cost of conditionally executing the memory</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">      // operations accurately is quite difficult and the current solution</td>
    <td class="lineNumber">245</td>
    <td class="codeline">      // operations accurately is quite difficult and the current solution</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">      // provides a very rough estimate only.</td>
    <td class="lineNumber">246</td>
    <td class="codeline">      // provides a very rough estimate only.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">      ConditionalCost =</td>
    <td class="lineNumber">247</td>
    <td class="codeline">      ConditionalCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">          VT->getNumElements() *</td>
    <td class="lineNumber">248</td>
    <td class="codeline">          VT->getNumElements() *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">          (getVectorInstrCost(</td>
    <td class="lineNumber">249</td>
    <td class="codeline">          (getVectorInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">               Instruction::ExtractElement,</td>
    <td class="lineNumber">250</td>
    <td class="codeline">               Instruction::ExtractElement,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">               FixedVectorType::get(Type::getInt1Ty(DataTy->getContext()),</td>
    <td class="lineNumber">251</td>
    <td class="codeline">               FixedVectorType::get(Type::getInt1Ty(DataTy->getContext()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">                                    VT->getNumElements()),</td>
    <td class="lineNumber">252</td>
    <td class="codeline">                                    VT->getNumElements()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">               CostKind, -1, nullptr, nullptr) +</td>
    <td class="lineNumber">253</td>
    <td class="codeline">               CostKind, -1, nullptr, nullptr) +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">           getCFInstrCost(Instruction::Br, CostKind) +</td>
    <td class="lineNumber">254</td>
    <td class="codeline">           getCFInstrCost(Instruction::Br, CostKind) +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">           getCFInstrCost(Instruction::PHI, CostKind));</td>
    <td class="lineNumber">255</td>
    <td class="codeline">           getCFInstrCost(Instruction::PHI, CostKind));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">256</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline"></td>
    <td class="lineNumber">257</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">    return LoadCost + PackingCost + ConditionalCost;</td>
    <td class="lineNumber">258</td>
    <td class="codeline">    return LoadCost + PackingCost + ConditionalCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">259</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline"></td>
    <td class="lineNumber">260</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">261</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">  explicit BasicTTIImplBase(const TargetMachine *TM, const DataLayout &DL)</td>
    <td class="lineNumber">262</td>
    <td class="codeline">  explicit BasicTTIImplBase(const TargetMachine *TM, const DataLayout &DL)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">      : BaseT(DL) {}</td>
    <td class="lineNumber">263</td>
    <td class="codeline">      : BaseT(DL) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  virtual ~BasicTTIImplBase() = default;</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  virtual ~BasicTTIImplBase() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline"></td>
    <td class="lineNumber">265</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">  using TargetTransformInfoImplBase::DL;</td>
    <td class="lineNumber">266</td>
    <td class="codeline">  using TargetTransformInfoImplBase::DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline"></td>
    <td class="lineNumber">267</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">268</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  /// \name Scalar TTI Implementations</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  /// \name Scalar TTI Implementations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">  /// @{</td>
    <td class="lineNumber">270</td>
    <td class="codeline">  /// @{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">                                      unsigned AddressSpace, Align Alignment,</td>
    <td class="lineNumber">272</td>
    <td class="codeline">                                      unsigned AddressSpace, Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">                                      unsigned *Fast) const {</td>
    <td class="lineNumber">273</td>
    <td class="codeline">                                      unsigned *Fast) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">    EVT E = EVT::getIntegerVT(Context, BitWidth);</td>
    <td class="lineNumber">274</td>
    <td class="codeline">    EVT E = EVT::getIntegerVT(Context, BitWidth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">    return getTLI()->allowsMisalignedMemoryAccesses(</td>
    <td class="lineNumber">275</td>
    <td class="codeline">    return getTLI()->allowsMisalignedMemoryAccesses(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">        E, AddressSpace, Alignment, MachineMemOperand::MONone, Fast);</td>
    <td class="lineNumber">276</td>
    <td class="codeline">        E, AddressSpace, Alignment, MachineMemOperand::MONone, Fast);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">277</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline"></td>
    <td class="lineNumber">278</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">  bool hasBranchDivergence(const Function *F = nullptr) { return false; }</td>
    <td class="lineNumber">279</td>
    <td class="codeline">  bool hasBranchDivergence(const Function *F = nullptr) { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline"></td>
    <td class="lineNumber">280</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">  bool isSourceOfDivergence(const Value *V) { return false; }</td>
    <td class="lineNumber">281</td>
    <td class="codeline">  bool isSourceOfDivergence(const Value *V) { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
    <td class="lineNumber">282</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  bool isAlwaysUniform(const Value *V) { return false; }</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  bool isAlwaysUniform(const Value *V) { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline"></td>
    <td class="lineNumber">284</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const {</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">286</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">287</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const {</td>
    <td class="lineNumber">289</td>
    <td class="codeline">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">290</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
    <td class="lineNumber">292</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  unsigned getFlatAddressSpace() {</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  unsigned getFlatAddressSpace() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">    // Return an invalid address space.</td>
    <td class="lineNumber">294</td>
    <td class="codeline">    // Return an invalid address space.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">    return -1;</td>
    <td class="lineNumber">295</td>
    <td class="codeline">    return -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">296</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline"></td>
    <td class="lineNumber">297</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td class="lineNumber">298</td>
    <td class="codeline">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">                                  Intrinsic::ID IID) const {</td>
    <td class="lineNumber">299</td>
    <td class="codeline">                                  Intrinsic::ID IID) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">300</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline"></td>
    <td class="lineNumber">302</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const {</td>
    <td class="lineNumber">303</td>
    <td class="codeline">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">    return getTLI()->getTargetMachine().isNoopAddrSpaceCast(FromAS, ToAS);</td>
    <td class="lineNumber">304</td>
    <td class="codeline">    return getTLI()->getTargetMachine().isNoopAddrSpaceCast(FromAS, ToAS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">305</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline"></td>
    <td class="lineNumber">306</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  unsigned getAssumedAddrSpace(const Value *V) const {</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  unsigned getAssumedAddrSpace(const Value *V) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">    return getTLI()->getTargetMachine().getAssumedAddrSpace(V);</td>
    <td class="lineNumber">308</td>
    <td class="codeline">    return getTLI()->getTargetMachine().getAssumedAddrSpace(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline"></td>
    <td class="lineNumber">310</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">  bool isSingleThreaded() const {</td>
    <td class="lineNumber">311</td>
    <td class="codeline">  bool isSingleThreaded() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">    return getTLI()->getTargetMachine().Options.ThreadModel ==</td>
    <td class="lineNumber">312</td>
    <td class="codeline">    return getTLI()->getTargetMachine().Options.ThreadModel ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">           ThreadModel::Single;</td>
    <td class="lineNumber">313</td>
    <td class="codeline">           ThreadModel::Single;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">314</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">  std::pair<const Value *, unsigned></td>
    <td class="lineNumber">316</td>
    <td class="codeline">  std::pair<const Value *, unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">  getPredicatedAddrSpace(const Value *V) const {</td>
    <td class="lineNumber">317</td>
    <td class="codeline">  getPredicatedAddrSpace(const Value *V) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">    return getTLI()->getTargetMachine().getPredicatedAddrSpace(V);</td>
    <td class="lineNumber">318</td>
    <td class="codeline">    return getTLI()->getTargetMachine().getPredicatedAddrSpace(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">319</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline"></td>
    <td class="lineNumber">320</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
    <td class="lineNumber">321</td>
    <td class="codeline">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">                                          Value *NewV) const {</td>
    <td class="lineNumber">322</td>
    <td class="codeline">                                          Value *NewV) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">323</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">324</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline"></td>
    <td class="lineNumber">325</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">  bool isLegalAddImmediate(int64_t imm) {</td>
    <td class="lineNumber">326</td>
    <td class="codeline">  bool isLegalAddImmediate(int64_t imm) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">    return getTLI()->isLegalAddImmediate(imm);</td>
    <td class="lineNumber">327</td>
    <td class="codeline">    return getTLI()->isLegalAddImmediate(imm);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">328</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline"></td>
    <td class="lineNumber">329</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  bool isLegalICmpImmediate(int64_t imm) {</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  bool isLegalICmpImmediate(int64_t imm) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">    return getTLI()->isLegalICmpImmediate(imm);</td>
    <td class="lineNumber">331</td>
    <td class="codeline">    return getTLI()->isLegalICmpImmediate(imm);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">332</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline"></td>
    <td class="lineNumber">333</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
    <td class="lineNumber">334</td>
    <td class="codeline">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">                             bool HasBaseReg, int64_t Scale,</td>
    <td class="lineNumber">335</td>
    <td class="codeline">                             bool HasBaseReg, int64_t Scale,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">                             unsigned AddrSpace, Instruction *I = nullptr) {</td>
    <td class="lineNumber">336</td>
    <td class="codeline">                             unsigned AddrSpace, Instruction *I = nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">    TargetLoweringBase::AddrMode AM;</td>
    <td class="lineNumber">337</td>
    <td class="codeline">    TargetLoweringBase::AddrMode AM;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">    AM.BaseGV = BaseGV;</td>
    <td class="lineNumber">338</td>
    <td class="codeline">    AM.BaseGV = BaseGV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">    AM.BaseOffs = BaseOffset;</td>
    <td class="lineNumber">339</td>
    <td class="codeline">    AM.BaseOffs = BaseOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">    AM.HasBaseReg = HasBaseReg;</td>
    <td class="lineNumber">340</td>
    <td class="codeline">    AM.HasBaseReg = HasBaseReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">    AM.Scale = Scale;</td>
    <td class="lineNumber">341</td>
    <td class="codeline">    AM.Scale = Scale;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">    return getTLI()->isLegalAddressingMode(DL, AM, Ty, AddrSpace, I);</td>
    <td class="lineNumber">342</td>
    <td class="codeline">    return getTLI()->isLegalAddressingMode(DL, AM, Ty, AddrSpace, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">343</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">                             Type *ScalarValTy) const {</td>
    <td class="lineNumber">346</td>
    <td class="codeline">                             Type *ScalarValTy) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">    auto &&IsSupportedByTarget = [this, ScalarMemTy, ScalarValTy](unsigned VF) {</td>
    <td class="lineNumber">347</td>
    <td class="codeline">    auto &&IsSupportedByTarget = [this, ScalarMemTy, ScalarValTy](unsigned VF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">      auto *SrcTy = FixedVectorType::get(ScalarMemTy, VF / 2);</td>
    <td class="lineNumber">348</td>
    <td class="codeline">      auto *SrcTy = FixedVectorType::get(ScalarMemTy, VF / 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">      EVT VT = getTLI()->getValueType(DL, SrcTy);</td>
    <td class="lineNumber">349</td>
    <td class="codeline">      EVT VT = getTLI()->getValueType(DL, SrcTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">      if (getTLI()->isOperationLegal(ISD::STORE, VT) ||</td>
    <td class="lineNumber">350</td>
    <td class="codeline">      if (getTLI()->isOperationLegal(ISD::STORE, VT) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">          getTLI()->isOperationCustom(ISD::STORE, VT))</td>
    <td class="lineNumber">351</td>
    <td class="codeline">          getTLI()->isOperationCustom(ISD::STORE, VT))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">352</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline"></td>
    <td class="lineNumber">353</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">      EVT ValVT =</td>
    <td class="lineNumber">354</td>
    <td class="codeline">      EVT ValVT =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">          getTLI()->getValueType(DL, FixedVectorType::get(ScalarValTy, VF / 2));</td>
    <td class="lineNumber">355</td>
    <td class="codeline">          getTLI()->getValueType(DL, FixedVectorType::get(ScalarValTy, VF / 2));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">      EVT LegalizedVT =</td>
    <td class="lineNumber">356</td>
    <td class="codeline">      EVT LegalizedVT =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">          getTLI()->getTypeToTransformTo(ScalarMemTy->getContext(), VT);</td>
    <td class="lineNumber">357</td>
    <td class="codeline">          getTLI()->getTypeToTransformTo(ScalarMemTy->getContext(), VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">      return getTLI()->isTruncStoreLegal(LegalizedVT, ValVT);</td>
    <td class="lineNumber">358</td>
    <td class="codeline">      return getTLI()->isTruncStoreLegal(LegalizedVT, ValVT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">359</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">    while (VF > 2 && IsSupportedByTarget(VF))</td>
    <td class="lineNumber">360</td>
    <td class="codeline">    while (VF > 2 && IsSupportedByTarget(VF))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">      VF /= 2;</td>
    <td class="lineNumber">361</td>
    <td class="codeline">      VF /= 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">    return VF;</td>
    <td class="lineNumber">362</td>
    <td class="codeline">    return VF;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">363</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline"></td>
    <td class="lineNumber">364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">  bool isIndexedLoadLegal(TTI::MemIndexedMode M, Type *Ty,</td>
    <td class="lineNumber">365</td>
    <td class="codeline">  bool isIndexedLoadLegal(TTI::MemIndexedMode M, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">                          const DataLayout &DL) const {</td>
    <td class="lineNumber">366</td>
    <td class="codeline">                          const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">367</td>
    <td class="codeline">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">    return getTLI()->isIndexedLoadLegal(getISDIndexedMode(M), VT);</td>
    <td class="lineNumber">368</td>
    <td class="codeline">    return getTLI()->isIndexedLoadLegal(getISDIndexedMode(M), VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">369</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline"></td>
    <td class="lineNumber">370</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  bool isIndexedStoreLegal(TTI::MemIndexedMode M, Type *Ty,</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  bool isIndexedStoreLegal(TTI::MemIndexedMode M, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">                           const DataLayout &DL) const {</td>
    <td class="lineNumber">372</td>
    <td class="codeline">                           const DataLayout &DL) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">373</td>
    <td class="codeline">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">    return getTLI()->isIndexedStoreLegal(getISDIndexedMode(M), VT);</td>
    <td class="lineNumber">374</td>
    <td class="codeline">    return getTLI()->isIndexedStoreLegal(getISDIndexedMode(M), VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">375</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline"></td>
    <td class="lineNumber">376</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">  bool isLSRCostLess(TTI::LSRCost C1, TTI::LSRCost C2) {</td>
    <td class="lineNumber">377</td>
    <td class="codeline">  bool isLSRCostLess(TTI::LSRCost C1, TTI::LSRCost C2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">    return TargetTransformInfoImplBase::isLSRCostLess(C1, C2);</td>
    <td class="lineNumber">378</td>
    <td class="codeline">    return TargetTransformInfoImplBase::isLSRCostLess(C1, C2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">379</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline"></td>
    <td class="lineNumber">380</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">  bool isNumRegsMajorCostOfLSR() {</td>
    <td class="lineNumber">381</td>
    <td class="codeline">  bool isNumRegsMajorCostOfLSR() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">    return TargetTransformInfoImplBase::isNumRegsMajorCostOfLSR();</td>
    <td class="lineNumber">382</td>
    <td class="codeline">    return TargetTransformInfoImplBase::isNumRegsMajorCostOfLSR();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline"></td>
    <td class="lineNumber">384</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  bool isProfitableLSRChainElement(Instruction *I) {</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  bool isProfitableLSRChainElement(Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">    return TargetTransformInfoImplBase::isProfitableLSRChainElement(I);</td>
    <td class="lineNumber">386</td>
    <td class="codeline">    return TargetTransformInfoImplBase::isProfitableLSRChainElement(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">387</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
    <td class="lineNumber">388</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">389</td>
    <td class="codeline">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">                                       int64_t BaseOffset, bool HasBaseReg,</td>
    <td class="lineNumber">390</td>
    <td class="codeline">                                       int64_t BaseOffset, bool HasBaseReg,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">                                       int64_t Scale, unsigned AddrSpace) {</td>
    <td class="lineNumber">391</td>
    <td class="codeline">                                       int64_t Scale, unsigned AddrSpace) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">    TargetLoweringBase::AddrMode AM;</td>
    <td class="lineNumber">392</td>
    <td class="codeline">    TargetLoweringBase::AddrMode AM;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">    AM.BaseGV = BaseGV;</td>
    <td class="lineNumber">393</td>
    <td class="codeline">    AM.BaseGV = BaseGV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">    AM.BaseOffs = BaseOffset;</td>
    <td class="lineNumber">394</td>
    <td class="codeline">    AM.BaseOffs = BaseOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">    AM.HasBaseReg = HasBaseReg;</td>
    <td class="lineNumber">395</td>
    <td class="codeline">    AM.HasBaseReg = HasBaseReg;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">    AM.Scale = Scale;</td>
    <td class="lineNumber">396</td>
    <td class="codeline">    AM.Scale = Scale;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">    if (getTLI()->isLegalAddressingMode(DL, AM, Ty, AddrSpace))</td>
    <td class="lineNumber">397</td>
    <td class="codeline">    if (getTLI()->isLegalAddressingMode(DL, AM, Ty, AddrSpace))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">      return 0;</td>
    <td class="lineNumber">398</td>
    <td class="codeline">      return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">    return -1;</td>
    <td class="lineNumber">399</td>
    <td class="codeline">    return -1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">400</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline"></td>
    <td class="lineNumber">401</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">  bool isTruncateFree(Type *Ty1, Type *Ty2) {</td>
    <td class="lineNumber">402</td>
    <td class="codeline">  bool isTruncateFree(Type *Ty1, Type *Ty2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">    return getTLI()->isTruncateFree(Ty1, Ty2);</td>
    <td class="lineNumber">403</td>
    <td class="codeline">    return getTLI()->isTruncateFree(Ty1, Ty2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline"></td>
    <td class="lineNumber">405</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">  bool isProfitableToHoist(Instruction *I) {</td>
    <td class="lineNumber">406</td>
    <td class="codeline">  bool isProfitableToHoist(Instruction *I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">    return getTLI()->isProfitableToHoist(I);</td>
    <td class="lineNumber">407</td>
    <td class="codeline">    return getTLI()->isProfitableToHoist(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">408</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">  bool useAA() const { return getST()->useAA(); }</td>
    <td class="lineNumber">410</td>
    <td class="codeline">  bool useAA() const { return getST()->useAA(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline"></td>
    <td class="lineNumber">411</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  bool isTypeLegal(Type *Ty) {</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  bool isTypeLegal(Type *Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">413</td>
    <td class="codeline">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">    return getTLI()->isTypeLegal(VT);</td>
    <td class="lineNumber">414</td>
    <td class="codeline">    return getTLI()->isTypeLegal(VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">415</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline"></td>
    <td class="lineNumber">416</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">  unsigned getRegUsageForType(Type *Ty) {</td>
    <td class="lineNumber">417</td>
    <td class="codeline">  unsigned getRegUsageForType(Type *Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">    EVT ETy = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">418</td>
    <td class="codeline">    EVT ETy = getTLI()->getValueType(DL, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">    return getTLI()->getNumRegisters(Ty->getContext(), ETy);</td>
    <td class="lineNumber">419</td>
    <td class="codeline">    return getTLI()->getNumRegisters(Ty->getContext(), ETy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">420</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline"></td>
    <td class="lineNumber">421</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">  InstructionCost getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  InstructionCost getGEPCost(Type *PointeeType, const Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">                             ArrayRef<const Value *> Operands, Type *AccessType,</td>
    <td class="lineNumber">423</td>
    <td class="codeline">                             ArrayRef<const Value *> Operands, Type *AccessType,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">                             TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">424</td>
    <td class="codeline">                             TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">    return BaseT::getGEPCost(PointeeType, Ptr, Operands, AccessType, CostKind);</td>
    <td class="lineNumber">425</td>
    <td class="codeline">    return BaseT::getGEPCost(PointeeType, Ptr, Operands, AccessType, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline"></td>
    <td class="lineNumber">427</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">                                            unsigned &JumpTableSize,</td>
    <td class="lineNumber">429</td>
    <td class="codeline">                                            unsigned &JumpTableSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">                                            ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">430</td>
    <td class="codeline">                                            ProfileSummaryInfo *PSI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">                                            BlockFrequencyInfo *BFI) {</td>
    <td class="lineNumber">431</td>
    <td class="codeline">                                            BlockFrequencyInfo *BFI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">    /// Try to find the estimated number of clusters. Note that the number of</td>
    <td class="lineNumber">432</td>
    <td class="codeline">    /// Try to find the estimated number of clusters. Note that the number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">    /// clusters identified in this function could be different from the actual</td>
    <td class="lineNumber">433</td>
    <td class="codeline">    /// clusters identified in this function could be different from the actual</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">    /// numbers found in lowering. This function ignore switches that are</td>
    <td class="lineNumber">434</td>
    <td class="codeline">    /// numbers found in lowering. This function ignore switches that are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">    /// lowered with a mix of jump table / bit test / BTree. This function was</td>
    <td class="lineNumber">435</td>
    <td class="codeline">    /// lowered with a mix of jump table / bit test / BTree. This function was</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">    /// initially intended to be used when estimating the cost of switch in</td>
    <td class="lineNumber">436</td>
    <td class="codeline">    /// initially intended to be used when estimating the cost of switch in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">    /// inline cost heuristic, but it's a generic cost model to be used in other</td>
    <td class="lineNumber">437</td>
    <td class="codeline">    /// inline cost heuristic, but it's a generic cost model to be used in other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">    /// places (e.g., in loop unrolling).</td>
    <td class="lineNumber">438</td>
    <td class="codeline">    /// places (e.g., in loop unrolling).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">    unsigned N = SI.getNumCases();</td>
    <td class="lineNumber">439</td>
    <td class="codeline">    unsigned N = SI.getNumCases();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">440</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">    const DataLayout &DL = this->getDataLayout();</td>
    <td class="lineNumber">441</td>
    <td class="codeline">    const DataLayout &DL = this->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline"></td>
    <td class="lineNumber">442</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">    JumpTableSize = 0;</td>
    <td class="lineNumber">443</td>
    <td class="codeline">    JumpTableSize = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">    bool IsJTAllowed = TLI->areJTsAllowed(SI.getParent()->getParent());</td>
    <td class="lineNumber">444</td>
    <td class="codeline">    bool IsJTAllowed = TLI->areJTsAllowed(SI.getParent()->getParent());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline"></td>
    <td class="lineNumber">445</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">    // Early exit if both a jump table and bit test are not allowed.</td>
    <td class="lineNumber">446</td>
    <td class="codeline">    // Early exit if both a jump table and bit test are not allowed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">    if (N < 1 || (!IsJTAllowed && DL.getIndexSizeInBits(0u) < N))</td>
    <td class="lineNumber">447</td>
    <td class="codeline">    if (N < 1 || (!IsJTAllowed && DL.getIndexSizeInBits(0u) < N))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">      return N;</td>
    <td class="lineNumber">448</td>
    <td class="codeline">      return N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline"></td>
    <td class="lineNumber">449</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">    APInt MaxCaseVal = SI.case_begin()->getCaseValue()->getValue();</td>
    <td class="lineNumber">450</td>
    <td class="codeline">    APInt MaxCaseVal = SI.case_begin()->getCaseValue()->getValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">    APInt MinCaseVal = MaxCaseVal;</td>
    <td class="lineNumber">451</td>
    <td class="codeline">    APInt MinCaseVal = MaxCaseVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">    for (auto CI : SI.cases()) {</td>
    <td class="lineNumber">452</td>
    <td class="codeline">    for (auto CI : SI.cases()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">      const APInt &CaseVal = CI.getCaseValue()->getValue();</td>
    <td class="lineNumber">453</td>
    <td class="codeline">      const APInt &CaseVal = CI.getCaseValue()->getValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">      if (CaseVal.sgt(MaxCaseVal))</td>
    <td class="lineNumber">454</td>
    <td class="codeline">      if (CaseVal.sgt(MaxCaseVal))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">        MaxCaseVal = CaseVal;</td>
    <td class="lineNumber">455</td>
    <td class="codeline">        MaxCaseVal = CaseVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">      if (CaseVal.slt(MinCaseVal))</td>
    <td class="lineNumber">456</td>
    <td class="codeline">      if (CaseVal.slt(MinCaseVal))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">        MinCaseVal = CaseVal;</td>
    <td class="lineNumber">457</td>
    <td class="codeline">        MinCaseVal = CaseVal;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">458</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline"></td>
    <td class="lineNumber">459</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">    // Check if suitable for a bit test</td>
    <td class="lineNumber">460</td>
    <td class="codeline">    // Check if suitable for a bit test</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">    if (N <= DL.getIndexSizeInBits(0u)) {</td>
    <td class="lineNumber">461</td>
    <td class="codeline">    if (N <= DL.getIndexSizeInBits(0u)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">      SmallPtrSet<const BasicBlock *, 4> Dests;</td>
    <td class="lineNumber">462</td>
    <td class="codeline">      SmallPtrSet<const BasicBlock *, 4> Dests;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">      for (auto I : SI.cases())</td>
    <td class="lineNumber">463</td>
    <td class="codeline">      for (auto I : SI.cases())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">        Dests.insert(I.getCaseSuccessor());</td>
    <td class="lineNumber">464</td>
    <td class="codeline">        Dests.insert(I.getCaseSuccessor());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline"></td>
    <td class="lineNumber">465</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">      if (TLI->isSuitableForBitTests(Dests.size(), N, MinCaseVal, MaxCaseVal,</td>
    <td class="lineNumber">466</td>
    <td class="codeline">      if (TLI->isSuitableForBitTests(Dests.size(), N, MinCaseVal, MaxCaseVal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">                                     DL))</td>
    <td class="lineNumber">467</td>
    <td class="codeline">                                     DL))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">        return 1;</td>
    <td class="lineNumber">468</td>
    <td class="codeline">        return 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">469</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline"></td>
    <td class="lineNumber">470</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">    // Check if suitable for a jump table.</td>
    <td class="lineNumber">471</td>
    <td class="codeline">    // Check if suitable for a jump table.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">    if (IsJTAllowed) {</td>
    <td class="lineNumber">472</td>
    <td class="codeline">    if (IsJTAllowed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">      if (N < 2 || N < TLI->getMinimumJumpTableEntries())</td>
    <td class="lineNumber">473</td>
    <td class="codeline">      if (N < 2 || N < TLI->getMinimumJumpTableEntries())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">        return N;</td>
    <td class="lineNumber">474</td>
    <td class="codeline">        return N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">      uint64_t Range =</td>
    <td class="lineNumber">475</td>
    <td class="codeline">      uint64_t Range =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">          (MaxCaseVal - MinCaseVal)</td>
    <td class="lineNumber">476</td>
    <td class="codeline">          (MaxCaseVal - MinCaseVal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">              .getLimitedValue(std::numeric_limits<uint64_t>::max() - 1) + 1;</td>
    <td class="lineNumber">477</td>
    <td class="codeline">              .getLimitedValue(std::numeric_limits<uint64_t>::max() - 1) + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">      // Check whether a range of clusters is dense enough for a jump table</td>
    <td class="lineNumber">478</td>
    <td class="codeline">      // Check whether a range of clusters is dense enough for a jump table</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">      if (TLI->isSuitableForJumpTable(&SI, N, Range, PSI, BFI)) {</td>
    <td class="lineNumber">479</td>
    <td class="codeline">      if (TLI->isSuitableForJumpTable(&SI, N, Range, PSI, BFI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">        JumpTableSize = Range;</td>
    <td class="lineNumber">480</td>
    <td class="codeline">        JumpTableSize = Range;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">        return 1;</td>
    <td class="lineNumber">481</td>
    <td class="codeline">        return 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">482</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">483</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">    return N;</td>
    <td class="lineNumber">484</td>
    <td class="codeline">    return N;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">485</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline"></td>
    <td class="lineNumber">486</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">  bool shouldBuildLookupTables() {</td>
    <td class="lineNumber">487</td>
    <td class="codeline">  bool shouldBuildLookupTables() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">488</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">    return TLI->isOperationLegalOrCustom(ISD::BR_JT, MVT::Other) ||</td>
    <td class="lineNumber">489</td>
    <td class="codeline">    return TLI->isOperationLegalOrCustom(ISD::BR_JT, MVT::Other) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">           TLI->isOperationLegalOrCustom(ISD::BRIND, MVT::Other);</td>
    <td class="lineNumber">490</td>
    <td class="codeline">           TLI->isOperationLegalOrCustom(ISD::BRIND, MVT::Other);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline"></td>
    <td class="lineNumber">492</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  bool shouldBuildRelLookupTables() const {</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  bool shouldBuildRelLookupTables() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">    const TargetMachine &TM = getTLI()->getTargetMachine();</td>
    <td class="lineNumber">494</td>
    <td class="codeline">    const TargetMachine &TM = getTLI()->getTargetMachine();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">    // If non-PIC mode, do not generate a relative lookup table.</td>
    <td class="lineNumber">495</td>
    <td class="codeline">    // If non-PIC mode, do not generate a relative lookup table.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">    if (!TM.isPositionIndependent())</td>
    <td class="lineNumber">496</td>
    <td class="codeline">    if (!TM.isPositionIndependent())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">497</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline"></td>
    <td class="lineNumber">498</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">    /// Relative lookup table entries consist of 32-bit offsets.</td>
    <td class="lineNumber">499</td>
    <td class="codeline">    /// Relative lookup table entries consist of 32-bit offsets.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">    /// Do not generate relative lookup tables for large code models</td>
    <td class="lineNumber">500</td>
    <td class="codeline">    /// Do not generate relative lookup tables for large code models</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">    /// in 64-bit achitectures where 32-bit offsets might not be enough.</td>
    <td class="lineNumber">501</td>
    <td class="codeline">    /// in 64-bit achitectures where 32-bit offsets might not be enough.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">    if (TM.getCodeModel() == CodeModel::Medium ||</td>
    <td class="lineNumber">502</td>
    <td class="codeline">    if (TM.getCodeModel() == CodeModel::Medium ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">        TM.getCodeModel() == CodeModel::Large)</td>
    <td class="lineNumber">503</td>
    <td class="codeline">        TM.getCodeModel() == CodeModel::Large)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">504</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline"></td>
    <td class="lineNumber">505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">    Triple TargetTriple = TM.getTargetTriple();</td>
    <td class="lineNumber">506</td>
    <td class="codeline">    Triple TargetTriple = TM.getTargetTriple();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">    if (!TargetTriple.isArch64Bit())</td>
    <td class="lineNumber">507</td>
    <td class="codeline">    if (!TargetTriple.isArch64Bit())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">508</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline"></td>
    <td class="lineNumber">509</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">    // TODO: Triggers issues on aarch64 on darwin, so temporarily disable it</td>
    <td class="lineNumber">510</td>
    <td class="codeline">    // TODO: Triggers issues on aarch64 on darwin, so temporarily disable it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">    // there.</td>
    <td class="lineNumber">511</td>
    <td class="codeline">    // there.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">    if (TargetTriple.getArch() == Triple::aarch64 && TargetTriple.isOSDarwin())</td>
    <td class="lineNumber">512</td>
    <td class="codeline">    if (TargetTriple.getArch() == Triple::aarch64 && TargetTriple.isOSDarwin())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">513</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline"></td>
    <td class="lineNumber">514</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">515</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">516</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
    <td class="lineNumber">517</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">  bool haveFastSqrt(Type *Ty) {</td>
    <td class="lineNumber">518</td>
    <td class="codeline">  bool haveFastSqrt(Type *Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">519</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">    EVT VT = TLI->getValueType(DL, Ty);</td>
    <td class="lineNumber">520</td>
    <td class="codeline">    EVT VT = TLI->getValueType(DL, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">    return TLI->isTypeLegal(VT) &&</td>
    <td class="lineNumber">521</td>
    <td class="codeline">    return TLI->isTypeLegal(VT) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">           TLI->isOperationLegalOrCustom(ISD::FSQRT, VT);</td>
    <td class="lineNumber">522</td>
    <td class="codeline">           TLI->isOperationLegalOrCustom(ISD::FSQRT, VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">523</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline"></td>
    <td class="lineNumber">524</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) {</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">526</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline"></td>
    <td class="lineNumber">528</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">  InstructionCost getFPOpCost(Type *Ty) {</td>
    <td class="lineNumber">529</td>
    <td class="codeline">  InstructionCost getFPOpCost(Type *Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">    // Check whether FADD is available, as a proxy for floating-point in</td>
    <td class="lineNumber">530</td>
    <td class="codeline">    // Check whether FADD is available, as a proxy for floating-point in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">    // general.</td>
    <td class="lineNumber">531</td>
    <td class="codeline">    // general.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">532</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">    EVT VT = TLI->getValueType(DL, Ty);</td>
    <td class="lineNumber">533</td>
    <td class="codeline">    EVT VT = TLI->getValueType(DL, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">    if (TLI->isOperationLegalOrCustomOrPromote(ISD::FADD, VT))</td>
    <td class="lineNumber">534</td>
    <td class="codeline">    if (TLI->isOperationLegalOrCustomOrPromote(ISD::FADD, VT))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">      return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">535</td>
    <td class="codeline">      return TargetTransformInfo::TCC_Basic;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">    return TargetTransformInfo::TCC_Expensive;</td>
    <td class="lineNumber">536</td>
    <td class="codeline">    return TargetTransformInfo::TCC_Expensive;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline"></td>
    <td class="lineNumber">538</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  unsigned getInliningThresholdMultiplier() const { return 1; }</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  unsigned getInliningThresholdMultiplier() const { return 1; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">  unsigned adjustInliningThreshold(const CallBase *CB) { return 0; }</td>
    <td class="lineNumber">540</td>
    <td class="codeline">  unsigned adjustInliningThreshold(const CallBase *CB) { return 0; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  unsigned getCallerAllocaCost(const CallBase *CB, const AllocaInst *AI) const {</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  unsigned getCallerAllocaCost(const CallBase *CB, const AllocaInst *AI) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">542</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">543</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline"></td>
    <td class="lineNumber">544</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">  int getInlinerVectorBonusPercent() const { return 150; }</td>
    <td class="lineNumber">545</td>
    <td class="codeline">  int getInlinerVectorBonusPercent() const { return 150; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline"></td>
    <td class="lineNumber">546</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">  void getUnrollingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">547</td>
    <td class="codeline">  void getUnrollingPreferences(Loop *L, ScalarEvolution &SE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">                               TTI::UnrollingPreferences &UP,</td>
    <td class="lineNumber">548</td>
    <td class="codeline">                               TTI::UnrollingPreferences &UP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">                               OptimizationRemarkEmitter *ORE) {</td>
    <td class="lineNumber">549</td>
    <td class="codeline">                               OptimizationRemarkEmitter *ORE) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">    // This unrolling functionality is target independent, but to provide some</td>
    <td class="lineNumber">550</td>
    <td class="codeline">    // This unrolling functionality is target independent, but to provide some</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">    // motivation for its intended use, for x86:</td>
    <td class="lineNumber">551</td>
    <td class="codeline">    // motivation for its intended use, for x86:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline"></td>
    <td class="lineNumber">552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">    // According to the Intel 64 and IA-32 Architectures Optimization Reference</td>
    <td class="lineNumber">553</td>
    <td class="codeline">    // According to the Intel 64 and IA-32 Architectures Optimization Reference</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">    // Manual, Intel Core models and later have a loop stream detector (and</td>
    <td class="lineNumber">554</td>
    <td class="codeline">    // Manual, Intel Core models and later have a loop stream detector (and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">    // associated uop queue) that can benefit from partial unrolling.</td>
    <td class="lineNumber">555</td>
    <td class="codeline">    // associated uop queue) that can benefit from partial unrolling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">    // The relevant requirements are:</td>
    <td class="lineNumber">556</td>
    <td class="codeline">    // The relevant requirements are:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">    //  - The loop must have no more than 4 (8 for Nehalem and later) branches</td>
    <td class="lineNumber">557</td>
    <td class="codeline">    //  - The loop must have no more than 4 (8 for Nehalem and later) branches</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">    //    taken, and none of them may be calls.</td>
    <td class="lineNumber">558</td>
    <td class="codeline">    //    taken, and none of them may be calls.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">    //  - The loop can have no more than 18 (28 for Nehalem and later) uops.</td>
    <td class="lineNumber">559</td>
    <td class="codeline">    //  - The loop can have no more than 18 (28 for Nehalem and later) uops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline"></td>
    <td class="lineNumber">560</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">    // According to the Software Optimization Guide for AMD Family 15h</td>
    <td class="lineNumber">561</td>
    <td class="codeline">    // According to the Software Optimization Guide for AMD Family 15h</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">    // Processors, models 30h-4fh (Steamroller and later) have a loop predictor</td>
    <td class="lineNumber">562</td>
    <td class="codeline">    // Processors, models 30h-4fh (Steamroller and later) have a loop predictor</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">    // and loop buffer which can benefit from partial unrolling.</td>
    <td class="lineNumber">563</td>
    <td class="codeline">    // and loop buffer which can benefit from partial unrolling.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">    // The relevant requirements are:</td>
    <td class="lineNumber">564</td>
    <td class="codeline">    // The relevant requirements are:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">    //  - The loop must have fewer than 16 branches</td>
    <td class="lineNumber">565</td>
    <td class="codeline">    //  - The loop must have fewer than 16 branches</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">    //  - The loop must have less than 40 uops in all executed loop branches</td>
    <td class="lineNumber">566</td>
    <td class="codeline">    //  - The loop must have less than 40 uops in all executed loop branches</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline"></td>
    <td class="lineNumber">567</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">    // The number of taken branches in a loop is hard to estimate here, and</td>
    <td class="lineNumber">568</td>
    <td class="codeline">    // The number of taken branches in a loop is hard to estimate here, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">    // benchmarking has revealed that it is better not to be conservative when</td>
    <td class="lineNumber">569</td>
    <td class="codeline">    // benchmarking has revealed that it is better not to be conservative when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">    // estimating the branch count. As a result, we'll ignore the branch limits</td>
    <td class="lineNumber">570</td>
    <td class="codeline">    // estimating the branch count. As a result, we'll ignore the branch limits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">    // until someone finds a case where it matters in practice.</td>
    <td class="lineNumber">571</td>
    <td class="codeline">    // until someone finds a case where it matters in practice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline"></td>
    <td class="lineNumber">572</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">    unsigned MaxOps;</td>
    <td class="lineNumber">573</td>
    <td class="codeline">    unsigned MaxOps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">    const TargetSubtargetInfo *ST = getST();</td>
    <td class="lineNumber">574</td>
    <td class="codeline">    const TargetSubtargetInfo *ST = getST();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">    if (PartialUnrollingThreshold.getNumOccurrences() > 0)</td>
    <td class="lineNumber">575</td>
    <td class="codeline">    if (PartialUnrollingThreshold.getNumOccurrences() > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">      MaxOps = PartialUnrollingThreshold;</td>
    <td class="lineNumber">576</td>
    <td class="codeline">      MaxOps = PartialUnrollingThreshold;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">    else if (ST->getSchedModel().LoopMicroOpBufferSize > 0)</td>
    <td class="lineNumber">577</td>
    <td class="codeline">    else if (ST->getSchedModel().LoopMicroOpBufferSize > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">      MaxOps = ST->getSchedModel().LoopMicroOpBufferSize;</td>
    <td class="lineNumber">578</td>
    <td class="codeline">      MaxOps = ST->getSchedModel().LoopMicroOpBufferSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">579</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">580</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline"></td>
    <td class="lineNumber">581</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">    // Scan the loop: don't unroll loops with calls.</td>
    <td class="lineNumber">582</td>
    <td class="codeline">    // Scan the loop: don't unroll loops with calls.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">    for (BasicBlock *BB : L->blocks()) {</td>
    <td class="lineNumber">583</td>
    <td class="codeline">    for (BasicBlock *BB : L->blocks()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">      for (Instruction &I : *BB) {</td>
    <td class="lineNumber">584</td>
    <td class="codeline">      for (Instruction &I : *BB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">        if (isa<CallInst>(I) || isa<InvokeInst>(I)) {</td>
    <td class="lineNumber">585</td>
    <td class="codeline">        if (isa<CallInst>(I) || isa<InvokeInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">          if (const Function *F = cast<CallBase>(I).getCalledFunction()) {</td>
    <td class="lineNumber">586</td>
    <td class="codeline">          if (const Function *F = cast<CallBase>(I).getCalledFunction()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">            if (!thisT()->isLoweredToCall(F))</td>
    <td class="lineNumber">587</td>
    <td class="codeline">            if (!thisT()->isLoweredToCall(F))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">              continue;</td>
    <td class="lineNumber">588</td>
    <td class="codeline">              continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">589</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
    <td class="lineNumber">590</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">          if (ORE) {</td>
    <td class="lineNumber">591</td>
    <td class="codeline">          if (ORE) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">            ORE->emit([&]() {</td>
    <td class="lineNumber">592</td>
    <td class="codeline">            ORE->emit([&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">              return OptimizationRemark("TTI", "DontUnroll", L->getStartLoc(),</td>
    <td class="lineNumber">593</td>
    <td class="codeline">              return OptimizationRemark("TTI", "DontUnroll", L->getStartLoc(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">                                        L->getHeader())</td>
    <td class="lineNumber">594</td>
    <td class="codeline">                                        L->getHeader())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">                     << "advising against unrolling the loop because it "</td>
    <td class="lineNumber">595</td>
    <td class="codeline">                     << "advising against unrolling the loop because it "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">                        "contains a "</td>
    <td class="lineNumber">596</td>
    <td class="codeline">                        "contains a "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">                     << ore::NV("Call", &I);</td>
    <td class="lineNumber">597</td>
    <td class="codeline">                     << ore::NV("Call", &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">            });</td>
    <td class="lineNumber">598</td>
    <td class="codeline">            });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">599</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">          return;</td>
    <td class="lineNumber">600</td>
    <td class="codeline">          return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">601</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">602</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">603</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline"></td>
    <td class="lineNumber">604</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">    // Enable runtime and partial unrolling up to the specified size.</td>
    <td class="lineNumber">605</td>
    <td class="codeline">    // Enable runtime and partial unrolling up to the specified size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">    // Enable using trip count upper bound to unroll loops.</td>
    <td class="lineNumber">606</td>
    <td class="codeline">    // Enable using trip count upper bound to unroll loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">    UP.Partial = UP.Runtime = UP.UpperBound = true;</td>
    <td class="lineNumber">607</td>
    <td class="codeline">    UP.Partial = UP.Runtime = UP.UpperBound = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">    UP.PartialThreshold = MaxOps;</td>
    <td class="lineNumber">608</td>
    <td class="codeline">    UP.PartialThreshold = MaxOps;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline"></td>
    <td class="lineNumber">609</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">    // Avoid unrolling when optimizing for size.</td>
    <td class="lineNumber">610</td>
    <td class="codeline">    // Avoid unrolling when optimizing for size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">    UP.OptSizeThreshold = 0;</td>
    <td class="lineNumber">611</td>
    <td class="codeline">    UP.OptSizeThreshold = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">    UP.PartialOptSizeThreshold = 0;</td>
    <td class="lineNumber">612</td>
    <td class="codeline">    UP.PartialOptSizeThreshold = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
    <td class="lineNumber">613</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">    // Set number of instructions optimized when "back edge"</td>
    <td class="lineNumber">614</td>
    <td class="codeline">    // Set number of instructions optimized when "back edge"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">    // becomes "fall through" to default value of 2.</td>
    <td class="lineNumber">615</td>
    <td class="codeline">    // becomes "fall through" to default value of 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">    UP.BEInsns = 2;</td>
    <td class="lineNumber">616</td>
    <td class="codeline">    UP.BEInsns = 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">617</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
    <td class="lineNumber">618</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">619</td>
    <td class="codeline">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">                             TTI::PeelingPreferences &PP) {</td>
    <td class="lineNumber">620</td>
    <td class="codeline">                             TTI::PeelingPreferences &PP) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">    PP.PeelCount = 0;</td>
    <td class="lineNumber">621</td>
    <td class="codeline">    PP.PeelCount = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">    PP.AllowPeeling = true;</td>
    <td class="lineNumber">622</td>
    <td class="codeline">    PP.AllowPeeling = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">    PP.AllowLoopNestsPeeling = false;</td>
    <td class="lineNumber">623</td>
    <td class="codeline">    PP.AllowLoopNestsPeeling = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">    PP.PeelProfiledIterations = true;</td>
    <td class="lineNumber">624</td>
    <td class="codeline">    PP.PeelProfiledIterations = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">625</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline"></td>
    <td class="lineNumber">626</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">627</td>
    <td class="codeline">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">                                AssumptionCache &AC,</td>
    <td class="lineNumber">628</td>
    <td class="codeline">                                AssumptionCache &AC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">                                TargetLibraryInfo *LibInfo,</td>
    <td class="lineNumber">629</td>
    <td class="codeline">                                TargetLibraryInfo *LibInfo,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">                                HardwareLoopInfo &HWLoopInfo) {</td>
    <td class="lineNumber">630</td>
    <td class="codeline">                                HardwareLoopInfo &HWLoopInfo) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">    return BaseT::isHardwareLoopProfitable(L, SE, AC, LibInfo, HWLoopInfo);</td>
    <td class="lineNumber">631</td>
    <td class="codeline">    return BaseT::isHardwareLoopProfitable(L, SE, AC, LibInfo, HWLoopInfo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">632</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline"></td>
    <td class="lineNumber">633</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) {</td>
    <td class="lineNumber">634</td>
    <td class="codeline">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">    return BaseT::preferPredicateOverEpilogue(TFI);</td>
    <td class="lineNumber">635</td>
    <td class="codeline">    return BaseT::preferPredicateOverEpilogue(TFI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">636</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline"></td>
    <td class="lineNumber">637</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">  TailFoldingStyle</td>
    <td class="lineNumber">638</td>
    <td class="codeline">  TailFoldingStyle</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) {</td>
    <td class="lineNumber">639</td>
    <td class="codeline">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">    return BaseT::getPreferredTailFoldingStyle(IVUpdateMayOverflow);</td>
    <td class="lineNumber">640</td>
    <td class="codeline">    return BaseT::getPreferredTailFoldingStyle(IVUpdateMayOverflow);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">641</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline"></td>
    <td class="lineNumber">642</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  std::optional<Instruction *> instCombineIntrinsic(InstCombiner &IC,</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  std::optional<Instruction *> instCombineIntrinsic(InstCombiner &IC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">                                               IntrinsicInst &II) {</td>
    <td class="lineNumber">644</td>
    <td class="codeline">                                               IntrinsicInst &II) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">    return BaseT::instCombineIntrinsic(IC, II);</td>
    <td class="lineNumber">645</td>
    <td class="codeline">    return BaseT::instCombineIntrinsic(IC, II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">646</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline"></td>
    <td class="lineNumber">647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">  std::optional<Value *></td>
    <td class="lineNumber">648</td>
    <td class="codeline">  std::optional<Value *></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">                                   APInt DemandedMask, KnownBits &Known,</td>
    <td class="lineNumber">650</td>
    <td class="codeline">                                   APInt DemandedMask, KnownBits &Known,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">                                   bool &KnownBitsComputed) {</td>
    <td class="lineNumber">651</td>
    <td class="codeline">                                   bool &KnownBitsComputed) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">    return BaseT::simplifyDemandedUseBitsIntrinsic(IC, II, DemandedMask, Known,</td>
    <td class="lineNumber">652</td>
    <td class="codeline">    return BaseT::simplifyDemandedUseBitsIntrinsic(IC, II, DemandedMask, Known,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">                                                   KnownBitsComputed);</td>
    <td class="lineNumber">653</td>
    <td class="codeline">                                                   KnownBitsComputed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">654</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline"></td>
    <td class="lineNumber">655</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,</td>
    <td class="lineNumber">657</td>
    <td class="codeline">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">      APInt &UndefElts2, APInt &UndefElts3,</td>
    <td class="lineNumber">658</td>
    <td class="codeline">      APInt &UndefElts2, APInt &UndefElts3,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td class="lineNumber">659</td>
    <td class="codeline">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">          SimplifyAndSetOp) {</td>
    <td class="lineNumber">660</td>
    <td class="codeline">          SimplifyAndSetOp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">    return BaseT::simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">661</td>
    <td class="codeline">    return BaseT::simplifyDemandedVectorEltsIntrinsic(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">        IC, II, DemandedElts, UndefElts, UndefElts2, UndefElts3,</td>
    <td class="lineNumber">662</td>
    <td class="codeline">        IC, II, DemandedElts, UndefElts, UndefElts2, UndefElts3,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">        SimplifyAndSetOp);</td>
    <td class="lineNumber">663</td>
    <td class="codeline">        SimplifyAndSetOp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">664</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline"></td>
    <td class="lineNumber">665</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">  virtual std::optional<unsigned></td>
    <td class="lineNumber">666</td>
    <td class="codeline">  virtual std::optional<unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">  getCacheSize(TargetTransformInfo::CacheLevel Level) const {</td>
    <td class="lineNumber">667</td>
    <td class="codeline">  getCacheSize(TargetTransformInfo::CacheLevel Level) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">    return std::optional<unsigned>(</td>
    <td class="lineNumber">668</td>
    <td class="codeline">    return std::optional<unsigned>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">        getST()->getCacheSize(static_cast<unsigned>(Level)));</td>
    <td class="lineNumber">669</td>
    <td class="codeline">        getST()->getCacheSize(static_cast<unsigned>(Level)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">670</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline"></td>
    <td class="lineNumber">671</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline">  virtual std::optional<unsigned></td>
    <td class="lineNumber">672</td>
    <td class="codeline">  virtual std::optional<unsigned></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">  getCacheAssociativity(TargetTransformInfo::CacheLevel Level) const {</td>
    <td class="lineNumber">673</td>
    <td class="codeline">  getCacheAssociativity(TargetTransformInfo::CacheLevel Level) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">    std::optional<unsigned> TargetResult =</td>
    <td class="lineNumber">674</td>
    <td class="codeline">    std::optional<unsigned> TargetResult =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">        getST()->getCacheAssociativity(static_cast<unsigned>(Level));</td>
    <td class="lineNumber">675</td>
    <td class="codeline">        getST()->getCacheAssociativity(static_cast<unsigned>(Level));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
    <td class="lineNumber">676</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">    if (TargetResult)</td>
    <td class="lineNumber">677</td>
    <td class="codeline">    if (TargetResult)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">      return TargetResult;</td>
    <td class="lineNumber">678</td>
    <td class="codeline">      return TargetResult;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline"></td>
    <td class="lineNumber">679</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">    return BaseT::getCacheAssociativity(Level);</td>
    <td class="lineNumber">680</td>
    <td class="codeline">    return BaseT::getCacheAssociativity(Level);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">681</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline"></td>
    <td class="lineNumber">682</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">  virtual unsigned getCacheLineSize() const {</td>
    <td class="lineNumber">683</td>
    <td class="codeline">  virtual unsigned getCacheLineSize() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">    return getST()->getCacheLineSize();</td>
    <td class="lineNumber">684</td>
    <td class="codeline">    return getST()->getCacheLineSize();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">685</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline"></td>
    <td class="lineNumber">686</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">  virtual unsigned getPrefetchDistance() const {</td>
    <td class="lineNumber">687</td>
    <td class="codeline">  virtual unsigned getPrefetchDistance() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">    return getST()->getPrefetchDistance();</td>
    <td class="lineNumber">688</td>
    <td class="codeline">    return getST()->getPrefetchDistance();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">689</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline"></td>
    <td class="lineNumber">690</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">  virtual unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td class="lineNumber">691</td>
    <td class="codeline">  virtual unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">                                        unsigned NumStridedMemAccesses,</td>
    <td class="lineNumber">692</td>
    <td class="codeline">                                        unsigned NumStridedMemAccesses,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">                                        unsigned NumPrefetches,</td>
    <td class="lineNumber">693</td>
    <td class="codeline">                                        unsigned NumPrefetches,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">                                        bool HasCall) const {</td>
    <td class="lineNumber">694</td>
    <td class="codeline">                                        bool HasCall) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">    return getST()->getMinPrefetchStride(NumMemAccesses, NumStridedMemAccesses,</td>
    <td class="lineNumber">695</td>
    <td class="codeline">    return getST()->getMinPrefetchStride(NumMemAccesses, NumStridedMemAccesses,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">                                         NumPrefetches, HasCall);</td>
    <td class="lineNumber">696</td>
    <td class="codeline">                                         NumPrefetches, HasCall);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">697</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline"></td>
    <td class="lineNumber">698</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">  virtual unsigned getMaxPrefetchIterationsAhead() const {</td>
    <td class="lineNumber">699</td>
    <td class="codeline">  virtual unsigned getMaxPrefetchIterationsAhead() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">    return getST()->getMaxPrefetchIterationsAhead();</td>
    <td class="lineNumber">700</td>
    <td class="codeline">    return getST()->getMaxPrefetchIterationsAhead();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">701</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline"></td>
    <td class="lineNumber">702</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">  virtual bool enableWritePrefetching() const {</td>
    <td class="lineNumber">703</td>
    <td class="codeline">  virtual bool enableWritePrefetching() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">    return getST()->enableWritePrefetching();</td>
    <td class="lineNumber">704</td>
    <td class="codeline">    return getST()->enableWritePrefetching();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">705</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline"></td>
    <td class="lineNumber">706</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">  virtual bool shouldPrefetchAddressSpace(unsigned AS) const {</td>
    <td class="lineNumber">707</td>
    <td class="codeline">  virtual bool shouldPrefetchAddressSpace(unsigned AS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">    return getST()->shouldPrefetchAddressSpace(AS);</td>
    <td class="lineNumber">708</td>
    <td class="codeline">    return getST()->shouldPrefetchAddressSpace(AS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">709</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline"></td>
    <td class="lineNumber">710</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">  /// @}</td>
    <td class="lineNumber">711</td>
    <td class="codeline">  /// @}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">  /// \name Vector TTI Implementations</td>
    <td class="lineNumber">713</td>
    <td class="codeline">  /// \name Vector TTI Implementations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">  /// @{</td>
    <td class="lineNumber">714</td>
    <td class="codeline">  /// @{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline"></td>
    <td class="lineNumber">715</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">  TypeSize getRegisterBitWidth(TargetTransformInfo::RegisterKind K) const {</td>
    <td class="lineNumber">716</td>
    <td class="codeline">  TypeSize getRegisterBitWidth(TargetTransformInfo::RegisterKind K) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">    return TypeSize::getFixed(32);</td>
    <td class="lineNumber">717</td>
    <td class="codeline">    return TypeSize::getFixed(32);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">718</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline"></td>
    <td class="lineNumber">719</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">  std::optional<unsigned> getMaxVScale() const { return std::nullopt; }</td>
    <td class="lineNumber">720</td>
    <td class="codeline">  std::optional<unsigned> getMaxVScale() const { return std::nullopt; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">  std::optional<unsigned> getVScaleForTuning() const { return std::nullopt; }</td>
    <td class="lineNumber">721</td>
    <td class="codeline">  std::optional<unsigned> getVScaleForTuning() const { return std::nullopt; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">  bool isVScaleKnownToBeAPowerOfTwo() const { return false; }</td>
    <td class="lineNumber">722</td>
    <td class="codeline">  bool isVScaleKnownToBeAPowerOfTwo() const { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline"></td>
    <td class="lineNumber">723</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">  /// Estimate the overhead of scalarizing an instruction. Insert and Extract</td>
    <td class="lineNumber">724</td>
    <td class="codeline">  /// Estimate the overhead of scalarizing an instruction. Insert and Extract</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">  /// are set if the demanded result elements need to be inserted and/or</td>
    <td class="lineNumber">725</td>
    <td class="codeline">  /// are set if the demanded result elements need to be inserted and/or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">  /// extracted from vectors.</td>
    <td class="lineNumber">726</td>
    <td class="codeline">  /// extracted from vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">  InstructionCost getScalarizationOverhead(VectorType *InTy,</td>
    <td class="lineNumber">727</td>
    <td class="codeline">  InstructionCost getScalarizationOverhead(VectorType *InTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">                                           const APInt &DemandedElts,</td>
    <td class="lineNumber">728</td>
    <td class="codeline">                                           const APInt &DemandedElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">                                           bool Insert, bool Extract,</td>
    <td class="lineNumber">729</td>
    <td class="codeline">                                           bool Insert, bool Extract,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">730</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">    /// FIXME: a bitfield is not a reasonable abstraction for talking about</td>
    <td class="lineNumber">731</td>
    <td class="codeline">    /// FIXME: a bitfield is not a reasonable abstraction for talking about</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">    /// which elements are needed from a scalable vector</td>
    <td class="lineNumber">732</td>
    <td class="codeline">    /// which elements are needed from a scalable vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">    if (isa<ScalableVectorType>(InTy))</td>
    <td class="lineNumber">733</td>
    <td class="codeline">    if (isa<ScalableVectorType>(InTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">734</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">    auto *Ty = cast<FixedVectorType>(InTy);</td>
    <td class="lineNumber">735</td>
    <td class="codeline">    auto *Ty = cast<FixedVectorType>(InTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline"></td>
    <td class="lineNumber">736</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline">    assert(DemandedElts.getBitWidth() == Ty->getNumElements() &&</td>
    <td class="lineNumber">737</td>
    <td class="codeline">    assert(DemandedElts.getBitWidth() == Ty->getNumElements() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">           "Vector size mismatch");</td>
    <td class="lineNumber">738</td>
    <td class="codeline">           "Vector size mismatch");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline"></td>
    <td class="lineNumber">739</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">740</td>
    <td class="codeline">    InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline"></td>
    <td class="lineNumber">741</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">    for (int i = 0, e = Ty->getNumElements(); i < e; ++i) {</td>
    <td class="lineNumber">742</td>
    <td class="codeline">    for (int i = 0, e = Ty->getNumElements(); i < e; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">      if (!DemandedElts[i])</td>
    <td class="lineNumber">743</td>
    <td class="codeline">      if (!DemandedElts[i])</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">744</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">      if (Insert)</td>
    <td class="lineNumber">745</td>
    <td class="codeline">      if (Insert)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">        Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, Ty,</td>
    <td class="lineNumber">746</td>
    <td class="codeline">        Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">                                            CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">747</td>
    <td class="codeline">                                            CostKind, i, nullptr, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">      if (Extract)</td>
    <td class="lineNumber">748</td>
    <td class="codeline">      if (Extract)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">        Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
    <td class="lineNumber">749</td>
    <td class="codeline">        Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">                                            CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">750</td>
    <td class="codeline">                                            CostKind, i, nullptr, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">751</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline"></td>
    <td class="lineNumber">752</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">    return Cost;</td>
    <td class="lineNumber">753</td>
    <td class="codeline">    return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">754</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline"></td>
    <td class="lineNumber">755</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">  /// Helper wrapper for the DemandedElts variant of getScalarizationOverhead.</td>
    <td class="lineNumber">756</td>
    <td class="codeline">  /// Helper wrapper for the DemandedElts variant of getScalarizationOverhead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">  InstructionCost getScalarizationOverhead(VectorType *InTy, bool Insert,</td>
    <td class="lineNumber">757</td>
    <td class="codeline">  InstructionCost getScalarizationOverhead(VectorType *InTy, bool Insert,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">                                           bool Extract,</td>
    <td class="lineNumber">758</td>
    <td class="codeline">                                           bool Extract,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">759</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">    if (isa<ScalableVectorType>(InTy))</td>
    <td class="lineNumber">760</td>
    <td class="codeline">    if (isa<ScalableVectorType>(InTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">761</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">    auto *Ty = cast<FixedVectorType>(InTy);</td>
    <td class="lineNumber">762</td>
    <td class="codeline">    auto *Ty = cast<FixedVectorType>(InTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline"></td>
    <td class="lineNumber">763</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">    APInt DemandedElts = APInt::getAllOnes(Ty->getNumElements());</td>
    <td class="lineNumber">764</td>
    <td class="codeline">    APInt DemandedElts = APInt::getAllOnes(Ty->getNumElements());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">    return thisT()->getScalarizationOverhead(Ty, DemandedElts, Insert, Extract,</td>
    <td class="lineNumber">765</td>
    <td class="codeline">    return thisT()->getScalarizationOverhead(Ty, DemandedElts, Insert, Extract,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">                                             CostKind);</td>
    <td class="lineNumber">766</td>
    <td class="codeline">                                             CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">767</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline"></td>
    <td class="lineNumber">768</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">  /// Estimate the overhead of scalarizing an instructions unique</td>
    <td class="lineNumber">769</td>
    <td class="codeline">  /// Estimate the overhead of scalarizing an instructions unique</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">  /// non-constant operands. The (potentially vector) types to use for each of</td>
    <td class="lineNumber">770</td>
    <td class="codeline">  /// non-constant operands. The (potentially vector) types to use for each of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">  /// argument are passes via Tys.</td>
    <td class="lineNumber">771</td>
    <td class="codeline">  /// argument are passes via Tys.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">772</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">773</td>
    <td class="codeline">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">774</td>
    <td class="codeline">                                   ArrayRef<Type *> Tys,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">                                   TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">775</td>
    <td class="codeline">                                   TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">    assert(Args.size() == Tys.size() && "Expected matching Args and Tys");</td>
    <td class="lineNumber">776</td>
    <td class="codeline">    assert(Args.size() == Tys.size() && "Expected matching Args and Tys");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline"></td>
    <td class="lineNumber">777</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">778</td>
    <td class="codeline">    InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">    SmallPtrSet<const Value*, 4> UniqueOperands;</td>
    <td class="lineNumber">779</td>
    <td class="codeline">    SmallPtrSet<const Value*, 4> UniqueOperands;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">    for (int I = 0, E = Args.size(); I != E; I++) {</td>
    <td class="lineNumber">780</td>
    <td class="codeline">    for (int I = 0, E = Args.size(); I != E; I++) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">      // Disregard things like metadata arguments.</td>
    <td class="lineNumber">781</td>
    <td class="codeline">      // Disregard things like metadata arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">      const Value *A = Args[I];</td>
    <td class="lineNumber">782</td>
    <td class="codeline">      const Value *A = Args[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">      Type *Ty = Tys[I];</td>
    <td class="lineNumber">783</td>
    <td class="codeline">      Type *Ty = Tys[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">      if (!Ty->isIntOrIntVectorTy() && !Ty->isFPOrFPVectorTy() &&</td>
    <td class="lineNumber">784</td>
    <td class="codeline">      if (!Ty->isIntOrIntVectorTy() && !Ty->isFPOrFPVectorTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">          !Ty->isPtrOrPtrVectorTy())</td>
    <td class="lineNumber">785</td>
    <td class="codeline">          !Ty->isPtrOrPtrVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">786</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline"></td>
    <td class="lineNumber">787</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">      if (!isa<Constant>(A) && UniqueOperands.insert(A).second) {</td>
    <td class="lineNumber">788</td>
    <td class="codeline">      if (!isa<Constant>(A) && UniqueOperands.insert(A).second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">        if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td class="lineNumber">789</td>
    <td class="codeline">        if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">          Cost += getScalarizationOverhead(VecTy, /*Insert*/ false,</td>
    <td class="lineNumber">790</td>
    <td class="codeline">          Cost += getScalarizationOverhead(VecTy, /*Insert*/ false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">                                           /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">791</td>
    <td class="codeline">                                           /*Extract*/ true, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">792</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">793</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline"></td>
    <td class="lineNumber">794</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">    return Cost;</td>
    <td class="lineNumber">795</td>
    <td class="codeline">    return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">796</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline"></td>
    <td class="lineNumber">797</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">  /// Estimate the overhead of scalarizing the inputs and outputs of an</td>
    <td class="lineNumber">798</td>
    <td class="codeline">  /// Estimate the overhead of scalarizing the inputs and outputs of an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">  /// instruction, with return type RetTy and arguments Args of type Tys. If</td>
    <td class="lineNumber">799</td>
    <td class="codeline">  /// instruction, with return type RetTy and arguments Args of type Tys. If</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">  /// Args are unknown (empty), then the cost associated with one argument is</td>
    <td class="lineNumber">800</td>
    <td class="codeline">  /// Args are unknown (empty), then the cost associated with one argument is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">  /// added as a heuristic.</td>
    <td class="lineNumber">801</td>
    <td class="codeline">  /// added as a heuristic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">  InstructionCost getScalarizationOverhead(VectorType *RetTy,</td>
    <td class="lineNumber">802</td>
    <td class="codeline">  InstructionCost getScalarizationOverhead(VectorType *RetTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">                                           ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">803</td>
    <td class="codeline">                                           ArrayRef<const Value *> Args,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">                                           ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">804</td>
    <td class="codeline">                                           ArrayRef<Type *> Tys,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">805</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">    InstructionCost Cost = getScalarizationOverhead(</td>
    <td class="lineNumber">806</td>
    <td class="codeline">    InstructionCost Cost = getScalarizationOverhead(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">        RetTy, /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">807</td>
    <td class="codeline">        RetTy, /*Insert*/ true, /*Extract*/ false, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">    if (!Args.empty())</td>
    <td class="lineNumber">808</td>
    <td class="codeline">    if (!Args.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">      Cost += getOperandsScalarizationOverhead(Args, Tys, CostKind);</td>
    <td class="lineNumber">809</td>
    <td class="codeline">      Cost += getOperandsScalarizationOverhead(Args, Tys, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">810</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">      // When no information on arguments is provided, we add the cost</td>
    <td class="lineNumber">811</td>
    <td class="codeline">      // When no information on arguments is provided, we add the cost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">      // associated with one argument as a heuristic.</td>
    <td class="lineNumber">812</td>
    <td class="codeline">      // associated with one argument as a heuristic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">      Cost += getScalarizationOverhead(RetTy, /*Insert*/ false,</td>
    <td class="lineNumber">813</td>
    <td class="codeline">      Cost += getScalarizationOverhead(RetTy, /*Insert*/ false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">                                       /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">814</td>
    <td class="codeline">                                       /*Extract*/ true, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline"></td>
    <td class="lineNumber">815</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">    return Cost;</td>
    <td class="lineNumber">816</td>
    <td class="codeline">    return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline"></td>
    <td class="lineNumber">818</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">  /// Estimate the cost of type-legalization and the legalized type.</td>
    <td class="lineNumber">819</td>
    <td class="codeline">  /// Estimate the cost of type-legalization and the legalized type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">  std::pair<InstructionCost, MVT> getTypeLegalizationCost(Type *Ty) const {</td>
    <td class="lineNumber">820</td>
    <td class="codeline">  std::pair<InstructionCost, MVT> getTypeLegalizationCost(Type *Ty) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">    LLVMContext &C = Ty->getContext();</td>
    <td class="lineNumber">821</td>
    <td class="codeline">    LLVMContext &C = Ty->getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">    EVT MTy = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">822</td>
    <td class="codeline">    EVT MTy = getTLI()->getValueType(DL, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline"></td>
    <td class="lineNumber">823</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">    InstructionCost Cost = 1;</td>
    <td class="lineNumber">824</td>
    <td class="codeline">    InstructionCost Cost = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">    // We keep legalizing the type until we find a legal kind. We assume that</td>
    <td class="lineNumber">825</td>
    <td class="codeline">    // We keep legalizing the type until we find a legal kind. We assume that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">    // the only operation that costs anything is the split. After splitting</td>
    <td class="lineNumber">826</td>
    <td class="codeline">    // the only operation that costs anything is the split. After splitting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">    // we need to handle two types.</td>
    <td class="lineNumber">827</td>
    <td class="codeline">    // we need to handle two types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">    while (true) {</td>
    <td class="lineNumber">828</td>
    <td class="codeline">    while (true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">      TargetLoweringBase::LegalizeKind LK = getTLI()->getTypeConversion(C, MTy);</td>
    <td class="lineNumber">829</td>
    <td class="codeline">      TargetLoweringBase::LegalizeKind LK = getTLI()->getTypeConversion(C, MTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline"></td>
    <td class="lineNumber">830</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">      if (LK.first == TargetLoweringBase::TypeScalarizeScalableVector) {</td>
    <td class="lineNumber">831</td>
    <td class="codeline">      if (LK.first == TargetLoweringBase::TypeScalarizeScalableVector) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">        // Ensure we return a sensible simple VT here, since many callers of</td>
    <td class="lineNumber">832</td>
    <td class="codeline">        // Ensure we return a sensible simple VT here, since many callers of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">        // this function require it.</td>
    <td class="lineNumber">833</td>
    <td class="codeline">        // this function require it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">        MVT VT = MTy.isSimple() ? MTy.getSimpleVT() : MVT::i64;</td>
    <td class="lineNumber">834</td>
    <td class="codeline">        MVT VT = MTy.isSimple() ? MTy.getSimpleVT() : MVT::i64;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">        return std::make_pair(InstructionCost::getInvalid(), VT);</td>
    <td class="lineNumber">835</td>
    <td class="codeline">        return std::make_pair(InstructionCost::getInvalid(), VT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">836</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline"></td>
    <td class="lineNumber">837</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">      if (LK.first == TargetLoweringBase::TypeLegal)</td>
    <td class="lineNumber">838</td>
    <td class="codeline">      if (LK.first == TargetLoweringBase::TypeLegal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">        return std::make_pair(Cost, MTy.getSimpleVT());</td>
    <td class="lineNumber">839</td>
    <td class="codeline">        return std::make_pair(Cost, MTy.getSimpleVT());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline"></td>
    <td class="lineNumber">840</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">      if (LK.first == TargetLoweringBase::TypeSplitVector ||</td>
    <td class="lineNumber">841</td>
    <td class="codeline">      if (LK.first == TargetLoweringBase::TypeSplitVector ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">          LK.first == TargetLoweringBase::TypeExpandInteger)</td>
    <td class="lineNumber">842</td>
    <td class="codeline">          LK.first == TargetLoweringBase::TypeExpandInteger)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">        Cost *= 2;</td>
    <td class="lineNumber">843</td>
    <td class="codeline">        Cost *= 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline"></td>
    <td class="lineNumber">844</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">      // Do not loop with f128 type.</td>
    <td class="lineNumber">845</td>
    <td class="codeline">      // Do not loop with f128 type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">      if (MTy == LK.second)</td>
    <td class="lineNumber">846</td>
    <td class="codeline">      if (MTy == LK.second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">        return std::make_pair(Cost, MTy.getSimpleVT());</td>
    <td class="lineNumber">847</td>
    <td class="codeline">        return std::make_pair(Cost, MTy.getSimpleVT());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline"></td>
    <td class="lineNumber">848</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">      // Keep legalizing the type.</td>
    <td class="lineNumber">849</td>
    <td class="codeline">      // Keep legalizing the type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">      MTy = LK.second;</td>
    <td class="lineNumber">850</td>
    <td class="codeline">      MTy = LK.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">851</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">852</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline"></td>
    <td class="lineNumber">853</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">  unsigned getMaxInterleaveFactor(ElementCount VF) { return 1; }</td>
    <td class="lineNumber">854</td>
    <td class="codeline">  unsigned getMaxInterleaveFactor(ElementCount VF) { return 1; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline"></td>
    <td class="lineNumber">855</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">  InstructionCost getArithmeticInstrCost(</td>
    <td class="lineNumber">856</td>
    <td class="codeline">  InstructionCost getArithmeticInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">857</td>
    <td class="codeline">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">      TTI::OperandValueInfo Opd1Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">858</td>
    <td class="codeline">      TTI::OperandValueInfo Opd1Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">      TTI::OperandValueInfo Opd2Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">859</td>
    <td class="codeline">      TTI::OperandValueInfo Opd2Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">      ArrayRef<const Value *> Args = ArrayRef<const Value *>(),</td>
    <td class="lineNumber">860</td>
    <td class="codeline">      ArrayRef<const Value *> Args = ArrayRef<const Value *>(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">      const Instruction *CxtI = nullptr) {</td>
    <td class="lineNumber">861</td>
    <td class="codeline">      const Instruction *CxtI = nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">    // Check if any of the operands are vector operands.</td>
    <td class="lineNumber">862</td>
    <td class="codeline">    // Check if any of the operands are vector operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">863</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
    <td class="lineNumber">864</td>
    <td class="codeline">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">    assert(ISD && "Invalid opcode");</td>
    <td class="lineNumber">865</td>
    <td class="codeline">    assert(ISD && "Invalid opcode");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline"></td>
    <td class="lineNumber">866</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">    // TODO: Handle more cost kinds.</td>
    <td class="lineNumber">867</td>
    <td class="codeline">    // TODO: Handle more cost kinds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">    if (CostKind != TTI::TCK_RecipThroughput)</td>
    <td class="lineNumber">868</td>
    <td class="codeline">    if (CostKind != TTI::TCK_RecipThroughput)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">      return BaseT::getArithmeticInstrCost(Opcode, Ty, CostKind,</td>
    <td class="lineNumber">869</td>
    <td class="codeline">      return BaseT::getArithmeticInstrCost(Opcode, Ty, CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">                                           Opd1Info, Opd2Info,</td>
    <td class="lineNumber">870</td>
    <td class="codeline">                                           Opd1Info, Opd2Info,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">                                           Args, CxtI);</td>
    <td class="lineNumber">871</td>
    <td class="codeline">                                           Args, CxtI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline"></td>
    <td class="lineNumber">872</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Ty);</td>
    <td class="lineNumber">873</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">    bool IsFloat = Ty->isFPOrFPVectorTy();</td>
    <td class="lineNumber">875</td>
    <td class="codeline">    bool IsFloat = Ty->isFPOrFPVectorTy();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">    // Assume that floating point arithmetic operations cost twice as much as</td>
    <td class="lineNumber">876</td>
    <td class="codeline">    // Assume that floating point arithmetic operations cost twice as much as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">    // integer operations.</td>
    <td class="lineNumber">877</td>
    <td class="codeline">    // integer operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">    InstructionCost OpCost = (IsFloat ? 2 : 1);</td>
    <td class="lineNumber">878</td>
    <td class="codeline">    InstructionCost OpCost = (IsFloat ? 2 : 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline"></td>
    <td class="lineNumber">879</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">    if (TLI->isOperationLegalOrPromote(ISD, LT.second)) {</td>
    <td class="lineNumber">880</td>
    <td class="codeline">    if (TLI->isOperationLegalOrPromote(ISD, LT.second)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">      // The operation is legal. Assume it costs 1.</td>
    <td class="lineNumber">881</td>
    <td class="codeline">      // The operation is legal. Assume it costs 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">      // TODO: Once we have extract/insert subvector cost we need to use them.</td>
    <td class="lineNumber">882</td>
    <td class="codeline">      // TODO: Once we have extract/insert subvector cost we need to use them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">      return LT.first * OpCost;</td>
    <td class="lineNumber">883</td>
    <td class="codeline">      return LT.first * OpCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">884</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline"></td>
    <td class="lineNumber">885</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">    if (!TLI->isOperationExpand(ISD, LT.second)) {</td>
    <td class="lineNumber">886</td>
    <td class="codeline">    if (!TLI->isOperationExpand(ISD, LT.second)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">      // If the operation is custom lowered, then assume that the code is twice</td>
    <td class="lineNumber">887</td>
    <td class="codeline">      // If the operation is custom lowered, then assume that the code is twice</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">      // as expensive.</td>
    <td class="lineNumber">888</td>
    <td class="codeline">      // as expensive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">      return LT.first * 2 * OpCost;</td>
    <td class="lineNumber">889</td>
    <td class="codeline">      return LT.first * 2 * OpCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">890</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline"></td>
    <td class="lineNumber">891</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">    // An 'Expand' of URem and SRem is special because it may default</td>
    <td class="lineNumber">892</td>
    <td class="codeline">    // An 'Expand' of URem and SRem is special because it may default</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">    // to expanding the operation into a sequence of sub-operations</td>
    <td class="lineNumber">893</td>
    <td class="codeline">    // to expanding the operation into a sequence of sub-operations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">    // i.e. X % Y -> X-(X/Y)*Y.</td>
    <td class="lineNumber">894</td>
    <td class="codeline">    // i.e. X % Y -> X-(X/Y)*Y.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">    if (ISD == ISD::UREM || ISD == ISD::SREM) {</td>
    <td class="lineNumber">895</td>
    <td class="codeline">    if (ISD == ISD::UREM || ISD == ISD::SREM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">      bool IsSigned = ISD == ISD::SREM;</td>
    <td class="lineNumber">896</td>
    <td class="codeline">      bool IsSigned = ISD == ISD::SREM;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline">      if (TLI->isOperationLegalOrCustom(IsSigned ? ISD::SDIVREM : ISD::UDIVREM,</td>
    <td class="lineNumber">897</td>
    <td class="codeline">      if (TLI->isOperationLegalOrCustom(IsSigned ? ISD::SDIVREM : ISD::UDIVREM,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">                                        LT.second) ||</td>
    <td class="lineNumber">898</td>
    <td class="codeline">                                        LT.second) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">          TLI->isOperationLegalOrCustom(IsSigned ? ISD::SDIV : ISD::UDIV,</td>
    <td class="lineNumber">899</td>
    <td class="codeline">          TLI->isOperationLegalOrCustom(IsSigned ? ISD::SDIV : ISD::UDIV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">                                        LT.second)) {</td>
    <td class="lineNumber">900</td>
    <td class="codeline">                                        LT.second)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">        unsigned DivOpc = IsSigned ? Instruction::SDiv : Instruction::UDiv;</td>
    <td class="lineNumber">901</td>
    <td class="codeline">        unsigned DivOpc = IsSigned ? Instruction::SDiv : Instruction::UDiv;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">        InstructionCost DivCost = thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">902</td>
    <td class="codeline">        InstructionCost DivCost = thisT()->getArithmeticInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">            DivOpc, Ty, CostKind, Opd1Info, Opd2Info);</td>
    <td class="lineNumber">903</td>
    <td class="codeline">            DivOpc, Ty, CostKind, Opd1Info, Opd2Info);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">        InstructionCost MulCost =</td>
    <td class="lineNumber">904</td>
    <td class="codeline">        InstructionCost MulCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">            thisT()->getArithmeticInstrCost(Instruction::Mul, Ty, CostKind);</td>
    <td class="lineNumber">905</td>
    <td class="codeline">            thisT()->getArithmeticInstrCost(Instruction::Mul, Ty, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">        InstructionCost SubCost =</td>
    <td class="lineNumber">906</td>
    <td class="codeline">        InstructionCost SubCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">            thisT()->getArithmeticInstrCost(Instruction::Sub, Ty, CostKind);</td>
    <td class="lineNumber">907</td>
    <td class="codeline">            thisT()->getArithmeticInstrCost(Instruction::Sub, Ty, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">        return DivCost + MulCost + SubCost;</td>
    <td class="lineNumber">908</td>
    <td class="codeline">        return DivCost + MulCost + SubCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">909</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">910</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline"></td>
    <td class="lineNumber">911</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">    // We cannot scalarize scalable vectors, so return Invalid.</td>
    <td class="lineNumber">912</td>
    <td class="codeline">    // We cannot scalarize scalable vectors, so return Invalid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline">    if (isa<ScalableVectorType>(Ty))</td>
    <td class="lineNumber">913</td>
    <td class="codeline">    if (isa<ScalableVectorType>(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">914</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline"></td>
    <td class="lineNumber">915</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">    // Else, assume that we need to scalarize this op.</td>
    <td class="lineNumber">916</td>
    <td class="codeline">    // Else, assume that we need to scalarize this op.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">    // TODO: If one of the types get legalized by splitting, handle this</td>
    <td class="lineNumber">917</td>
    <td class="codeline">    // TODO: If one of the types get legalized by splitting, handle this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">    // similarly to what getCastInstrCost() does.</td>
    <td class="lineNumber">918</td>
    <td class="codeline">    // similarly to what getCastInstrCost() does.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">    if (auto *VTy = dyn_cast<FixedVectorType>(Ty)) {</td>
    <td class="lineNumber">919</td>
    <td class="codeline">    if (auto *VTy = dyn_cast<FixedVectorType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">      InstructionCost Cost = thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">920</td>
    <td class="codeline">      InstructionCost Cost = thisT()->getArithmeticInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">          Opcode, VTy->getScalarType(), CostKind, Opd1Info, Opd2Info,</td>
    <td class="lineNumber">921</td>
    <td class="codeline">          Opcode, VTy->getScalarType(), CostKind, Opd1Info, Opd2Info,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">          Args, CxtI);</td>
    <td class="lineNumber">922</td>
    <td class="codeline">          Args, CxtI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">      // Return the cost of multiple scalar invocation plus the cost of</td>
    <td class="lineNumber">923</td>
    <td class="codeline">      // Return the cost of multiple scalar invocation plus the cost of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">      // inserting and extracting the values.</td>
    <td class="lineNumber">924</td>
    <td class="codeline">      // inserting and extracting the values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">      SmallVector<Type *> Tys(Args.size(), Ty);</td>
    <td class="lineNumber">925</td>
    <td class="codeline">      SmallVector<Type *> Tys(Args.size(), Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">      return getScalarizationOverhead(VTy, Args, Tys, CostKind) +</td>
    <td class="lineNumber">926</td>
    <td class="codeline">      return getScalarizationOverhead(VTy, Args, Tys, CostKind) +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">             VTy->getNumElements() * Cost;</td>
    <td class="lineNumber">927</td>
    <td class="codeline">             VTy->getNumElements() * Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">928</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline"></td>
    <td class="lineNumber">929</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">    // We don't know anything about this scalar instruction.</td>
    <td class="lineNumber">930</td>
    <td class="codeline">    // We don't know anything about this scalar instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">    return OpCost;</td>
    <td class="lineNumber">931</td>
    <td class="codeline">    return OpCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">932</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline"></td>
    <td class="lineNumber">933</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline">  TTI::ShuffleKind improveShuffleKindFromMask(TTI::ShuffleKind Kind,</td>
    <td class="lineNumber">934</td>
    <td class="codeline">  TTI::ShuffleKind improveShuffleKindFromMask(TTI::ShuffleKind Kind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">                                              ArrayRef<int> Mask) const {</td>
    <td class="lineNumber">935</td>
    <td class="codeline">                                              ArrayRef<int> Mask) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">    int Limit = Mask.size() * 2;</td>
    <td class="lineNumber">936</td>
    <td class="codeline">    int Limit = Mask.size() * 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">    if (Mask.empty() ||</td>
    <td class="lineNumber">937</td>
    <td class="codeline">    if (Mask.empty() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">        // Extra check required by isSingleSourceMaskImpl function (called by</td>
    <td class="lineNumber">938</td>
    <td class="codeline">        // Extra check required by isSingleSourceMaskImpl function (called by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">        // ShuffleVectorInst::isSingleSourceMask).</td>
    <td class="lineNumber">939</td>
    <td class="codeline">        // ShuffleVectorInst::isSingleSourceMask).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">        any_of(Mask, [Limit](int I) { return I >= Limit; }))</td>
    <td class="lineNumber">940</td>
    <td class="codeline">        any_of(Mask, [Limit](int I) { return I >= Limit; }))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">      return Kind;</td>
    <td class="lineNumber">941</td>
    <td class="codeline">      return Kind;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">    int Index;</td>
    <td class="lineNumber">942</td>
    <td class="codeline">    int Index;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">    switch (Kind) {</td>
    <td class="lineNumber">943</td>
    <td class="codeline">    switch (Kind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">    case TTI::SK_PermuteSingleSrc:</td>
    <td class="lineNumber">944</td>
    <td class="codeline">    case TTI::SK_PermuteSingleSrc:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">      if (ShuffleVectorInst::isReverseMask(Mask))</td>
    <td class="lineNumber">945</td>
    <td class="codeline">      if (ShuffleVectorInst::isReverseMask(Mask))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">        return TTI::SK_Reverse;</td>
    <td class="lineNumber">946</td>
    <td class="codeline">        return TTI::SK_Reverse;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">      if (ShuffleVectorInst::isZeroEltSplatMask(Mask))</td>
    <td class="lineNumber">947</td>
    <td class="codeline">      if (ShuffleVectorInst::isZeroEltSplatMask(Mask))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">        return TTI::SK_Broadcast;</td>
    <td class="lineNumber">948</td>
    <td class="codeline">        return TTI::SK_Broadcast;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">949</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">    case TTI::SK_PermuteTwoSrc:</td>
    <td class="lineNumber">950</td>
    <td class="codeline">    case TTI::SK_PermuteTwoSrc:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">      if (ShuffleVectorInst::isSelectMask(Mask))</td>
    <td class="lineNumber">951</td>
    <td class="codeline">      if (ShuffleVectorInst::isSelectMask(Mask))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">        return TTI::SK_Select;</td>
    <td class="lineNumber">952</td>
    <td class="codeline">        return TTI::SK_Select;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">      if (ShuffleVectorInst::isTransposeMask(Mask))</td>
    <td class="lineNumber">953</td>
    <td class="codeline">      if (ShuffleVectorInst::isTransposeMask(Mask))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">        return TTI::SK_Transpose;</td>
    <td class="lineNumber">954</td>
    <td class="codeline">        return TTI::SK_Transpose;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">      if (ShuffleVectorInst::isSpliceMask(Mask, Index))</td>
    <td class="lineNumber">955</td>
    <td class="codeline">      if (ShuffleVectorInst::isSpliceMask(Mask, Index))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">        return TTI::SK_Splice;</td>
    <td class="lineNumber">956</td>
    <td class="codeline">        return TTI::SK_Splice;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">957</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">    case TTI::SK_Select:</td>
    <td class="lineNumber">958</td>
    <td class="codeline">    case TTI::SK_Select:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">    case TTI::SK_Reverse:</td>
    <td class="lineNumber">959</td>
    <td class="codeline">    case TTI::SK_Reverse:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">    case TTI::SK_Broadcast:</td>
    <td class="lineNumber">960</td>
    <td class="codeline">    case TTI::SK_Broadcast:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">    case TTI::SK_Transpose:</td>
    <td class="lineNumber">961</td>
    <td class="codeline">    case TTI::SK_Transpose:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">    case TTI::SK_InsertSubvector:</td>
    <td class="lineNumber">962</td>
    <td class="codeline">    case TTI::SK_InsertSubvector:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">    case TTI::SK_ExtractSubvector:</td>
    <td class="lineNumber">963</td>
    <td class="codeline">    case TTI::SK_ExtractSubvector:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">    case TTI::SK_Splice:</td>
    <td class="lineNumber">964</td>
    <td class="codeline">    case TTI::SK_Splice:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">965</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">966</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">    return Kind;</td>
    <td class="lineNumber">967</td>
    <td class="codeline">    return Kind;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">968</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline"></td>
    <td class="lineNumber">969</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">  InstructionCost getShuffleCost(TTI::ShuffleKind Kind, VectorType *Tp,</td>
    <td class="lineNumber">970</td>
    <td class="codeline">  InstructionCost getShuffleCost(TTI::ShuffleKind Kind, VectorType *Tp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">                                 ArrayRef<int> Mask,</td>
    <td class="lineNumber">971</td>
    <td class="codeline">                                 ArrayRef<int> Mask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">                                 TTI::TargetCostKind CostKind, int Index,</td>
    <td class="lineNumber">972</td>
    <td class="codeline">                                 TTI::TargetCostKind CostKind, int Index,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">                                 VectorType *SubTp,</td>
    <td class="lineNumber">973</td>
    <td class="codeline">                                 VectorType *SubTp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">                                 ArrayRef<const Value *> Args = std::nullopt) {</td>
    <td class="lineNumber">974</td>
    <td class="codeline">                                 ArrayRef<const Value *> Args = std::nullopt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline"></td>
    <td class="lineNumber">975</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">    switch (improveShuffleKindFromMask(Kind, Mask)) {</td>
    <td class="lineNumber">976</td>
    <td class="codeline">    switch (improveShuffleKindFromMask(Kind, Mask)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">    case TTI::SK_Broadcast:</td>
    <td class="lineNumber">977</td>
    <td class="codeline">    case TTI::SK_Broadcast:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">      if (auto *FVT = dyn_cast<FixedVectorType>(Tp))</td>
    <td class="lineNumber">978</td>
    <td class="codeline">      if (auto *FVT = dyn_cast<FixedVectorType>(Tp))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">        return getBroadcastShuffleOverhead(FVT, CostKind);</td>
    <td class="lineNumber">979</td>
    <td class="codeline">        return getBroadcastShuffleOverhead(FVT, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">980</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">    case TTI::SK_Select:</td>
    <td class="lineNumber">981</td>
    <td class="codeline">    case TTI::SK_Select:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">    case TTI::SK_Splice:</td>
    <td class="lineNumber">982</td>
    <td class="codeline">    case TTI::SK_Splice:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">    case TTI::SK_Reverse:</td>
    <td class="lineNumber">983</td>
    <td class="codeline">    case TTI::SK_Reverse:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">    case TTI::SK_Transpose:</td>
    <td class="lineNumber">984</td>
    <td class="codeline">    case TTI::SK_Transpose:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">    case TTI::SK_PermuteSingleSrc:</td>
    <td class="lineNumber">985</td>
    <td class="codeline">    case TTI::SK_PermuteSingleSrc:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">    case TTI::SK_PermuteTwoSrc:</td>
    <td class="lineNumber">986</td>
    <td class="codeline">    case TTI::SK_PermuteTwoSrc:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">      if (auto *FVT = dyn_cast<FixedVectorType>(Tp))</td>
    <td class="lineNumber">987</td>
    <td class="codeline">      if (auto *FVT = dyn_cast<FixedVectorType>(Tp))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">        return getPermuteShuffleOverhead(FVT, CostKind);</td>
    <td class="lineNumber">988</td>
    <td class="codeline">        return getPermuteShuffleOverhead(FVT, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">989</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">    case TTI::SK_ExtractSubvector:</td>
    <td class="lineNumber">990</td>
    <td class="codeline">    case TTI::SK_ExtractSubvector:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">      return getExtractSubvectorOverhead(Tp, CostKind, Index,</td>
    <td class="lineNumber">991</td>
    <td class="codeline">      return getExtractSubvectorOverhead(Tp, CostKind, Index,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">                                         cast<FixedVectorType>(SubTp));</td>
    <td class="lineNumber">992</td>
    <td class="codeline">                                         cast<FixedVectorType>(SubTp));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline">    case TTI::SK_InsertSubvector:</td>
    <td class="lineNumber">993</td>
    <td class="codeline">    case TTI::SK_InsertSubvector:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">      return getInsertSubvectorOverhead(Tp, CostKind, Index,</td>
    <td class="lineNumber">994</td>
    <td class="codeline">      return getInsertSubvectorOverhead(Tp, CostKind, Index,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">                                        cast<FixedVectorType>(SubTp));</td>
    <td class="lineNumber">995</td>
    <td class="codeline">                                        cast<FixedVectorType>(SubTp));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">996</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">    llvm_unreachable("Unknown TTI::ShuffleKind");</td>
    <td class="lineNumber">997</td>
    <td class="codeline">    llvm_unreachable("Unknown TTI::ShuffleKind");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">998</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline"></td>
    <td class="lineNumber">999</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">  InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">  InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">                                   TTI::CastContextHint CCH,</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">                                   TTI::CastContextHint CCH,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">                                   TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">                                   TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">                                   const Instruction *I = nullptr) {</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">                                   const Instruction *I = nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">    if (BaseT::getCastInstrCost(Opcode, Dst, Src, CCH, CostKind, I) == 0)</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">    if (BaseT::getCastInstrCost(Opcode, Dst, Src, CCH, CostKind, I) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">      return 0;</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">      return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline"></td>
    <td class="lineNumber">1006</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">    assert(ISD && "Invalid opcode");</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">    assert(ISD && "Invalid opcode");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> SrcLT = getTypeLegalizationCost(Src);</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> SrcLT = getTypeLegalizationCost(Src);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> DstLT = getTypeLegalizationCost(Dst);</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> DstLT = getTypeLegalizationCost(Dst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline"></td>
    <td class="lineNumber">1012</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">    TypeSize SrcSize = SrcLT.second.getSizeInBits();</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">    TypeSize SrcSize = SrcLT.second.getSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">    TypeSize DstSize = DstLT.second.getSizeInBits();</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">    TypeSize DstSize = DstLT.second.getSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline">    bool IntOrPtrSrc = Src->isIntegerTy() || Src->isPointerTy();</td>
    <td class="lineNumber">1015</td>
    <td class="codeline">    bool IntOrPtrSrc = Src->isIntegerTy() || Src->isPointerTy();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">    bool IntOrPtrDst = Dst->isIntegerTy() || Dst->isPointerTy();</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">    bool IntOrPtrDst = Dst->isIntegerTy() || Dst->isPointerTy();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline"></td>
    <td class="lineNumber">1017</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">    switch (Opcode) {</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">    switch (Opcode) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">    case Instruction::Trunc:</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">    case Instruction::Trunc:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">      // Check for NOOP conversions.</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">      // Check for NOOP conversions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">      if (TLI->isTruncateFree(SrcLT.second, DstLT.second))</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">      if (TLI->isTruncateFree(SrcLT.second, DstLT.second))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">        return 0;</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">        return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">      [[fallthrough]];</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">      [[fallthrough]];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">    case Instruction::BitCast:</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">    case Instruction::BitCast:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">      // Bitcast between types that are legalized to the same type are free and</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">      // Bitcast between types that are legalized to the same type are free and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">      // assume int to/from ptr of the same size is also free.</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">      // assume int to/from ptr of the same size is also free.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">      if (SrcLT.first == DstLT.first && IntOrPtrSrc == IntOrPtrDst &&</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">      if (SrcLT.first == DstLT.first && IntOrPtrSrc == IntOrPtrDst &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">          SrcSize == DstSize)</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">          SrcSize == DstSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">        return 0;</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">        return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">    case Instruction::FPExt:</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">    case Instruction::FPExt:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">      if (I && getTLI()->isExtFree(I))</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">      if (I && getTLI()->isExtFree(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">        return 0;</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">        return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">    case Instruction::ZExt:</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">    case Instruction::ZExt:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">      if (TLI->isZExtFree(SrcLT.second, DstLT.second))</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">      if (TLI->isZExtFree(SrcLT.second, DstLT.second))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">        return 0;</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">        return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">      [[fallthrough]];</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">      [[fallthrough]];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">    case Instruction::SExt:</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">    case Instruction::SExt:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">      if (I && getTLI()->isExtFree(I))</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">      if (I && getTLI()->isExtFree(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">        return 0;</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">        return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline"></td>
    <td class="lineNumber">1044</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">      // If this is a zext/sext of a load, return 0 if the corresponding</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">      // If this is a zext/sext of a load, return 0 if the corresponding</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">      // extending load exists on target and the result type is legal.</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">      // extending load exists on target and the result type is legal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">      if (CCH == TTI::CastContextHint::Normal) {</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">      if (CCH == TTI::CastContextHint::Normal) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">        EVT ExtVT = EVT::getEVT(Dst);</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">        EVT ExtVT = EVT::getEVT(Dst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">        EVT LoadVT = EVT::getEVT(Src);</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">        EVT LoadVT = EVT::getEVT(Src);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">        unsigned LType =</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">        unsigned LType =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">          ((Opcode == Instruction::ZExt) ? ISD::ZEXTLOAD : ISD::SEXTLOAD);</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">          ((Opcode == Instruction::ZExt) ? ISD::ZEXTLOAD : ISD::SEXTLOAD);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">        if (DstLT.first == SrcLT.first &&</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">        if (DstLT.first == SrcLT.first &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">            TLI->isLoadExtLegal(LType, ExtVT, LoadVT))</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">            TLI->isLoadExtLegal(LType, ExtVT, LoadVT))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">          return 0;</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">          return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">    case Instruction::AddrSpaceCast:</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">    case Instruction::AddrSpaceCast:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">      if (TLI->isFreeAddrSpaceCast(Src->getPointerAddressSpace(),</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">      if (TLI->isFreeAddrSpaceCast(Src->getPointerAddressSpace(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">                                   Dst->getPointerAddressSpace()))</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">                                   Dst->getPointerAddressSpace()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">        return 0;</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">        return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline"></td>
    <td class="lineNumber">1063</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">    auto *SrcVTy = dyn_cast<VectorType>(Src);</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">    auto *SrcVTy = dyn_cast<VectorType>(Src);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">    auto *DstVTy = dyn_cast<VectorType>(Dst);</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">    auto *DstVTy = dyn_cast<VectorType>(Dst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline"></td>
    <td class="lineNumber">1066</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">    // If the cast is marked as legal (or promote) then assume low cost.</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">    // If the cast is marked as legal (or promote) then assume low cost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">    if (SrcLT.first == DstLT.first &&</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">    if (SrcLT.first == DstLT.first &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">        TLI->isOperationLegalOrPromote(ISD, DstLT.second))</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">        TLI->isOperationLegalOrPromote(ISD, DstLT.second))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">      return SrcLT.first;</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">      return SrcLT.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
    <td class="lineNumber">1071</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">    // Handle scalar conversions.</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">    // Handle scalar conversions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">    if (!SrcVTy && !DstVTy) {</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">    if (!SrcVTy && !DstVTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">      // Just check the op cost. If the operation is legal then assume it costs</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">      // Just check the op cost. If the operation is legal then assume it costs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">      // 1.</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">      // 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">      if (!TLI->isOperationExpand(ISD, DstLT.second))</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">      if (!TLI->isOperationExpand(ISD, DstLT.second))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">        return 1;</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">        return 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline"></td>
    <td class="lineNumber">1078</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">      // Assume that illegal scalar instruction are expensive.</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">      // Assume that illegal scalar instruction are expensive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">      return 4;</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">      return 4;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1081</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline"></td>
    <td class="lineNumber">1082</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">    // Check vector-to-vector casts.</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">    // Check vector-to-vector casts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">    if (DstVTy && SrcVTy) {</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">    if (DstVTy && SrcVTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">      // If the cast is between same-sized registers, then the check is simple.</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">      // If the cast is between same-sized registers, then the check is simple.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">      if (SrcLT.first == DstLT.first && SrcSize == DstSize) {</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">      if (SrcLT.first == DstLT.first && SrcSize == DstSize) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline"></td>
    <td class="lineNumber">1087</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">        // Assume that Zext is done using AND.</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">        // Assume that Zext is done using AND.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">        if (Opcode == Instruction::ZExt)</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">        if (Opcode == Instruction::ZExt)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">          return SrcLT.first;</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">          return SrcLT.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline"></td>
    <td class="lineNumber">1091</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">        // Assume that sext is done using SHL and SRA.</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">        // Assume that sext is done using SHL and SRA.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">        if (Opcode == Instruction::SExt)</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">        if (Opcode == Instruction::SExt)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">          return SrcLT.first * 2;</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">          return SrcLT.first * 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline"></td>
    <td class="lineNumber">1095</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">        // Just check the op cost. If the operation is legal then assume it</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">        // Just check the op cost. If the operation is legal then assume it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">        // costs</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">        // costs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">        // 1 and multiply by the type-legalization overhead.</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">        // 1 and multiply by the type-legalization overhead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">        if (!TLI->isOperationExpand(ISD, DstLT.second))</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">        if (!TLI->isOperationExpand(ISD, DstLT.second))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">          return SrcLT.first * 1;</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">          return SrcLT.first * 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline"></td>
    <td class="lineNumber">1102</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">      // If we are legalizing by splitting, query the concrete TTI for the cost</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">      // If we are legalizing by splitting, query the concrete TTI for the cost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline">      // of casting the original vector twice. We also need to factor in the</td>
    <td class="lineNumber">1104</td>
    <td class="codeline">      // of casting the original vector twice. We also need to factor in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">      // cost of the split itself. Count that as 1, to be consistent with</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">      // cost of the split itself. Count that as 1, to be consistent with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">      // getTypeLegalizationCost().</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">      // getTypeLegalizationCost().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">      bool SplitSrc =</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">      bool SplitSrc =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">          TLI->getTypeAction(Src->getContext(), TLI->getValueType(DL, Src)) ==</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">          TLI->getTypeAction(Src->getContext(), TLI->getValueType(DL, Src)) ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">          TargetLowering::TypeSplitVector;</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">          TargetLowering::TypeSplitVector;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">      bool SplitDst =</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">      bool SplitDst =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">          TLI->getTypeAction(Dst->getContext(), TLI->getValueType(DL, Dst)) ==</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">          TLI->getTypeAction(Dst->getContext(), TLI->getValueType(DL, Dst)) ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">          TargetLowering::TypeSplitVector;</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">          TargetLowering::TypeSplitVector;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">      if ((SplitSrc || SplitDst) && SrcVTy->getElementCount().isVector() &&</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">      if ((SplitSrc || SplitDst) && SrcVTy->getElementCount().isVector() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">          DstVTy->getElementCount().isVector()) {</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">          DstVTy->getElementCount().isVector()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">        Type *SplitDstTy = VectorType::getHalfElementsVectorType(DstVTy);</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">        Type *SplitDstTy = VectorType::getHalfElementsVectorType(DstVTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">        Type *SplitSrcTy = VectorType::getHalfElementsVectorType(SrcVTy);</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">        Type *SplitSrcTy = VectorType::getHalfElementsVectorType(SrcVTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">        T *TTI = static_cast<T *>(this);</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">        T *TTI = static_cast<T *>(this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">        // If both types need to be split then the split is free.</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">        // If both types need to be split then the split is free.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">        InstructionCost SplitCost =</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">        InstructionCost SplitCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">            (!SplitSrc || !SplitDst) ? TTI->getVectorSplitCost() : 0;</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">            (!SplitSrc || !SplitDst) ? TTI->getVectorSplitCost() : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">        return SplitCost +</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">        return SplitCost +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">               (2 * TTI->getCastInstrCost(Opcode, SplitDstTy, SplitSrcTy, CCH,</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">               (2 * TTI->getCastInstrCost(Opcode, SplitDstTy, SplitSrcTy, CCH,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">                                          CostKind, I));</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">                                          CostKind, I));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1124</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline"></td>
    <td class="lineNumber">1125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">      // Scalarization cost is Invalid, can't assume any num elements.</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">      // Scalarization cost is Invalid, can't assume any num elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">      if (isa<ScalableVectorType>(DstVTy))</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">      if (isa<ScalableVectorType>(DstVTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">        return InstructionCost::getInvalid();</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">        return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline"></td>
    <td class="lineNumber">1129</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">      // In other cases where the source or destination are illegal, assume</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">      // In other cases where the source or destination are illegal, assume</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">      // the operation will get scalarized.</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">      // the operation will get scalarized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">      unsigned Num = cast<FixedVectorType>(DstVTy)->getNumElements();</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">      unsigned Num = cast<FixedVectorType>(DstVTy)->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">      InstructionCost Cost = thisT()->getCastInstrCost(</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">      InstructionCost Cost = thisT()->getCastInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">          Opcode, Dst->getScalarType(), Src->getScalarType(), CCH, CostKind, I);</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">          Opcode, Dst->getScalarType(), Src->getScalarType(), CCH, CostKind, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline"></td>
    <td class="lineNumber">1135</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">      // Return the cost of multiple scalar invocation plus the cost of</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">      // Return the cost of multiple scalar invocation plus the cost of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline">      // inserting and extracting the values.</td>
    <td class="lineNumber">1137</td>
    <td class="codeline">      // inserting and extracting the values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">      return getScalarizationOverhead(DstVTy, /*Insert*/ true, /*Extract*/ true,</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">      return getScalarizationOverhead(DstVTy, /*Insert*/ true, /*Extract*/ true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">                                      CostKind) +</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">                                      CostKind) +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">             Num * Cost;</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">             Num * Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline"></td>
    <td class="lineNumber">1142</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">    // We already handled vector-to-vector and scalar-to-scalar conversions.</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">    // We already handled vector-to-vector and scalar-to-scalar conversions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">    // This</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">    // This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">    // is where we handle bitcast between vectors and scalars. We need to assume</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">    // is where we handle bitcast between vectors and scalars. We need to assume</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">    //  that the conversion is scalarized in one way or another.</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">    //  that the conversion is scalarized in one way or another.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">    if (Opcode == Instruction::BitCast) {</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">    if (Opcode == Instruction::BitCast) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">      // Illegal bitcasts are done by storing and loading from a stack slot.</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">      // Illegal bitcasts are done by storing and loading from a stack slot.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">      return (SrcVTy ? getScalarizationOverhead(SrcVTy, /*Insert*/ false,</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">      return (SrcVTy ? getScalarizationOverhead(SrcVTy, /*Insert*/ false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">                                                /*Extract*/ true, CostKind)</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">                                                /*Extract*/ true, CostKind)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">                     : 0) +</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">                     : 0) +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">             (DstVTy ? getScalarizationOverhead(DstVTy, /*Insert*/ true,</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">             (DstVTy ? getScalarizationOverhead(DstVTy, /*Insert*/ true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">                                                /*Extract*/ false, CostKind)</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">                                                /*Extract*/ false, CostKind)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">                     : 0);</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">                     : 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline"></td>
    <td class="lineNumber">1156</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">    llvm_unreachable("Unhandled cast");</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">    llvm_unreachable("Unhandled cast");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
    <td class="lineNumber">1159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">                                           VectorType *VecTy, unsigned Index) {</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">                                           VectorType *VecTy, unsigned Index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">    TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput;</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">    TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">    return thisT()->getVectorInstrCost(Instruction::ExtractElement, VecTy,</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">    return thisT()->getVectorInstrCost(Instruction::ExtractElement, VecTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">                                       CostKind, Index, nullptr, nullptr) +</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">                                       CostKind, Index, nullptr, nullptr) +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">           thisT()->getCastInstrCost(Opcode, Dst, VecTy->getElementType(),</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">           thisT()->getCastInstrCost(Opcode, Dst, VecTy->getElementType(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">                                     TTI::CastContextHint::None, CostKind);</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">                                     TTI::CastContextHint::None, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline"></td>
    <td class="lineNumber">1168</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">  InstructionCost getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">  InstructionCost getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline">                                 const Instruction *I = nullptr) {</td>
    <td class="lineNumber">1170</td>
    <td class="codeline">                                 const Instruction *I = nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">    return BaseT::getCFInstrCost(Opcode, CostKind, I);</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">    return BaseT::getCFInstrCost(Opcode, CostKind, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline"></td>
    <td class="lineNumber">1173</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">  InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">  InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">                                     CmpInst::Predicate VecPred,</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">                                     CmpInst::Predicate VecPred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">                                     const Instruction *I = nullptr) {</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">                                     const Instruction *I = nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">    assert(ISD && "Invalid opcode");</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">    assert(ISD && "Invalid opcode");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
    <td class="lineNumber">1181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">    // TODO: Handle other cost kinds.</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">    // TODO: Handle other cost kinds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">    if (CostKind != TTI::TCK_RecipThroughput)</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">    if (CostKind != TTI::TCK_RecipThroughput)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">      return BaseT::getCmpSelInstrCost(Opcode, ValTy, CondTy, VecPred, CostKind,</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">      return BaseT::getCmpSelInstrCost(Opcode, ValTy, CondTy, VecPred, CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">                                       I);</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">                                       I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline"></td>
    <td class="lineNumber">1186</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">    // Selects on vectors are actually vector selects.</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">    // Selects on vectors are actually vector selects.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">    if (ISD == ISD::SELECT) {</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">    if (ISD == ISD::SELECT) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">      assert(CondTy && "CondTy must exist");</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">      assert(CondTy && "CondTy must exist");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">      if (CondTy->isVectorTy())</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">      if (CondTy->isVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">        ISD = ISD::VSELECT;</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">        ISD = ISD::VSELECT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(ValTy);</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(ValTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline"></td>
    <td class="lineNumber">1194</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">    if (!(ValTy->isVectorTy() && !LT.second.isVector()) &&</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">    if (!(ValTy->isVectorTy() && !LT.second.isVector()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">        !TLI->isOperationExpand(ISD, LT.second)) {</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">        !TLI->isOperationExpand(ISD, LT.second)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">      // The operation is legal. Assume it costs 1. Multiply</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">      // The operation is legal. Assume it costs 1. Multiply</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">      // by the type-legalization overhead.</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">      // by the type-legalization overhead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">      return LT.first * 1;</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">      return LT.first * 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1200</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline"></td>
    <td class="lineNumber">1201</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">    // Otherwise, assume that the cast is scalarized.</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">    // Otherwise, assume that the cast is scalarized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">    // TODO: If one of the types get legalized by splitting, handle this</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">    // TODO: If one of the types get legalized by splitting, handle this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">    // similarly to what getCastInstrCost() does.</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">    // similarly to what getCastInstrCost() does.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">    if (auto *ValVTy = dyn_cast<VectorType>(ValTy)) {</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">    if (auto *ValVTy = dyn_cast<VectorType>(ValTy)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">      if (isa<ScalableVectorType>(ValTy))</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">      if (isa<ScalableVectorType>(ValTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">        return InstructionCost::getInvalid();</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">        return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline"></td>
    <td class="lineNumber">1208</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">      unsigned Num = cast<FixedVectorType>(ValVTy)->getNumElements();</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">      unsigned Num = cast<FixedVectorType>(ValVTy)->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">      if (CondTy)</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">      if (CondTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">        CondTy = CondTy->getScalarType();</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">        CondTy = CondTy->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">      InstructionCost Cost = thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">      InstructionCost Cost = thisT()->getCmpSelInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">          Opcode, ValVTy->getScalarType(), CondTy, VecPred, CostKind, I);</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">          Opcode, ValVTy->getScalarType(), CondTy, VecPred, CostKind, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline"></td>
    <td class="lineNumber">1214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">      // Return the cost of multiple scalar invocation plus the cost of</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">      // Return the cost of multiple scalar invocation plus the cost of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">      // inserting and extracting the values.</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">      // inserting and extracting the values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">      return getScalarizationOverhead(ValVTy, /*Insert*/ true,</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">      return getScalarizationOverhead(ValVTy, /*Insert*/ true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">                                      /*Extract*/ false, CostKind) +</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">                                      /*Extract*/ false, CostKind) +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">             Num * Cost;</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">             Num * Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
    <td class="lineNumber">1221</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">    // Unknown scalar opcode.</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">    // Unknown scalar opcode.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">    return 1;</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">    return 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
    <td class="lineNumber">1225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">                                     unsigned Index, Value *Op0, Value *Op1) {</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">                                     unsigned Index, Value *Op0, Value *Op1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">    return getRegUsageForType(Val->getScalarType());</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">    return getRegUsageForType(Val->getScalarType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1230</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline"></td>
    <td class="lineNumber">1231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">                                     TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">                                     unsigned Index) {</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">                                     unsigned Index) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">    Value *Op0 = nullptr;</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">    Value *Op0 = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">    Value *Op1 = nullptr;</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">    Value *Op1 = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">    if (auto *IE = dyn_cast<InsertElementInst>(&I)) {</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">    if (auto *IE = dyn_cast<InsertElementInst>(&I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">      Op0 = IE->getOperand(0);</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">      Op0 = IE->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">      Op1 = IE->getOperand(1);</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">      Op1 = IE->getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">    return thisT()->getVectorInstrCost(I.getOpcode(), Val, CostKind, Index, Op0,</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">    return thisT()->getVectorInstrCost(I.getOpcode(), Val, CostKind, Index, Op0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">                                       Op1);</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">                                       Op1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline"></td>
    <td class="lineNumber">1244</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">  InstructionCost getReplicationShuffleCost(Type *EltTy, int ReplicationFactor,</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">  InstructionCost getReplicationShuffleCost(Type *EltTy, int ReplicationFactor,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">                                            int VF,</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">                                            int VF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">                                            const APInt &DemandedDstElts,</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">                                            const APInt &DemandedDstElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">                                            TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">                                            TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">    assert(DemandedDstElts.getBitWidth() == (unsigned)VF * ReplicationFactor &&</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">    assert(DemandedDstElts.getBitWidth() == (unsigned)VF * ReplicationFactor &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">           "Unexpected size of DemandedDstElts.");</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">           "Unexpected size of DemandedDstElts.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline"></td>
    <td class="lineNumber">1251</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">    InstructionCost Cost;</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">    InstructionCost Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline"></td>
    <td class="lineNumber">1253</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">    auto *SrcVT = FixedVectorType::get(EltTy, VF);</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">    auto *SrcVT = FixedVectorType::get(EltTy, VF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">    auto *ReplicatedVT = FixedVectorType::get(EltTy, VF * ReplicationFactor);</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">    auto *ReplicatedVT = FixedVectorType::get(EltTy, VF * ReplicationFactor);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline"></td>
    <td class="lineNumber">1256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">    // The Mask shuffling cost is extract all the elements of the Mask</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">    // The Mask shuffling cost is extract all the elements of the Mask</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">    // and insert each of them Factor times into the wide vector:</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">    // and insert each of them Factor times into the wide vector:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">    // E.g. an interleaved group with factor 3:</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">    // E.g. an interleaved group with factor 3:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">    //    %mask = icmp ult <8 x i32> %vec1, %vec2</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">    //    %mask = icmp ult <8 x i32> %vec1, %vec2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">    //    %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">    //    %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">    //        <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7></td>
    <td class="lineNumber">1263</td>
    <td class="codeline">    //        <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">    // The cost is estimated as extract all mask elements from the <8xi1> mask</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">    // The cost is estimated as extract all mask elements from the <8xi1> mask</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">    // vector and insert them factor times into the <24xi1> shuffled mask</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">    // vector and insert them factor times into the <24xi1> shuffled mask</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">    // vector.</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">    // vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">    APInt DemandedSrcElts = APIntOps::ScaleBitMask(DemandedDstElts, VF);</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">    APInt DemandedSrcElts = APIntOps::ScaleBitMask(DemandedDstElts, VF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">    Cost += thisT()->getScalarizationOverhead(SrcVT, DemandedSrcElts,</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">    Cost += thisT()->getScalarizationOverhead(SrcVT, DemandedSrcElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">                                              /*Insert*/ false,</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">                                              /*Insert*/ false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">                                              /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">                                              /*Extract*/ true, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">    Cost += thisT()->getScalarizationOverhead(ReplicatedVT, DemandedDstElts,</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">    Cost += thisT()->getScalarizationOverhead(ReplicatedVT, DemandedDstElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">                                              /*Insert*/ true,</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">                                              /*Insert*/ true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">                                              /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">                                              /*Extract*/ false, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline"></td>
    <td class="lineNumber">1274</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">    return Cost;</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">    return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline"></td>
    <td class="lineNumber">1277</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">  getMemoryOpCost(unsigned Opcode, Type *Src, MaybeAlign Alignment,</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">  getMemoryOpCost(unsigned Opcode, Type *Src, MaybeAlign Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">                  unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">                  unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">                  TTI::OperandValueInfo OpInfo = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">                  TTI::OperandValueInfo OpInfo = {TTI::OK_AnyValue, TTI::OP_None},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">                  const Instruction *I = nullptr) {</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">                  const Instruction *I = nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">    assert(!Src->isVoidTy() && "Invalid type");</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">    assert(!Src->isVoidTy() && "Invalid type");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">    // Assume types, such as structs, are expensive.</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">    // Assume types, such as structs, are expensive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">    if (getTLI()->getValueType(DL, Src,  true) == MVT::Other)</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">    if (getTLI()->getValueType(DL, Src,  true) == MVT::Other)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">      return 4;</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">      return 4;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Src);</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Src);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline"></td>
    <td class="lineNumber">1288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">    // Assuming that all loads of legal types cost 1.</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">    // Assuming that all loads of legal types cost 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">    InstructionCost Cost = LT.first;</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">    InstructionCost Cost = LT.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">    if (CostKind != TTI::TCK_RecipThroughput)</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">    if (CostKind != TTI::TCK_RecipThroughput)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">      return Cost;</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">      return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline"></td>
    <td class="lineNumber">1293</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">    const DataLayout &DL = this->getDataLayout();</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">    const DataLayout &DL = this->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">    if (Src->isVectorTy() &&</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">    if (Src->isVectorTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">        // In practice it's not currently possible to have a change in lane</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">        // In practice it's not currently possible to have a change in lane</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">        // length for extending loads or truncating stores so both types should</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">        // length for extending loads or truncating stores so both types should</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">        // have the same scalable property.</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">        // have the same scalable property.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">        TypeSize::isKnownLT(DL.getTypeStoreSizeInBits(Src),</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">        TypeSize::isKnownLT(DL.getTypeStoreSizeInBits(Src),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">                            LT.second.getSizeInBits())) {</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">                            LT.second.getSizeInBits())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">      // This is a vector load that legalizes to a larger type than the vector</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">      // This is a vector load that legalizes to a larger type than the vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">      // itself. Unless the corresponding extending load or truncating store is</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">      // itself. Unless the corresponding extending load or truncating store is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">      // legal, then this will scalarize.</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">      // legal, then this will scalarize.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">      TargetLowering::LegalizeAction LA = TargetLowering::Expand;</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">      TargetLowering::LegalizeAction LA = TargetLowering::Expand;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">      EVT MemVT = getTLI()->getValueType(DL, Src);</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">      EVT MemVT = getTLI()->getValueType(DL, Src);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline">      if (Opcode == Instruction::Store)</td>
    <td class="lineNumber">1306</td>
    <td class="codeline">      if (Opcode == Instruction::Store)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">        LA = getTLI()->getTruncStoreAction(LT.second, MemVT);</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">        LA = getTLI()->getTruncStoreAction(LT.second, MemVT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">        LA = getTLI()->getLoadExtAction(ISD::EXTLOAD, LT.second, MemVT);</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">        LA = getTLI()->getLoadExtAction(ISD::EXTLOAD, LT.second, MemVT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline"></td>
    <td class="lineNumber">1310</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline">      if (LA != TargetLowering::Legal && LA != TargetLowering::Custom) {</td>
    <td class="lineNumber">1311</td>
    <td class="codeline">      if (LA != TargetLowering::Legal && LA != TargetLowering::Custom) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">        // This is a vector load/store for some illegal type that is scalarized.</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">        // This is a vector load/store for some illegal type that is scalarized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">        // We must account for the cost of building or decomposing the vector.</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">        // We must account for the cost of building or decomposing the vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">        Cost += getScalarizationOverhead(</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">        Cost += getScalarizationOverhead(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">            cast<VectorType>(Src), Opcode != Instruction::Store,</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">            cast<VectorType>(Src), Opcode != Instruction::Store,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">            Opcode == Instruction::Store, CostKind);</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">            Opcode == Instruction::Store, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline"></td>
    <td class="lineNumber">1319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">    return Cost;</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">    return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline"></td>
    <td class="lineNumber">1322</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">  InstructionCost getMaskedMemoryOpCost(unsigned Opcode, Type *DataTy,</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">  InstructionCost getMaskedMemoryOpCost(unsigned Opcode, Type *DataTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">                                        Align Alignment, unsigned AddressSpace,</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">                                        Align Alignment, unsigned AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">                                        TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">                                        TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">    return getCommonMaskedMemoryOpCost(Opcode, DataTy, Alignment, true, false,</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">    return getCommonMaskedMemoryOpCost(Opcode, DataTy, Alignment, true, false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">                                       CostKind);</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">                                       CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline"></td>
    <td class="lineNumber">1329</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">  InstructionCost getGatherScatterOpCost(unsigned Opcode, Type *DataTy,</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">  InstructionCost getGatherScatterOpCost(unsigned Opcode, Type *DataTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">                                         const Value *Ptr, bool VariableMask,</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">                                         const Value *Ptr, bool VariableMask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">                                         Align Alignment,</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">                                         Align Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">                                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">                                         TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">                                         const Instruction *I = nullptr) {</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">                                         const Instruction *I = nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">    return getCommonMaskedMemoryOpCost(Opcode, DataTy, Alignment, VariableMask,</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">    return getCommonMaskedMemoryOpCost(Opcode, DataTy, Alignment, VariableMask,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">                                       true, CostKind);</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">                                       true, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline"></td>
    <td class="lineNumber">1338</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">  InstructionCost getInterleavedMemoryOpCost(</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">  InstructionCost getInterleavedMemoryOpCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">      bool UseMaskForCond = false, bool UseMaskForGaps = false) {</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">      bool UseMaskForCond = false, bool UseMaskForGaps = false) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">    // We cannot scalarize scalable vectors, so return Invalid.</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">    // We cannot scalarize scalable vectors, so return Invalid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">    if (isa<ScalableVectorType>(VecTy))</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">    if (isa<ScalableVectorType>(VecTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline"></td>
    <td class="lineNumber">1347</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">    auto *VT = cast<FixedVectorType>(VecTy);</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">    auto *VT = cast<FixedVectorType>(VecTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">    unsigned NumElts = VT->getNumElements();</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">    unsigned NumElts = VT->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">    assert(Factor > 1 && NumElts % Factor == 0 && "Invalid interleave factor");</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">    assert(Factor > 1 && NumElts % Factor == 0 && "Invalid interleave factor");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline"></td>
    <td class="lineNumber">1352</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">    unsigned NumSubElts = NumElts / Factor;</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">    unsigned NumSubElts = NumElts / Factor;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">    auto *SubVT = FixedVectorType::get(VT->getElementType(), NumSubElts);</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">    auto *SubVT = FixedVectorType::get(VT->getElementType(), NumSubElts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline"></td>
    <td class="lineNumber">1355</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">    // Firstly, the cost of load/store operation.</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">    // Firstly, the cost of load/store operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">    InstructionCost Cost;</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">    InstructionCost Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">    if (UseMaskForCond || UseMaskForGaps)</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">    if (UseMaskForCond || UseMaskForGaps)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">      Cost = thisT()->getMaskedMemoryOpCost(Opcode, VecTy, Alignment,</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">      Cost = thisT()->getMaskedMemoryOpCost(Opcode, VecTy, Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">                                            AddressSpace, CostKind);</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">                                            AddressSpace, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">      Cost = thisT()->getMemoryOpCost(Opcode, VecTy, Alignment, AddressSpace,</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">      Cost = thisT()->getMemoryOpCost(Opcode, VecTy, Alignment, AddressSpace,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">                                      CostKind);</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">                                      CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline"></td>
    <td class="lineNumber">1364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">    // Legalize the vector type, and get the legalized and unlegalized type</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">    // Legalize the vector type, and get the legalized and unlegalized type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">    // sizes.</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">    // sizes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">    MVT VecTyLT = getTypeLegalizationCost(VecTy).second;</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">    MVT VecTyLT = getTypeLegalizationCost(VecTy).second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">    unsigned VecTySize = thisT()->getDataLayout().getTypeStoreSize(VecTy);</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">    unsigned VecTySize = thisT()->getDataLayout().getTypeStoreSize(VecTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">    unsigned VecTyLTSize = VecTyLT.getStoreSize();</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">    unsigned VecTyLTSize = VecTyLT.getStoreSize();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline"></td>
    <td class="lineNumber">1370</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">    // Scale the cost of the memory operation by the fraction of legalized</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">    // Scale the cost of the memory operation by the fraction of legalized</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">    // instructions that will actually be used. We shouldn't account for the</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">    // instructions that will actually be used. We shouldn't account for the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">    // cost of dead instructions since they will be removed.</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">    // cost of dead instructions since they will be removed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">    // E.g., An interleaved load of factor 8:</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">    // E.g., An interleaved load of factor 8:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">    //       %vec = load <16 x i64>, <16 x i64>* %ptr</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">    //       %vec = load <16 x i64>, <16 x i64>* %ptr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">    //       %v0 = shufflevector %vec, undef, <0, 8></td>
    <td class="lineNumber">1377</td>
    <td class="codeline">    //       %v0 = shufflevector %vec, undef, <0, 8></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">    // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">    // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">    // used (those corresponding to elements [0:1] and [8:9] of the unlegalized</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">    // used (those corresponding to elements [0:1] and [8:9] of the unlegalized</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">    // type). The other loads are unused.</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">    // type). The other loads are unused.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">    //</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">    //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">    // TODO: Note that legalization can turn masked loads/stores into unmasked</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">    // TODO: Note that legalization can turn masked loads/stores into unmasked</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">    // (legalized) loads/stores. This can be reflected in the cost.</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">    // (legalized) loads/stores. This can be reflected in the cost.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">    if (Cost.isValid() && VecTySize > VecTyLTSize) {</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">    if (Cost.isValid() && VecTySize > VecTyLTSize) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">      // The number of loads of a legal type it will take to represent a load</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">      // The number of loads of a legal type it will take to represent a load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">      // of the unlegalized vector type.</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">      // of the unlegalized vector type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">      unsigned NumLegalInsts = divideCeil(VecTySize, VecTyLTSize);</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">      unsigned NumLegalInsts = divideCeil(VecTySize, VecTyLTSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline"></td>
    <td class="lineNumber">1389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">      // The number of elements of the unlegalized type that correspond to a</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">      // The number of elements of the unlegalized type that correspond to a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">      // single legal instruction.</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">      // single legal instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">      unsigned NumEltsPerLegalInst = divideCeil(NumElts, NumLegalInsts);</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">      unsigned NumEltsPerLegalInst = divideCeil(NumElts, NumLegalInsts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
    <td class="lineNumber">1393</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">      // Determine which legal instructions will be used.</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">      // Determine which legal instructions will be used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">      BitVector UsedInsts(NumLegalInsts, false);</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">      BitVector UsedInsts(NumLegalInsts, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">      for (unsigned Index : Indices)</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">      for (unsigned Index : Indices)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">        for (unsigned Elt = 0; Elt < NumSubElts; ++Elt)</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">        for (unsigned Elt = 0; Elt < NumSubElts; ++Elt)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">          UsedInsts.set((Index + Elt * Factor) / NumEltsPerLegalInst);</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">          UsedInsts.set((Index + Elt * Factor) / NumEltsPerLegalInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline"></td>
    <td class="lineNumber">1399</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">      // Scale the cost of the load by the fraction of legal instructions that</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">      // Scale the cost of the load by the fraction of legal instructions that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">      // will be used.</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">      // will be used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">      Cost = divideCeil(UsedInsts.count() * *Cost.getValue(), NumLegalInsts);</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">      Cost = divideCeil(UsedInsts.count() * *Cost.getValue(), NumLegalInsts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline"></td>
    <td class="lineNumber">1404</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">    // Then plus the cost of interleave operation.</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">    // Then plus the cost of interleave operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">    assert(Indices.size() <= Factor &&</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">    assert(Indices.size() <= Factor &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">           "Interleaved memory op has too many members");</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">           "Interleaved memory op has too many members");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline"></td>
    <td class="lineNumber">1408</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">    const APInt DemandedAllSubElts = APInt::getAllOnes(NumSubElts);</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">    const APInt DemandedAllSubElts = APInt::getAllOnes(NumSubElts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">    const APInt DemandedAllResultElts = APInt::getAllOnes(NumElts);</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">    const APInt DemandedAllResultElts = APInt::getAllOnes(NumElts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline"></td>
    <td class="lineNumber">1411</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">    APInt DemandedLoadStoreElts = APInt::getZero(NumElts);</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">    APInt DemandedLoadStoreElts = APInt::getZero(NumElts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">    for (unsigned Index : Indices) {</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">    for (unsigned Index : Indices) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">      assert(Index < Factor && "Invalid index for interleaved memory op");</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">      assert(Index < Factor && "Invalid index for interleaved memory op");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">      for (unsigned Elm = 0; Elm < NumSubElts; Elm++)</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">      for (unsigned Elm = 0; Elm < NumSubElts; Elm++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline">        DemandedLoadStoreElts.setBit(Index + Elm * Factor);</td>
    <td class="lineNumber">1416</td>
    <td class="codeline">        DemandedLoadStoreElts.setBit(Index + Elm * Factor);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline"></td>
    <td class="lineNumber">1418</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">    if (Opcode == Instruction::Load) {</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">    if (Opcode == Instruction::Load) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">      // The interleave cost is similar to extract sub vectors' elements</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">      // The interleave cost is similar to extract sub vectors' elements</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">      // from the wide vector, and insert them into sub vectors.</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">      // from the wide vector, and insert them into sub vectors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">1422</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">      // E.g. An interleaved load of factor 2 (with one member of index 0):</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">      // E.g. An interleaved load of factor 2 (with one member of index 0):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">      //      %vec = load <8 x i32>, <8 x i32>* %ptr</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">      //      %vec = load <8 x i32>, <8 x i32>* %ptr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">      //      %v0 = shuffle %vec, undef, <0, 2, 4, 6>         ; Index 0</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">      //      %v0 = shuffle %vec, undef, <0, 2, 4, 6>         ; Index 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">      // The cost is estimated as extract elements at 0, 2, 4, 6 from the</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">      // The cost is estimated as extract elements at 0, 2, 4, 6 from the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">      // <8 x i32> vector and insert them into a <4 x i32> vector.</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">      // <8 x i32> vector and insert them into a <4 x i32> vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">      InstructionCost InsSubCost = thisT()->getScalarizationOverhead(</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">      InstructionCost InsSubCost = thisT()->getScalarizationOverhead(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">          SubVT, DemandedAllSubElts,</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">          SubVT, DemandedAllSubElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">          /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">          /*Insert*/ true, /*Extract*/ false, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">      Cost += Indices.size() * InsSubCost;</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">      Cost += Indices.size() * InsSubCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">      Cost += thisT()->getScalarizationOverhead(VT, DemandedLoadStoreElts,</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">      Cost += thisT()->getScalarizationOverhead(VT, DemandedLoadStoreElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">                                                /*Insert*/ false,</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">                                                /*Insert*/ false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">                                                /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">                                                /*Extract*/ true, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">      // The interleave cost is extract elements from sub vectors, and</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">      // The interleave cost is extract elements from sub vectors, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">      // insert them into the wide vector.</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">      // insert them into the wide vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">      // E.g. An interleaved store of factor 3 with 2 members at indices 0,1:</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">      // E.g. An interleaved store of factor 3 with 2 members at indices 0,1:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">      // (using VF=4):</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">      // (using VF=4):</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">      //    %v0_v1 = shuffle %v0, %v1, <0,4,undef,1,5,undef,2,6,undef,3,7,undef></td>
    <td class="lineNumber">1441</td>
    <td class="codeline">      //    %v0_v1 = shuffle %v0, %v1, <0,4,undef,1,5,undef,2,6,undef,3,7,undef></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">      //    %gaps.mask = <true, true, false, true, true, false,</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">      //    %gaps.mask = <true, true, false, true, true, false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">      //                  true, true, false, true, true, false></td>
    <td class="lineNumber">1443</td>
    <td class="codeline">      //                  true, true, false, true, true, false></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">      //    call llvm.masked.store <12 x i32> %v0_v1, <12 x i32>* %ptr,</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">      //    call llvm.masked.store <12 x i32> %v0_v1, <12 x i32>* %ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">      //                           i32 Align, <12 x i1> %gaps.mask</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">      //                           i32 Align, <12 x i1> %gaps.mask</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">      // The cost is estimated as extract all elements (of actual members,</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">      // The cost is estimated as extract all elements (of actual members,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">      // excluding gaps) from both <4 x i32> vectors and insert into the <12 x</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">      // excluding gaps) from both <4 x i32> vectors and insert into the <12 x</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">      // i32> vector.</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">      // i32> vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">      InstructionCost ExtSubCost = thisT()->getScalarizationOverhead(</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">      InstructionCost ExtSubCost = thisT()->getScalarizationOverhead(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">          SubVT, DemandedAllSubElts,</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">          SubVT, DemandedAllSubElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">          /*Insert*/ false, /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">          /*Insert*/ false, /*Extract*/ true, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">      Cost += ExtSubCost * Indices.size();</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">      Cost += ExtSubCost * Indices.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">      Cost += thisT()->getScalarizationOverhead(VT, DemandedLoadStoreElts,</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">      Cost += thisT()->getScalarizationOverhead(VT, DemandedLoadStoreElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">                                                /*Insert*/ true,</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">                                                /*Insert*/ true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">                                                /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">                                                /*Extract*/ false, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline"></td>
    <td class="lineNumber">1457</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">    if (!UseMaskForCond)</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">    if (!UseMaskForCond)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">      return Cost;</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">      return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline"></td>
    <td class="lineNumber">1460</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">    Type *I8Type = Type::getInt8Ty(VT->getContext());</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">    Type *I8Type = Type::getInt8Ty(VT->getContext());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline"></td>
    <td class="lineNumber">1462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">    Cost += thisT()->getReplicationShuffleCost(</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">    Cost += thisT()->getReplicationShuffleCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">        I8Type, Factor, NumSubElts,</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">        I8Type, Factor, NumSubElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">        UseMaskForGaps ? DemandedLoadStoreElts : DemandedAllResultElts,</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">        UseMaskForGaps ? DemandedLoadStoreElts : DemandedAllResultElts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">        CostKind);</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">        CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline"></td>
    <td class="lineNumber">1467</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">    // The Gaps mask is invariant and created outside the loop, therefore the</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">    // The Gaps mask is invariant and created outside the loop, therefore the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">    // cost of creating it is not accounted for here. However if we have both</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">    // cost of creating it is not accounted for here. However if we have both</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">    // a MaskForGaps and some other mask that guards the execution of the</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">    // a MaskForGaps and some other mask that guards the execution of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">    // memory access, we need to account for the cost of And-ing the two masks</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">    // memory access, we need to account for the cost of And-ing the two masks</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">    // inside the loop.</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">    // inside the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">    if (UseMaskForGaps) {</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">    if (UseMaskForGaps) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">      auto *MaskVT = FixedVectorType::get(I8Type, NumElts);</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">      auto *MaskVT = FixedVectorType::get(I8Type, NumElts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(BinaryOperator::And, MaskVT,</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(BinaryOperator::And, MaskVT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">                                              CostKind);</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">                                              CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline"></td>
    <td class="lineNumber">1478</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">    return Cost;</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">    return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline"></td>
    <td class="lineNumber">1481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">  /// Get intrinsic cost based on arguments.</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">  /// Get intrinsic cost based on arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">1483</td>
    <td class="codeline">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">                                        TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">                                        TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">    // Check for generically free intrinsics.</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">    // Check for generically free intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">    if (BaseT::getIntrinsicInstrCost(ICA, CostKind) == 0)</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">    if (BaseT::getIntrinsicInstrCost(ICA, CostKind) == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">      return 0;</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">      return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline"></td>
    <td class="lineNumber">1488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">    // Assume that target intrinsics are cheap.</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">    // Assume that target intrinsics are cheap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">    Intrinsic::ID IID = ICA.getID();</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">    Intrinsic::ID IID = ICA.getID();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">    if (Function::isTargetIntrinsic(IID))</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">    if (Function::isTargetIntrinsic(IID))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">      return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">      return TargetTransformInfo::TCC_Basic;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline"></td>
    <td class="lineNumber">1493</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">    if (ICA.isTypeBasedOnly())</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">    if (ICA.isTypeBasedOnly())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">      return getTypeBasedIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">      return getTypeBasedIntrinsicInstrCost(ICA, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline"></td>
    <td class="lineNumber">1496</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">    Type *RetTy = ICA.getReturnType();</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">    Type *RetTy = ICA.getReturnType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline"></td>
    <td class="lineNumber">1498</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">    ElementCount RetVF =</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">    ElementCount RetVF =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">        (RetTy->isVectorTy() ? cast<VectorType>(RetTy)->getElementCount()</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">        (RetTy->isVectorTy() ? cast<VectorType>(RetTy)->getElementCount()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">                             : ElementCount::getFixed(1));</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">                             : ElementCount::getFixed(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">    const IntrinsicInst *I = ICA.getInst();</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">    const IntrinsicInst *I = ICA.getInst();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">    const SmallVectorImpl<const Value *> &Args = ICA.getArgs();</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">    const SmallVectorImpl<const Value *> &Args = ICA.getArgs();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">    FastMathFlags FMF = ICA.getFlags();</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">    FastMathFlags FMF = ICA.getFlags();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">    switch (IID) {</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">    switch (IID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">    default:</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">    default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline"></td>
    <td class="lineNumber">1508</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">    case Intrinsic::powi:</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">    case Intrinsic::powi:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">      if (auto *RHSC = dyn_cast<ConstantInt>(Args[1])) {</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">      if (auto *RHSC = dyn_cast<ConstantInt>(Args[1])) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">        bool ShouldOptForSize = I->getParent()->getParent()->hasOptSize();</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">        bool ShouldOptForSize = I->getParent()->getParent()->hasOptSize();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">        if (getTLI()->isBeneficialToExpandPowI(RHSC->getSExtValue(),</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">        if (getTLI()->isBeneficialToExpandPowI(RHSC->getSExtValue(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">                                               ShouldOptForSize)) {</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">                                               ShouldOptForSize)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">          // The cost is modeled on the expansion performed by ExpandPowI in</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">          // The cost is modeled on the expansion performed by ExpandPowI in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">          // SelectionDAGBuilder.</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">          // SelectionDAGBuilder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">          APInt Exponent = RHSC->getValue().abs();</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">          APInt Exponent = RHSC->getValue().abs();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">          unsigned ActiveBits = Exponent.getActiveBits();</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">          unsigned ActiveBits = Exponent.getActiveBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">          unsigned PopCount = Exponent.popcount();</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">          unsigned PopCount = Exponent.popcount();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">          InstructionCost Cost = (ActiveBits + PopCount - 2) *</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">          InstructionCost Cost = (ActiveBits + PopCount - 2) *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">                                 thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">                                 thisT()->getArithmeticInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">                                     Instruction::FMul, RetTy, CostKind);</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">                                     Instruction::FMul, RetTy, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">          if (RHSC->isNegative())</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">          if (RHSC->isNegative())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">            Cost += thisT()->getArithmeticInstrCost(Instruction::FDiv, RetTy,</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">            Cost += thisT()->getArithmeticInstrCost(Instruction::FDiv, RetTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">                                                    CostKind);</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">                                                    CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">          return Cost;</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">          return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">    case Intrinsic::cttz:</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">    case Intrinsic::cttz:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">      // FIXME: If necessary, this should go in target-specific overrides.</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">      // FIXME: If necessary, this should go in target-specific overrides.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">      if (RetVF.isScalar() && getTLI()->isCheapToSpeculateCttz(RetTy))</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">      if (RetVF.isScalar() && getTLI()->isCheapToSpeculateCttz(RetTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">        return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">        return TargetTransformInfo::TCC_Basic;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline"></td>
    <td class="lineNumber">1534</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">    case Intrinsic::ctlz:</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">    case Intrinsic::ctlz:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">      // FIXME: If necessary, this should go in target-specific overrides.</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">      // FIXME: If necessary, this should go in target-specific overrides.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">      if (RetVF.isScalar() && getTLI()->isCheapToSpeculateCtlz(RetTy))</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">      if (RetVF.isScalar() && getTLI()->isCheapToSpeculateCtlz(RetTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">        return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">        return TargetTransformInfo::TCC_Basic;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline"></td>
    <td class="lineNumber">1540</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">    case Intrinsic::memcpy:</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">    case Intrinsic::memcpy:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">      return thisT()->getMemcpyCost(ICA.getInst());</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">      return thisT()->getMemcpyCost(ICA.getInst());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline"></td>
    <td class="lineNumber">1543</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">    case Intrinsic::masked_scatter: {</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">    case Intrinsic::masked_scatter: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">      const Value *Mask = Args[3];</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">      const Value *Mask = Args[3];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">      bool VarMask = !isa<Constant>(Mask);</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">      bool VarMask = !isa<Constant>(Mask);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">      Align Alignment = cast<ConstantInt>(Args[2])->getAlignValue();</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">      Align Alignment = cast<ConstantInt>(Args[2])->getAlignValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">      return thisT()->getGatherScatterOpCost(Instruction::Store,</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">      return thisT()->getGatherScatterOpCost(Instruction::Store,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">                                             ICA.getArgTypes()[0], Args[1],</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">                                             ICA.getArgTypes()[0], Args[1],</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">                                             VarMask, Alignment, CostKind, I);</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">                                             VarMask, Alignment, CostKind, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline">    case Intrinsic::masked_gather: {</td>
    <td class="lineNumber">1552</td>
    <td class="codeline">    case Intrinsic::masked_gather: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">      const Value *Mask = Args[2];</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">      const Value *Mask = Args[2];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">      bool VarMask = !isa<Constant>(Mask);</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">      bool VarMask = !isa<Constant>(Mask);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">      Align Alignment = cast<ConstantInt>(Args[1])->getAlignValue();</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">      Align Alignment = cast<ConstantInt>(Args[1])->getAlignValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">      return thisT()->getGatherScatterOpCost(Instruction::Load, RetTy, Args[0],</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">      return thisT()->getGatherScatterOpCost(Instruction::Load, RetTy, Args[0],</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">                                             VarMask, Alignment, CostKind, I);</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">                                             VarMask, Alignment, CostKind, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">    case Intrinsic::experimental_stepvector: {</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">    case Intrinsic::experimental_stepvector: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">      if (isa<ScalableVectorType>(RetTy))</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">      if (isa<ScalableVectorType>(RetTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">      // The cost of materialising a constant integer vector.</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">      // The cost of materialising a constant integer vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">      return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">      return TargetTransformInfo::TCC_Basic;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">    case Intrinsic::vector_extract: {</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">    case Intrinsic::vector_extract: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">      // FIXME: Handle case where a scalable vector is extracted from a scalable</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">      // FIXME: Handle case where a scalable vector is extracted from a scalable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">      // vector</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">      // vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline">      if (isa<ScalableVectorType>(RetTy))</td>
    <td class="lineNumber">1568</td>
    <td class="codeline">      if (isa<ScalableVectorType>(RetTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">      unsigned Index = cast<ConstantInt>(Args[1])->getZExtValue();</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">      unsigned Index = cast<ConstantInt>(Args[1])->getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">      return thisT()->getShuffleCost(</td>
    <td class="lineNumber">1571</td>
    <td class="codeline">      return thisT()->getShuffleCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">          TTI::SK_ExtractSubvector, cast<VectorType>(Args[0]->getType()),</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">          TTI::SK_ExtractSubvector, cast<VectorType>(Args[0]->getType()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">          std::nullopt, CostKind, Index, cast<VectorType>(RetTy));</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">          std::nullopt, CostKind, Index, cast<VectorType>(RetTy));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">    case Intrinsic::vector_insert: {</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">    case Intrinsic::vector_insert: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">      // FIXME: Handle case where a scalable vector is inserted into a scalable</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">      // FIXME: Handle case where a scalable vector is inserted into a scalable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">      // vector</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">      // vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">      if (isa<ScalableVectorType>(Args[1]->getType()))</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">      if (isa<ScalableVectorType>(Args[1]->getType()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">      unsigned Index = cast<ConstantInt>(Args[2])->getZExtValue();</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">      unsigned Index = cast<ConstantInt>(Args[2])->getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">      return thisT()->getShuffleCost(</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">      return thisT()->getShuffleCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">          TTI::SK_InsertSubvector, cast<VectorType>(Args[0]->getType()),</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">          TTI::SK_InsertSubvector, cast<VectorType>(Args[0]->getType()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">          std::nullopt, CostKind, Index, cast<VectorType>(Args[1]->getType()));</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">          std::nullopt, CostKind, Index, cast<VectorType>(Args[1]->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">    case Intrinsic::experimental_vector_reverse: {</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">    case Intrinsic::experimental_vector_reverse: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">      return thisT()->getShuffleCost(</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">      return thisT()->getShuffleCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">          TTI::SK_Reverse, cast<VectorType>(Args[0]->getType()), std::nullopt,</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">          TTI::SK_Reverse, cast<VectorType>(Args[0]->getType()), std::nullopt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">          CostKind, 0, cast<VectorType>(RetTy));</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">          CostKind, 0, cast<VectorType>(RetTy));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">    case Intrinsic::experimental_vector_splice: {</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">    case Intrinsic::experimental_vector_splice: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline">      unsigned Index = cast<ConstantInt>(Args[2])->getZExtValue();</td>
    <td class="lineNumber">1591</td>
    <td class="codeline">      unsigned Index = cast<ConstantInt>(Args[2])->getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">      return thisT()->getShuffleCost(</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">      return thisT()->getShuffleCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">          TTI::SK_Splice, cast<VectorType>(Args[0]->getType()), std::nullopt,</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">          TTI::SK_Splice, cast<VectorType>(Args[0]->getType()), std::nullopt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">          CostKind, Index, cast<VectorType>(RetTy));</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">          CostKind, Index, cast<VectorType>(RetTy));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">    case Intrinsic::vector_reduce_add:</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">    case Intrinsic::vector_reduce_add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">    case Intrinsic::vector_reduce_mul:</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">    case Intrinsic::vector_reduce_mul:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">    case Intrinsic::vector_reduce_and:</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">    case Intrinsic::vector_reduce_and:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">    case Intrinsic::vector_reduce_or:</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">    case Intrinsic::vector_reduce_or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">    case Intrinsic::vector_reduce_xor:</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">    case Intrinsic::vector_reduce_xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">    case Intrinsic::vector_reduce_smax:</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">    case Intrinsic::vector_reduce_smax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">    case Intrinsic::vector_reduce_smin:</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">    case Intrinsic::vector_reduce_smin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmax:</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmin:</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmaximum:</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmaximum:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fminimum:</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fminimum:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">    case Intrinsic::vector_reduce_umax:</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">    case Intrinsic::vector_reduce_umax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">    case Intrinsic::vector_reduce_umin: {</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">    case Intrinsic::vector_reduce_umin: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(IID, RetTy, Args[0]->getType(), FMF, I, 1);</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(IID, RetTy, Args[0]->getType(), FMF, I, 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">      return getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">      return getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fadd:</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fadd:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmul: {</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmul: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">          IID, RetTy, {Args[0]->getType(), Args[1]->getType()}, FMF, I, 1);</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">          IID, RetTy, {Args[0]->getType(), Args[1]->getType()}, FMF, I, 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">      return getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">      return getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">    case Intrinsic::fshl:</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">    case Intrinsic::fshl:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">    case Intrinsic::fshr: {</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">    case Intrinsic::fshr: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">      const Value *X = Args[0];</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">      const Value *X = Args[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">      const Value *Y = Args[1];</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">      const Value *Y = Args[1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline">      const Value *Z = Args[2];</td>
    <td class="lineNumber">1622</td>
    <td class="codeline">      const Value *Z = Args[2];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">      const TTI::OperandValueInfo OpInfoX = TTI::getOperandInfo(X);</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">      const TTI::OperandValueInfo OpInfoX = TTI::getOperandInfo(X);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">      const TTI::OperandValueInfo OpInfoY = TTI::getOperandInfo(Y);</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">      const TTI::OperandValueInfo OpInfoY = TTI::getOperandInfo(Y);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">      const TTI::OperandValueInfo OpInfoZ = TTI::getOperandInfo(Z);</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">      const TTI::OperandValueInfo OpInfoZ = TTI::getOperandInfo(Z);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">      const TTI::OperandValueInfo OpInfoBW =</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">      const TTI::OperandValueInfo OpInfoBW =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">        {TTI::OK_UniformConstantValue,</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">        {TTI::OK_UniformConstantValue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">         isPowerOf2_32(RetTy->getScalarSizeInBits()) ? TTI::OP_PowerOf2</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">         isPowerOf2_32(RetTy->getScalarSizeInBits()) ? TTI::OP_PowerOf2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">         : TTI::OP_None};</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">         : TTI::OP_None};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline"></td>
    <td class="lineNumber">1630</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">      // fshl: (X << (Z % BW)) | (Y >> (BW - (Z % BW)))</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">      // fshl: (X << (Z % BW)) | (Y >> (BW - (Z % BW)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">      // fshr: (X << (BW - (Z % BW))) | (Y >> (Z % BW))</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">      // fshr: (X << (BW - (Z % BW))) | (Y >> (Z % BW))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">      Cost +=</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">      Cost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">          thisT()->getArithmeticInstrCost(BinaryOperator::Or, RetTy, CostKind);</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">          thisT()->getArithmeticInstrCost(BinaryOperator::Or, RetTy, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">      Cost +=</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">      Cost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">          thisT()->getArithmeticInstrCost(BinaryOperator::Sub, RetTy, CostKind);</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">          thisT()->getArithmeticInstrCost(BinaryOperator::Sub, RetTy, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">          BinaryOperator::Shl, RetTy, CostKind, OpInfoX,</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">          BinaryOperator::Shl, RetTy, CostKind, OpInfoX,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">          {OpInfoZ.Kind, TTI::OP_None});</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">          {OpInfoZ.Kind, TTI::OP_None});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">          BinaryOperator::LShr, RetTy, CostKind, OpInfoY,</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">          BinaryOperator::LShr, RetTy, CostKind, OpInfoY,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">          {OpInfoZ.Kind, TTI::OP_None});</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">          {OpInfoZ.Kind, TTI::OP_None});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">      // Non-constant shift amounts requires a modulo.</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">      // Non-constant shift amounts requires a modulo.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">      if (!OpInfoZ.isConstant())</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">      if (!OpInfoZ.isConstant())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">        Cost += thisT()->getArithmeticInstrCost(BinaryOperator::URem, RetTy,</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">        Cost += thisT()->getArithmeticInstrCost(BinaryOperator::URem, RetTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">                                                CostKind, OpInfoZ, OpInfoBW);</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">                                                CostKind, OpInfoZ, OpInfoBW);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">      // For non-rotates (X != Y) we must add shift-by-zero handling costs.</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">      // For non-rotates (X != Y) we must add shift-by-zero handling costs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">      if (X != Y) {</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">      if (X != Y) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">        Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">        Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">        Cost +=</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">        Cost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">            thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">            thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">                                        CmpInst::ICMP_EQ, CostKind);</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">                                        CmpInst::ICMP_EQ, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">        Cost +=</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">        Cost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">            thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">            thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">                                        CmpInst::ICMP_EQ, CostKind);</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">                                        CmpInst::ICMP_EQ, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">      return Cost;</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">      return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">    case Intrinsic::get_active_lane_mask: {</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">    case Intrinsic::get_active_lane_mask: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">      EVT ResVT = getTLI()->getValueType(DL, RetTy, true);</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">      EVT ResVT = getTLI()->getValueType(DL, RetTy, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">      EVT ArgType = getTLI()->getValueType(DL, ICA.getArgTypes()[0], true);</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">      EVT ArgType = getTLI()->getValueType(DL, ICA.getArgTypes()[0], true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline"></td>
    <td class="lineNumber">1663</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">      // If we're not expanding the intrinsic then we assume this is cheap</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">      // If we're not expanding the intrinsic then we assume this is cheap</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">      // to implement.</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">      // to implement.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">      if (!getTLI()->shouldExpandGetActiveLaneMask(ResVT, ArgType)) {</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">      if (!getTLI()->shouldExpandGetActiveLaneMask(ResVT, ArgType)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">        return getTypeLegalizationCost(RetTy).first;</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">        return getTypeLegalizationCost(RetTy).first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline"></td>
    <td class="lineNumber">1669</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">      // Create the expanded types that will be used to calculate the uadd_sat</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">      // Create the expanded types that will be used to calculate the uadd_sat</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">      // operation.</td>
    <td class="lineNumber">1671</td>
    <td class="codeline">      // operation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">      Type *ExpRetTy = VectorType::get(</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">      Type *ExpRetTy = VectorType::get(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">          ICA.getArgTypes()[0], cast<VectorType>(RetTy)->getElementCount());</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">          ICA.getArgTypes()[0], cast<VectorType>(RetTy)->getElementCount());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(Intrinsic::uadd_sat, ExpRetTy, {}, FMF);</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(Intrinsic::uadd_sat, ExpRetTy, {}, FMF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">      InstructionCost Cost =</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">      InstructionCost Cost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">          thisT()->getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">          thisT()->getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, ExpRetTy, RetTy,</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, ExpRetTy, RetTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline">                                          CmpInst::ICMP_ULT, CostKind);</td>
    <td class="lineNumber">1678</td>
    <td class="codeline">                                          CmpInst::ICMP_ULT, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">      return Cost;</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">      return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline"></td>
    <td class="lineNumber">1682</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">    // Assume that we need to scalarize this intrinsic.</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">    // Assume that we need to scalarize this intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">    // Compute the scalarization overhead based on Args for a vector</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">    // Compute the scalarization overhead based on Args for a vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">    // intrinsic.</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">    // intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">    InstructionCost ScalarizationCost = InstructionCost::getInvalid();</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">    InstructionCost ScalarizationCost = InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">    if (RetVF.isVector() && !RetVF.isScalable()) {</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">    if (RetVF.isVector() && !RetVF.isScalable()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">      ScalarizationCost = 0;</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">      ScalarizationCost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">      if (!RetTy->isVoidTy())</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">      if (!RetTy->isVoidTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">        ScalarizationCost += getScalarizationOverhead(</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">        ScalarizationCost += getScalarizationOverhead(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">            cast<VectorType>(RetTy),</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">            cast<VectorType>(RetTy),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">            /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">            /*Insert*/ true, /*Extract*/ false, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">      ScalarizationCost +=</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">      ScalarizationCost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">          getOperandsScalarizationOverhead(Args, ICA.getArgTypes(), CostKind);</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">          getOperandsScalarizationOverhead(Args, ICA.getArgTypes(), CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">    IntrinsicCostAttributes Attrs(IID, RetTy, ICA.getArgTypes(), FMF, I,</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">    IntrinsicCostAttributes Attrs(IID, RetTy, ICA.getArgTypes(), FMF, I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">                                  ScalarizationCost);</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">                                  ScalarizationCost);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">    return thisT()->getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">    return thisT()->getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline"></td>
    <td class="lineNumber">1701</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">  /// Get intrinsic cost based on argument types.</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">  /// Get intrinsic cost based on argument types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">  /// If ScalarizationCostPassed is std::numeric_limits<unsigned>::max(), the</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">  /// If ScalarizationCostPassed is std::numeric_limits<unsigned>::max(), the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">  /// cost of scalarizing the arguments and the return value will be computed</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">  /// cost of scalarizing the arguments and the return value will be computed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">  /// based on types.</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">  /// based on types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">  InstructionCost</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">  InstructionCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">  getTypeBasedIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">  getTypeBasedIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">                                 TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">                                 TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">    Intrinsic::ID IID = ICA.getID();</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">    Intrinsic::ID IID = ICA.getID();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">    Type *RetTy = ICA.getReturnType();</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">    Type *RetTy = ICA.getReturnType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">    const SmallVectorImpl<Type *> &Tys = ICA.getArgTypes();</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">    const SmallVectorImpl<Type *> &Tys = ICA.getArgTypes();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">    FastMathFlags FMF = ICA.getFlags();</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">    FastMathFlags FMF = ICA.getFlags();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">    InstructionCost ScalarizationCostPassed = ICA.getScalarizationCost();</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">    InstructionCost ScalarizationCostPassed = ICA.getScalarizationCost();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">    bool SkipScalarizationCost = ICA.skipScalarizationCost();</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">    bool SkipScalarizationCost = ICA.skipScalarizationCost();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline"></td>
    <td class="lineNumber">1715</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">    VectorType *VecOpTy = nullptr;</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">    VectorType *VecOpTy = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">    if (!Tys.empty()) {</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">    if (!Tys.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">      // The vector reduction operand is operand 0 except for fadd/fmul.</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">      // The vector reduction operand is operand 0 except for fadd/fmul.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">      // Their operand 0 is a scalar start value, so the vector op is operand 1.</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">      // Their operand 0 is a scalar start value, so the vector op is operand 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">      unsigned VecTyIndex = 0;</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">      unsigned VecTyIndex = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">      if (IID == Intrinsic::vector_reduce_fadd ||</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">      if (IID == Intrinsic::vector_reduce_fadd ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">          IID == Intrinsic::vector_reduce_fmul)</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">          IID == Intrinsic::vector_reduce_fmul)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline">        VecTyIndex = 1;</td>
    <td class="lineNumber">1723</td>
    <td class="codeline">        VecTyIndex = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">      assert(Tys.size() > VecTyIndex && "Unexpected IntrinsicCostAttributes");</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">      assert(Tys.size() > VecTyIndex && "Unexpected IntrinsicCostAttributes");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">      VecOpTy = dyn_cast<VectorType>(Tys[VecTyIndex]);</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">      VecOpTy = dyn_cast<VectorType>(Tys[VecTyIndex]);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline"></td>
    <td class="lineNumber">1727</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">    // Library call cost - other than size, make it expensive.</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">    // Library call cost - other than size, make it expensive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">    unsigned SingleCallCost = CostKind == TTI::TCK_CodeSize ? 1 : 10;</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">    unsigned SingleCallCost = CostKind == TTI::TCK_CodeSize ? 1 : 10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">    unsigned ISD = 0;</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">    unsigned ISD = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">    switch (IID) {</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">    switch (IID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">    default: {</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">    default: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">      // Scalable vectors cannot be scalarized, so return Invalid.</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">      // Scalable vectors cannot be scalarized, so return Invalid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">      if (isa<ScalableVectorType>(RetTy) || any_of(Tys, [](const Type *Ty) {</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">      if (isa<ScalableVectorType>(RetTy) || any_of(Tys, [](const Type *Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">            return isa<ScalableVectorType>(Ty);</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">            return isa<ScalableVectorType>(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">          }))</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">          }))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">        return InstructionCost::getInvalid();</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">        return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline"></td>
    <td class="lineNumber">1738</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">      // Assume that we need to scalarize this intrinsic.</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">      // Assume that we need to scalarize this intrinsic.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">      InstructionCost ScalarizationCost =</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">      InstructionCost ScalarizationCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">          SkipScalarizationCost ? ScalarizationCostPassed : 0;</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">          SkipScalarizationCost ? ScalarizationCostPassed : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">      unsigned ScalarCalls = 1;</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">      unsigned ScalarCalls = 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">      Type *ScalarRetTy = RetTy;</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">      Type *ScalarRetTy = RetTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">      if (auto *RetVTy = dyn_cast<VectorType>(RetTy)) {</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">      if (auto *RetVTy = dyn_cast<VectorType>(RetTy)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">        if (!SkipScalarizationCost)</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">        if (!SkipScalarizationCost)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">          ScalarizationCost = getScalarizationOverhead(</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">          ScalarizationCost = getScalarizationOverhead(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">              RetVTy, /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">              RetVTy, /*Insert*/ true, /*Extract*/ false, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">        ScalarCalls = std::max(ScalarCalls,</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">        ScalarCalls = std::max(ScalarCalls,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">                               cast<FixedVectorType>(RetVTy)->getNumElements());</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">                               cast<FixedVectorType>(RetVTy)->getNumElements());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">        ScalarRetTy = RetTy->getScalarType();</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">        ScalarRetTy = RetTy->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">      SmallVector<Type *, 4> ScalarTys;</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">      SmallVector<Type *, 4> ScalarTys;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">        Type *Ty = Tys[i];</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">        Type *Ty = Tys[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">        if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">        if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">          if (!SkipScalarizationCost)</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">          if (!SkipScalarizationCost)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">            ScalarizationCost += getScalarizationOverhead(</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">            ScalarizationCost += getScalarizationOverhead(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">                VTy, /*Insert*/ false, /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">                VTy, /*Insert*/ false, /*Extract*/ true, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">          ScalarCalls = std::max(ScalarCalls,</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">          ScalarCalls = std::max(ScalarCalls,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">                                 cast<FixedVectorType>(VTy)->getNumElements());</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">                                 cast<FixedVectorType>(VTy)->getNumElements());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">          Ty = Ty->getScalarType();</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">          Ty = Ty->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">        ScalarTys.push_back(Ty);</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">        ScalarTys.push_back(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">      if (ScalarCalls == 1)</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">      if (ScalarCalls == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">        return 1; // Return cost of a scalar intrinsic. Assume it to be cheap.</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">        return 1; // Return cost of a scalar intrinsic. Assume it to be cheap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">      IntrinsicCostAttributes ScalarAttrs(IID, ScalarRetTy, ScalarTys, FMF);</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">      IntrinsicCostAttributes ScalarAttrs(IID, ScalarRetTy, ScalarTys, FMF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">      InstructionCost ScalarCost =</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">      InstructionCost ScalarCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">          thisT()->getIntrinsicInstrCost(ScalarAttrs, CostKind);</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">          thisT()->getIntrinsicInstrCost(ScalarAttrs, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline"></td>
    <td class="lineNumber">1771</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">      return ScalarCalls * ScalarCost + ScalarizationCost;</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">      return ScalarCalls * ScalarCost + ScalarizationCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">    // Look for intrinsics that can be lowered directly or turned into a scalar</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">    // Look for intrinsics that can be lowered directly or turned into a scalar</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">    // intrinsic call.</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">    // intrinsic call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">    case Intrinsic::sqrt:</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">    case Intrinsic::sqrt:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">      ISD = ISD::FSQRT;</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">      ISD = ISD::FSQRT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">    case Intrinsic::sin:</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">    case Intrinsic::sin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">      ISD = ISD::FSIN;</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">      ISD = ISD::FSIN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">    case Intrinsic::cos:</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">    case Intrinsic::cos:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">      ISD = ISD::FCOS;</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">      ISD = ISD::FCOS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">    case Intrinsic::exp:</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">    case Intrinsic::exp:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">      ISD = ISD::FEXP;</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">      ISD = ISD::FEXP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">    case Intrinsic::exp2:</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">    case Intrinsic::exp2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">      ISD = ISD::FEXP2;</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">      ISD = ISD::FEXP2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">    case Intrinsic::log:</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">    case Intrinsic::log:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">      ISD = ISD::FLOG;</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">      ISD = ISD::FLOG;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">    case Intrinsic::log10:</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">    case Intrinsic::log10:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">      ISD = ISD::FLOG10;</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">      ISD = ISD::FLOG10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">    case Intrinsic::log2:</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">    case Intrinsic::log2:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">      ISD = ISD::FLOG2;</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">      ISD = ISD::FLOG2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">    case Intrinsic::fabs:</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">    case Intrinsic::fabs:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">      ISD = ISD::FABS;</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">      ISD = ISD::FABS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">    case Intrinsic::canonicalize:</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">    case Intrinsic::canonicalize:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">      ISD = ISD::FCANONICALIZE;</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">      ISD = ISD::FCANONICALIZE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">    case Intrinsic::minnum:</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">    case Intrinsic::minnum:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">      ISD = ISD::FMINNUM;</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">      ISD = ISD::FMINNUM;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">    case Intrinsic::maxnum:</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">    case Intrinsic::maxnum:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">      ISD = ISD::FMAXNUM;</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">      ISD = ISD::FMAXNUM;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">    case Intrinsic::minimum:</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">    case Intrinsic::minimum:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">      ISD = ISD::FMINIMUM;</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">      ISD = ISD::FMINIMUM;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">    case Intrinsic::maximum:</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">    case Intrinsic::maximum:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">      ISD = ISD::FMAXIMUM;</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">      ISD = ISD::FMAXIMUM;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">    case Intrinsic::copysign:</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">    case Intrinsic::copysign:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">      ISD = ISD::FCOPYSIGN;</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">      ISD = ISD::FCOPYSIGN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1820</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">    case Intrinsic::floor:</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">    case Intrinsic::floor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">      ISD = ISD::FFLOOR;</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">      ISD = ISD::FFLOOR;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">    case Intrinsic::ceil:</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">    case Intrinsic::ceil:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">      ISD = ISD::FCEIL;</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">      ISD = ISD::FCEIL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">    case Intrinsic::trunc:</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">    case Intrinsic::trunc:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">      ISD = ISD::FTRUNC;</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">      ISD = ISD::FTRUNC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">    case Intrinsic::nearbyint:</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">    case Intrinsic::nearbyint:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">      ISD = ISD::FNEARBYINT;</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">      ISD = ISD::FNEARBYINT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">    case Intrinsic::rint:</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">    case Intrinsic::rint:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">      ISD = ISD::FRINT;</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">      ISD = ISD::FRINT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">    case Intrinsic::round:</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">    case Intrinsic::round:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">      ISD = ISD::FROUND;</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">      ISD = ISD::FROUND;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">    case Intrinsic::roundeven:</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">    case Intrinsic::roundeven:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">      ISD = ISD::FROUNDEVEN;</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">      ISD = ISD::FROUNDEVEN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">    case Intrinsic::pow:</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">    case Intrinsic::pow:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">      ISD = ISD::FPOW;</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">      ISD = ISD::FPOW;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline">    case Intrinsic::fma:</td>
    <td class="lineNumber">1845</td>
    <td class="codeline">    case Intrinsic::fma:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">      ISD = ISD::FMA;</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">      ISD = ISD::FMA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">    case Intrinsic::fmuladd:</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">    case Intrinsic::fmuladd:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">      ISD = ISD::FMA;</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">      ISD = ISD::FMA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">    case Intrinsic::experimental_constrained_fmuladd:</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">    case Intrinsic::experimental_constrained_fmuladd:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">      ISD = ISD::STRICT_FMA;</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">      ISD = ISD::STRICT_FMA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">    // FIXME: We should return 0 whenever getIntrinsicCost == TCC_Free.</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">    // FIXME: We should return 0 whenever getIntrinsicCost == TCC_Free.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">    case Intrinsic::lifetime_start:</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">    case Intrinsic::lifetime_start:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">    case Intrinsic::lifetime_end:</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">    case Intrinsic::lifetime_end:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">    case Intrinsic::sideeffect:</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">    case Intrinsic::sideeffect:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">    case Intrinsic::pseudoprobe:</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">    case Intrinsic::pseudoprobe:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">    case Intrinsic::arithmetic_fence:</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">    case Intrinsic::arithmetic_fence:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">      return 0;</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">      return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">    case Intrinsic::masked_store: {</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">    case Intrinsic::masked_store: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">      Type *Ty = Tys[0];</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">      Type *Ty = Tys[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">      Align TyAlign = thisT()->DL.getABITypeAlign(Ty);</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">      Align TyAlign = thisT()->DL.getABITypeAlign(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">      return thisT()->getMaskedMemoryOpCost(Instruction::Store, Ty, TyAlign, 0,</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">      return thisT()->getMaskedMemoryOpCost(Instruction::Store, Ty, TyAlign, 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">                                            CostKind);</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">                                            CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1866</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">    case Intrinsic::masked_load: {</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">    case Intrinsic::masked_load: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">      Type *Ty = RetTy;</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">      Type *Ty = RetTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">      Align TyAlign = thisT()->DL.getABITypeAlign(Ty);</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">      Align TyAlign = thisT()->DL.getABITypeAlign(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">      return thisT()->getMaskedMemoryOpCost(Instruction::Load, Ty, TyAlign, 0,</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">      return thisT()->getMaskedMemoryOpCost(Instruction::Load, Ty, TyAlign, 0,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">                                            CostKind);</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">                                            CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">    case Intrinsic::vector_reduce_add:</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">    case Intrinsic::vector_reduce_add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::Add, VecOpTy,</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::Add, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">                                                 std::nullopt, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline">    case Intrinsic::vector_reduce_mul:</td>
    <td class="lineNumber">1876</td>
    <td class="codeline">    case Intrinsic::vector_reduce_mul:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::Mul, VecOpTy,</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::Mul, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">                                                 std::nullopt, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">    case Intrinsic::vector_reduce_and:</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">    case Intrinsic::vector_reduce_and:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::And, VecOpTy,</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::And, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">                                                 std::nullopt, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">    case Intrinsic::vector_reduce_or:</td>
    <td class="lineNumber">1882</td>
    <td class="codeline">    case Intrinsic::vector_reduce_or:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::Or, VecOpTy,</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::Or, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">                                                 std::nullopt, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">    case Intrinsic::vector_reduce_xor:</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">    case Intrinsic::vector_reduce_xor:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::Xor, VecOpTy,</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::Xor, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">                                                 std::nullopt, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fadd:</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fadd:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::FAdd, VecOpTy,</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::FAdd, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">                                                 FMF, CostKind);</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">                                                 FMF, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmul:</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmul:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::FMul, VecOpTy,</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">      return thisT()->getArithmeticReductionCost(Instruction::FMul, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">                                                 FMF, CostKind);</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">                                                 FMF, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">    case Intrinsic::vector_reduce_smax:</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">    case Intrinsic::vector_reduce_smax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::smax, VecOpTy,</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::smax, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">    case Intrinsic::vector_reduce_smin:</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">    case Intrinsic::vector_reduce_smin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::smin, VecOpTy,</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::smin, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">    case Intrinsic::vector_reduce_umax:</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">    case Intrinsic::vector_reduce_umax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::umax, VecOpTy,</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::umax, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">    case Intrinsic::vector_reduce_umin:</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">    case Intrinsic::vector_reduce_umin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::umin, VecOpTy,</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::umin, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmax:</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::maxnum, VecOpTy,</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::maxnum, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmin:</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::minnum, VecOpTy,</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::minnum, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmaximum:</td>
    <td class="lineNumber">1912</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fmaximum:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::maximum, VecOpTy,</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::maximum, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fminimum:</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">    case Intrinsic::vector_reduce_fminimum:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::minimum, VecOpTy,</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">      return thisT()->getMinMaxReductionCost(Intrinsic::minimum, VecOpTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">                                             ICA.getFlags(), CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">    case Intrinsic::abs: {</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">    case Intrinsic::abs: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">      // abs(X) = select(icmp(X,0),X,sub(0,X))</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">      // abs(X) = select(icmp(X,0),X,sub(0,X))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline">      CmpInst::Predicate Pred = CmpInst::ICMP_SGT;</td>
    <td class="lineNumber">1921</td>
    <td class="codeline">      CmpInst::Predicate Pred = CmpInst::ICMP_SGT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">                                          Pred, CostKind);</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">                                          Pred, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline">                                          Pred, CostKind);</td>
    <td class="lineNumber">1926</td>
    <td class="codeline">                                          Pred, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">      // TODO: Should we add an OperandValueProperties::OP_Zero property?</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">      // TODO: Should we add an OperandValueProperties::OP_Zero property?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">         BinaryOperator::Sub, RetTy, CostKind, {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">         BinaryOperator::Sub, RetTy, CostKind, {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">      return Cost;</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">      return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline">    case Intrinsic::smax:</td>
    <td class="lineNumber">1932</td>
    <td class="codeline">    case Intrinsic::smax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">    case Intrinsic::smin:</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">    case Intrinsic::smin:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">    case Intrinsic::umax:</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">    case Intrinsic::umax:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">    case Intrinsic::umin: {</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">    case Intrinsic::umin: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">      // minmax(X,Y) = select(icmp(X,Y),X,Y)</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">      // minmax(X,Y) = select(icmp(X,Y),X,Y)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">      bool IsUnsigned = IID == Intrinsic::umax || IID == Intrinsic::umin;</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">      bool IsUnsigned = IID == Intrinsic::umax || IID == Intrinsic::umin;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">      CmpInst::Predicate Pred =</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">      CmpInst::Predicate Pred =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">          IsUnsigned ? CmpInst::ICMP_UGT : CmpInst::ICMP_SGT;</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">          IsUnsigned ? CmpInst::ICMP_UGT : CmpInst::ICMP_SGT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">                                          Pred, CostKind);</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">                                          Pred, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">                                          Pred, CostKind);</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">                                          Pred, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">      return Cost;</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">      return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1947</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">    case Intrinsic::sadd_sat:</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">    case Intrinsic::sadd_sat:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">    case Intrinsic::ssub_sat: {</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">    case Intrinsic::ssub_sat: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline"></td>
    <td class="lineNumber">1951</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">      Type *OpTy = StructType::create({RetTy, CondTy});</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">      Type *OpTy = StructType::create({RetTy, CondTy});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">      Intrinsic::ID OverflowOp = IID == Intrinsic::sadd_sat</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">      Intrinsic::ID OverflowOp = IID == Intrinsic::sadd_sat</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">                                     ? Intrinsic::sadd_with_overflow</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">                                     ? Intrinsic::sadd_with_overflow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">                                     : Intrinsic::ssub_with_overflow;</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">                                     : Intrinsic::ssub_with_overflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">      CmpInst::Predicate Pred = CmpInst::ICMP_SGT;</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">      CmpInst::Predicate Pred = CmpInst::ICMP_SGT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline"></td>
    <td class="lineNumber">1957</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">      // SatMax -> Overflow && SumDiff < 0</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">      // SatMax -> Overflow && SumDiff < 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">      // SatMin -> Overflow && SumDiff >= 0</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">      // SatMin -> Overflow && SumDiff >= 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(OverflowOp, OpTy, {RetTy, RetTy}, FMF,</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(OverflowOp, OpTy, {RetTy, RetTy}, FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">                                    nullptr, ScalarizationCostPassed);</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">                                    nullptr, ScalarizationCostPassed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">      Cost += thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">      Cost += thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">                                          Pred, CostKind);</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">                                          Pred, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">      Cost += 2 * thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy,</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">      Cost += 2 * thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">                                              CondTy, Pred, CostKind);</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">                                              CondTy, Pred, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">      return Cost;</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">      return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">    case Intrinsic::uadd_sat:</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">    case Intrinsic::uadd_sat:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">    case Intrinsic::usub_sat: {</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">    case Intrinsic::usub_sat: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline"></td>
    <td class="lineNumber">1973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">      Type *OpTy = StructType::create({RetTy, CondTy});</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">      Type *OpTy = StructType::create({RetTy, CondTy});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">      Intrinsic::ID OverflowOp = IID == Intrinsic::uadd_sat</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">      Intrinsic::ID OverflowOp = IID == Intrinsic::uadd_sat</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">                                     ? Intrinsic::uadd_with_overflow</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">                                     ? Intrinsic::uadd_with_overflow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">                                     : Intrinsic::usub_with_overflow;</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">                                     : Intrinsic::usub_with_overflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline"></td>
    <td class="lineNumber">1978</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(OverflowOp, OpTy, {RetTy, RetTy}, FMF,</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(OverflowOp, OpTy, {RetTy, RetTy}, FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline">                                    nullptr, ScalarizationCostPassed);</td>
    <td class="lineNumber">1981</td>
    <td class="codeline">                                    nullptr, ScalarizationCostPassed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">      Cost += thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">      Cost += thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">      Cost +=</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">      Cost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">          thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">          thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">                                      CmpInst::BAD_ICMP_PREDICATE, CostKind);</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">                                      CmpInst::BAD_ICMP_PREDICATE, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">      return Cost;</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">      return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">    case Intrinsic::smul_fix:</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">    case Intrinsic::smul_fix:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">    case Intrinsic::umul_fix: {</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">    case Intrinsic::umul_fix: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">      unsigned ExtSize = RetTy->getScalarSizeInBits() * 2;</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">      unsigned ExtSize = RetTy->getScalarSizeInBits() * 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">      Type *ExtTy = RetTy->getWithNewBitWidth(ExtSize);</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">      Type *ExtTy = RetTy->getWithNewBitWidth(ExtSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline"></td>
    <td class="lineNumber">1992</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">      unsigned ExtOp =</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">      unsigned ExtOp =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">          IID == Intrinsic::smul_fix ? Instruction::SExt : Instruction::ZExt;</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">          IID == Intrinsic::smul_fix ? Instruction::SExt : Instruction::ZExt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">      TTI::CastContextHint CCH = TTI::CastContextHint::None;</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">      TTI::CastContextHint CCH = TTI::CastContextHint::None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline"></td>
    <td class="lineNumber">1996</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">      Cost += 2 * thisT()->getCastInstrCost(ExtOp, ExtTy, RetTy, CCH, CostKind);</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">      Cost += 2 * thisT()->getCastInstrCost(ExtOp, ExtTy, RetTy, CCH, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">      Cost +=</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">      Cost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">          thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">          thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">      Cost += 2 * thisT()->getCastInstrCost(Instruction::Trunc, RetTy, ExtTy,</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">      Cost += 2 * thisT()->getCastInstrCost(Instruction::Trunc, RetTy, ExtTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">                                            CCH, CostKind);</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">                                            CCH, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(Instruction::LShr, RetTy,</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(Instruction::LShr, RetTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">                                              CostKind,</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">                                              CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(Instruction::Shl, RetTy, CostKind,</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(Instruction::Shl, RetTy, CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(Instruction::Or, RetTy, CostKind);</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(Instruction::Or, RetTy, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">      return Cost;</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">      return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">    case Intrinsic::sadd_with_overflow:</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">    case Intrinsic::sadd_with_overflow:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">    case Intrinsic::ssub_with_overflow: {</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">    case Intrinsic::ssub_with_overflow: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">      Type *SumTy = RetTy->getContainedType(0);</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">      Type *SumTy = RetTy->getContainedType(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">      Type *OverflowTy = RetTy->getContainedType(1);</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">      Type *OverflowTy = RetTy->getContainedType(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">      unsigned Opcode = IID == Intrinsic::sadd_with_overflow</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">      unsigned Opcode = IID == Intrinsic::sadd_with_overflow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">                            ? BinaryOperator::Add</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">                            ? BinaryOperator::Add</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">                            : BinaryOperator::Sub;</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">                            : BinaryOperator::Sub;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline"></td>
    <td class="lineNumber">2020</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">      //   Add:</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">      //   Add:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">      //   Overflow -> (Result < LHS) ^ (RHS < 0)</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">      //   Overflow -> (Result < LHS) ^ (RHS < 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">      //   Sub:</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">      //   Sub:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">      //   Overflow -> (Result < LHS) ^ (RHS > 0)</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">      //   Overflow -> (Result < LHS) ^ (RHS > 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(Opcode, SumTy, CostKind);</td>
    <td class="lineNumber">2026</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(Opcode, SumTy, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">      Cost += 2 * thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">      Cost += 2 * thisT()->getCmpSelInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">                      Instruction::ICmp, SumTy, OverflowTy,</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">                      Instruction::ICmp, SumTy, OverflowTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">                      CmpInst::ICMP_SGT, CostKind);</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">                      CmpInst::ICMP_SGT, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(BinaryOperator::Xor, OverflowTy,</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(BinaryOperator::Xor, OverflowTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">                                              CostKind);</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">                                              CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">      return Cost;</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">      return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">    case Intrinsic::uadd_with_overflow:</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">    case Intrinsic::uadd_with_overflow:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">    case Intrinsic::usub_with_overflow: {</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">    case Intrinsic::usub_with_overflow: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">      Type *SumTy = RetTy->getContainedType(0);</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">      Type *SumTy = RetTy->getContainedType(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">      Type *OverflowTy = RetTy->getContainedType(1);</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">      Type *OverflowTy = RetTy->getContainedType(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">      unsigned Opcode = IID == Intrinsic::uadd_with_overflow</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">      unsigned Opcode = IID == Intrinsic::uadd_with_overflow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">                            ? BinaryOperator::Add</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">                            ? BinaryOperator::Add</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">                            : BinaryOperator::Sub;</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">                            : BinaryOperator::Sub;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">      CmpInst::Predicate Pred = IID == Intrinsic::uadd_with_overflow</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">      CmpInst::Predicate Pred = IID == Intrinsic::uadd_with_overflow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">                                    ? CmpInst::ICMP_ULT</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">                                    ? CmpInst::ICMP_ULT</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">                                    : CmpInst::ICMP_UGT;</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">                                    : CmpInst::ICMP_UGT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline"></td>
    <td class="lineNumber">2044</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(Opcode, SumTy, CostKind);</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(Opcode, SumTy, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">      Cost +=</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">      Cost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">          thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, SumTy, OverflowTy,</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">          thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, SumTy, OverflowTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">                                      Pred, CostKind);</td>
    <td class="lineNumber">2049</td>
    <td class="codeline">                                      Pred, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">      return Cost;</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">      return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">    case Intrinsic::smul_with_overflow:</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">    case Intrinsic::smul_with_overflow:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">    case Intrinsic::umul_with_overflow: {</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">    case Intrinsic::umul_with_overflow: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">      Type *MulTy = RetTy->getContainedType(0);</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">      Type *MulTy = RetTy->getContainedType(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">      Type *OverflowTy = RetTy->getContainedType(1);</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">      Type *OverflowTy = RetTy->getContainedType(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">      unsigned ExtSize = MulTy->getScalarSizeInBits() * 2;</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">      unsigned ExtSize = MulTy->getScalarSizeInBits() * 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">      Type *ExtTy = MulTy->getWithNewBitWidth(ExtSize);</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">      Type *ExtTy = MulTy->getWithNewBitWidth(ExtSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">      bool IsSigned = IID == Intrinsic::smul_with_overflow;</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">      bool IsSigned = IID == Intrinsic::smul_with_overflow;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">      unsigned ExtOp = IsSigned ? Instruction::SExt : Instruction::ZExt;</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">      unsigned ExtOp = IsSigned ? Instruction::SExt : Instruction::ZExt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">      TTI::CastContextHint CCH = TTI::CastContextHint::None;</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">      TTI::CastContextHint CCH = TTI::CastContextHint::None;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline"></td>
    <td class="lineNumber">2062</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">      Cost += 2 * thisT()->getCastInstrCost(ExtOp, ExtTy, MulTy, CCH, CostKind);</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">      Cost += 2 * thisT()->getCastInstrCost(ExtOp, ExtTy, MulTy, CCH, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">      Cost +=</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">      Cost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">          thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">          thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">      Cost += 2 * thisT()->getCastInstrCost(Instruction::Trunc, MulTy, ExtTy,</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">      Cost += 2 * thisT()->getCastInstrCost(Instruction::Trunc, MulTy, ExtTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">                                            CCH, CostKind);</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">                                            CCH, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(Instruction::LShr, ExtTy,</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">      Cost += thisT()->getArithmeticInstrCost(Instruction::LShr, ExtTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">                                              CostKind,</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">                                              CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline"></td>
    <td class="lineNumber">2073</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">      if (IsSigned)</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">      if (IsSigned)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline">        Cost += thisT()->getArithmeticInstrCost(Instruction::AShr, MulTy,</td>
    <td class="lineNumber">2075</td>
    <td class="codeline">        Cost += thisT()->getArithmeticInstrCost(Instruction::AShr, MulTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">                                                CostKind,</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">                                                CostKind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">                                                {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">                                                {TTI::OK_AnyValue, TTI::OP_None},</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline">                                                {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">2078</td>
    <td class="codeline">                                                {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline"></td>
    <td class="lineNumber">2079</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">      Cost += thisT()->getCmpSelInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">          BinaryOperator::ICmp, MulTy, OverflowTy, CmpInst::ICMP_NE, CostKind);</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">          BinaryOperator::ICmp, MulTy, OverflowTy, CmpInst::ICMP_NE, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">      return Cost;</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">      return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">    case Intrinsic::fptosi_sat:</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">    case Intrinsic::fptosi_sat:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">    case Intrinsic::fptoui_sat: {</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">    case Intrinsic::fptoui_sat: {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">      if (Tys.empty())</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">      if (Tys.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">      Type *FromTy = Tys[0];</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">      Type *FromTy = Tys[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">      bool IsSigned = IID == Intrinsic::fptosi_sat;</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">      bool IsSigned = IID == Intrinsic::fptosi_sat;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline"></td>
    <td class="lineNumber">2090</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">      InstructionCost Cost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs1(Intrinsic::minnum, FromTy,</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs1(Intrinsic::minnum, FromTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">                                     {FromTy, FromTy});</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">                                     {FromTy, FromTy});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">      Cost += thisT()->getIntrinsicInstrCost(Attrs1, CostKind);</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">      Cost += thisT()->getIntrinsicInstrCost(Attrs1, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs2(Intrinsic::maxnum, FromTy,</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs2(Intrinsic::maxnum, FromTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">                                     {FromTy, FromTy});</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">                                     {FromTy, FromTy});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">      Cost += thisT()->getIntrinsicInstrCost(Attrs2, CostKind);</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">      Cost += thisT()->getIntrinsicInstrCost(Attrs2, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline">      Cost += thisT()->getCastInstrCost(</td>
    <td class="lineNumber">2098</td>
    <td class="codeline">      Cost += thisT()->getCastInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">          IsSigned ? Instruction::FPToSI : Instruction::FPToUI, RetTy, FromTy,</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">          IsSigned ? Instruction::FPToSI : Instruction::FPToUI, RetTy, FromTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">          TTI::CastContextHint::None, CostKind);</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">          TTI::CastContextHint::None, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">      if (IsSigned) {</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">      if (IsSigned) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">        Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">        Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">        Cost += thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">        Cost += thisT()->getCmpSelInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">            BinaryOperator::FCmp, FromTy, CondTy, CmpInst::FCMP_UNO, CostKind);</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">            BinaryOperator::FCmp, FromTy, CondTy, CmpInst::FCMP_UNO, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">        Cost += thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">        Cost += thisT()->getCmpSelInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">            BinaryOperator::Select, RetTy, CondTy, CmpInst::FCMP_UNO, CostKind);</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">            BinaryOperator::Select, RetTy, CondTy, CmpInst::FCMP_UNO, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">      return Cost;</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">      return Cost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">    case Intrinsic::ctpop:</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">    case Intrinsic::ctpop:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">      ISD = ISD::CTPOP;</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">      ISD = ISD::CTPOP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">      // In case of legalization use TCC_Expensive. This is cheaper than a</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">      // In case of legalization use TCC_Expensive. This is cheaper than a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">      // library call but still not a cheap instruction.</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">      // library call but still not a cheap instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">      SingleCallCost = TargetTransformInfo::TCC_Expensive;</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">      SingleCallCost = TargetTransformInfo::TCC_Expensive;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">    case Intrinsic::ctlz:</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">    case Intrinsic::ctlz:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">      ISD = ISD::CTLZ;</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">      ISD = ISD::CTLZ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">    case Intrinsic::cttz:</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">    case Intrinsic::cttz:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">      ISD = ISD::CTTZ;</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">      ISD = ISD::CTTZ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">    case Intrinsic::bswap:</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">    case Intrinsic::bswap:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">      ISD = ISD::BSWAP;</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">      ISD = ISD::BSWAP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">    case Intrinsic::bitreverse:</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">    case Intrinsic::bitreverse:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">      ISD = ISD::BITREVERSE;</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">      ISD = ISD::BITREVERSE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline"></td>
    <td class="lineNumber">2129</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">    const TargetLoweringBase *TLI = getTLI();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(RetTy);</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(RetTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline"></td>
    <td class="lineNumber">2132</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">    if (TLI->isOperationLegalOrPromote(ISD, LT.second)) {</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">    if (TLI->isOperationLegalOrPromote(ISD, LT.second)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">      if (IID == Intrinsic::fabs && LT.second.isFloatingPoint() &&</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">      if (IID == Intrinsic::fabs && LT.second.isFloatingPoint() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">          TLI->isFAbsFree(LT.second)) {</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">          TLI->isFAbsFree(LT.second)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">        return 0;</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">        return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline"></td>
    <td class="lineNumber">2138</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">      // The operation is legal. Assume it costs 1.</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">      // The operation is legal. Assume it costs 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">      // If the type is split to multiple registers, assume that there is some</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">      // If the type is split to multiple registers, assume that there is some</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">      // overhead to this.</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">      // overhead to this.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">      // TODO: Once we have extract/insert subvector cost we need to use them.</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">      // TODO: Once we have extract/insert subvector cost we need to use them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">      if (LT.first > 1)</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">      if (LT.first > 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">        return (LT.first * 2);</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">        return (LT.first * 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">        return (LT.first * 1);</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">        return (LT.first * 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">    } else if (!TLI->isOperationExpand(ISD, LT.second)) {</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">    } else if (!TLI->isOperationExpand(ISD, LT.second)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">      // If the operation is custom lowered then assume</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">      // If the operation is custom lowered then assume</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">      // that the code is twice as expensive.</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">      // that the code is twice as expensive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">      return (LT.first * 2);</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">      return (LT.first * 2);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline"></td>
    <td class="lineNumber">2152</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline">    // If we can't lower fmuladd into an FMA estimate the cost as a floating</td>
    <td class="lineNumber">2153</td>
    <td class="codeline">    // If we can't lower fmuladd into an FMA estimate the cost as a floating</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">    // point mul followed by an add.</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">    // point mul followed by an add.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">    if (IID == Intrinsic::fmuladd)</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">    if (IID == Intrinsic::fmuladd)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">      return thisT()->getArithmeticInstrCost(BinaryOperator::FMul, RetTy,</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">      return thisT()->getArithmeticInstrCost(BinaryOperator::FMul, RetTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline">                                             CostKind) +</td>
    <td class="lineNumber">2157</td>
    <td class="codeline">                                             CostKind) +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">             thisT()->getArithmeticInstrCost(BinaryOperator::FAdd, RetTy,</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">             thisT()->getArithmeticInstrCost(BinaryOperator::FAdd, RetTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">                                             CostKind);</td>
    <td class="lineNumber">2159</td>
    <td class="codeline">                                             CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">    if (IID == Intrinsic::experimental_constrained_fmuladd) {</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">    if (IID == Intrinsic::experimental_constrained_fmuladd) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">      IntrinsicCostAttributes FMulAttrs(</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">      IntrinsicCostAttributes FMulAttrs(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">        Intrinsic::experimental_constrained_fmul, RetTy, Tys);</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">        Intrinsic::experimental_constrained_fmul, RetTy, Tys);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">      IntrinsicCostAttributes FAddAttrs(</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">      IntrinsicCostAttributes FAddAttrs(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">        Intrinsic::experimental_constrained_fadd, RetTy, Tys);</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">        Intrinsic::experimental_constrained_fadd, RetTy, Tys);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">      return thisT()->getIntrinsicInstrCost(FMulAttrs, CostKind) +</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">      return thisT()->getIntrinsicInstrCost(FMulAttrs, CostKind) +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">             thisT()->getIntrinsicInstrCost(FAddAttrs, CostKind);</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">             thisT()->getIntrinsicInstrCost(FAddAttrs, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline"></td>
    <td class="lineNumber">2168</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">    // Else, assume that we need to scalarize this intrinsic. For math builtins</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">    // Else, assume that we need to scalarize this intrinsic. For math builtins</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">    // this will emit a costly libcall, adding call overhead and spills. Make it</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">    // this will emit a costly libcall, adding call overhead and spills. Make it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">    // very expensive.</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">    // very expensive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline">    if (auto *RetVTy = dyn_cast<VectorType>(RetTy)) {</td>
    <td class="lineNumber">2172</td>
    <td class="codeline">    if (auto *RetVTy = dyn_cast<VectorType>(RetTy)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">      // Scalable vectors cannot be scalarized, so return Invalid.</td>
    <td class="lineNumber">2173</td>
    <td class="codeline">      // Scalable vectors cannot be scalarized, so return Invalid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">      if (isa<ScalableVectorType>(RetTy) || any_of(Tys, [](const Type *Ty) {</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">      if (isa<ScalableVectorType>(RetTy) || any_of(Tys, [](const Type *Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">            return isa<ScalableVectorType>(Ty);</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">            return isa<ScalableVectorType>(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">          }))</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">          }))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">        return InstructionCost::getInvalid();</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">        return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline"></td>
    <td class="lineNumber">2178</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">      InstructionCost ScalarizationCost =</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">      InstructionCost ScalarizationCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">          SkipScalarizationCost</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">          SkipScalarizationCost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline">              ? ScalarizationCostPassed</td>
    <td class="lineNumber">2181</td>
    <td class="codeline">              ? ScalarizationCostPassed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">              : getScalarizationOverhead(RetVTy, /*Insert*/ true,</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">              : getScalarizationOverhead(RetVTy, /*Insert*/ true,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">                                         /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">                                         /*Extract*/ false, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline"></td>
    <td class="lineNumber">2184</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">      unsigned ScalarCalls = cast<FixedVectorType>(RetVTy)->getNumElements();</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">      unsigned ScalarCalls = cast<FixedVectorType>(RetVTy)->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline">      SmallVector<Type *, 4> ScalarTys;</td>
    <td class="lineNumber">2186</td>
    <td class="codeline">      SmallVector<Type *, 4> ScalarTys;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">        Type *Ty = Tys[i];</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">        Type *Ty = Tys[i];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">        if (Ty->isVectorTy())</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">        if (Ty->isVectorTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">          Ty = Ty->getScalarType();</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">          Ty = Ty->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">        ScalarTys.push_back(Ty);</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">        ScalarTys.push_back(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(IID, RetTy->getScalarType(), ScalarTys, FMF);</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(IID, RetTy->getScalarType(), ScalarTys, FMF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">      InstructionCost ScalarCost =</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">      InstructionCost ScalarCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline">          thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">2195</td>
    <td class="codeline">          thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">        if (auto *VTy = dyn_cast<VectorType>(Tys[i])) {</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">        if (auto *VTy = dyn_cast<VectorType>(Tys[i])) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline">          if (!ICA.skipScalarizationCost())</td>
    <td class="lineNumber">2198</td>
    <td class="codeline">          if (!ICA.skipScalarizationCost())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">            ScalarizationCost += getScalarizationOverhead(</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">            ScalarizationCost += getScalarizationOverhead(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">                VTy, /*Insert*/ false, /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">                VTy, /*Insert*/ false, /*Extract*/ true, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">          ScalarCalls = std::max(ScalarCalls,</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">          ScalarCalls = std::max(ScalarCalls,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">                                 cast<FixedVectorType>(VTy)->getNumElements());</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">                                 cast<FixedVectorType>(VTy)->getNumElements());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">      return ScalarCalls * ScalarCost + ScalarizationCost;</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">      return ScalarCalls * ScalarCost + ScalarizationCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2206</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline"></td>
    <td class="lineNumber">2207</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">    // This is going to be turned into a library call, make it expensive.</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">    // This is going to be turned into a library call, make it expensive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">    return SingleCallCost;</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">    return SingleCallCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline"></td>
    <td class="lineNumber">2211</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">  /// Compute a cost of the given call instruction.</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">  /// Compute a cost of the given call instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">  /// Compute the cost of calling function F with return type RetTy and</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">  /// Compute the cost of calling function F with return type RetTy and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">  /// argument types Tys. F might be nullptr, in this case the cost of an</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">  /// argument types Tys. F might be nullptr, in this case the cost of an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline">  /// arbitrary call with the specified signature will be returned.</td>
    <td class="lineNumber">2216</td>
    <td class="codeline">  /// arbitrary call with the specified signature will be returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">  /// This is used, for instance,  when we estimate call of a vector</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">  /// This is used, for instance,  when we estimate call of a vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">  /// counterpart of the given function.</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">  /// counterpart of the given function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">  /// \param F Called function, might be nullptr.</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">  /// \param F Called function, might be nullptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">  /// \param RetTy Return value types.</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">  /// \param RetTy Return value types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">  /// \param Tys Argument types.</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">  /// \param Tys Argument types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">  /// \returns The cost of Call instruction.</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">  /// \returns The cost of Call instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">  InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
    <td class="lineNumber">2223</td>
    <td class="codeline">  InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">                                   ArrayRef<Type *> Tys,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline">                                   TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">2225</td>
    <td class="codeline">                                   TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">    return 10;</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">    return 10;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline"></td>
    <td class="lineNumber">2228</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">  unsigned getNumberOfParts(Type *Tp) {</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">  unsigned getNumberOfParts(Type *Tp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Tp);</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Tp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline">    return LT.first.isValid() ? *LT.first.getValue() : 0;</td>
    <td class="lineNumber">2231</td>
    <td class="codeline">    return LT.first.isValid() ? *LT.first.getValue() : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline"></td>
    <td class="lineNumber">2233</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">  InstructionCost getAddressComputationCost(Type *Ty, ScalarEvolution *,</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">  InstructionCost getAddressComputationCost(Type *Ty, ScalarEvolution *,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">                                            const SCEV *) {</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">                                            const SCEV *) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">    return 0;</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">    return 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline"></td>
    <td class="lineNumber">2238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">  /// Try to calculate arithmetic and shuffle op costs for reduction intrinsics.</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">  /// Try to calculate arithmetic and shuffle op costs for reduction intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">  /// We're assuming that reduction operation are performing the following way:</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">  /// We're assuming that reduction operation are performing the following way:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">  /// %val1 = shufflevector<n x t> %val, <n x t> %undef,</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">  /// %val1 = shufflevector<n x t> %val, <n x t> %undef,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline">  /// <n x i32> <i32 n/2, i32 n/2 + 1, ..., i32 n, i32 undef, ..., i32 undef></td>
    <td class="lineNumber">2243</td>
    <td class="codeline">  /// <n x i32> <i32 n/2, i32 n/2 + 1, ..., i32 n, i32 undef, ..., i32 undef></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">  ///            \----------------v-------------/  \----------v------------/</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">  ///            \----------------v-------------/  \----------v------------/</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">  ///                            n/2 elements               n/2 elements</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">  ///                            n/2 elements               n/2 elements</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">  /// %red1 = op <n x t> %val, <n x t> val1</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">  /// %red1 = op <n x t> %val, <n x t> val1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">  /// After this operation we have a vector %red1 where only the first n/2</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">  /// After this operation we have a vector %red1 where only the first n/2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline">  /// elements are meaningful, the second n/2 elements are undefined and can be</td>
    <td class="lineNumber">2248</td>
    <td class="codeline">  /// elements are meaningful, the second n/2 elements are undefined and can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">  /// dropped. All other operations are actually working with the vector of</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">  /// dropped. All other operations are actually working with the vector of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">  /// length n/2, not n, though the real vector length is still n.</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">  /// length n/2, not n, though the real vector length is still n.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">  /// %val2 = shufflevector<n x t> %red1, <n x t> %undef,</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">  /// %val2 = shufflevector<n x t> %red1, <n x t> %undef,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">  /// <n x i32> <i32 n/4, i32 n/4 + 1, ..., i32 n/2, i32 undef, ..., i32 undef></td>
    <td class="lineNumber">2252</td>
    <td class="codeline">  /// <n x i32> <i32 n/4, i32 n/4 + 1, ..., i32 n/2, i32 undef, ..., i32 undef></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">  ///            \----------------v-------------/  \----------v------------/</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">  ///            \----------------v-------------/  \----------v------------/</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">  ///                            n/4 elements               3*n/4 elements</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">  ///                            n/4 elements               3*n/4 elements</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">  /// %red2 = op <n x t> %red1, <n x t> val2  - working with the vector of</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">  /// %red2 = op <n x t> %red1, <n x t> val2  - working with the vector of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">  /// length n/2, the resulting vector has length n/4 etc.</td>
    <td class="lineNumber">2256</td>
    <td class="codeline">  /// length n/2, the resulting vector has length n/4 etc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">  /// The cost model should take into account that the actual length of the</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">  /// The cost model should take into account that the actual length of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">  /// vector is reduced on each iteration.</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">  /// vector is reduced on each iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline">  InstructionCost getTreeReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">2260</td>
    <td class="codeline">  InstructionCost getTreeReductionCost(unsigned Opcode, VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">                                       TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">                                       TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">    // Targets must implement a default value for the scalable case, since</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">    // Targets must implement a default value for the scalable case, since</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline">    // we don't know how many lanes the vector has.</td>
    <td class="lineNumber">2263</td>
    <td class="codeline">    // we don't know how many lanes the vector has.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">    if (isa<ScalableVectorType>(Ty))</td>
    <td class="lineNumber">2264</td>
    <td class="codeline">    if (isa<ScalableVectorType>(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline"></td>
    <td class="lineNumber">2266</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">    Type *ScalarTy = Ty->getElementType();</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">    Type *ScalarTy = Ty->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">    unsigned NumVecElts = cast<FixedVectorType>(Ty)->getNumElements();</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">    unsigned NumVecElts = cast<FixedVectorType>(Ty)->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">    if ((Opcode == Instruction::Or || Opcode == Instruction::And) &&</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">    if ((Opcode == Instruction::Or || Opcode == Instruction::And) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">        ScalarTy == IntegerType::getInt1Ty(Ty->getContext()) &&</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">        ScalarTy == IntegerType::getInt1Ty(Ty->getContext()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">        NumVecElts >= 2) {</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">        NumVecElts >= 2) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">      // Or reduction for i1 is represented as:</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">      // Or reduction for i1 is represented as:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline">      // %val = bitcast <ReduxWidth x i1> to iReduxWidth</td>
    <td class="lineNumber">2273</td>
    <td class="codeline">      // %val = bitcast <ReduxWidth x i1> to iReduxWidth</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">      // %res = cmp ne iReduxWidth %val, 0</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">      // %res = cmp ne iReduxWidth %val, 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">      // And reduction for i1 is represented as:</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">      // And reduction for i1 is represented as:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">      // %val = bitcast <ReduxWidth x i1> to iReduxWidth</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">      // %val = bitcast <ReduxWidth x i1> to iReduxWidth</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">      // %res = cmp eq iReduxWidth %val, 11111</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">      // %res = cmp eq iReduxWidth %val, 11111</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">      Type *ValTy = IntegerType::get(Ty->getContext(), NumVecElts);</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">      Type *ValTy = IntegerType::get(Ty->getContext(), NumVecElts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline">      return thisT()->getCastInstrCost(Instruction::BitCast, ValTy, Ty,</td>
    <td class="lineNumber">2279</td>
    <td class="codeline">      return thisT()->getCastInstrCost(Instruction::BitCast, ValTy, Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">                                       TTI::CastContextHint::None, CostKind) +</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">                                       TTI::CastContextHint::None, CostKind) +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">             thisT()->getCmpSelInstrCost(Instruction::ICmp, ValTy,</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">             thisT()->getCmpSelInstrCost(Instruction::ICmp, ValTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">                                         CmpInst::makeCmpResultType(ValTy),</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">                                         CmpInst::makeCmpResultType(ValTy),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">                                         CmpInst::BAD_ICMP_PREDICATE, CostKind);</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">                                         CmpInst::BAD_ICMP_PREDICATE, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2284</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">    unsigned NumReduxLevels = Log2_32(NumVecElts);</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">    unsigned NumReduxLevels = Log2_32(NumVecElts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline">    InstructionCost ArithCost = 0;</td>
    <td class="lineNumber">2286</td>
    <td class="codeline">    InstructionCost ArithCost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">    InstructionCost ShuffleCost = 0;</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">    InstructionCost ShuffleCost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = thisT()->getTypeLegalizationCost(Ty);</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = thisT()->getTypeLegalizationCost(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">    unsigned LongVectorCount = 0;</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">    unsigned LongVectorCount = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">    unsigned MVTLen =</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">    unsigned MVTLen =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline">        LT.second.isVector() ? LT.second.getVectorNumElements() : 1;</td>
    <td class="lineNumber">2291</td>
    <td class="codeline">        LT.second.isVector() ? LT.second.getVectorNumElements() : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">    while (NumVecElts > MVTLen) {</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">    while (NumVecElts > MVTLen) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">      NumVecElts /= 2;</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">      NumVecElts /= 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">      VectorType *SubTy = FixedVectorType::get(ScalarTy, NumVecElts);</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">      VectorType *SubTy = FixedVectorType::get(ScalarTy, NumVecElts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline">      ShuffleCost +=</td>
    <td class="lineNumber">2295</td>
    <td class="codeline">      ShuffleCost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">          thisT()->getShuffleCost(TTI::SK_ExtractSubvector, Ty, std::nullopt,</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">          thisT()->getShuffleCost(TTI::SK_ExtractSubvector, Ty, std::nullopt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">                                  CostKind, NumVecElts, SubTy);</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">                                  CostKind, NumVecElts, SubTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline">      ArithCost += thisT()->getArithmeticInstrCost(Opcode, SubTy, CostKind);</td>
    <td class="lineNumber">2298</td>
    <td class="codeline">      ArithCost += thisT()->getArithmeticInstrCost(Opcode, SubTy, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">      Ty = SubTy;</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">      Ty = SubTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">      ++LongVectorCount;</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">      ++LongVectorCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2301</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline"></td>
    <td class="lineNumber">2302</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">    NumReduxLevels -= LongVectorCount;</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">    NumReduxLevels -= LongVectorCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline"></td>
    <td class="lineNumber">2304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">    // The minimal length of the vector is limited by the real length of vector</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">    // The minimal length of the vector is limited by the real length of vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">    // operations performed on the current platform. That's why several final</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">    // operations performed on the current platform. That's why several final</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline">    // reduction operations are performed on the vectors with the same</td>
    <td class="lineNumber">2307</td>
    <td class="codeline">    // reduction operations are performed on the vectors with the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline">    // architecture-dependent length.</td>
    <td class="lineNumber">2308</td>
    <td class="codeline">    // architecture-dependent length.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline"></td>
    <td class="lineNumber">2309</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline">    // By default reductions need one shuffle per reduction level.</td>
    <td class="lineNumber">2310</td>
    <td class="codeline">    // By default reductions need one shuffle per reduction level.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">    ShuffleCost +=</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">    ShuffleCost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">        NumReduxLevels * thisT()->getShuffleCost(TTI::SK_PermuteSingleSrc, Ty,</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">        NumReduxLevels * thisT()->getShuffleCost(TTI::SK_PermuteSingleSrc, Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline">                                                 std::nullopt, CostKind, 0, Ty);</td>
    <td class="lineNumber">2313</td>
    <td class="codeline">                                                 std::nullopt, CostKind, 0, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">    ArithCost +=</td>
    <td class="lineNumber">2314</td>
    <td class="codeline">    ArithCost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">        NumReduxLevels * thisT()->getArithmeticInstrCost(Opcode, Ty, CostKind);</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">        NumReduxLevels * thisT()->getArithmeticInstrCost(Opcode, Ty, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">    return ShuffleCost + ArithCost +</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">    return ShuffleCost + ArithCost +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">           thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">           thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline">                                       CostKind, 0, nullptr, nullptr);</td>
    <td class="lineNumber">2318</td>
    <td class="codeline">                                       CostKind, 0, nullptr, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2319</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline"></td>
    <td class="lineNumber">2320</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">  /// Try to calculate the cost of performing strict (in-order) reductions,</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">  /// Try to calculate the cost of performing strict (in-order) reductions,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">  /// which involves doing a sequence of floating point additions in lane</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">  /// which involves doing a sequence of floating point additions in lane</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">  /// order, starting with an initial value. For example, consider a scalar</td>
    <td class="lineNumber">2323</td>
    <td class="codeline">  /// order, starting with an initial value. For example, consider a scalar</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">  /// initial value 'InitVal' of type float and a vector of type <4 x float>:</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">  /// initial value 'InitVal' of type float and a vector of type <4 x float>:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">  ///   Vector = <float %v0, float %v1, float %v2, float %v3></td>
    <td class="lineNumber">2326</td>
    <td class="codeline">  ///   Vector = <float %v0, float %v1, float %v2, float %v3></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">  ///   %add1 = %InitVal + %v0</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">  ///   %add1 = %InitVal + %v0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">  ///   %add2 = %add1 + %v1</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">  ///   %add2 = %add1 + %v1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">  ///   %add3 = %add2 + %v2</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">  ///   %add3 = %add2 + %v2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline">  ///   %add4 = %add3 + %v3</td>
    <td class="lineNumber">2331</td>
    <td class="codeline">  ///   %add4 = %add3 + %v3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">  /// As a simple estimate we can say the cost of such a reduction is 4 times</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">  /// As a simple estimate we can say the cost of such a reduction is 4 times</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">  /// the cost of a scalar FP addition. We can only estimate the costs for</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">  /// the cost of a scalar FP addition. We can only estimate the costs for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline">  /// fixed-width vectors here because for scalable vectors we do not know the</td>
    <td class="lineNumber">2335</td>
    <td class="codeline">  /// fixed-width vectors here because for scalable vectors we do not know the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">  /// runtime number of operations.</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">  /// runtime number of operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">  InstructionCost getOrderedReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">  InstructionCost getOrderedReductionCost(unsigned Opcode, VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">                                          TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">                                          TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">    // Targets must implement a default value for the scalable case, since</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">    // Targets must implement a default value for the scalable case, since</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">    // we don't know how many lanes the vector has.</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">    // we don't know how many lanes the vector has.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">    if (isa<ScalableVectorType>(Ty))</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">    if (isa<ScalableVectorType>(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">2342</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline"></td>
    <td class="lineNumber">2343</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline">    auto *VTy = cast<FixedVectorType>(Ty);</td>
    <td class="lineNumber">2344</td>
    <td class="codeline">    auto *VTy = cast<FixedVectorType>(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">    InstructionCost ExtractCost = getScalarizationOverhead(</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">    InstructionCost ExtractCost = getScalarizationOverhead(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">        VTy, /*Insert=*/false, /*Extract=*/true, CostKind);</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">        VTy, /*Insert=*/false, /*Extract=*/true, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">    InstructionCost ArithCost = thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">2347</td>
    <td class="codeline">    InstructionCost ArithCost = thisT()->getArithmeticInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline">        Opcode, VTy->getElementType(), CostKind);</td>
    <td class="lineNumber">2348</td>
    <td class="codeline">        Opcode, VTy->getElementType(), CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">    ArithCost *= VTy->getNumElements();</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">    ArithCost *= VTy->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline"></td>
    <td class="lineNumber">2350</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">    return ExtractCost + ArithCost;</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">    return ExtractCost + ArithCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2352</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline"></td>
    <td class="lineNumber">2353</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">  InstructionCost getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">  InstructionCost getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">                                             std::optional<FastMathFlags> FMF,</td>
    <td class="lineNumber">2355</td>
    <td class="codeline">                                             std::optional<FastMathFlags> FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">                                             TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">                                             TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline">    assert(Ty && "Unknown reduction vector type");</td>
    <td class="lineNumber">2357</td>
    <td class="codeline">    assert(Ty && "Unknown reduction vector type");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline">    if (TTI::requiresOrderedReduction(FMF))</td>
    <td class="lineNumber">2358</td>
    <td class="codeline">    if (TTI::requiresOrderedReduction(FMF))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline">      return getOrderedReductionCost(Opcode, Ty, CostKind);</td>
    <td class="lineNumber">2359</td>
    <td class="codeline">      return getOrderedReductionCost(Opcode, Ty, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">    return getTreeReductionCost(Opcode, Ty, CostKind);</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">    return getTreeReductionCost(Opcode, Ty, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2361</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline"></td>
    <td class="lineNumber">2362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">  /// Try to calculate op costs for min/max reduction operations.</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">  /// Try to calculate op costs for min/max reduction operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline">  /// \param CondTy Conditional type for the Select instruction.</td>
    <td class="lineNumber">2364</td>
    <td class="codeline">  /// \param CondTy Conditional type for the Select instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">  InstructionCost getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty,</td>
    <td class="lineNumber">2365</td>
    <td class="codeline">  InstructionCost getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline">                                         FastMathFlags FMF,</td>
    <td class="lineNumber">2366</td>
    <td class="codeline">                                         FastMathFlags FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline">                                         TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">2367</td>
    <td class="codeline">                                         TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">    // Targets must implement a default value for the scalable case, since</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">    // Targets must implement a default value for the scalable case, since</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">    // we don't know how many lanes the vector has.</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">    // we don't know how many lanes the vector has.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline">    if (isa<ScalableVectorType>(Ty))</td>
    <td class="lineNumber">2370</td>
    <td class="codeline">    if (isa<ScalableVectorType>(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">      return InstructionCost::getInvalid();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline"></td>
    <td class="lineNumber">2372</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">    Type *ScalarTy = Ty->getElementType();</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">    Type *ScalarTy = Ty->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">    unsigned NumVecElts = cast<FixedVectorType>(Ty)->getNumElements();</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">    unsigned NumVecElts = cast<FixedVectorType>(Ty)->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">    unsigned NumReduxLevels = Log2_32(NumVecElts);</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">    unsigned NumReduxLevels = Log2_32(NumVecElts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline">    InstructionCost MinMaxCost = 0;</td>
    <td class="lineNumber">2376</td>
    <td class="codeline">    InstructionCost MinMaxCost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline">    InstructionCost ShuffleCost = 0;</td>
    <td class="lineNumber">2377</td>
    <td class="codeline">    InstructionCost ShuffleCost = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = thisT()->getTypeLegalizationCost(Ty);</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">    std::pair<InstructionCost, MVT> LT = thisT()->getTypeLegalizationCost(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline">    unsigned LongVectorCount = 0;</td>
    <td class="lineNumber">2379</td>
    <td class="codeline">    unsigned LongVectorCount = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">    unsigned MVTLen =</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">    unsigned MVTLen =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">        LT.second.isVector() ? LT.second.getVectorNumElements() : 1;</td>
    <td class="lineNumber">2381</td>
    <td class="codeline">        LT.second.isVector() ? LT.second.getVectorNumElements() : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">    while (NumVecElts > MVTLen) {</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">    while (NumVecElts > MVTLen) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">      NumVecElts /= 2;</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">      NumVecElts /= 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">      auto *SubTy = FixedVectorType::get(ScalarTy, NumVecElts);</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">      auto *SubTy = FixedVectorType::get(ScalarTy, NumVecElts);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline"></td>
    <td class="lineNumber">2385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">      ShuffleCost +=</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">      ShuffleCost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline">          thisT()->getShuffleCost(TTI::SK_ExtractSubvector, Ty, std::nullopt,</td>
    <td class="lineNumber">2387</td>
    <td class="codeline">          thisT()->getShuffleCost(TTI::SK_ExtractSubvector, Ty, std::nullopt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">                                  CostKind, NumVecElts, SubTy);</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">                                  CostKind, NumVecElts, SubTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline"></td>
    <td class="lineNumber">2389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(IID, SubTy, {SubTy, SubTy}, FMF);</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">      IntrinsicCostAttributes Attrs(IID, SubTy, {SubTy, SubTy}, FMF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">      MinMaxCost += getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">      MinMaxCost += getIntrinsicInstrCost(Attrs, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline">      Ty = SubTy;</td>
    <td class="lineNumber">2392</td>
    <td class="codeline">      Ty = SubTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">      ++LongVectorCount;</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">      ++LongVectorCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline"></td>
    <td class="lineNumber">2395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">    NumReduxLevels -= LongVectorCount;</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">    NumReduxLevels -= LongVectorCount;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline"></td>
    <td class="lineNumber">2397</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline">    // The minimal length of the vector is limited by the real length of vector</td>
    <td class="lineNumber">2398</td>
    <td class="codeline">    // The minimal length of the vector is limited by the real length of vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">    // operations performed on the current platform. That's why several final</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">    // operations performed on the current platform. That's why several final</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline">    // reduction opertions are perfomed on the vectors with the same</td>
    <td class="lineNumber">2400</td>
    <td class="codeline">    // reduction opertions are perfomed on the vectors with the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline">    // architecture-dependent length.</td>
    <td class="lineNumber">2401</td>
    <td class="codeline">    // architecture-dependent length.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline">    ShuffleCost +=</td>
    <td class="lineNumber">2402</td>
    <td class="codeline">    ShuffleCost +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline">        NumReduxLevels * thisT()->getShuffleCost(TTI::SK_PermuteSingleSrc, Ty,</td>
    <td class="lineNumber">2403</td>
    <td class="codeline">        NumReduxLevels * thisT()->getShuffleCost(TTI::SK_PermuteSingleSrc, Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">                                                 std::nullopt, CostKind, 0, Ty);</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">                                                 std::nullopt, CostKind, 0, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline">    IntrinsicCostAttributes Attrs(IID, Ty, {Ty, Ty}, FMF);</td>
    <td class="lineNumber">2405</td>
    <td class="codeline">    IntrinsicCostAttributes Attrs(IID, Ty, {Ty, Ty}, FMF);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline">    MinMaxCost += NumReduxLevels * getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">2406</td>
    <td class="codeline">    MinMaxCost += NumReduxLevels * getIntrinsicInstrCost(Attrs, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">    // The last min/max should be in vector registers and we counted it above.</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">    // The last min/max should be in vector registers and we counted it above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline">    // So just need a single extractelement.</td>
    <td class="lineNumber">2408</td>
    <td class="codeline">    // So just need a single extractelement.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">    return ShuffleCost + MinMaxCost +</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">    return ShuffleCost + MinMaxCost +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline">           thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
    <td class="lineNumber">2410</td>
    <td class="codeline">           thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline">                                       CostKind, 0, nullptr, nullptr);</td>
    <td class="lineNumber">2411</td>
    <td class="codeline">                                       CostKind, 0, nullptr, nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2412</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline"></td>
    <td class="lineNumber">2413</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">  InstructionCost getExtendedReductionCost(unsigned Opcode, bool IsUnsigned,</td>
    <td class="lineNumber">2414</td>
    <td class="codeline">  InstructionCost getExtendedReductionCost(unsigned Opcode, bool IsUnsigned,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">                                           Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">                                           Type *ResTy, VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline">                                           FastMathFlags FMF,</td>
    <td class="lineNumber">2416</td>
    <td class="codeline">                                           FastMathFlags FMF,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">2417</td>
    <td class="codeline">                                           TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">    // Without any native support, this is equivalent to the cost of</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">    // Without any native support, this is equivalent to the cost of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline">    // vecreduce.opcode(ext(Ty A)).</td>
    <td class="lineNumber">2419</td>
    <td class="codeline">    // vecreduce.opcode(ext(Ty A)).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline">    VectorType *ExtTy = VectorType::get(ResTy, Ty);</td>
    <td class="lineNumber">2420</td>
    <td class="codeline">    VectorType *ExtTy = VectorType::get(ResTy, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">    InstructionCost RedCost =</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">    InstructionCost RedCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline">        thisT()->getArithmeticReductionCost(Opcode, ExtTy, FMF, CostKind);</td>
    <td class="lineNumber">2422</td>
    <td class="codeline">        thisT()->getArithmeticReductionCost(Opcode, ExtTy, FMF, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline">    InstructionCost ExtCost = thisT()->getCastInstrCost(</td>
    <td class="lineNumber">2423</td>
    <td class="codeline">    InstructionCost ExtCost = thisT()->getCastInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">        IsUnsigned ? Instruction::ZExt : Instruction::SExt, ExtTy, Ty,</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">        IsUnsigned ? Instruction::ZExt : Instruction::SExt, ExtTy, Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">        TTI::CastContextHint::None, CostKind);</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">        TTI::CastContextHint::None, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline"></td>
    <td class="lineNumber">2426</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline">    return RedCost + ExtCost;</td>
    <td class="lineNumber">2427</td>
    <td class="codeline">    return RedCost + ExtCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2428</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline"></td>
    <td class="lineNumber">2429</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline">  InstructionCost getMulAccReductionCost(bool IsUnsigned, Type *ResTy,</td>
    <td class="lineNumber">2430</td>
    <td class="codeline">  InstructionCost getMulAccReductionCost(bool IsUnsigned, Type *ResTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline">                                         VectorType *Ty,</td>
    <td class="lineNumber">2431</td>
    <td class="codeline">                                         VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">                                         TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">                                         TTI::TargetCostKind CostKind) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">    // Without any native support, this is equivalent to the cost of</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">    // Without any native support, this is equivalent to the cost of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline">    // vecreduce.add(mul(ext(Ty A), ext(Ty B))) or</td>
    <td class="lineNumber">2434</td>
    <td class="codeline">    // vecreduce.add(mul(ext(Ty A), ext(Ty B))) or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">    // vecreduce.add(mul(A, B)).</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">    // vecreduce.add(mul(A, B)).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline">    VectorType *ExtTy = VectorType::get(ResTy, Ty);</td>
    <td class="lineNumber">2436</td>
    <td class="codeline">    VectorType *ExtTy = VectorType::get(ResTy, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline">    InstructionCost RedCost = thisT()->getArithmeticReductionCost(</td>
    <td class="lineNumber">2437</td>
    <td class="codeline">    InstructionCost RedCost = thisT()->getArithmeticReductionCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">        Instruction::Add, ExtTy, std::nullopt, CostKind);</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">        Instruction::Add, ExtTy, std::nullopt, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">    InstructionCost ExtCost = thisT()->getCastInstrCost(</td>
    <td class="lineNumber">2439</td>
    <td class="codeline">    InstructionCost ExtCost = thisT()->getCastInstrCost(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline">        IsUnsigned ? Instruction::ZExt : Instruction::SExt, ExtTy, Ty,</td>
    <td class="lineNumber">2440</td>
    <td class="codeline">        IsUnsigned ? Instruction::ZExt : Instruction::SExt, ExtTy, Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">        TTI::CastContextHint::None, CostKind);</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">        TTI::CastContextHint::None, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline"></td>
    <td class="lineNumber">2442</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline">    InstructionCost MulCost =</td>
    <td class="lineNumber">2443</td>
    <td class="codeline">    InstructionCost MulCost =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">        thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">        thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline"></td>
    <td class="lineNumber">2445</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">    return RedCost + MulCost + 2 * ExtCost;</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">    return RedCost + MulCost + 2 * ExtCost;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline"></td>
    <td class="lineNumber">2448</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline">  InstructionCost getVectorSplitCost() { return 1; }</td>
    <td class="lineNumber">2449</td>
    <td class="codeline">  InstructionCost getVectorSplitCost() { return 1; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline"></td>
    <td class="lineNumber">2450</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">  /// @}</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">  /// @}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2452</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline"></td>
    <td class="lineNumber">2453</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">/// Concrete BasicTTIImpl that can be used if no further customization</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">/// Concrete BasicTTIImpl that can be used if no further customization</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">/// is needed.</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">/// is needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline">class BasicTTIImpl : public BasicTTIImplBase<BasicTTIImpl> {</td>
    <td class="lineNumber">2456</td>
    <td class="codeline">class BasicTTIImpl : public BasicTTIImplBase<BasicTTIImpl> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">  using BaseT = BasicTTIImplBase<BasicTTIImpl>;</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">  using BaseT = BasicTTIImplBase<BasicTTIImpl>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline"></td>
    <td class="lineNumber">2458</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline">  friend class BasicTTIImplBase<BasicTTIImpl>;</td>
    <td class="lineNumber">2459</td>
    <td class="codeline">  friend class BasicTTIImplBase<BasicTTIImpl>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline"></td>
    <td class="lineNumber">2460</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline">  const TargetSubtargetInfo *ST;</td>
    <td class="lineNumber">2461</td>
    <td class="codeline">  const TargetSubtargetInfo *ST;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline">  const TargetLoweringBase *TLI;</td>
    <td class="lineNumber">2462</td>
    <td class="codeline">  const TargetLoweringBase *TLI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline"></td>
    <td class="lineNumber">2463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">  const TargetSubtargetInfo *getST() const { return ST; }</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">  const TargetSubtargetInfo *getST() const { return ST; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">  const TargetLoweringBase *getTLI() const { return TLI; }</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">  const TargetLoweringBase *getTLI() const { return TLI; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline"></td>
    <td class="lineNumber">2466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2467</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">  explicit BasicTTIImpl(const TargetMachine *TM, const Function &F);</td>
    <td class="lineNumber">2468</td>
    <td class="codeline">  explicit BasicTTIImpl(const TargetMachine *TM, const Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline"></td>
    <td class="lineNumber">2470</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">2471</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline"></td>
    <td class="lineNumber">2472</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline">#endif // LLVM_CODEGEN_BASICTTIIMPL_H</td>
    <td class="lineNumber">2473</td>
    <td class="codeline">#endif // LLVM_CODEGEN_BASICTTIIMPL_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline"></td>
    <td class="lineNumber">2474</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- BasicTTIImpl.h -------------------------------------------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- BasicTTIImpl.h -------------------------------------------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">/// This file provides a helper that implements much of the TTI interface in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">/// This file provides a helper that implements much of the TTI interface in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">/// terms of the target-independent code generator and TargetLowering</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">/// terms of the target-independent code generator and TargetLowering</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">/// interfaces.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">/// interfaces.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#ifndef LLVM_CODEGEN_BASICTTIIMPL_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#ifndef LLVM_CODEGEN_BASICTTIIMPL_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#define LLVM_CODEGEN_BASICTTIIMPL_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#define LLVM_CODEGEN_BASICTTIIMPL_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/ADT/BitVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Analysis/LoopInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/Analysis/LoopInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Analysis/OptimizationRemarkEmitter.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Analysis/TargetTransformInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Analysis/TargetTransformInfoImpl.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/Analysis/TargetTransformInfoImpl.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/CodeGen/ISDOpcodes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/CodeGen/ISDOpcodes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineValueType.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineValueType.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/CodeGen/ValueTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/IR/Intrinsics.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/IR/Intrinsics.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/Support/MathExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/Target/TargetOptions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/Target/TargetOptions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">#include <limits></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">#include <limits></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">class Function;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">class Function;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">class GlobalValue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">class GlobalValue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">class LLVMContext;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">class LLVMContext;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">class ScalarEvolution;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">class ScalarEvolution;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">class SCEV;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">class SCEV;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">class TargetMachine;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">class TargetMachine;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">extern cl::opt<unsigned> PartialUnrollingThreshold;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">extern cl::opt<unsigned> PartialUnrollingThreshold;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">/// Base class which can be used to help build a TTI implementation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">/// Base class which can be used to help build a TTI implementation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">/// This class provides as much implementation of the TTI interface as is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">/// This class provides as much implementation of the TTI interface as is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">/// possible using the target independent parts of the code generator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">/// possible using the target independent parts of the code generator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">/// In order to subclass it, your class must implement a getST() method to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">/// In order to subclass it, your class must implement a getST() method to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">/// return the subtarget, and a getTLI() method to return the target lowering.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">/// return the subtarget, and a getTLI() method to return the target lowering.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">/// We need these methods implemented in the derived class so that this class</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">/// We need these methods implemented in the derived class so that this class</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">/// doesn't have to duplicate storage for them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">/// doesn't have to duplicate storage for them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">class BasicTTIImplBase : public TargetTransformInfoImplCRTPBase<T> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">class BasicTTIImplBase : public TargetTransformInfoImplCRTPBase<T> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">  using BaseT = TargetTransformInfoImplCRTPBase<T>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">  using BaseT = TargetTransformInfoImplCRTPBase<T>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">  using TTI = TargetTransformInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">  using TTI = TargetTransformInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">  /// Helper function to access this as a T.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">  /// Helper function to access this as a T.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">  T *thisT() { return static_cast<T *>(this); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">  T *thisT() { return static_cast<T *>(this); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">  /// Estimate a cost of Broadcast as an extract and sequence of insert</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">  /// Estimate a cost of Broadcast as an extract and sequence of insert</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">  /// operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">  /// operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">  InstructionCost getBroadcastShuffleOverhead(FixedVectorType *VTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">  InstructionCost getBroadcastShuffleOverhead(FixedVectorType *VTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">                                              TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">                                              TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">    // Broadcast cost is equal to the cost of extracting the zero'th element</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">    // Broadcast cost is equal to the cost of extracting the zero'th element</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">    // plus the cost of inserting it into every element of the result vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">    // plus the cost of inserting it into every element of the result vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">    Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">    Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">                                        CostKind, 0, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">                                        CostKind, 0, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">    for (int i = 0, e = VTy->getNumElements(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">    for (int i = 0, e = VTy->getNumElements(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, VTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, VTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">  /// Estimate a cost of shuffle as a sequence of extract and insert</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">  /// Estimate a cost of shuffle as a sequence of extract and insert</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">  /// operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">  /// operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">  InstructionCost getPermuteShuffleOverhead(FixedVectorType *VTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">  InstructionCost getPermuteShuffleOverhead(FixedVectorType *VTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">                                            TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">                                            TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">    // Shuffle cost is equal to the cost of extracting element from its argument</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">    // Shuffle cost is equal to the cost of extracting element from its argument</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">    // plus the cost of inserting them onto the result vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">    // plus the cost of inserting them onto the result vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">    // e.g. <4 x float> has a mask of <0,5,2,7> i.e we need to extract from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">    // e.g. <4 x float> has a mask of <0,5,2,7> i.e we need to extract from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">    // index 0 of first vector, index 1 of second vector,index 2 of first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">    // index 0 of first vector, index 1 of second vector,index 2 of first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">    // vector and finally index 3 of second vector and insert them at index</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">    // vector and finally index 3 of second vector and insert them at index</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">    // <0,1,2,3> of result vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">    // <0,1,2,3> of result vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">    for (int i = 0, e = VTy->getNumElements(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">    for (int i = 0, e = VTy->getNumElements(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, VTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, VTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">      Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">      Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">  /// Estimate a cost of subvector extraction as a sequence of extract and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">  /// Estimate a cost of subvector extraction as a sequence of extract and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">  /// insert operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">  /// insert operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  InstructionCost getExtractSubvectorOverhead(VectorType *VTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  InstructionCost getExtractSubvectorOverhead(VectorType *VTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">                                              TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">                                              TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">                                              int Index,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">                                              int Index,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">                                              FixedVectorType *SubVTy) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">                                              FixedVectorType *SubVTy) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">    assert(VTy && SubVTy &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">    assert(VTy && SubVTy &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">           "Can only extract subvectors from vectors");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">           "Can only extract subvectors from vectors");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">    int NumSubElts = SubVTy->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">    int NumSubElts = SubVTy->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">    assert((!isa<FixedVectorType>(VTy) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">    assert((!isa<FixedVectorType>(VTy) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">            (Index + NumSubElts) <=</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">            (Index + NumSubElts) <=</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">                (int)cast<FixedVectorType>(VTy)->getNumElements()) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">                (int)cast<FixedVectorType>(VTy)->getNumElements()) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">           "SK_ExtractSubvector index out of range");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">           "SK_ExtractSubvector index out of range");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">    // Subvector extraction cost is equal to the cost of extracting element from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">    // Subvector extraction cost is equal to the cost of extracting element from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">    // the source type plus the cost of inserting them into the result vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">    // the source type plus the cost of inserting them into the result vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">    // type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">    // type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">    for (int i = 0; i != NumSubElts; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">    for (int i = 0; i != NumSubElts; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">          thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">          thisT()->getVectorInstrCost(Instruction::ExtractElement, VTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">                                      CostKind, i + Index, nullptr, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">                                      CostKind, i + Index, nullptr, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, SubVTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">      Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, SubVTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">  /// Estimate a cost of subvector insertion as a sequence of extract and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">  /// Estimate a cost of subvector insertion as a sequence of extract and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">  /// insert operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">  /// insert operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">  InstructionCost getInsertSubvectorOverhead(VectorType *VTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">  InstructionCost getInsertSubvectorOverhead(VectorType *VTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">                                             TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">                                             TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">                                             int Index,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">                                             int Index,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">                                             FixedVectorType *SubVTy) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">                                             FixedVectorType *SubVTy) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">    assert(VTy && SubVTy &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">    assert(VTy && SubVTy &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">           "Can only insert subvectors into vectors");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">           "Can only insert subvectors into vectors");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">    int NumSubElts = SubVTy->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">    int NumSubElts = SubVTy->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">    assert((!isa<FixedVectorType>(VTy) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">    assert((!isa<FixedVectorType>(VTy) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">            (Index + NumSubElts) <=</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">            (Index + NumSubElts) <=</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">                (int)cast<FixedVectorType>(VTy)->getNumElements()) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">                (int)cast<FixedVectorType>(VTy)->getNumElements()) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">           "SK_InsertSubvector index out of range");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">           "SK_InsertSubvector index out of range");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">    // Subvector insertion cost is equal to the cost of extracting element from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">    // Subvector insertion cost is equal to the cost of extracting element from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">    // the source type plus the cost of inserting them into the result vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">    // the source type plus the cost of inserting them into the result vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">    // type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">    // type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">    for (int i = 0; i != NumSubElts; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">    for (int i = 0; i != NumSubElts; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">      Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, SubVTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">      Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, SubVTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">                                          CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">          thisT()->getVectorInstrCost(Instruction::InsertElement, VTy, CostKind,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">          thisT()->getVectorInstrCost(Instruction::InsertElement, VTy, CostKind,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">                                      i + Index, nullptr, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">                                      i + Index, nullptr, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">  /// Local query method delegates up to T which *must* implement this!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">  /// Local query method delegates up to T which *must* implement this!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">  const TargetSubtargetInfo *getST() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">  const TargetSubtargetInfo *getST() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">    return static_cast<const T *>(this)->getST();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">    return static_cast<const T *>(this)->getST();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">  /// Local query method delegates up to T which *must* implement this!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">  /// Local query method delegates up to T which *must* implement this!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">  const TargetLoweringBase *getTLI() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">  const TargetLoweringBase *getTLI() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">    return static_cast<const T *>(this)->getTLI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">    return static_cast<const T *>(this)->getTLI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">  static ISD::MemIndexedMode getISDIndexedMode(TTI::MemIndexedMode M) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">  static ISD::MemIndexedMode getISDIndexedMode(TTI::MemIndexedMode M) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">    switch (M) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">    switch (M) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">      case TTI::MIM_Unindexed:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">      case TTI::MIM_Unindexed:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">        return ISD::UNINDEXED;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">        return ISD::UNINDEXED;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">      case TTI::MIM_PreInc:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">      case TTI::MIM_PreInc:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">        return ISD::PRE_INC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">        return ISD::PRE_INC;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">      case TTI::MIM_PreDec:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">      case TTI::MIM_PreDec:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">        return ISD::PRE_DEC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">        return ISD::PRE_DEC;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">      case TTI::MIM_PostInc:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">      case TTI::MIM_PostInc:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">        return ISD::POST_INC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">        return ISD::POST_INC;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">      case TTI::MIM_PostDec:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">      case TTI::MIM_PostDec:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">        return ISD::POST_DEC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">        return ISD::POST_DEC;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">    llvm_unreachable("Unexpected MemIndexedMode");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">    llvm_unreachable("Unexpected MemIndexedMode");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">  InstructionCost getCommonMaskedMemoryOpCost(unsigned Opcode, Type *DataTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">  InstructionCost getCommonMaskedMemoryOpCost(unsigned Opcode, Type *DataTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">                                              Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">                                              Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">                                              bool VariableMask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">                                              bool VariableMask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">                                              bool IsGatherScatter,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">                                              bool IsGatherScatter,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">                                              TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">                                              TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">    // We cannot scalarize scalable vectors, so return Invalid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">    // We cannot scalarize scalable vectors, so return Invalid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(DataTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(DataTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">    auto *VT = cast<FixedVectorType>(DataTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">    auto *VT = cast<FixedVectorType>(DataTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">    // Assume the target does not have support for gather/scatter operations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">    // Assume the target does not have support for gather/scatter operations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">    // and provide a rough estimate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">    // and provide a rough estimate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">    // First, compute the cost of the individual memory operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">    // First, compute the cost of the individual memory operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">    InstructionCost AddrExtractCost =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">    InstructionCost AddrExtractCost =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">        IsGatherScatter</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">        IsGatherScatter</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">            ? getVectorInstrCost(Instruction::ExtractElement,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">            ? getVectorInstrCost(Instruction::ExtractElement,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">                                 FixedVectorType::get(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">                                 FixedVectorType::get(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">                                     PointerType::get(VT->getElementType(), 0),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">                                     PointerType::get(VT->getElementType(), 0),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">                                     VT->getNumElements()),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">                                     VT->getNumElements()),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">                                 CostKind, -1, nullptr, nullptr)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">                                 CostKind, -1, nullptr, nullptr)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">            : 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">            : 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">    InstructionCost LoadCost =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">    InstructionCost LoadCost =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">        VT->getNumElements() *</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">        VT->getNumElements() *</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">        (AddrExtractCost +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">        (AddrExtractCost +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">         getMemoryOpCost(Opcode, VT->getElementType(), Alignment, 0, CostKind));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">         getMemoryOpCost(Opcode, VT->getElementType(), Alignment, 0, CostKind));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">    // Next, compute the cost of packing the result in a vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">    // Next, compute the cost of packing the result in a vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">    InstructionCost PackingCost =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">    InstructionCost PackingCost =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">        getScalarizationOverhead(VT, Opcode != Instruction::Store,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">        getScalarizationOverhead(VT, Opcode != Instruction::Store,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">                                 Opcode == Instruction::Store, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">                                 Opcode == Instruction::Store, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">    InstructionCost ConditionalCost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">    InstructionCost ConditionalCost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">    if (VariableMask) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">    if (VariableMask) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">      // Compute the cost of conditionally executing the memory operations with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">      // Compute the cost of conditionally executing the memory operations with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">      // variable masks. This includes extracting the individual conditions, a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">      // variable masks. This includes extracting the individual conditions, a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">      // branches and PHIs to combine the results.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">      // branches and PHIs to combine the results.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">      // NOTE: Estimating the cost of conditionally executing the memory</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">      // NOTE: Estimating the cost of conditionally executing the memory</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">      // operations accurately is quite difficult and the current solution</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">      // operations accurately is quite difficult and the current solution</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">      // provides a very rough estimate only.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">      // provides a very rough estimate only.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">      ConditionalCost =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">      ConditionalCost =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">          VT->getNumElements() *</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">          VT->getNumElements() *</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">          (getVectorInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">          (getVectorInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">               Instruction::ExtractElement,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">               Instruction::ExtractElement,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">               FixedVectorType::get(Type::getInt1Ty(DataTy->getContext()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">               FixedVectorType::get(Type::getInt1Ty(DataTy->getContext()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">                                    VT->getNumElements()),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">                                    VT->getNumElements()),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">               CostKind, -1, nullptr, nullptr) +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">               CostKind, -1, nullptr, nullptr) +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">           getCFInstrCost(Instruction::Br, CostKind) +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">           getCFInstrCost(Instruction::Br, CostKind) +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">           getCFInstrCost(Instruction::PHI, CostKind));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">           getCFInstrCost(Instruction::PHI, CostKind));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">    return LoadCost + PackingCost + ConditionalCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">    return LoadCost + PackingCost + ConditionalCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine coveredLine">  explicit BasicTTIImplBase(const TargetMachine *TM, const DataLayout &DL)</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">262</td>
    <td class="codeLine coveredLine">  explicit BasicTTIImplBase(const TargetMachine *TM, const DataLayout &DL)</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine coveredLine">      : BaseT(DL) {}</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">263</td>
    <td class="codeLine coveredLine">      : BaseT(DL) {}</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine coveredLine">  virtual ~BasicTTIImplBase() = default;</td>
    <td class="lineNumber">27</td>
    <td class="lineNumber">264</td>
    <td class="codeLine coveredLine">  virtual ~BasicTTIImplBase() = default;</td>
    <td class="lineNumber">27</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">  using TargetTransformInfoImplBase::DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">  using TargetTransformInfoImplBase::DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  /// \name Scalar TTI Implementations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  /// \name Scalar TTI Implementations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  bool allowsMisalignedMemoryAccesses(LLVMContext &Context, unsigned BitWidth,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">                                      unsigned AddressSpace, Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">                                      unsigned AddressSpace, Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">                                      unsigned *Fast) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">                                      unsigned *Fast) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">    EVT E = EVT::getIntegerVT(Context, BitWidth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">    EVT E = EVT::getIntegerVT(Context, BitWidth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">    return getTLI()->allowsMisalignedMemoryAccesses(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">    return getTLI()->allowsMisalignedMemoryAccesses(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">        E, AddressSpace, Alignment, MachineMemOperand::MONone, Fast);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">        E, AddressSpace, Alignment, MachineMemOperand::MONone, Fast);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine coveredLine">  bool hasBranchDivergence(const Function *F = nullptr) { return false; }</td>
    <td class="lineNumber">21</td>
    <td class="lineNumber">279</td>
    <td class="codeLine coveredLine">  bool hasBranchDivergence(const Function *F = nullptr) { return false; }</td>
    <td class="lineNumber">21</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">  bool isSourceOfDivergence(const Value *V) { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">  bool isSourceOfDivergence(const Value *V) { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">  bool isAlwaysUniform(const Value *V) { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">  bool isAlwaysUniform(const Value *V) { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  bool isValidAddrSpaceCast(unsigned FromAS, unsigned ToAS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">  bool addrspacesMayAlias(unsigned AS0, unsigned AS1) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  unsigned getFlatAddressSpace() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  unsigned getFlatAddressSpace() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">    // Return an invalid address space.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">    // Return an invalid address space.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">    return -1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">    return -1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">  bool collectFlatAddressOperands(SmallVectorImpl<int> &OpIndexes,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">                                  Intrinsic::ID IID) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">                                  Intrinsic::ID IID) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">  bool isNoopAddrSpaceCast(unsigned FromAS, unsigned ToAS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">    return getTLI()->getTargetMachine().isNoopAddrSpaceCast(FromAS, ToAS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">    return getTLI()->getTargetMachine().isNoopAddrSpaceCast(FromAS, ToAS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">  unsigned getAssumedAddrSpace(const Value *V) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">  unsigned getAssumedAddrSpace(const Value *V) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">    return getTLI()->getTargetMachine().getAssumedAddrSpace(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">    return getTLI()->getTargetMachine().getAssumedAddrSpace(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">  bool isSingleThreaded() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">  bool isSingleThreaded() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">    return getTLI()->getTargetMachine().Options.ThreadModel ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">    return getTLI()->getTargetMachine().Options.ThreadModel ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">           ThreadModel::Single;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">           ThreadModel::Single;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">  std::pair<const Value *, unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">  std::pair<const Value *, unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">  getPredicatedAddrSpace(const Value *V) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">  getPredicatedAddrSpace(const Value *V) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">    return getTLI()->getTargetMachine().getPredicatedAddrSpace(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">    return getTLI()->getTargetMachine().getPredicatedAddrSpace(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">  Value *rewriteIntrinsicWithAddressSpace(IntrinsicInst *II, Value *OldV,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">                                          Value *NewV) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">                                          Value *NewV) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">  bool isLegalAddImmediate(int64_t imm) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">  bool isLegalAddImmediate(int64_t imm) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">    return getTLI()->isLegalAddImmediate(imm);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">    return getTLI()->isLegalAddImmediate(imm);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  bool isLegalICmpImmediate(int64_t imm) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  bool isLegalICmpImmediate(int64_t imm) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">    return getTLI()->isLegalICmpImmediate(imm);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">    return getTLI()->isLegalICmpImmediate(imm);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">  bool isLegalAddressingMode(Type *Ty, GlobalValue *BaseGV, int64_t BaseOffset,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">                             bool HasBaseReg, int64_t Scale,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">                             bool HasBaseReg, int64_t Scale,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">                             unsigned AddrSpace, Instruction *I = nullptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">                             unsigned AddrSpace, Instruction *I = nullptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">    TargetLoweringBase::AddrMode AM;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">    TargetLoweringBase::AddrMode AM;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">    AM.BaseGV = BaseGV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">    AM.BaseGV = BaseGV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">    AM.BaseOffs = BaseOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">    AM.BaseOffs = BaseOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">    AM.HasBaseReg = HasBaseReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">    AM.HasBaseReg = HasBaseReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">    AM.Scale = Scale;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">    AM.Scale = Scale;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">    return getTLI()->isLegalAddressingMode(DL, AM, Ty, AddrSpace, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">    return getTLI()->isLegalAddressingMode(DL, AM, Ty, AddrSpace, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  unsigned getStoreMinimumVF(unsigned VF, Type *ScalarMemTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">                             Type *ScalarValTy) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">                             Type *ScalarValTy) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">    auto &&IsSupportedByTarget = [this, ScalarMemTy, ScalarValTy](unsigned VF) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">    auto &&IsSupportedByTarget = [this, ScalarMemTy, ScalarValTy](unsigned VF) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">      auto *SrcTy = FixedVectorType::get(ScalarMemTy, VF / 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">      auto *SrcTy = FixedVectorType::get(ScalarMemTy, VF / 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">      EVT VT = getTLI()->getValueType(DL, SrcTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">      EVT VT = getTLI()->getValueType(DL, SrcTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">      if (getTLI()->isOperationLegal(ISD::STORE, VT) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">      if (getTLI()->isOperationLegal(ISD::STORE, VT) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">          getTLI()->isOperationCustom(ISD::STORE, VT))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">          getTLI()->isOperationCustom(ISD::STORE, VT))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">      EVT ValVT =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">      EVT ValVT =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">          getTLI()->getValueType(DL, FixedVectorType::get(ScalarValTy, VF / 2));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">          getTLI()->getValueType(DL, FixedVectorType::get(ScalarValTy, VF / 2));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">      EVT LegalizedVT =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">      EVT LegalizedVT =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">          getTLI()->getTypeToTransformTo(ScalarMemTy->getContext(), VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">          getTLI()->getTypeToTransformTo(ScalarMemTy->getContext(), VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">      return getTLI()->isTruncStoreLegal(LegalizedVT, ValVT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">      return getTLI()->isTruncStoreLegal(LegalizedVT, ValVT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">    while (VF > 2 && IsSupportedByTarget(VF))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">    while (VF > 2 && IsSupportedByTarget(VF))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">      VF /= 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">      VF /= 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">    return VF;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">    return VF;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">  bool isIndexedLoadLegal(TTI::MemIndexedMode M, Type *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">  bool isIndexedLoadLegal(TTI::MemIndexedMode M, Type *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">                          const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">                          const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">    return getTLI()->isIndexedLoadLegal(getISDIndexedMode(M), VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">    return getTLI()->isIndexedLoadLegal(getISDIndexedMode(M), VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">  bool isIndexedStoreLegal(TTI::MemIndexedMode M, Type *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">  bool isIndexedStoreLegal(TTI::MemIndexedMode M, Type *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">                           const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">                           const DataLayout &DL) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">    return getTLI()->isIndexedStoreLegal(getISDIndexedMode(M), VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">    return getTLI()->isIndexedStoreLegal(getISDIndexedMode(M), VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">  bool isLSRCostLess(TTI::LSRCost C1, TTI::LSRCost C2) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">  bool isLSRCostLess(TTI::LSRCost C1, TTI::LSRCost C2) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">    return TargetTransformInfoImplBase::isLSRCostLess(C1, C2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">    return TargetTransformInfoImplBase::isLSRCostLess(C1, C2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">  bool isNumRegsMajorCostOfLSR() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">  bool isNumRegsMajorCostOfLSR() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">    return TargetTransformInfoImplBase::isNumRegsMajorCostOfLSR();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">    return TargetTransformInfoImplBase::isNumRegsMajorCostOfLSR();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">  bool isProfitableLSRChainElement(Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">  bool isProfitableLSRChainElement(Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">    return TargetTransformInfoImplBase::isProfitableLSRChainElement(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">    return TargetTransformInfoImplBase::isProfitableLSRChainElement(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">  InstructionCost getScalingFactorCost(Type *Ty, GlobalValue *BaseGV,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">                                       int64_t BaseOffset, bool HasBaseReg,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">                                       int64_t BaseOffset, bool HasBaseReg,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">                                       int64_t Scale, unsigned AddrSpace) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">                                       int64_t Scale, unsigned AddrSpace) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">    TargetLoweringBase::AddrMode AM;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">    TargetLoweringBase::AddrMode AM;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">    AM.BaseGV = BaseGV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">    AM.BaseGV = BaseGV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">    AM.BaseOffs = BaseOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">    AM.BaseOffs = BaseOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">    AM.HasBaseReg = HasBaseReg;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">    AM.HasBaseReg = HasBaseReg;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">    AM.Scale = Scale;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">    AM.Scale = Scale;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">    if (getTLI()->isLegalAddressingMode(DL, AM, Ty, AddrSpace))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">    if (getTLI()->isLegalAddressingMode(DL, AM, Ty, AddrSpace))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">      return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">      return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">    return -1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">    return -1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">  bool isTruncateFree(Type *Ty1, Type *Ty2) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">  bool isTruncateFree(Type *Ty1, Type *Ty2) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">    return getTLI()->isTruncateFree(Ty1, Ty2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">    return getTLI()->isTruncateFree(Ty1, Ty2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">  bool isProfitableToHoist(Instruction *I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">  bool isProfitableToHoist(Instruction *I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">    return getTLI()->isProfitableToHoist(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">    return getTLI()->isProfitableToHoist(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">  bool useAA() const { return getST()->useAA(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">  bool useAA() const { return getST()->useAA(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  bool isTypeLegal(Type *Ty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  bool isTypeLegal(Type *Ty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">    EVT VT = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">    return getTLI()->isTypeLegal(VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">    return getTLI()->isTypeLegal(VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">  unsigned getRegUsageForType(Type *Ty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">  unsigned getRegUsageForType(Type *Ty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">    EVT ETy = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">    EVT ETy = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">    return getTLI()->getNumRegisters(Ty->getContext(), ETy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">    return getTLI()->getNumRegisters(Ty->getContext(), ETy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">  InstructionCost getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  InstructionCost getGEPCost(Type *PointeeType, const Value *Ptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">                             ArrayRef<const Value *> Operands, Type *AccessType,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">                             ArrayRef<const Value *> Operands, Type *AccessType,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">                             TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">                             TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">    return BaseT::getGEPCost(PointeeType, Ptr, Operands, AccessType, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">    return BaseT::getGEPCost(PointeeType, Ptr, Operands, AccessType, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  unsigned getEstimatedNumberOfCaseClusters(const SwitchInst &SI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">                                            unsigned &JumpTableSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">                                            unsigned &JumpTableSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">                                            ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">                                            ProfileSummaryInfo *PSI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">                                            BlockFrequencyInfo *BFI) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">                                            BlockFrequencyInfo *BFI) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">    /// Try to find the estimated number of clusters. Note that the number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">    /// Try to find the estimated number of clusters. Note that the number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">    /// clusters identified in this function could be different from the actual</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">    /// clusters identified in this function could be different from the actual</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">    /// numbers found in lowering. This function ignore switches that are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">    /// numbers found in lowering. This function ignore switches that are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">    /// lowered with a mix of jump table / bit test / BTree. This function was</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">    /// lowered with a mix of jump table / bit test / BTree. This function was</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">    /// initially intended to be used when estimating the cost of switch in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">    /// initially intended to be used when estimating the cost of switch in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">    /// inline cost heuristic, but it's a generic cost model to be used in other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">    /// inline cost heuristic, but it's a generic cost model to be used in other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">    /// places (e.g., in loop unrolling).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">    /// places (e.g., in loop unrolling).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">    unsigned N = SI.getNumCases();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">    unsigned N = SI.getNumCases();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">    const DataLayout &DL = this->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">    const DataLayout &DL = this->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">    JumpTableSize = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">    JumpTableSize = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">    bool IsJTAllowed = TLI->areJTsAllowed(SI.getParent()->getParent());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">    bool IsJTAllowed = TLI->areJTsAllowed(SI.getParent()->getParent());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">    // Early exit if both a jump table and bit test are not allowed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">    // Early exit if both a jump table and bit test are not allowed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">    if (N < 1 || (!IsJTAllowed && DL.getIndexSizeInBits(0u) < N))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">    if (N < 1 || (!IsJTAllowed && DL.getIndexSizeInBits(0u) < N))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">      return N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">      return N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">    APInt MaxCaseVal = SI.case_begin()->getCaseValue()->getValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">    APInt MaxCaseVal = SI.case_begin()->getCaseValue()->getValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">    APInt MinCaseVal = MaxCaseVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">    APInt MinCaseVal = MaxCaseVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">    for (auto CI : SI.cases()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">    for (auto CI : SI.cases()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">      const APInt &CaseVal = CI.getCaseValue()->getValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">      const APInt &CaseVal = CI.getCaseValue()->getValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">      if (CaseVal.sgt(MaxCaseVal))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">      if (CaseVal.sgt(MaxCaseVal))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">        MaxCaseVal = CaseVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">        MaxCaseVal = CaseVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">      if (CaseVal.slt(MinCaseVal))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">      if (CaseVal.slt(MinCaseVal))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">        MinCaseVal = CaseVal;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">        MinCaseVal = CaseVal;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">    // Check if suitable for a bit test</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">    // Check if suitable for a bit test</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">    if (N <= DL.getIndexSizeInBits(0u)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">    if (N <= DL.getIndexSizeInBits(0u)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">      SmallPtrSet<const BasicBlock *, 4> Dests;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">      SmallPtrSet<const BasicBlock *, 4> Dests;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">      for (auto I : SI.cases())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">      for (auto I : SI.cases())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">        Dests.insert(I.getCaseSuccessor());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">        Dests.insert(I.getCaseSuccessor());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">      if (TLI->isSuitableForBitTests(Dests.size(), N, MinCaseVal, MaxCaseVal,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">      if (TLI->isSuitableForBitTests(Dests.size(), N, MinCaseVal, MaxCaseVal,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">                                     DL))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">                                     DL))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">        return 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">        return 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">    // Check if suitable for a jump table.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">    // Check if suitable for a jump table.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">    if (IsJTAllowed) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">    if (IsJTAllowed) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">      if (N < 2 || N < TLI->getMinimumJumpTableEntries())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">      if (N < 2 || N < TLI->getMinimumJumpTableEntries())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">        return N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">        return N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">      uint64_t Range =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">      uint64_t Range =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">          (MaxCaseVal - MinCaseVal)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">          (MaxCaseVal - MinCaseVal)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">              .getLimitedValue(std::numeric_limits<uint64_t>::max() - 1) + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">              .getLimitedValue(std::numeric_limits<uint64_t>::max() - 1) + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">      // Check whether a range of clusters is dense enough for a jump table</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">      // Check whether a range of clusters is dense enough for a jump table</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">      if (TLI->isSuitableForJumpTable(&SI, N, Range, PSI, BFI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">      if (TLI->isSuitableForJumpTable(&SI, N, Range, PSI, BFI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">        JumpTableSize = Range;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">        JumpTableSize = Range;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">        return 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">        return 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">    return N;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">    return N;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">  bool shouldBuildLookupTables() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">  bool shouldBuildLookupTables() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">    return TLI->isOperationLegalOrCustom(ISD::BR_JT, MVT::Other) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">    return TLI->isOperationLegalOrCustom(ISD::BR_JT, MVT::Other) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">           TLI->isOperationLegalOrCustom(ISD::BRIND, MVT::Other);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">           TLI->isOperationLegalOrCustom(ISD::BRIND, MVT::Other);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  bool shouldBuildRelLookupTables() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  bool shouldBuildRelLookupTables() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">    const TargetMachine &TM = getTLI()->getTargetMachine();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">    const TargetMachine &TM = getTLI()->getTargetMachine();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">    // If non-PIC mode, do not generate a relative lookup table.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">    // If non-PIC mode, do not generate a relative lookup table.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">    if (!TM.isPositionIndependent())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">    if (!TM.isPositionIndependent())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">    /// Relative lookup table entries consist of 32-bit offsets.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">    /// Relative lookup table entries consist of 32-bit offsets.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">    /// Do not generate relative lookup tables for large code models</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">    /// Do not generate relative lookup tables for large code models</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">    /// in 64-bit achitectures where 32-bit offsets might not be enough.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">    /// in 64-bit achitectures where 32-bit offsets might not be enough.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">    if (TM.getCodeModel() == CodeModel::Medium ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">    if (TM.getCodeModel() == CodeModel::Medium ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">        TM.getCodeModel() == CodeModel::Large)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">        TM.getCodeModel() == CodeModel::Large)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">    Triple TargetTriple = TM.getTargetTriple();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">    Triple TargetTriple = TM.getTargetTriple();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">    if (!TargetTriple.isArch64Bit())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">    if (!TargetTriple.isArch64Bit())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">    // TODO: Triggers issues on aarch64 on darwin, so temporarily disable it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">    // TODO: Triggers issues on aarch64 on darwin, so temporarily disable it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">    // there.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">    // there.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">    if (TargetTriple.getArch() == Triple::aarch64 && TargetTriple.isOSDarwin())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">    if (TargetTriple.getArch() == Triple::aarch64 && TargetTriple.isOSDarwin())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">  bool haveFastSqrt(Type *Ty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">  bool haveFastSqrt(Type *Ty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">    EVT VT = TLI->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">    EVT VT = TLI->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">    return TLI->isTypeLegal(VT) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">    return TLI->isTypeLegal(VT) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">           TLI->isOperationLegalOrCustom(ISD::FSQRT, VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">           TLI->isOperationLegalOrCustom(ISD::FSQRT, VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  bool isFCmpOrdCheaperThanFCmpZero(Type *Ty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">  InstructionCost getFPOpCost(Type *Ty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">  InstructionCost getFPOpCost(Type *Ty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">    // Check whether FADD is available, as a proxy for floating-point in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">    // Check whether FADD is available, as a proxy for floating-point in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">    // general.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">    // general.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">    EVT VT = TLI->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">    EVT VT = TLI->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">    if (TLI->isOperationLegalOrCustomOrPromote(ISD::FADD, VT))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">    if (TLI->isOperationLegalOrCustomOrPromote(ISD::FADD, VT))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">      return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">      return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">    return TargetTransformInfo::TCC_Expensive;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">    return TargetTransformInfo::TCC_Expensive;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  unsigned getInliningThresholdMultiplier() const { return 1; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  unsigned getInliningThresholdMultiplier() const { return 1; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">  unsigned adjustInliningThreshold(const CallBase *CB) { return 0; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">  unsigned adjustInliningThreshold(const CallBase *CB) { return 0; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  unsigned getCallerAllocaCost(const CallBase *CB, const AllocaInst *AI) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  unsigned getCallerAllocaCost(const CallBase *CB, const AllocaInst *AI) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">  int getInlinerVectorBonusPercent() const { return 150; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">  int getInlinerVectorBonusPercent() const { return 150; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">  void getUnrollingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">  void getUnrollingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">                               TTI::UnrollingPreferences &UP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">                               TTI::UnrollingPreferences &UP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">                               OptimizationRemarkEmitter *ORE) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">                               OptimizationRemarkEmitter *ORE) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">    // This unrolling functionality is target independent, but to provide some</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">    // This unrolling functionality is target independent, but to provide some</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">    // motivation for its intended use, for x86:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">    // motivation for its intended use, for x86:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">    // According to the Intel 64 and IA-32 Architectures Optimization Reference</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">    // According to the Intel 64 and IA-32 Architectures Optimization Reference</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">    // Manual, Intel Core models and later have a loop stream detector (and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">    // Manual, Intel Core models and later have a loop stream detector (and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">    // associated uop queue) that can benefit from partial unrolling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">    // associated uop queue) that can benefit from partial unrolling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">    // The relevant requirements are:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">    // The relevant requirements are:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">    //  - The loop must have no more than 4 (8 for Nehalem and later) branches</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">    //  - The loop must have no more than 4 (8 for Nehalem and later) branches</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">    //    taken, and none of them may be calls.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">    //    taken, and none of them may be calls.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">    //  - The loop can have no more than 18 (28 for Nehalem and later) uops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">    //  - The loop can have no more than 18 (28 for Nehalem and later) uops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">    // According to the Software Optimization Guide for AMD Family 15h</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">    // According to the Software Optimization Guide for AMD Family 15h</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">    // Processors, models 30h-4fh (Steamroller and later) have a loop predictor</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">    // Processors, models 30h-4fh (Steamroller and later) have a loop predictor</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">    // and loop buffer which can benefit from partial unrolling.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">    // and loop buffer which can benefit from partial unrolling.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">    // The relevant requirements are:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">    // The relevant requirements are:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">    //  - The loop must have fewer than 16 branches</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">    //  - The loop must have fewer than 16 branches</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">    //  - The loop must have less than 40 uops in all executed loop branches</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">    //  - The loop must have less than 40 uops in all executed loop branches</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">    // The number of taken branches in a loop is hard to estimate here, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">    // The number of taken branches in a loop is hard to estimate here, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">    // benchmarking has revealed that it is better not to be conservative when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">    // benchmarking has revealed that it is better not to be conservative when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">    // estimating the branch count. As a result, we'll ignore the branch limits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">    // estimating the branch count. As a result, we'll ignore the branch limits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">    // until someone finds a case where it matters in practice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">    // until someone finds a case where it matters in practice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">    unsigned MaxOps;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">    unsigned MaxOps;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">    const TargetSubtargetInfo *ST = getST();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">    const TargetSubtargetInfo *ST = getST();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">    if (PartialUnrollingThreshold.getNumOccurrences() > 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">    if (PartialUnrollingThreshold.getNumOccurrences() > 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">      MaxOps = PartialUnrollingThreshold;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">      MaxOps = PartialUnrollingThreshold;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">    else if (ST->getSchedModel().LoopMicroOpBufferSize > 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">    else if (ST->getSchedModel().LoopMicroOpBufferSize > 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">      MaxOps = ST->getSchedModel().LoopMicroOpBufferSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">      MaxOps = ST->getSchedModel().LoopMicroOpBufferSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">    // Scan the loop: don't unroll loops with calls.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">    // Scan the loop: don't unroll loops with calls.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">    for (BasicBlock *BB : L->blocks()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">    for (BasicBlock *BB : L->blocks()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">      for (Instruction &I : *BB) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">      for (Instruction &I : *BB) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">        if (isa<CallInst>(I) || isa<InvokeInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">        if (isa<CallInst>(I) || isa<InvokeInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">          if (const Function *F = cast<CallBase>(I).getCalledFunction()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">          if (const Function *F = cast<CallBase>(I).getCalledFunction()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">            if (!thisT()->isLoweredToCall(F))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">            if (!thisT()->isLoweredToCall(F))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">              continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">          if (ORE) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">          if (ORE) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">            ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">            ORE->emit([&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">              return OptimizationRemark("TTI", "DontUnroll", L->getStartLoc(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">              return OptimizationRemark("TTI", "DontUnroll", L->getStartLoc(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">                                        L->getHeader())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">                                        L->getHeader())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">                     << "advising against unrolling the loop because it "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">                     << "advising against unrolling the loop because it "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">                        "contains a "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">                        "contains a "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">                     << ore::NV("Call", &I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">                     << ore::NV("Call", &I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">            });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">            });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">          return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">          return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">    // Enable runtime and partial unrolling up to the specified size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">    // Enable runtime and partial unrolling up to the specified size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">    // Enable using trip count upper bound to unroll loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">    // Enable using trip count upper bound to unroll loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">    UP.Partial = UP.Runtime = UP.UpperBound = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">    UP.Partial = UP.Runtime = UP.UpperBound = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">    UP.PartialThreshold = MaxOps;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">    UP.PartialThreshold = MaxOps;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">    // Avoid unrolling when optimizing for size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">    // Avoid unrolling when optimizing for size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">    UP.OptSizeThreshold = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">    UP.OptSizeThreshold = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">    UP.PartialOptSizeThreshold = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">    UP.PartialOptSizeThreshold = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">    // Set number of instructions optimized when "back edge"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">    // Set number of instructions optimized when "back edge"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">    // becomes "fall through" to default value of 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">    // becomes "fall through" to default value of 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">    UP.BEInsns = 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">    UP.BEInsns = 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">  void getPeelingPreferences(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">                             TTI::PeelingPreferences &PP) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">                             TTI::PeelingPreferences &PP) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">    PP.PeelCount = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">    PP.PeelCount = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">    PP.AllowPeeling = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">    PP.AllowPeeling = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">    PP.AllowLoopNestsPeeling = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">    PP.AllowLoopNestsPeeling = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">    PP.PeelProfiledIterations = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">    PP.PeelProfiledIterations = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">  bool isHardwareLoopProfitable(Loop *L, ScalarEvolution &SE,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">                                AssumptionCache &AC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">                                AssumptionCache &AC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">                                TargetLibraryInfo *LibInfo,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">                                TargetLibraryInfo *LibInfo,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">                                HardwareLoopInfo &HWLoopInfo) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">                                HardwareLoopInfo &HWLoopInfo) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">    return BaseT::isHardwareLoopProfitable(L, SE, AC, LibInfo, HWLoopInfo);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">    return BaseT::isHardwareLoopProfitable(L, SE, AC, LibInfo, HWLoopInfo);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">  bool preferPredicateOverEpilogue(TailFoldingInfo *TFI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">    return BaseT::preferPredicateOverEpilogue(TFI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">    return BaseT::preferPredicateOverEpilogue(TFI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">  TailFoldingStyle</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">  TailFoldingStyle</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">  getPreferredTailFoldingStyle(bool IVUpdateMayOverflow = true) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">    return BaseT::getPreferredTailFoldingStyle(IVUpdateMayOverflow);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">    return BaseT::getPreferredTailFoldingStyle(IVUpdateMayOverflow);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  std::optional<Instruction *> instCombineIntrinsic(InstCombiner &IC,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  std::optional<Instruction *> instCombineIntrinsic(InstCombiner &IC,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">                                               IntrinsicInst &II) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">                                               IntrinsicInst &II) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">    return BaseT::instCombineIntrinsic(IC, II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">    return BaseT::instCombineIntrinsic(IC, II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">  std::optional<Value *></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">  std::optional<Value *></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  simplifyDemandedUseBitsIntrinsic(InstCombiner &IC, IntrinsicInst &II,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">                                   APInt DemandedMask, KnownBits &Known,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">                                   APInt DemandedMask, KnownBits &Known,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">                                   bool &KnownBitsComputed) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">                                   bool &KnownBitsComputed) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">    return BaseT::simplifyDemandedUseBitsIntrinsic(IC, II, DemandedMask, Known,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">    return BaseT::simplifyDemandedUseBitsIntrinsic(IC, II, DemandedMask, Known,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">                                                   KnownBitsComputed);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">                                                   KnownBitsComputed);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  std::optional<Value *> simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">      InstCombiner &IC, IntrinsicInst &II, APInt DemandedElts, APInt &UndefElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">      APInt &UndefElts2, APInt &UndefElts3,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">      APInt &UndefElts2, APInt &UndefElts3,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">      std::function<void(Instruction *, unsigned, APInt, APInt &)></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">          SimplifyAndSetOp) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">          SimplifyAndSetOp) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">    return BaseT::simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">    return BaseT::simplifyDemandedVectorEltsIntrinsic(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">        IC, II, DemandedElts, UndefElts, UndefElts2, UndefElts3,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">        IC, II, DemandedElts, UndefElts, UndefElts2, UndefElts3,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">        SimplifyAndSetOp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">        SimplifyAndSetOp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">  virtual std::optional<unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">  virtual std::optional<unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">  getCacheSize(TargetTransformInfo::CacheLevel Level) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">  getCacheSize(TargetTransformInfo::CacheLevel Level) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">    return std::optional<unsigned>(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">    return std::optional<unsigned>(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">        getST()->getCacheSize(static_cast<unsigned>(Level)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">        getST()->getCacheSize(static_cast<unsigned>(Level)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine">  virtual std::optional<unsigned></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine">  virtual std::optional<unsigned></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">  getCacheAssociativity(TargetTransformInfo::CacheLevel Level) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">  getCacheAssociativity(TargetTransformInfo::CacheLevel Level) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">    std::optional<unsigned> TargetResult =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">    std::optional<unsigned> TargetResult =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">        getST()->getCacheAssociativity(static_cast<unsigned>(Level));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">        getST()->getCacheAssociativity(static_cast<unsigned>(Level));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">    if (TargetResult)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">    if (TargetResult)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">      return TargetResult;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">      return TargetResult;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">    return BaseT::getCacheAssociativity(Level);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">    return BaseT::getCacheAssociativity(Level);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">  virtual unsigned getCacheLineSize() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">  virtual unsigned getCacheLineSize() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">    return getST()->getCacheLineSize();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">    return getST()->getCacheLineSize();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">  virtual unsigned getPrefetchDistance() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">  virtual unsigned getPrefetchDistance() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">    return getST()->getPrefetchDistance();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">    return getST()->getPrefetchDistance();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">  virtual unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">  virtual unsigned getMinPrefetchStride(unsigned NumMemAccesses,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">                                        unsigned NumStridedMemAccesses,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">                                        unsigned NumStridedMemAccesses,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">                                        unsigned NumPrefetches,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">                                        unsigned NumPrefetches,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">                                        bool HasCall) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">                                        bool HasCall) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">    return getST()->getMinPrefetchStride(NumMemAccesses, NumStridedMemAccesses,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">    return getST()->getMinPrefetchStride(NumMemAccesses, NumStridedMemAccesses,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">                                         NumPrefetches, HasCall);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">                                         NumPrefetches, HasCall);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">  virtual unsigned getMaxPrefetchIterationsAhead() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">  virtual unsigned getMaxPrefetchIterationsAhead() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">    return getST()->getMaxPrefetchIterationsAhead();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">    return getST()->getMaxPrefetchIterationsAhead();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">  virtual bool enableWritePrefetching() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">  virtual bool enableWritePrefetching() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">    return getST()->enableWritePrefetching();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">    return getST()->enableWritePrefetching();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">  virtual bool shouldPrefetchAddressSpace(unsigned AS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">  virtual bool shouldPrefetchAddressSpace(unsigned AS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">    return getST()->shouldPrefetchAddressSpace(AS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">    return getST()->shouldPrefetchAddressSpace(AS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">  /// \name Vector TTI Implementations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">  /// \name Vector TTI Implementations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">  TypeSize getRegisterBitWidth(TargetTransformInfo::RegisterKind K) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">  TypeSize getRegisterBitWidth(TargetTransformInfo::RegisterKind K) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">    return TypeSize::getFixed(32);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">    return TypeSize::getFixed(32);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">  std::optional<unsigned> getMaxVScale() const { return std::nullopt; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">  std::optional<unsigned> getMaxVScale() const { return std::nullopt; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">  std::optional<unsigned> getVScaleForTuning() const { return std::nullopt; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">  std::optional<unsigned> getVScaleForTuning() const { return std::nullopt; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">  bool isVScaleKnownToBeAPowerOfTwo() const { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">  bool isVScaleKnownToBeAPowerOfTwo() const { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">  /// Estimate the overhead of scalarizing an instruction. Insert and Extract</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">  /// Estimate the overhead of scalarizing an instruction. Insert and Extract</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">  /// are set if the demanded result elements need to be inserted and/or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">  /// are set if the demanded result elements need to be inserted and/or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">  /// extracted from vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">  /// extracted from vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">  InstructionCost getScalarizationOverhead(VectorType *InTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">  InstructionCost getScalarizationOverhead(VectorType *InTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">                                           const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">                                           const APInt &DemandedElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">                                           bool Insert, bool Extract,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">                                           bool Insert, bool Extract,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">    /// FIXME: a bitfield is not a reasonable abstraction for talking about</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">    /// FIXME: a bitfield is not a reasonable abstraction for talking about</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">    /// which elements are needed from a scalable vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">    /// which elements are needed from a scalable vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(InTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(InTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">    auto *Ty = cast<FixedVectorType>(InTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">    auto *Ty = cast<FixedVectorType>(InTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine">    assert(DemandedElts.getBitWidth() == Ty->getNumElements() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">737</td>
    <td class="codeLine">    assert(DemandedElts.getBitWidth() == Ty->getNumElements() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">           "Vector size mismatch");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">           "Vector size mismatch");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">    for (int i = 0, e = Ty->getNumElements(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">    for (int i = 0, e = Ty->getNumElements(); i < e; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">      if (!DemandedElts[i])</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">      if (!DemandedElts[i])</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">      if (Insert)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">      if (Insert)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">        Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">        Cost += thisT()->getVectorInstrCost(Instruction::InsertElement, Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">                                            CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">                                            CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">      if (Extract)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">      if (Extract)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">        Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">        Cost += thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">                                            CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">                                            CostKind, i, nullptr, nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">  /// Helper wrapper for the DemandedElts variant of getScalarizationOverhead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">  /// Helper wrapper for the DemandedElts variant of getScalarizationOverhead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">  InstructionCost getScalarizationOverhead(VectorType *InTy, bool Insert,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">  InstructionCost getScalarizationOverhead(VectorType *InTy, bool Insert,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">                                           bool Extract,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">                                           bool Extract,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(InTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(InTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">    auto *Ty = cast<FixedVectorType>(InTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">    auto *Ty = cast<FixedVectorType>(InTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">    APInt DemandedElts = APInt::getAllOnes(Ty->getNumElements());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">    APInt DemandedElts = APInt::getAllOnes(Ty->getNumElements());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">    return thisT()->getScalarizationOverhead(Ty, DemandedElts, Insert, Extract,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">    return thisT()->getScalarizationOverhead(Ty, DemandedElts, Insert, Extract,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">                                             CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">                                             CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">  /// Estimate the overhead of scalarizing an instructions unique</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">  /// Estimate the overhead of scalarizing an instructions unique</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">  /// non-constant operands. The (potentially vector) types to use for each of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">  /// non-constant operands. The (potentially vector) types to use for each of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">  /// argument are passes via Tys.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">  /// argument are passes via Tys.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">  getOperandsScalarizationOverhead(ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">                                   TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">                                   TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">    assert(Args.size() == Tys.size() && "Expected matching Args and Tys");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">    assert(Args.size() == Tys.size() && "Expected matching Args and Tys");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">    InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">    SmallPtrSet<const Value*, 4> UniqueOperands;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">    SmallPtrSet<const Value*, 4> UniqueOperands;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">    for (int I = 0, E = Args.size(); I != E; I++) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">    for (int I = 0, E = Args.size(); I != E; I++) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">      // Disregard things like metadata arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">      // Disregard things like metadata arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">      const Value *A = Args[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">      const Value *A = Args[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">      Type *Ty = Tys[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">      Type *Ty = Tys[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">      if (!Ty->isIntOrIntVectorTy() && !Ty->isFPOrFPVectorTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">      if (!Ty->isIntOrIntVectorTy() && !Ty->isFPOrFPVectorTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">          !Ty->isPtrOrPtrVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">          !Ty->isPtrOrPtrVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">      if (!isa<Constant>(A) && UniqueOperands.insert(A).second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">      if (!isa<Constant>(A) && UniqueOperands.insert(A).second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">        if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">        if (auto *VecTy = dyn_cast<VectorType>(Ty))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">          Cost += getScalarizationOverhead(VecTy, /*Insert*/ false,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">          Cost += getScalarizationOverhead(VecTy, /*Insert*/ false,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">                                           /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">                                           /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">  /// Estimate the overhead of scalarizing the inputs and outputs of an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">  /// Estimate the overhead of scalarizing the inputs and outputs of an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">  /// instruction, with return type RetTy and arguments Args of type Tys. If</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">  /// instruction, with return type RetTy and arguments Args of type Tys. If</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">  /// Args are unknown (empty), then the cost associated with one argument is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">  /// Args are unknown (empty), then the cost associated with one argument is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">  /// added as a heuristic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">  /// added as a heuristic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">  InstructionCost getScalarizationOverhead(VectorType *RetTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">  InstructionCost getScalarizationOverhead(VectorType *RetTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">                                           ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">                                           ArrayRef<const Value *> Args,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">                                           ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">                                           ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">    InstructionCost Cost = getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">    InstructionCost Cost = getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">        RetTy, /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">        RetTy, /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">    if (!Args.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">    if (!Args.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">      Cost += getOperandsScalarizationOverhead(Args, Tys, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">      Cost += getOperandsScalarizationOverhead(Args, Tys, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">      // When no information on arguments is provided, we add the cost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">      // When no information on arguments is provided, we add the cost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">      // associated with one argument as a heuristic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">      // associated with one argument as a heuristic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">      Cost += getScalarizationOverhead(RetTy, /*Insert*/ false,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">      Cost += getScalarizationOverhead(RetTy, /*Insert*/ false,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">                                       /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">                                       /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">  /// Estimate the cost of type-legalization and the legalized type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">  /// Estimate the cost of type-legalization and the legalized type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">  std::pair<InstructionCost, MVT> getTypeLegalizationCost(Type *Ty) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">  std::pair<InstructionCost, MVT> getTypeLegalizationCost(Type *Ty) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">    LLVMContext &C = Ty->getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">    LLVMContext &C = Ty->getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">    EVT MTy = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">    EVT MTy = getTLI()->getValueType(DL, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">    InstructionCost Cost = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">    InstructionCost Cost = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">    // We keep legalizing the type until we find a legal kind. We assume that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">    // We keep legalizing the type until we find a legal kind. We assume that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">    // the only operation that costs anything is the split. After splitting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">    // the only operation that costs anything is the split. After splitting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">    // we need to handle two types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">    // we need to handle two types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">    while (true) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">    while (true) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">      TargetLoweringBase::LegalizeKind LK = getTLI()->getTypeConversion(C, MTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">      TargetLoweringBase::LegalizeKind LK = getTLI()->getTypeConversion(C, MTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">      if (LK.first == TargetLoweringBase::TypeScalarizeScalableVector) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">      if (LK.first == TargetLoweringBase::TypeScalarizeScalableVector) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">        // Ensure we return a sensible simple VT here, since many callers of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">        // Ensure we return a sensible simple VT here, since many callers of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">        // this function require it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">        // this function require it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">        MVT VT = MTy.isSimple() ? MTy.getSimpleVT() : MVT::i64;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">        MVT VT = MTy.isSimple() ? MTy.getSimpleVT() : MVT::i64;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">        return std::make_pair(InstructionCost::getInvalid(), VT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">        return std::make_pair(InstructionCost::getInvalid(), VT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">      if (LK.first == TargetLoweringBase::TypeLegal)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">      if (LK.first == TargetLoweringBase::TypeLegal)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">        return std::make_pair(Cost, MTy.getSimpleVT());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">        return std::make_pair(Cost, MTy.getSimpleVT());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">      if (LK.first == TargetLoweringBase::TypeSplitVector ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">      if (LK.first == TargetLoweringBase::TypeSplitVector ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">          LK.first == TargetLoweringBase::TypeExpandInteger)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">          LK.first == TargetLoweringBase::TypeExpandInteger)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">        Cost *= 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">        Cost *= 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">      // Do not loop with f128 type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">      // Do not loop with f128 type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">      if (MTy == LK.second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">      if (MTy == LK.second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">        return std::make_pair(Cost, MTy.getSimpleVT());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">        return std::make_pair(Cost, MTy.getSimpleVT());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">      // Keep legalizing the type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">      // Keep legalizing the type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">      MTy = LK.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">      MTy = LK.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">  unsigned getMaxInterleaveFactor(ElementCount VF) { return 1; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">  unsigned getMaxInterleaveFactor(ElementCount VF) { return 1; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">  InstructionCost getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">  InstructionCost getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">      unsigned Opcode, Type *Ty, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">      TTI::OperandValueInfo Opd1Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">      TTI::OperandValueInfo Opd1Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">      TTI::OperandValueInfo Opd2Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">      TTI::OperandValueInfo Opd2Info = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">      ArrayRef<const Value *> Args = ArrayRef<const Value *>(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">      ArrayRef<const Value *> Args = ArrayRef<const Value *>(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">      const Instruction *CxtI = nullptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">      const Instruction *CxtI = nullptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">    // Check if any of the operands are vector operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">    // Check if any of the operands are vector operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">    assert(ISD && "Invalid opcode");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">    assert(ISD && "Invalid opcode");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">    // TODO: Handle more cost kinds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">    // TODO: Handle more cost kinds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">    if (CostKind != TTI::TCK_RecipThroughput)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">    if (CostKind != TTI::TCK_RecipThroughput)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">      return BaseT::getArithmeticInstrCost(Opcode, Ty, CostKind,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">      return BaseT::getArithmeticInstrCost(Opcode, Ty, CostKind,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">                                           Opd1Info, Opd2Info,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">                                           Opd1Info, Opd2Info,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">                                           Args, CxtI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">                                           Args, CxtI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">    bool IsFloat = Ty->isFPOrFPVectorTy();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">    bool IsFloat = Ty->isFPOrFPVectorTy();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">    // Assume that floating point arithmetic operations cost twice as much as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">    // Assume that floating point arithmetic operations cost twice as much as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">    // integer operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">    // integer operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">    InstructionCost OpCost = (IsFloat ? 2 : 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">    InstructionCost OpCost = (IsFloat ? 2 : 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">    if (TLI->isOperationLegalOrPromote(ISD, LT.second)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">    if (TLI->isOperationLegalOrPromote(ISD, LT.second)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">      // The operation is legal. Assume it costs 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">      // The operation is legal. Assume it costs 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">      // TODO: Once we have extract/insert subvector cost we need to use them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">      // TODO: Once we have extract/insert subvector cost we need to use them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">      return LT.first * OpCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">      return LT.first * OpCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">    if (!TLI->isOperationExpand(ISD, LT.second)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">    if (!TLI->isOperationExpand(ISD, LT.second)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">      // If the operation is custom lowered, then assume that the code is twice</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">      // If the operation is custom lowered, then assume that the code is twice</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">      // as expensive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">      // as expensive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">      return LT.first * 2 * OpCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">      return LT.first * 2 * OpCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">    // An 'Expand' of URem and SRem is special because it may default</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">    // An 'Expand' of URem and SRem is special because it may default</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">    // to expanding the operation into a sequence of sub-operations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">    // to expanding the operation into a sequence of sub-operations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">    // i.e. X % Y -> X-(X/Y)*Y.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">    // i.e. X % Y -> X-(X/Y)*Y.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">    if (ISD == ISD::UREM || ISD == ISD::SREM) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">    if (ISD == ISD::UREM || ISD == ISD::SREM) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">      bool IsSigned = ISD == ISD::SREM;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">      bool IsSigned = ISD == ISD::SREM;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine">      if (TLI->isOperationLegalOrCustom(IsSigned ? ISD::SDIVREM : ISD::UDIVREM,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">897</td>
    <td class="codeLine">      if (TLI->isOperationLegalOrCustom(IsSigned ? ISD::SDIVREM : ISD::UDIVREM,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">                                        LT.second) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">                                        LT.second) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">          TLI->isOperationLegalOrCustom(IsSigned ? ISD::SDIV : ISD::UDIV,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">          TLI->isOperationLegalOrCustom(IsSigned ? ISD::SDIV : ISD::UDIV,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">                                        LT.second)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">                                        LT.second)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">        unsigned DivOpc = IsSigned ? Instruction::SDiv : Instruction::UDiv;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">        unsigned DivOpc = IsSigned ? Instruction::SDiv : Instruction::UDiv;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">        InstructionCost DivCost = thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">        InstructionCost DivCost = thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">            DivOpc, Ty, CostKind, Opd1Info, Opd2Info);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">            DivOpc, Ty, CostKind, Opd1Info, Opd2Info);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">        InstructionCost MulCost =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">        InstructionCost MulCost =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">            thisT()->getArithmeticInstrCost(Instruction::Mul, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">            thisT()->getArithmeticInstrCost(Instruction::Mul, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">        InstructionCost SubCost =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">        InstructionCost SubCost =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">            thisT()->getArithmeticInstrCost(Instruction::Sub, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">            thisT()->getArithmeticInstrCost(Instruction::Sub, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">        return DivCost + MulCost + SubCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">        return DivCost + MulCost + SubCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">911</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">    // We cannot scalarize scalable vectors, so return Invalid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">    // We cannot scalarize scalable vectors, so return Invalid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(Ty))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">913</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(Ty))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">    // Else, assume that we need to scalarize this op.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">    // Else, assume that we need to scalarize this op.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">    // TODO: If one of the types get legalized by splitting, handle this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">    // TODO: If one of the types get legalized by splitting, handle this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">    // similarly to what getCastInstrCost() does.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">    // similarly to what getCastInstrCost() does.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">    if (auto *VTy = dyn_cast<FixedVectorType>(Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">    if (auto *VTy = dyn_cast<FixedVectorType>(Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">      InstructionCost Cost = thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">      InstructionCost Cost = thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">          Opcode, VTy->getScalarType(), CostKind, Opd1Info, Opd2Info,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">          Opcode, VTy->getScalarType(), CostKind, Opd1Info, Opd2Info,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">          Args, CxtI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">          Args, CxtI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">      // Return the cost of multiple scalar invocation plus the cost of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">      // Return the cost of multiple scalar invocation plus the cost of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">      // inserting and extracting the values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">      // inserting and extracting the values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">      SmallVector<Type *> Tys(Args.size(), Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">      SmallVector<Type *> Tys(Args.size(), Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">      return getScalarizationOverhead(VTy, Args, Tys, CostKind) +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">      return getScalarizationOverhead(VTy, Args, Tys, CostKind) +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">             VTy->getNumElements() * Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">             VTy->getNumElements() * Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">    // We don't know anything about this scalar instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">    // We don't know anything about this scalar instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">    return OpCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">    return OpCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine">  TTI::ShuffleKind improveShuffleKindFromMask(TTI::ShuffleKind Kind,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">934</td>
    <td class="codeLine">  TTI::ShuffleKind improveShuffleKindFromMask(TTI::ShuffleKind Kind,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">                                              ArrayRef<int> Mask) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">                                              ArrayRef<int> Mask) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">    int Limit = Mask.size() * 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">    int Limit = Mask.size() * 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">    if (Mask.empty() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">    if (Mask.empty() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">        // Extra check required by isSingleSourceMaskImpl function (called by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">        // Extra check required by isSingleSourceMaskImpl function (called by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">        // ShuffleVectorInst::isSingleSourceMask).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">        // ShuffleVectorInst::isSingleSourceMask).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">        any_of(Mask, [Limit](int I) { return I >= Limit; }))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">        any_of(Mask, [Limit](int I) { return I >= Limit; }))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">      return Kind;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">      return Kind;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">    int Index;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">    int Index;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">    switch (Kind) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">    switch (Kind) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">    case TTI::SK_PermuteSingleSrc:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">    case TTI::SK_PermuteSingleSrc:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">      if (ShuffleVectorInst::isReverseMask(Mask))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">      if (ShuffleVectorInst::isReverseMask(Mask))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">        return TTI::SK_Reverse;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">        return TTI::SK_Reverse;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">      if (ShuffleVectorInst::isZeroEltSplatMask(Mask))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">      if (ShuffleVectorInst::isZeroEltSplatMask(Mask))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">        return TTI::SK_Broadcast;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">        return TTI::SK_Broadcast;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">    case TTI::SK_PermuteTwoSrc:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">    case TTI::SK_PermuteTwoSrc:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">      if (ShuffleVectorInst::isSelectMask(Mask))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">      if (ShuffleVectorInst::isSelectMask(Mask))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">        return TTI::SK_Select;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">        return TTI::SK_Select;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">      if (ShuffleVectorInst::isTransposeMask(Mask))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">      if (ShuffleVectorInst::isTransposeMask(Mask))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">        return TTI::SK_Transpose;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">        return TTI::SK_Transpose;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">      if (ShuffleVectorInst::isSpliceMask(Mask, Index))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">      if (ShuffleVectorInst::isSpliceMask(Mask, Index))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">        return TTI::SK_Splice;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">        return TTI::SK_Splice;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">    case TTI::SK_Select:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">    case TTI::SK_Select:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">    case TTI::SK_Reverse:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">    case TTI::SK_Reverse:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">    case TTI::SK_Broadcast:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">    case TTI::SK_Broadcast:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">    case TTI::SK_Transpose:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">    case TTI::SK_Transpose:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">    case TTI::SK_InsertSubvector:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">    case TTI::SK_InsertSubvector:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">    case TTI::SK_ExtractSubvector:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">    case TTI::SK_ExtractSubvector:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">    case TTI::SK_Splice:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">    case TTI::SK_Splice:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">    return Kind;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">    return Kind;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">  InstructionCost getShuffleCost(TTI::ShuffleKind Kind, VectorType *Tp,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">  InstructionCost getShuffleCost(TTI::ShuffleKind Kind, VectorType *Tp,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">                                 ArrayRef<int> Mask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">                                 ArrayRef<int> Mask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">                                 TTI::TargetCostKind CostKind, int Index,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">                                 TTI::TargetCostKind CostKind, int Index,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">                                 VectorType *SubTp,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">                                 VectorType *SubTp,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">                                 ArrayRef<const Value *> Args = std::nullopt) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">                                 ArrayRef<const Value *> Args = std::nullopt) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">    switch (improveShuffleKindFromMask(Kind, Mask)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">    switch (improveShuffleKindFromMask(Kind, Mask)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">    case TTI::SK_Broadcast:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">    case TTI::SK_Broadcast:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">      if (auto *FVT = dyn_cast<FixedVectorType>(Tp))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">      if (auto *FVT = dyn_cast<FixedVectorType>(Tp))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">        return getBroadcastShuffleOverhead(FVT, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">        return getBroadcastShuffleOverhead(FVT, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">    case TTI::SK_Select:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">    case TTI::SK_Select:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">    case TTI::SK_Splice:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">    case TTI::SK_Splice:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">    case TTI::SK_Reverse:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">    case TTI::SK_Reverse:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">    case TTI::SK_Transpose:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">    case TTI::SK_Transpose:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">    case TTI::SK_PermuteSingleSrc:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">    case TTI::SK_PermuteSingleSrc:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">    case TTI::SK_PermuteTwoSrc:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">    case TTI::SK_PermuteTwoSrc:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">      if (auto *FVT = dyn_cast<FixedVectorType>(Tp))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">      if (auto *FVT = dyn_cast<FixedVectorType>(Tp))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">        return getPermuteShuffleOverhead(FVT, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">        return getPermuteShuffleOverhead(FVT, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">    case TTI::SK_ExtractSubvector:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">    case TTI::SK_ExtractSubvector:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">      return getExtractSubvectorOverhead(Tp, CostKind, Index,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">      return getExtractSubvectorOverhead(Tp, CostKind, Index,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">                                         cast<FixedVectorType>(SubTp));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">                                         cast<FixedVectorType>(SubTp));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine">    case TTI::SK_InsertSubvector:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">993</td>
    <td class="codeLine">    case TTI::SK_InsertSubvector:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">      return getInsertSubvectorOverhead(Tp, CostKind, Index,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">      return getInsertSubvectorOverhead(Tp, CostKind, Index,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">                                        cast<FixedVectorType>(SubTp));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">                                        cast<FixedVectorType>(SubTp));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">    llvm_unreachable("Unknown TTI::ShuffleKind");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">    llvm_unreachable("Unknown TTI::ShuffleKind");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">  InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">  InstructionCost getCastInstrCost(unsigned Opcode, Type *Dst, Type *Src,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">                                   TTI::CastContextHint CCH,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">                                   TTI::CastContextHint CCH,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">                                   TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">                                   TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">                                   const Instruction *I = nullptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">                                   const Instruction *I = nullptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">    if (BaseT::getCastInstrCost(Opcode, Dst, Src, CCH, CostKind, I) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">    if (BaseT::getCastInstrCost(Opcode, Dst, Src, CCH, CostKind, I) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">      return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">      return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">    assert(ISD && "Invalid opcode");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">    assert(ISD && "Invalid opcode");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> SrcLT = getTypeLegalizationCost(Src);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> SrcLT = getTypeLegalizationCost(Src);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> DstLT = getTypeLegalizationCost(Dst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> DstLT = getTypeLegalizationCost(Dst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">    TypeSize SrcSize = SrcLT.second.getSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">    TypeSize SrcSize = SrcLT.second.getSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">    TypeSize DstSize = DstLT.second.getSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">    TypeSize DstSize = DstLT.second.getSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine">    bool IntOrPtrSrc = Src->isIntegerTy() || Src->isPointerTy();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine">    bool IntOrPtrSrc = Src->isIntegerTy() || Src->isPointerTy();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">    bool IntOrPtrDst = Dst->isIntegerTy() || Dst->isPointerTy();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">    bool IntOrPtrDst = Dst->isIntegerTy() || Dst->isPointerTy();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">    switch (Opcode) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">    switch (Opcode) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">    case Instruction::Trunc:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">    case Instruction::Trunc:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">      // Check for NOOP conversions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">      // Check for NOOP conversions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">      if (TLI->isTruncateFree(SrcLT.second, DstLT.second))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">      if (TLI->isTruncateFree(SrcLT.second, DstLT.second))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">      [[fallthrough]];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">      [[fallthrough]];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">    case Instruction::BitCast:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">    case Instruction::BitCast:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">      // Bitcast between types that are legalized to the same type are free and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">      // Bitcast between types that are legalized to the same type are free and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">      // assume int to/from ptr of the same size is also free.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">      // assume int to/from ptr of the same size is also free.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">      if (SrcLT.first == DstLT.first && IntOrPtrSrc == IntOrPtrDst &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">      if (SrcLT.first == DstLT.first && IntOrPtrSrc == IntOrPtrDst &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">          SrcSize == DstSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">          SrcSize == DstSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">    case Instruction::FPExt:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">    case Instruction::FPExt:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">      if (I && getTLI()->isExtFree(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">      if (I && getTLI()->isExtFree(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">    case Instruction::ZExt:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">    case Instruction::ZExt:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">      if (TLI->isZExtFree(SrcLT.second, DstLT.second))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">      if (TLI->isZExtFree(SrcLT.second, DstLT.second))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">      [[fallthrough]];</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">      [[fallthrough]];</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">    case Instruction::SExt:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">    case Instruction::SExt:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">      if (I && getTLI()->isExtFree(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">      if (I && getTLI()->isExtFree(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">      // If this is a zext/sext of a load, return 0 if the corresponding</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">      // If this is a zext/sext of a load, return 0 if the corresponding</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">      // extending load exists on target and the result type is legal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">      // extending load exists on target and the result type is legal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">      if (CCH == TTI::CastContextHint::Normal) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">      if (CCH == TTI::CastContextHint::Normal) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">        EVT ExtVT = EVT::getEVT(Dst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">        EVT ExtVT = EVT::getEVT(Dst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">        EVT LoadVT = EVT::getEVT(Src);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">        EVT LoadVT = EVT::getEVT(Src);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">        unsigned LType =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">        unsigned LType =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">          ((Opcode == Instruction::ZExt) ? ISD::ZEXTLOAD : ISD::SEXTLOAD);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">          ((Opcode == Instruction::ZExt) ? ISD::ZEXTLOAD : ISD::SEXTLOAD);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">        if (DstLT.first == SrcLT.first &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">        if (DstLT.first == SrcLT.first &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">            TLI->isLoadExtLegal(LType, ExtVT, LoadVT))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">            TLI->isLoadExtLegal(LType, ExtVT, LoadVT))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">          return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">          return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">    case Instruction::AddrSpaceCast:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">    case Instruction::AddrSpaceCast:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">      if (TLI->isFreeAddrSpaceCast(Src->getPointerAddressSpace(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">      if (TLI->isFreeAddrSpaceCast(Src->getPointerAddressSpace(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">                                   Dst->getPointerAddressSpace()))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">                                   Dst->getPointerAddressSpace()))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">    auto *SrcVTy = dyn_cast<VectorType>(Src);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">    auto *SrcVTy = dyn_cast<VectorType>(Src);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">    auto *DstVTy = dyn_cast<VectorType>(Dst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">    auto *DstVTy = dyn_cast<VectorType>(Dst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">    // If the cast is marked as legal (or promote) then assume low cost.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">    // If the cast is marked as legal (or promote) then assume low cost.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">    if (SrcLT.first == DstLT.first &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">    if (SrcLT.first == DstLT.first &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">        TLI->isOperationLegalOrPromote(ISD, DstLT.second))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">        TLI->isOperationLegalOrPromote(ISD, DstLT.second))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">      return SrcLT.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">      return SrcLT.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">    // Handle scalar conversions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">    // Handle scalar conversions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">    if (!SrcVTy && !DstVTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">    if (!SrcVTy && !DstVTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">      // Just check the op cost. If the operation is legal then assume it costs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">      // Just check the op cost. If the operation is legal then assume it costs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">      // 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">      // 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">      if (!TLI->isOperationExpand(ISD, DstLT.second))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">      if (!TLI->isOperationExpand(ISD, DstLT.second))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">        return 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">        return 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">      // Assume that illegal scalar instruction are expensive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">      // Assume that illegal scalar instruction are expensive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">      return 4;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">      return 4;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">    // Check vector-to-vector casts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">    // Check vector-to-vector casts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">    if (DstVTy && SrcVTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">    if (DstVTy && SrcVTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">      // If the cast is between same-sized registers, then the check is simple.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">      // If the cast is between same-sized registers, then the check is simple.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">      if (SrcLT.first == DstLT.first && SrcSize == DstSize) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">      if (SrcLT.first == DstLT.first && SrcSize == DstSize) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">        // Assume that Zext is done using AND.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">        // Assume that Zext is done using AND.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">        if (Opcode == Instruction::ZExt)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">        if (Opcode == Instruction::ZExt)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">          return SrcLT.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">          return SrcLT.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">        // Assume that sext is done using SHL and SRA.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">        // Assume that sext is done using SHL and SRA.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">        if (Opcode == Instruction::SExt)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">        if (Opcode == Instruction::SExt)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">          return SrcLT.first * 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">          return SrcLT.first * 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">        // Just check the op cost. If the operation is legal then assume it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">        // Just check the op cost. If the operation is legal then assume it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">        // costs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">        // costs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">        // 1 and multiply by the type-legalization overhead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">        // 1 and multiply by the type-legalization overhead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">        if (!TLI->isOperationExpand(ISD, DstLT.second))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">        if (!TLI->isOperationExpand(ISD, DstLT.second))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">          return SrcLT.first * 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">          return SrcLT.first * 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">      // If we are legalizing by splitting, query the concrete TTI for the cost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">      // If we are legalizing by splitting, query the concrete TTI for the cost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine">      // of casting the original vector twice. We also need to factor in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine">      // of casting the original vector twice. We also need to factor in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">      // cost of the split itself. Count that as 1, to be consistent with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">      // cost of the split itself. Count that as 1, to be consistent with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">      // getTypeLegalizationCost().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">      // getTypeLegalizationCost().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">      bool SplitSrc =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">      bool SplitSrc =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">          TLI->getTypeAction(Src->getContext(), TLI->getValueType(DL, Src)) ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">          TLI->getTypeAction(Src->getContext(), TLI->getValueType(DL, Src)) ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">          TargetLowering::TypeSplitVector;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">          TargetLowering::TypeSplitVector;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">      bool SplitDst =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">      bool SplitDst =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">          TLI->getTypeAction(Dst->getContext(), TLI->getValueType(DL, Dst)) ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">          TLI->getTypeAction(Dst->getContext(), TLI->getValueType(DL, Dst)) ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">          TargetLowering::TypeSplitVector;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">          TargetLowering::TypeSplitVector;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">      if ((SplitSrc || SplitDst) && SrcVTy->getElementCount().isVector() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">      if ((SplitSrc || SplitDst) && SrcVTy->getElementCount().isVector() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">          DstVTy->getElementCount().isVector()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">          DstVTy->getElementCount().isVector()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">        Type *SplitDstTy = VectorType::getHalfElementsVectorType(DstVTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">        Type *SplitDstTy = VectorType::getHalfElementsVectorType(DstVTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">        Type *SplitSrcTy = VectorType::getHalfElementsVectorType(SrcVTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">        Type *SplitSrcTy = VectorType::getHalfElementsVectorType(SrcVTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">        T *TTI = static_cast<T *>(this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">        T *TTI = static_cast<T *>(this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">        // If both types need to be split then the split is free.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">        // If both types need to be split then the split is free.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">        InstructionCost SplitCost =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">        InstructionCost SplitCost =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">            (!SplitSrc || !SplitDst) ? TTI->getVectorSplitCost() : 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">            (!SplitSrc || !SplitDst) ? TTI->getVectorSplitCost() : 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">        return SplitCost +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">        return SplitCost +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">               (2 * TTI->getCastInstrCost(Opcode, SplitDstTy, SplitSrcTy, CCH,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">               (2 * TTI->getCastInstrCost(Opcode, SplitDstTy, SplitSrcTy, CCH,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">                                          CostKind, I));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">                                          CostKind, I));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">      // Scalarization cost is Invalid, can't assume any num elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">      // Scalarization cost is Invalid, can't assume any num elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(DstVTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(DstVTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">        return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">        return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">      // In other cases where the source or destination are illegal, assume</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">      // In other cases where the source or destination are illegal, assume</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">      // the operation will get scalarized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">      // the operation will get scalarized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">      unsigned Num = cast<FixedVectorType>(DstVTy)->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">      unsigned Num = cast<FixedVectorType>(DstVTy)->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">      InstructionCost Cost = thisT()->getCastInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">      InstructionCost Cost = thisT()->getCastInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">          Opcode, Dst->getScalarType(), Src->getScalarType(), CCH, CostKind, I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">          Opcode, Dst->getScalarType(), Src->getScalarType(), CCH, CostKind, I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">      // Return the cost of multiple scalar invocation plus the cost of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">      // Return the cost of multiple scalar invocation plus the cost of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine">      // inserting and extracting the values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine">      // inserting and extracting the values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">      return getScalarizationOverhead(DstVTy, /*Insert*/ true, /*Extract*/ true,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">      return getScalarizationOverhead(DstVTy, /*Insert*/ true, /*Extract*/ true,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">                                      CostKind) +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">                                      CostKind) +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">             Num * Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">             Num * Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">    // We already handled vector-to-vector and scalar-to-scalar conversions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">    // We already handled vector-to-vector and scalar-to-scalar conversions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">    // This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">    // This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">    // is where we handle bitcast between vectors and scalars. We need to assume</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">    // is where we handle bitcast between vectors and scalars. We need to assume</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">    //  that the conversion is scalarized in one way or another.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">    //  that the conversion is scalarized in one way or another.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">    if (Opcode == Instruction::BitCast) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">    if (Opcode == Instruction::BitCast) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">      // Illegal bitcasts are done by storing and loading from a stack slot.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">      // Illegal bitcasts are done by storing and loading from a stack slot.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">      return (SrcVTy ? getScalarizationOverhead(SrcVTy, /*Insert*/ false,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">      return (SrcVTy ? getScalarizationOverhead(SrcVTy, /*Insert*/ false,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">                                                /*Extract*/ true, CostKind)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">                                                /*Extract*/ true, CostKind)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">                     : 0) +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">                     : 0) +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">             (DstVTy ? getScalarizationOverhead(DstVTy, /*Insert*/ true,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">             (DstVTy ? getScalarizationOverhead(DstVTy, /*Insert*/ true,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">                                                /*Extract*/ false, CostKind)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">                                                /*Extract*/ false, CostKind)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">                     : 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">                     : 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">    llvm_unreachable("Unhandled cast");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">    llvm_unreachable("Unhandled cast");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">  InstructionCost getExtractWithExtendCost(unsigned Opcode, Type *Dst,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">                                           VectorType *VecTy, unsigned Index) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">                                           VectorType *VecTy, unsigned Index) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">    TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">    TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">    return thisT()->getVectorInstrCost(Instruction::ExtractElement, VecTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">    return thisT()->getVectorInstrCost(Instruction::ExtractElement, VecTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">                                       CostKind, Index, nullptr, nullptr) +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">                                       CostKind, Index, nullptr, nullptr) +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">           thisT()->getCastInstrCost(Opcode, Dst, VecTy->getElementType(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">           thisT()->getCastInstrCost(Opcode, Dst, VecTy->getElementType(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">                                     TTI::CastContextHint::None, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">                                     TTI::CastContextHint::None, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">  InstructionCost getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">  InstructionCost getCFInstrCost(unsigned Opcode, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine">                                 const Instruction *I = nullptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine">                                 const Instruction *I = nullptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">    return BaseT::getCFInstrCost(Opcode, CostKind, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">    return BaseT::getCFInstrCost(Opcode, CostKind, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">  InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">  InstructionCost getCmpSelInstrCost(unsigned Opcode, Type *ValTy, Type *CondTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">                                     CmpInst::Predicate VecPred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">                                     CmpInst::Predicate VecPred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">                                     const Instruction *I = nullptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">                                     const Instruction *I = nullptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">    int ISD = TLI->InstructionOpcodeToISD(Opcode);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">    assert(ISD && "Invalid opcode");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">    assert(ISD && "Invalid opcode");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">    // TODO: Handle other cost kinds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">    // TODO: Handle other cost kinds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">    if (CostKind != TTI::TCK_RecipThroughput)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">    if (CostKind != TTI::TCK_RecipThroughput)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">      return BaseT::getCmpSelInstrCost(Opcode, ValTy, CondTy, VecPred, CostKind,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">      return BaseT::getCmpSelInstrCost(Opcode, ValTy, CondTy, VecPred, CostKind,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">                                       I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">                                       I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">    // Selects on vectors are actually vector selects.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">    // Selects on vectors are actually vector selects.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">    if (ISD == ISD::SELECT) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">    if (ISD == ISD::SELECT) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">      assert(CondTy && "CondTy must exist");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">      assert(CondTy && "CondTy must exist");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">      if (CondTy->isVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">      if (CondTy->isVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">        ISD = ISD::VSELECT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">        ISD = ISD::VSELECT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(ValTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(ValTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">    if (!(ValTy->isVectorTy() && !LT.second.isVector()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">    if (!(ValTy->isVectorTy() && !LT.second.isVector()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">        !TLI->isOperationExpand(ISD, LT.second)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">        !TLI->isOperationExpand(ISD, LT.second)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">      // The operation is legal. Assume it costs 1. Multiply</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">      // The operation is legal. Assume it costs 1. Multiply</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">      // by the type-legalization overhead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">      // by the type-legalization overhead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">      return LT.first * 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">      return LT.first * 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">    // Otherwise, assume that the cast is scalarized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">    // Otherwise, assume that the cast is scalarized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">    // TODO: If one of the types get legalized by splitting, handle this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">    // TODO: If one of the types get legalized by splitting, handle this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">    // similarly to what getCastInstrCost() does.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">    // similarly to what getCastInstrCost() does.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">    if (auto *ValVTy = dyn_cast<VectorType>(ValTy)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">    if (auto *ValVTy = dyn_cast<VectorType>(ValTy)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(ValTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(ValTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">        return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">        return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">      unsigned Num = cast<FixedVectorType>(ValVTy)->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">      unsigned Num = cast<FixedVectorType>(ValVTy)->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">      if (CondTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">      if (CondTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">        CondTy = CondTy->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">        CondTy = CondTy->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">      InstructionCost Cost = thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">      InstructionCost Cost = thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">          Opcode, ValVTy->getScalarType(), CondTy, VecPred, CostKind, I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">          Opcode, ValVTy->getScalarType(), CondTy, VecPred, CostKind, I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">      // Return the cost of multiple scalar invocation plus the cost of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">      // Return the cost of multiple scalar invocation plus the cost of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">      // inserting and extracting the values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">      // inserting and extracting the values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">      return getScalarizationOverhead(ValVTy, /*Insert*/ true,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">      return getScalarizationOverhead(ValVTy, /*Insert*/ true,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">                                      /*Extract*/ false, CostKind) +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">                                      /*Extract*/ false, CostKind) +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">             Num * Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">             Num * Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">    // Unknown scalar opcode.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">    // Unknown scalar opcode.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">    return 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">    return 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">  InstructionCost getVectorInstrCost(unsigned Opcode, Type *Val,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">                                     unsigned Index, Value *Op0, Value *Op1) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">                                     unsigned Index, Value *Op0, Value *Op1) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">    return getRegUsageForType(Val->getScalarType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">    return getRegUsageForType(Val->getScalarType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  InstructionCost getVectorInstrCost(const Instruction &I, Type *Val,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">                                     TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">                                     unsigned Index) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">                                     unsigned Index) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">    Value *Op0 = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">    Value *Op0 = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">    Value *Op1 = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">    Value *Op1 = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">    if (auto *IE = dyn_cast<InsertElementInst>(&I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">    if (auto *IE = dyn_cast<InsertElementInst>(&I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">      Op0 = IE->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">      Op0 = IE->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">      Op1 = IE->getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">      Op1 = IE->getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">    return thisT()->getVectorInstrCost(I.getOpcode(), Val, CostKind, Index, Op0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">    return thisT()->getVectorInstrCost(I.getOpcode(), Val, CostKind, Index, Op0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">                                       Op1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">                                       Op1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">  InstructionCost getReplicationShuffleCost(Type *EltTy, int ReplicationFactor,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">  InstructionCost getReplicationShuffleCost(Type *EltTy, int ReplicationFactor,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">                                            int VF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">                                            int VF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">                                            const APInt &DemandedDstElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">                                            const APInt &DemandedDstElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">                                            TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">                                            TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">    assert(DemandedDstElts.getBitWidth() == (unsigned)VF * ReplicationFactor &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">    assert(DemandedDstElts.getBitWidth() == (unsigned)VF * ReplicationFactor &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">           "Unexpected size of DemandedDstElts.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">           "Unexpected size of DemandedDstElts.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">    InstructionCost Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">    InstructionCost Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">    auto *SrcVT = FixedVectorType::get(EltTy, VF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">    auto *SrcVT = FixedVectorType::get(EltTy, VF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">    auto *ReplicatedVT = FixedVectorType::get(EltTy, VF * ReplicationFactor);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">    auto *ReplicatedVT = FixedVectorType::get(EltTy, VF * ReplicationFactor);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">    // The Mask shuffling cost is extract all the elements of the Mask</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">    // The Mask shuffling cost is extract all the elements of the Mask</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">    // and insert each of them Factor times into the wide vector:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">    // and insert each of them Factor times into the wide vector:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">    // E.g. an interleaved group with factor 3:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">    // E.g. an interleaved group with factor 3:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">    //    %mask = icmp ult <8 x i32> %vec1, %vec2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">    //    %mask = icmp ult <8 x i32> %vec1, %vec2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">    //    %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">    //    %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">    //        <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">    //        <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">    // The cost is estimated as extract all mask elements from the <8xi1> mask</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">    // The cost is estimated as extract all mask elements from the <8xi1> mask</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">    // vector and insert them factor times into the <24xi1> shuffled mask</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">    // vector and insert them factor times into the <24xi1> shuffled mask</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">    // vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">    // vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">    APInt DemandedSrcElts = APIntOps::ScaleBitMask(DemandedDstElts, VF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">    APInt DemandedSrcElts = APIntOps::ScaleBitMask(DemandedDstElts, VF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">    Cost += thisT()->getScalarizationOverhead(SrcVT, DemandedSrcElts,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">    Cost += thisT()->getScalarizationOverhead(SrcVT, DemandedSrcElts,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">                                              /*Insert*/ false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">                                              /*Insert*/ false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">                                              /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">                                              /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">    Cost += thisT()->getScalarizationOverhead(ReplicatedVT, DemandedDstElts,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">    Cost += thisT()->getScalarizationOverhead(ReplicatedVT, DemandedDstElts,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">                                              /*Insert*/ true,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">                                              /*Insert*/ true,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">                                              /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">                                              /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">  getMemoryOpCost(unsigned Opcode, Type *Src, MaybeAlign Alignment,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">  getMemoryOpCost(unsigned Opcode, Type *Src, MaybeAlign Alignment,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">                  unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">                  unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">                  TTI::OperandValueInfo OpInfo = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">                  TTI::OperandValueInfo OpInfo = {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">                  const Instruction *I = nullptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">                  const Instruction *I = nullptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">    assert(!Src->isVoidTy() && "Invalid type");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">    assert(!Src->isVoidTy() && "Invalid type");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">    // Assume types, such as structs, are expensive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">    // Assume types, such as structs, are expensive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">    if (getTLI()->getValueType(DL, Src,  true) == MVT::Other)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">    if (getTLI()->getValueType(DL, Src,  true) == MVT::Other)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">      return 4;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">      return 4;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Src);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Src);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">    // Assuming that all loads of legal types cost 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">    // Assuming that all loads of legal types cost 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">    InstructionCost Cost = LT.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">    InstructionCost Cost = LT.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">    if (CostKind != TTI::TCK_RecipThroughput)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">    if (CostKind != TTI::TCK_RecipThroughput)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">    const DataLayout &DL = this->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">    const DataLayout &DL = this->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">    if (Src->isVectorTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">    if (Src->isVectorTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">        // In practice it's not currently possible to have a change in lane</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">        // In practice it's not currently possible to have a change in lane</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">        // length for extending loads or truncating stores so both types should</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">        // length for extending loads or truncating stores so both types should</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">        // have the same scalable property.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">        // have the same scalable property.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">        TypeSize::isKnownLT(DL.getTypeStoreSizeInBits(Src),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">        TypeSize::isKnownLT(DL.getTypeStoreSizeInBits(Src),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">                            LT.second.getSizeInBits())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">                            LT.second.getSizeInBits())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">      // This is a vector load that legalizes to a larger type than the vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">      // This is a vector load that legalizes to a larger type than the vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">      // itself. Unless the corresponding extending load or truncating store is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">      // itself. Unless the corresponding extending load or truncating store is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">      // legal, then this will scalarize.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">      // legal, then this will scalarize.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">      TargetLowering::LegalizeAction LA = TargetLowering::Expand;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">      TargetLowering::LegalizeAction LA = TargetLowering::Expand;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">      EVT MemVT = getTLI()->getValueType(DL, Src);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">      EVT MemVT = getTLI()->getValueType(DL, Src);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine">      if (Opcode == Instruction::Store)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine">      if (Opcode == Instruction::Store)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">        LA = getTLI()->getTruncStoreAction(LT.second, MemVT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">        LA = getTLI()->getTruncStoreAction(LT.second, MemVT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">        LA = getTLI()->getLoadExtAction(ISD::EXTLOAD, LT.second, MemVT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">        LA = getTLI()->getLoadExtAction(ISD::EXTLOAD, LT.second, MemVT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine">      if (LA != TargetLowering::Legal && LA != TargetLowering::Custom) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine">      if (LA != TargetLowering::Legal && LA != TargetLowering::Custom) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">        // This is a vector load/store for some illegal type that is scalarized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">        // This is a vector load/store for some illegal type that is scalarized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">        // We must account for the cost of building or decomposing the vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">        // We must account for the cost of building or decomposing the vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">        Cost += getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">        Cost += getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">            cast<VectorType>(Src), Opcode != Instruction::Store,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">            cast<VectorType>(Src), Opcode != Instruction::Store,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">            Opcode == Instruction::Store, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">            Opcode == Instruction::Store, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">  InstructionCost getMaskedMemoryOpCost(unsigned Opcode, Type *DataTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">  InstructionCost getMaskedMemoryOpCost(unsigned Opcode, Type *DataTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">                                        Align Alignment, unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">                                        Align Alignment, unsigned AddressSpace,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">                                        TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">                                        TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">    return getCommonMaskedMemoryOpCost(Opcode, DataTy, Alignment, true, false,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">    return getCommonMaskedMemoryOpCost(Opcode, DataTy, Alignment, true, false,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">                                       CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">                                       CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">  InstructionCost getGatherScatterOpCost(unsigned Opcode, Type *DataTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">  InstructionCost getGatherScatterOpCost(unsigned Opcode, Type *DataTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">                                         const Value *Ptr, bool VariableMask,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">                                         const Value *Ptr, bool VariableMask,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">                                         Align Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">                                         Align Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">                                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">                                         TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">                                         const Instruction *I = nullptr) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">                                         const Instruction *I = nullptr) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">    return getCommonMaskedMemoryOpCost(Opcode, DataTy, Alignment, VariableMask,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">    return getCommonMaskedMemoryOpCost(Opcode, DataTy, Alignment, VariableMask,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">                                       true, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">                                       true, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">  InstructionCost getInterleavedMemoryOpCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">  InstructionCost getInterleavedMemoryOpCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">      unsigned Opcode, Type *VecTy, unsigned Factor, ArrayRef<unsigned> Indices,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">      Align Alignment, unsigned AddressSpace, TTI::TargetCostKind CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">      bool UseMaskForCond = false, bool UseMaskForGaps = false) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">      bool UseMaskForCond = false, bool UseMaskForGaps = false) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">    // We cannot scalarize scalable vectors, so return Invalid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">    // We cannot scalarize scalable vectors, so return Invalid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(VecTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(VecTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">    auto *VT = cast<FixedVectorType>(VecTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">    auto *VT = cast<FixedVectorType>(VecTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">    unsigned NumElts = VT->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">    unsigned NumElts = VT->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">    assert(Factor > 1 && NumElts % Factor == 0 && "Invalid interleave factor");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">    assert(Factor > 1 && NumElts % Factor == 0 && "Invalid interleave factor");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">    unsigned NumSubElts = NumElts / Factor;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">    unsigned NumSubElts = NumElts / Factor;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">    auto *SubVT = FixedVectorType::get(VT->getElementType(), NumSubElts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">    auto *SubVT = FixedVectorType::get(VT->getElementType(), NumSubElts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">    // Firstly, the cost of load/store operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">    // Firstly, the cost of load/store operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">    InstructionCost Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">    InstructionCost Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">    if (UseMaskForCond || UseMaskForGaps)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">    if (UseMaskForCond || UseMaskForGaps)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">      Cost = thisT()->getMaskedMemoryOpCost(Opcode, VecTy, Alignment,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">      Cost = thisT()->getMaskedMemoryOpCost(Opcode, VecTy, Alignment,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">                                            AddressSpace, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">                                            AddressSpace, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">      Cost = thisT()->getMemoryOpCost(Opcode, VecTy, Alignment, AddressSpace,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">      Cost = thisT()->getMemoryOpCost(Opcode, VecTy, Alignment, AddressSpace,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">                                      CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">                                      CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">    // Legalize the vector type, and get the legalized and unlegalized type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">    // Legalize the vector type, and get the legalized and unlegalized type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">    // sizes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">    // sizes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">    MVT VecTyLT = getTypeLegalizationCost(VecTy).second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">    MVT VecTyLT = getTypeLegalizationCost(VecTy).second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">    unsigned VecTySize = thisT()->getDataLayout().getTypeStoreSize(VecTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">    unsigned VecTySize = thisT()->getDataLayout().getTypeStoreSize(VecTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">    unsigned VecTyLTSize = VecTyLT.getStoreSize();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">    unsigned VecTyLTSize = VecTyLT.getStoreSize();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">    // Scale the cost of the memory operation by the fraction of legalized</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">    // Scale the cost of the memory operation by the fraction of legalized</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">    // instructions that will actually be used. We shouldn't account for the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">    // instructions that will actually be used. We shouldn't account for the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">    // cost of dead instructions since they will be removed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">    // cost of dead instructions since they will be removed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">    // E.g., An interleaved load of factor 8:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">    // E.g., An interleaved load of factor 8:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">    //       %vec = load <16 x i64>, <16 x i64>* %ptr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">    //       %vec = load <16 x i64>, <16 x i64>* %ptr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">    //       %v0 = shufflevector %vec, undef, <0, 8></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">    //       %v0 = shufflevector %vec, undef, <0, 8></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">    // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">    // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">    // used (those corresponding to elements [0:1] and [8:9] of the unlegalized</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">    // used (those corresponding to elements [0:1] and [8:9] of the unlegalized</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">    // type). The other loads are unused.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">    // type). The other loads are unused.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">    //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">    // TODO: Note that legalization can turn masked loads/stores into unmasked</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">    // TODO: Note that legalization can turn masked loads/stores into unmasked</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">    // (legalized) loads/stores. This can be reflected in the cost.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">    // (legalized) loads/stores. This can be reflected in the cost.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">    if (Cost.isValid() && VecTySize > VecTyLTSize) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">    if (Cost.isValid() && VecTySize > VecTyLTSize) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">      // The number of loads of a legal type it will take to represent a load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">      // The number of loads of a legal type it will take to represent a load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">      // of the unlegalized vector type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">      // of the unlegalized vector type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">      unsigned NumLegalInsts = divideCeil(VecTySize, VecTyLTSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">      unsigned NumLegalInsts = divideCeil(VecTySize, VecTyLTSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">      // The number of elements of the unlegalized type that correspond to a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">      // The number of elements of the unlegalized type that correspond to a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">      // single legal instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">      // single legal instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">      unsigned NumEltsPerLegalInst = divideCeil(NumElts, NumLegalInsts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">      unsigned NumEltsPerLegalInst = divideCeil(NumElts, NumLegalInsts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">      // Determine which legal instructions will be used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">      // Determine which legal instructions will be used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">      BitVector UsedInsts(NumLegalInsts, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">      BitVector UsedInsts(NumLegalInsts, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">      for (unsigned Index : Indices)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">      for (unsigned Index : Indices)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">        for (unsigned Elt = 0; Elt < NumSubElts; ++Elt)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">        for (unsigned Elt = 0; Elt < NumSubElts; ++Elt)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">          UsedInsts.set((Index + Elt * Factor) / NumEltsPerLegalInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">          UsedInsts.set((Index + Elt * Factor) / NumEltsPerLegalInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">      // Scale the cost of the load by the fraction of legal instructions that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">      // Scale the cost of the load by the fraction of legal instructions that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">      // will be used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">      // will be used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">      Cost = divideCeil(UsedInsts.count() * *Cost.getValue(), NumLegalInsts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">      Cost = divideCeil(UsedInsts.count() * *Cost.getValue(), NumLegalInsts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">    // Then plus the cost of interleave operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">    // Then plus the cost of interleave operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">    assert(Indices.size() <= Factor &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">    assert(Indices.size() <= Factor &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">           "Interleaved memory op has too many members");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">           "Interleaved memory op has too many members");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">    const APInt DemandedAllSubElts = APInt::getAllOnes(NumSubElts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">    const APInt DemandedAllSubElts = APInt::getAllOnes(NumSubElts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">    const APInt DemandedAllResultElts = APInt::getAllOnes(NumElts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">    const APInt DemandedAllResultElts = APInt::getAllOnes(NumElts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">    APInt DemandedLoadStoreElts = APInt::getZero(NumElts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">    APInt DemandedLoadStoreElts = APInt::getZero(NumElts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">    for (unsigned Index : Indices) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">    for (unsigned Index : Indices) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">      assert(Index < Factor && "Invalid index for interleaved memory op");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">      assert(Index < Factor && "Invalid index for interleaved memory op");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">      for (unsigned Elm = 0; Elm < NumSubElts; Elm++)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">      for (unsigned Elm = 0; Elm < NumSubElts; Elm++)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine">        DemandedLoadStoreElts.setBit(Index + Elm * Factor);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine">        DemandedLoadStoreElts.setBit(Index + Elm * Factor);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">    if (Opcode == Instruction::Load) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">    if (Opcode == Instruction::Load) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">      // The interleave cost is similar to extract sub vectors' elements</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">      // The interleave cost is similar to extract sub vectors' elements</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">      // from the wide vector, and insert them into sub vectors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">      // from the wide vector, and insert them into sub vectors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">      // E.g. An interleaved load of factor 2 (with one member of index 0):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">      // E.g. An interleaved load of factor 2 (with one member of index 0):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">      //      %vec = load <8 x i32>, <8 x i32>* %ptr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">      //      %vec = load <8 x i32>, <8 x i32>* %ptr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">      //      %v0 = shuffle %vec, undef, <0, 2, 4, 6>         ; Index 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">      //      %v0 = shuffle %vec, undef, <0, 2, 4, 6>         ; Index 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">      // The cost is estimated as extract elements at 0, 2, 4, 6 from the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">      // The cost is estimated as extract elements at 0, 2, 4, 6 from the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">      // <8 x i32> vector and insert them into a <4 x i32> vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">      // <8 x i32> vector and insert them into a <4 x i32> vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">      InstructionCost InsSubCost = thisT()->getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">      InstructionCost InsSubCost = thisT()->getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">          SubVT, DemandedAllSubElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">          SubVT, DemandedAllSubElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">          /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">          /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">      Cost += Indices.size() * InsSubCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">      Cost += Indices.size() * InsSubCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">      Cost += thisT()->getScalarizationOverhead(VT, DemandedLoadStoreElts,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">      Cost += thisT()->getScalarizationOverhead(VT, DemandedLoadStoreElts,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">                                                /*Insert*/ false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">                                                /*Insert*/ false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">                                                /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">                                                /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">      // The interleave cost is extract elements from sub vectors, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">      // The interleave cost is extract elements from sub vectors, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">      // insert them into the wide vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">      // insert them into the wide vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">      // E.g. An interleaved store of factor 3 with 2 members at indices 0,1:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">      // E.g. An interleaved store of factor 3 with 2 members at indices 0,1:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">      // (using VF=4):</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">      // (using VF=4):</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">      //    %v0_v1 = shuffle %v0, %v1, <0,4,undef,1,5,undef,2,6,undef,3,7,undef></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">      //    %v0_v1 = shuffle %v0, %v1, <0,4,undef,1,5,undef,2,6,undef,3,7,undef></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">      //    %gaps.mask = <true, true, false, true, true, false,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">      //    %gaps.mask = <true, true, false, true, true, false,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">      //                  true, true, false, true, true, false></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">      //                  true, true, false, true, true, false></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">      //    call llvm.masked.store <12 x i32> %v0_v1, <12 x i32>* %ptr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">      //    call llvm.masked.store <12 x i32> %v0_v1, <12 x i32>* %ptr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">      //                           i32 Align, <12 x i1> %gaps.mask</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">      //                           i32 Align, <12 x i1> %gaps.mask</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">      // The cost is estimated as extract all elements (of actual members,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">      // The cost is estimated as extract all elements (of actual members,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">      // excluding gaps) from both <4 x i32> vectors and insert into the <12 x</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">      // excluding gaps) from both <4 x i32> vectors and insert into the <12 x</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">      // i32> vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">      // i32> vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">      InstructionCost ExtSubCost = thisT()->getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">      InstructionCost ExtSubCost = thisT()->getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">          SubVT, DemandedAllSubElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">          SubVT, DemandedAllSubElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">          /*Insert*/ false, /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">          /*Insert*/ false, /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">      Cost += ExtSubCost * Indices.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">      Cost += ExtSubCost * Indices.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">      Cost += thisT()->getScalarizationOverhead(VT, DemandedLoadStoreElts,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">      Cost += thisT()->getScalarizationOverhead(VT, DemandedLoadStoreElts,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">                                                /*Insert*/ true,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">                                                /*Insert*/ true,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">                                                /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">                                                /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">    if (!UseMaskForCond)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">    if (!UseMaskForCond)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">    Type *I8Type = Type::getInt8Ty(VT->getContext());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">    Type *I8Type = Type::getInt8Ty(VT->getContext());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">    Cost += thisT()->getReplicationShuffleCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">    Cost += thisT()->getReplicationShuffleCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">        I8Type, Factor, NumSubElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">        I8Type, Factor, NumSubElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">        UseMaskForGaps ? DemandedLoadStoreElts : DemandedAllResultElts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">        UseMaskForGaps ? DemandedLoadStoreElts : DemandedAllResultElts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">        CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">        CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">    // The Gaps mask is invariant and created outside the loop, therefore the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">    // The Gaps mask is invariant and created outside the loop, therefore the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">    // cost of creating it is not accounted for here. However if we have both</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">    // cost of creating it is not accounted for here. However if we have both</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">    // a MaskForGaps and some other mask that guards the execution of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">    // a MaskForGaps and some other mask that guards the execution of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">    // memory access, we need to account for the cost of And-ing the two masks</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">    // memory access, we need to account for the cost of And-ing the two masks</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">    // inside the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">    // inside the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">    if (UseMaskForGaps) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">    if (UseMaskForGaps) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">      auto *MaskVT = FixedVectorType::get(I8Type, NumElts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">      auto *MaskVT = FixedVectorType::get(I8Type, NumElts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(BinaryOperator::And, MaskVT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(BinaryOperator::And, MaskVT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">                                              CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">                                              CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">    return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">  /// Get intrinsic cost based on arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">  /// Get intrinsic cost based on arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine">  InstructionCost getIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">                                        TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">                                        TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">    // Check for generically free intrinsics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">    // Check for generically free intrinsics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">    if (BaseT::getIntrinsicInstrCost(ICA, CostKind) == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">    if (BaseT::getIntrinsicInstrCost(ICA, CostKind) == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">      return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">      return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">    // Assume that target intrinsics are cheap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">    // Assume that target intrinsics are cheap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">    Intrinsic::ID IID = ICA.getID();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">    Intrinsic::ID IID = ICA.getID();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">    if (Function::isTargetIntrinsic(IID))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">    if (Function::isTargetIntrinsic(IID))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">      return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">      return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">    if (ICA.isTypeBasedOnly())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">    if (ICA.isTypeBasedOnly())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">      return getTypeBasedIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">      return getTypeBasedIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">    Type *RetTy = ICA.getReturnType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">    Type *RetTy = ICA.getReturnType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">    ElementCount RetVF =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">    ElementCount RetVF =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">        (RetTy->isVectorTy() ? cast<VectorType>(RetTy)->getElementCount()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">        (RetTy->isVectorTy() ? cast<VectorType>(RetTy)->getElementCount()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">                             : ElementCount::getFixed(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">                             : ElementCount::getFixed(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">    const IntrinsicInst *I = ICA.getInst();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">    const IntrinsicInst *I = ICA.getInst();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">    const SmallVectorImpl<const Value *> &Args = ICA.getArgs();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">    const SmallVectorImpl<const Value *> &Args = ICA.getArgs();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">    FastMathFlags FMF = ICA.getFlags();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">    FastMathFlags FMF = ICA.getFlags();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">    switch (IID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">    switch (IID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">    default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">    case Intrinsic::powi:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">    case Intrinsic::powi:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">      if (auto *RHSC = dyn_cast<ConstantInt>(Args[1])) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">      if (auto *RHSC = dyn_cast<ConstantInt>(Args[1])) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">        bool ShouldOptForSize = I->getParent()->getParent()->hasOptSize();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">        bool ShouldOptForSize = I->getParent()->getParent()->hasOptSize();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">        if (getTLI()->isBeneficialToExpandPowI(RHSC->getSExtValue(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">        if (getTLI()->isBeneficialToExpandPowI(RHSC->getSExtValue(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">                                               ShouldOptForSize)) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">                                               ShouldOptForSize)) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">          // The cost is modeled on the expansion performed by ExpandPowI in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">          // The cost is modeled on the expansion performed by ExpandPowI in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">          // SelectionDAGBuilder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">          // SelectionDAGBuilder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">          APInt Exponent = RHSC->getValue().abs();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">          APInt Exponent = RHSC->getValue().abs();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">          unsigned ActiveBits = Exponent.getActiveBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">          unsigned ActiveBits = Exponent.getActiveBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">          unsigned PopCount = Exponent.popcount();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">          unsigned PopCount = Exponent.popcount();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">          InstructionCost Cost = (ActiveBits + PopCount - 2) *</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">          InstructionCost Cost = (ActiveBits + PopCount - 2) *</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">                                 thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">                                 thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">                                     Instruction::FMul, RetTy, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">                                     Instruction::FMul, RetTy, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">          if (RHSC->isNegative())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">          if (RHSC->isNegative())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">            Cost += thisT()->getArithmeticInstrCost(Instruction::FDiv, RetTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">            Cost += thisT()->getArithmeticInstrCost(Instruction::FDiv, RetTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">                                                    CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">                                                    CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">          return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">          return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">    case Intrinsic::cttz:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">    case Intrinsic::cttz:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">      // FIXME: If necessary, this should go in target-specific overrides.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">      // FIXME: If necessary, this should go in target-specific overrides.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">      if (RetVF.isScalar() && getTLI()->isCheapToSpeculateCttz(RetTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">      if (RetVF.isScalar() && getTLI()->isCheapToSpeculateCttz(RetTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">        return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">        return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">    case Intrinsic::ctlz:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">    case Intrinsic::ctlz:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">      // FIXME: If necessary, this should go in target-specific overrides.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">      // FIXME: If necessary, this should go in target-specific overrides.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">      if (RetVF.isScalar() && getTLI()->isCheapToSpeculateCtlz(RetTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">      if (RetVF.isScalar() && getTLI()->isCheapToSpeculateCtlz(RetTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">        return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">        return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">    case Intrinsic::memcpy:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">    case Intrinsic::memcpy:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">      return thisT()->getMemcpyCost(ICA.getInst());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">      return thisT()->getMemcpyCost(ICA.getInst());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">    case Intrinsic::masked_scatter: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">    case Intrinsic::masked_scatter: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">      const Value *Mask = Args[3];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">      const Value *Mask = Args[3];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">      bool VarMask = !isa<Constant>(Mask);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">      bool VarMask = !isa<Constant>(Mask);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">      Align Alignment = cast<ConstantInt>(Args[2])->getAlignValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">      Align Alignment = cast<ConstantInt>(Args[2])->getAlignValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">      return thisT()->getGatherScatterOpCost(Instruction::Store,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">      return thisT()->getGatherScatterOpCost(Instruction::Store,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">                                             ICA.getArgTypes()[0], Args[1],</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">                                             ICA.getArgTypes()[0], Args[1],</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">                                             VarMask, Alignment, CostKind, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">                                             VarMask, Alignment, CostKind, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine">    case Intrinsic::masked_gather: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine">    case Intrinsic::masked_gather: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">      const Value *Mask = Args[2];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">      const Value *Mask = Args[2];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">      bool VarMask = !isa<Constant>(Mask);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">      bool VarMask = !isa<Constant>(Mask);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">      Align Alignment = cast<ConstantInt>(Args[1])->getAlignValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">      Align Alignment = cast<ConstantInt>(Args[1])->getAlignValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">      return thisT()->getGatherScatterOpCost(Instruction::Load, RetTy, Args[0],</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">      return thisT()->getGatherScatterOpCost(Instruction::Load, RetTy, Args[0],</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">                                             VarMask, Alignment, CostKind, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">                                             VarMask, Alignment, CostKind, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">    case Intrinsic::experimental_stepvector: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">    case Intrinsic::experimental_stepvector: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(RetTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(RetTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">      // The cost of materialising a constant integer vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">      // The cost of materialising a constant integer vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">      return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">      return TargetTransformInfo::TCC_Basic;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">    case Intrinsic::vector_extract: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">    case Intrinsic::vector_extract: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">      // FIXME: Handle case where a scalable vector is extracted from a scalable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">      // FIXME: Handle case where a scalable vector is extracted from a scalable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">      // vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">      // vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(RetTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(RetTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">      unsigned Index = cast<ConstantInt>(Args[1])->getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">      unsigned Index = cast<ConstantInt>(Args[1])->getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">      return thisT()->getShuffleCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">      return thisT()->getShuffleCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">          TTI::SK_ExtractSubvector, cast<VectorType>(Args[0]->getType()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">          TTI::SK_ExtractSubvector, cast<VectorType>(Args[0]->getType()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">          std::nullopt, CostKind, Index, cast<VectorType>(RetTy));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">          std::nullopt, CostKind, Index, cast<VectorType>(RetTy));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">    case Intrinsic::vector_insert: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">    case Intrinsic::vector_insert: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">      // FIXME: Handle case where a scalable vector is inserted into a scalable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">      // FIXME: Handle case where a scalable vector is inserted into a scalable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">      // vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">      // vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(Args[1]->getType()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(Args[1]->getType()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">        return BaseT::getIntrinsicInstrCost(ICA, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">      unsigned Index = cast<ConstantInt>(Args[2])->getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">      unsigned Index = cast<ConstantInt>(Args[2])->getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">      return thisT()->getShuffleCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">      return thisT()->getShuffleCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">          TTI::SK_InsertSubvector, cast<VectorType>(Args[0]->getType()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">          TTI::SK_InsertSubvector, cast<VectorType>(Args[0]->getType()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">          std::nullopt, CostKind, Index, cast<VectorType>(Args[1]->getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">          std::nullopt, CostKind, Index, cast<VectorType>(Args[1]->getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">    case Intrinsic::experimental_vector_reverse: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">    case Intrinsic::experimental_vector_reverse: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">      return thisT()->getShuffleCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">      return thisT()->getShuffleCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">          TTI::SK_Reverse, cast<VectorType>(Args[0]->getType()), std::nullopt,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">          TTI::SK_Reverse, cast<VectorType>(Args[0]->getType()), std::nullopt,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">          CostKind, 0, cast<VectorType>(RetTy));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">          CostKind, 0, cast<VectorType>(RetTy));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">    case Intrinsic::experimental_vector_splice: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">    case Intrinsic::experimental_vector_splice: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine">      unsigned Index = cast<ConstantInt>(Args[2])->getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine">      unsigned Index = cast<ConstantInt>(Args[2])->getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">      return thisT()->getShuffleCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">      return thisT()->getShuffleCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">          TTI::SK_Splice, cast<VectorType>(Args[0]->getType()), std::nullopt,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">          TTI::SK_Splice, cast<VectorType>(Args[0]->getType()), std::nullopt,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">          CostKind, Index, cast<VectorType>(RetTy));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">          CostKind, Index, cast<VectorType>(RetTy));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_add:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_add:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_mul:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_mul:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_and:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_and:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_or:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_or:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_xor:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_xor:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_smax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_smax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_smin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_smin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmaximum:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmaximum:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fminimum:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fminimum:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_umax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_umax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_umin: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_umin: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(IID, RetTy, Args[0]->getType(), FMF, I, 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(IID, RetTy, Args[0]->getType(), FMF, I, 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">      return getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">      return getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fadd:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fadd:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmul: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmul: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">          IID, RetTy, {Args[0]->getType(), Args[1]->getType()}, FMF, I, 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">          IID, RetTy, {Args[0]->getType(), Args[1]->getType()}, FMF, I, 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">      return getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">      return getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">    case Intrinsic::fshl:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">    case Intrinsic::fshl:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">    case Intrinsic::fshr: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">    case Intrinsic::fshr: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">      const Value *X = Args[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">      const Value *X = Args[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">      const Value *Y = Args[1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">      const Value *Y = Args[1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine">      const Value *Z = Args[2];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine">      const Value *Z = Args[2];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">      const TTI::OperandValueInfo OpInfoX = TTI::getOperandInfo(X);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">      const TTI::OperandValueInfo OpInfoX = TTI::getOperandInfo(X);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">      const TTI::OperandValueInfo OpInfoY = TTI::getOperandInfo(Y);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">      const TTI::OperandValueInfo OpInfoY = TTI::getOperandInfo(Y);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">      const TTI::OperandValueInfo OpInfoZ = TTI::getOperandInfo(Z);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">      const TTI::OperandValueInfo OpInfoZ = TTI::getOperandInfo(Z);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">      const TTI::OperandValueInfo OpInfoBW =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">      const TTI::OperandValueInfo OpInfoBW =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">        {TTI::OK_UniformConstantValue,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">        {TTI::OK_UniformConstantValue,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">         isPowerOf2_32(RetTy->getScalarSizeInBits()) ? TTI::OP_PowerOf2</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">         isPowerOf2_32(RetTy->getScalarSizeInBits()) ? TTI::OP_PowerOf2</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">         : TTI::OP_None};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">         : TTI::OP_None};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">      // fshl: (X << (Z % BW)) | (Y >> (BW - (Z % BW)))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">      // fshl: (X << (Z % BW)) | (Y >> (BW - (Z % BW)))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">      // fshr: (X << (BW - (Z % BW))) | (Y >> (Z % BW))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">      // fshr: (X << (BW - (Z % BW))) | (Y >> (Z % BW))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">          thisT()->getArithmeticInstrCost(BinaryOperator::Or, RetTy, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">          thisT()->getArithmeticInstrCost(BinaryOperator::Or, RetTy, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">          thisT()->getArithmeticInstrCost(BinaryOperator::Sub, RetTy, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">          thisT()->getArithmeticInstrCost(BinaryOperator::Sub, RetTy, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">          BinaryOperator::Shl, RetTy, CostKind, OpInfoX,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">          BinaryOperator::Shl, RetTy, CostKind, OpInfoX,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">          {OpInfoZ.Kind, TTI::OP_None});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">          {OpInfoZ.Kind, TTI::OP_None});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">          BinaryOperator::LShr, RetTy, CostKind, OpInfoY,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">          BinaryOperator::LShr, RetTy, CostKind, OpInfoY,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">          {OpInfoZ.Kind, TTI::OP_None});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">          {OpInfoZ.Kind, TTI::OP_None});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">      // Non-constant shift amounts requires a modulo.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">      // Non-constant shift amounts requires a modulo.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">      if (!OpInfoZ.isConstant())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">      if (!OpInfoZ.isConstant())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">        Cost += thisT()->getArithmeticInstrCost(BinaryOperator::URem, RetTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">        Cost += thisT()->getArithmeticInstrCost(BinaryOperator::URem, RetTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">                                                CostKind, OpInfoZ, OpInfoBW);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">                                                CostKind, OpInfoZ, OpInfoBW);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">      // For non-rotates (X != Y) we must add shift-by-zero handling costs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">      // For non-rotates (X != Y) we must add shift-by-zero handling costs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">      if (X != Y) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">      if (X != Y) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">        Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">        Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">        Cost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">        Cost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">            thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">            thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">                                        CmpInst::ICMP_EQ, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">                                        CmpInst::ICMP_EQ, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">        Cost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">        Cost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">            thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">            thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">                                        CmpInst::ICMP_EQ, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">                                        CmpInst::ICMP_EQ, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">    case Intrinsic::get_active_lane_mask: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">    case Intrinsic::get_active_lane_mask: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">      EVT ResVT = getTLI()->getValueType(DL, RetTy, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">      EVT ResVT = getTLI()->getValueType(DL, RetTy, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">      EVT ArgType = getTLI()->getValueType(DL, ICA.getArgTypes()[0], true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">      EVT ArgType = getTLI()->getValueType(DL, ICA.getArgTypes()[0], true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">      // If we're not expanding the intrinsic then we assume this is cheap</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">      // If we're not expanding the intrinsic then we assume this is cheap</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">      // to implement.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">      // to implement.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">      if (!getTLI()->shouldExpandGetActiveLaneMask(ResVT, ArgType)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">      if (!getTLI()->shouldExpandGetActiveLaneMask(ResVT, ArgType)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">        return getTypeLegalizationCost(RetTy).first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">        return getTypeLegalizationCost(RetTy).first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">      // Create the expanded types that will be used to calculate the uadd_sat</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">      // Create the expanded types that will be used to calculate the uadd_sat</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">      // operation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">      // operation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">      Type *ExpRetTy = VectorType::get(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">      Type *ExpRetTy = VectorType::get(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">          ICA.getArgTypes()[0], cast<VectorType>(RetTy)->getElementCount());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">          ICA.getArgTypes()[0], cast<VectorType>(RetTy)->getElementCount());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(Intrinsic::uadd_sat, ExpRetTy, {}, FMF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(Intrinsic::uadd_sat, ExpRetTy, {}, FMF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">      InstructionCost Cost =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">      InstructionCost Cost =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">          thisT()->getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">          thisT()->getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, ExpRetTy, RetTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, ExpRetTy, RetTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine">                                          CmpInst::ICMP_ULT, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine">                                          CmpInst::ICMP_ULT, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">    // Assume that we need to scalarize this intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">    // Assume that we need to scalarize this intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">    // Compute the scalarization overhead based on Args for a vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">    // Compute the scalarization overhead based on Args for a vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">    // intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">    // intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">    InstructionCost ScalarizationCost = InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">    InstructionCost ScalarizationCost = InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">    if (RetVF.isVector() && !RetVF.isScalable()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">    if (RetVF.isVector() && !RetVF.isScalable()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">      ScalarizationCost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">      ScalarizationCost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">      if (!RetTy->isVoidTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">      if (!RetTy->isVoidTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">        ScalarizationCost += getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">        ScalarizationCost += getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">            cast<VectorType>(RetTy),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">            cast<VectorType>(RetTy),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">            /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">            /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">      ScalarizationCost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">      ScalarizationCost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">          getOperandsScalarizationOverhead(Args, ICA.getArgTypes(), CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">          getOperandsScalarizationOverhead(Args, ICA.getArgTypes(), CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">    IntrinsicCostAttributes Attrs(IID, RetTy, ICA.getArgTypes(), FMF, I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">    IntrinsicCostAttributes Attrs(IID, RetTy, ICA.getArgTypes(), FMF, I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">                                  ScalarizationCost);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">                                  ScalarizationCost);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">    return thisT()->getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">    return thisT()->getTypeBasedIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">  /// Get intrinsic cost based on argument types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">  /// Get intrinsic cost based on argument types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">  /// If ScalarizationCostPassed is std::numeric_limits<unsigned>::max(), the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">  /// If ScalarizationCostPassed is std::numeric_limits<unsigned>::max(), the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">  /// cost of scalarizing the arguments and the return value will be computed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">  /// cost of scalarizing the arguments and the return value will be computed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">  /// based on types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">  /// based on types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">  InstructionCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">  getTypeBasedIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">  getTypeBasedIntrinsicInstrCost(const IntrinsicCostAttributes &ICA,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">                                 TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">                                 TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">    Intrinsic::ID IID = ICA.getID();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">    Intrinsic::ID IID = ICA.getID();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">    Type *RetTy = ICA.getReturnType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">    Type *RetTy = ICA.getReturnType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">    const SmallVectorImpl<Type *> &Tys = ICA.getArgTypes();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">    const SmallVectorImpl<Type *> &Tys = ICA.getArgTypes();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">    FastMathFlags FMF = ICA.getFlags();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">    FastMathFlags FMF = ICA.getFlags();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">    InstructionCost ScalarizationCostPassed = ICA.getScalarizationCost();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">    InstructionCost ScalarizationCostPassed = ICA.getScalarizationCost();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">    bool SkipScalarizationCost = ICA.skipScalarizationCost();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">    bool SkipScalarizationCost = ICA.skipScalarizationCost();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">    VectorType *VecOpTy = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">    VectorType *VecOpTy = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">    if (!Tys.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">    if (!Tys.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">      // The vector reduction operand is operand 0 except for fadd/fmul.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">      // The vector reduction operand is operand 0 except for fadd/fmul.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">      // Their operand 0 is a scalar start value, so the vector op is operand 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">      // Their operand 0 is a scalar start value, so the vector op is operand 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">      unsigned VecTyIndex = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">      unsigned VecTyIndex = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">      if (IID == Intrinsic::vector_reduce_fadd ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">      if (IID == Intrinsic::vector_reduce_fadd ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">          IID == Intrinsic::vector_reduce_fmul)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">          IID == Intrinsic::vector_reduce_fmul)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine">        VecTyIndex = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine">        VecTyIndex = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">      assert(Tys.size() > VecTyIndex && "Unexpected IntrinsicCostAttributes");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">      assert(Tys.size() > VecTyIndex && "Unexpected IntrinsicCostAttributes");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">      VecOpTy = dyn_cast<VectorType>(Tys[VecTyIndex]);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">      VecOpTy = dyn_cast<VectorType>(Tys[VecTyIndex]);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">    // Library call cost - other than size, make it expensive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">    // Library call cost - other than size, make it expensive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">    unsigned SingleCallCost = CostKind == TTI::TCK_CodeSize ? 1 : 10;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">    unsigned SingleCallCost = CostKind == TTI::TCK_CodeSize ? 1 : 10;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">    unsigned ISD = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">    unsigned ISD = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">    switch (IID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">    switch (IID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">    default: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">    default: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">      // Scalable vectors cannot be scalarized, so return Invalid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">      // Scalable vectors cannot be scalarized, so return Invalid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(RetTy) || any_of(Tys, [](const Type *Ty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(RetTy) || any_of(Tys, [](const Type *Ty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">            return isa<ScalableVectorType>(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">            return isa<ScalableVectorType>(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">          }))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">          }))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">        return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">        return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">      // Assume that we need to scalarize this intrinsic.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">      // Assume that we need to scalarize this intrinsic.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">      InstructionCost ScalarizationCost =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">      InstructionCost ScalarizationCost =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">          SkipScalarizationCost ? ScalarizationCostPassed : 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">          SkipScalarizationCost ? ScalarizationCostPassed : 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">      unsigned ScalarCalls = 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">      unsigned ScalarCalls = 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">      Type *ScalarRetTy = RetTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">      Type *ScalarRetTy = RetTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">      if (auto *RetVTy = dyn_cast<VectorType>(RetTy)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">      if (auto *RetVTy = dyn_cast<VectorType>(RetTy)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">        if (!SkipScalarizationCost)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">        if (!SkipScalarizationCost)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">          ScalarizationCost = getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">          ScalarizationCost = getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">              RetVTy, /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">              RetVTy, /*Insert*/ true, /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">        ScalarCalls = std::max(ScalarCalls,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">        ScalarCalls = std::max(ScalarCalls,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">                               cast<FixedVectorType>(RetVTy)->getNumElements());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">                               cast<FixedVectorType>(RetVTy)->getNumElements());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">        ScalarRetTy = RetTy->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">        ScalarRetTy = RetTy->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">      SmallVector<Type *, 4> ScalarTys;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">      SmallVector<Type *, 4> ScalarTys;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">        Type *Ty = Tys[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">        Type *Ty = Tys[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">        if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">        if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">          if (!SkipScalarizationCost)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">          if (!SkipScalarizationCost)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">            ScalarizationCost += getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">            ScalarizationCost += getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">                VTy, /*Insert*/ false, /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">                VTy, /*Insert*/ false, /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">          ScalarCalls = std::max(ScalarCalls,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">          ScalarCalls = std::max(ScalarCalls,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">                                 cast<FixedVectorType>(VTy)->getNumElements());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">                                 cast<FixedVectorType>(VTy)->getNumElements());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">          Ty = Ty->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">          Ty = Ty->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">        ScalarTys.push_back(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">        ScalarTys.push_back(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">      if (ScalarCalls == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">      if (ScalarCalls == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">        return 1; // Return cost of a scalar intrinsic. Assume it to be cheap.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">        return 1; // Return cost of a scalar intrinsic. Assume it to be cheap.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">      IntrinsicCostAttributes ScalarAttrs(IID, ScalarRetTy, ScalarTys, FMF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">      IntrinsicCostAttributes ScalarAttrs(IID, ScalarRetTy, ScalarTys, FMF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">      InstructionCost ScalarCost =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">      InstructionCost ScalarCost =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">          thisT()->getIntrinsicInstrCost(ScalarAttrs, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">          thisT()->getIntrinsicInstrCost(ScalarAttrs, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">      return ScalarCalls * ScalarCost + ScalarizationCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">      return ScalarCalls * ScalarCost + ScalarizationCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">    // Look for intrinsics that can be lowered directly or turned into a scalar</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">    // Look for intrinsics that can be lowered directly or turned into a scalar</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">    // intrinsic call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">    // intrinsic call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">    case Intrinsic::sqrt:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">    case Intrinsic::sqrt:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">      ISD = ISD::FSQRT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">      ISD = ISD::FSQRT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">    case Intrinsic::sin:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">    case Intrinsic::sin:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">      ISD = ISD::FSIN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">      ISD = ISD::FSIN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">    case Intrinsic::cos:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">    case Intrinsic::cos:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">      ISD = ISD::FCOS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">      ISD = ISD::FCOS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">    case Intrinsic::exp:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">    case Intrinsic::exp:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">      ISD = ISD::FEXP;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">      ISD = ISD::FEXP;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">    case Intrinsic::exp2:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">    case Intrinsic::exp2:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">      ISD = ISD::FEXP2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">      ISD = ISD::FEXP2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">    case Intrinsic::log:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">    case Intrinsic::log:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">      ISD = ISD::FLOG;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">      ISD = ISD::FLOG;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">    case Intrinsic::log10:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">    case Intrinsic::log10:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">      ISD = ISD::FLOG10;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">      ISD = ISD::FLOG10;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">    case Intrinsic::log2:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">    case Intrinsic::log2:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">      ISD = ISD::FLOG2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">      ISD = ISD::FLOG2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">    case Intrinsic::fabs:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">    case Intrinsic::fabs:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">      ISD = ISD::FABS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">      ISD = ISD::FABS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">    case Intrinsic::canonicalize:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">    case Intrinsic::canonicalize:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">      ISD = ISD::FCANONICALIZE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">      ISD = ISD::FCANONICALIZE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">    case Intrinsic::minnum:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">    case Intrinsic::minnum:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">      ISD = ISD::FMINNUM;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">      ISD = ISD::FMINNUM;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">    case Intrinsic::maxnum:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">    case Intrinsic::maxnum:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">      ISD = ISD::FMAXNUM;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">      ISD = ISD::FMAXNUM;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">    case Intrinsic::minimum:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">    case Intrinsic::minimum:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">      ISD = ISD::FMINIMUM;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">      ISD = ISD::FMINIMUM;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">    case Intrinsic::maximum:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">    case Intrinsic::maximum:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">      ISD = ISD::FMAXIMUM;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">      ISD = ISD::FMAXIMUM;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">    case Intrinsic::copysign:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">    case Intrinsic::copysign:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">      ISD = ISD::FCOPYSIGN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">      ISD = ISD::FCOPYSIGN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">    case Intrinsic::floor:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">    case Intrinsic::floor:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">      ISD = ISD::FFLOOR;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">      ISD = ISD::FFLOOR;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">    case Intrinsic::ceil:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">    case Intrinsic::ceil:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">      ISD = ISD::FCEIL;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">      ISD = ISD::FCEIL;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">    case Intrinsic::trunc:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">    case Intrinsic::trunc:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">      ISD = ISD::FTRUNC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">      ISD = ISD::FTRUNC;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">    case Intrinsic::nearbyint:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">    case Intrinsic::nearbyint:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">      ISD = ISD::FNEARBYINT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">      ISD = ISD::FNEARBYINT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">    case Intrinsic::rint:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">    case Intrinsic::rint:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">      ISD = ISD::FRINT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">      ISD = ISD::FRINT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">    case Intrinsic::round:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">    case Intrinsic::round:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">      ISD = ISD::FROUND;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">      ISD = ISD::FROUND;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">    case Intrinsic::roundeven:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">    case Intrinsic::roundeven:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">      ISD = ISD::FROUNDEVEN;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">      ISD = ISD::FROUNDEVEN;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">    case Intrinsic::pow:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">    case Intrinsic::pow:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">      ISD = ISD::FPOW;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">      ISD = ISD::FPOW;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine">    case Intrinsic::fma:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine">    case Intrinsic::fma:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">      ISD = ISD::FMA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">      ISD = ISD::FMA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">    case Intrinsic::fmuladd:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">    case Intrinsic::fmuladd:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">      ISD = ISD::FMA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">      ISD = ISD::FMA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">    case Intrinsic::experimental_constrained_fmuladd:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">    case Intrinsic::experimental_constrained_fmuladd:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">      ISD = ISD::STRICT_FMA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">      ISD = ISD::STRICT_FMA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">    // FIXME: We should return 0 whenever getIntrinsicCost == TCC_Free.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">    // FIXME: We should return 0 whenever getIntrinsicCost == TCC_Free.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">    case Intrinsic::lifetime_start:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">    case Intrinsic::lifetime_start:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">    case Intrinsic::lifetime_end:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">    case Intrinsic::lifetime_end:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">    case Intrinsic::sideeffect:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">    case Intrinsic::sideeffect:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">    case Intrinsic::pseudoprobe:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">    case Intrinsic::pseudoprobe:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">    case Intrinsic::arithmetic_fence:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">    case Intrinsic::arithmetic_fence:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">      return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">      return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">    case Intrinsic::masked_store: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">    case Intrinsic::masked_store: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">      Type *Ty = Tys[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">      Type *Ty = Tys[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">      Align TyAlign = thisT()->DL.getABITypeAlign(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">      Align TyAlign = thisT()->DL.getABITypeAlign(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">      return thisT()->getMaskedMemoryOpCost(Instruction::Store, Ty, TyAlign, 0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">      return thisT()->getMaskedMemoryOpCost(Instruction::Store, Ty, TyAlign, 0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">                                            CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">                                            CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">    case Intrinsic::masked_load: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">    case Intrinsic::masked_load: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">      Type *Ty = RetTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">      Type *Ty = RetTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">      Align TyAlign = thisT()->DL.getABITypeAlign(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">      Align TyAlign = thisT()->DL.getABITypeAlign(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">      return thisT()->getMaskedMemoryOpCost(Instruction::Load, Ty, TyAlign, 0,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">      return thisT()->getMaskedMemoryOpCost(Instruction::Load, Ty, TyAlign, 0,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">                                            CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">                                            CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_add:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_add:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::Add, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::Add, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_mul:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_mul:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::Mul, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::Mul, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_and:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_and:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::And, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::And, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_or:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_or:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::Or, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::Or, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_xor:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_xor:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::Xor, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::Xor, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">                                                 std::nullopt, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fadd:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fadd:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::FAdd, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::FAdd, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">                                                 FMF, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">                                                 FMF, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmul:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmul:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::FMul, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">      return thisT()->getArithmeticReductionCost(Instruction::FMul, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">                                                 FMF, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">                                                 FMF, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_smax:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_smax:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::smax, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::smax, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_smin:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_smin:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::smin, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::smin, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_umax:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_umax:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::umax, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::umax, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_umin:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_umin:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::umin, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::umin, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmax:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmax:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::maxnum, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::maxnum, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmin:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmin:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::minnum, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::minnum, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmaximum:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fmaximum:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::maximum, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::maximum, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fminimum:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">    case Intrinsic::vector_reduce_fminimum:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::minimum, VecOpTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">      return thisT()->getMinMaxReductionCost(Intrinsic::minimum, VecOpTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">                                             ICA.getFlags(), CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">    case Intrinsic::abs: {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">    case Intrinsic::abs: {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">      // abs(X) = select(icmp(X,0),X,sub(0,X))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">      // abs(X) = select(icmp(X,0),X,sub(0,X))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine">      CmpInst::Predicate Pred = CmpInst::ICMP_SGT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine">      CmpInst::Predicate Pred = CmpInst::ICMP_SGT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">                                          Pred, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">                                          Pred, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine">                                          Pred, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine">                                          Pred, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">      // TODO: Should we add an OperandValueProperties::OP_Zero property?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">      // TODO: Should we add an OperandValueProperties::OP_Zero property?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">         BinaryOperator::Sub, RetTy, CostKind, {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">         BinaryOperator::Sub, RetTy, CostKind, {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine">    case Intrinsic::smax:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine">    case Intrinsic::smax:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">    case Intrinsic::smin:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">    case Intrinsic::smin:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">    case Intrinsic::umax:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">    case Intrinsic::umax:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">    case Intrinsic::umin: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">    case Intrinsic::umin: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">      // minmax(X,Y) = select(icmp(X,Y),X,Y)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">      // minmax(X,Y) = select(icmp(X,Y),X,Y)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">      bool IsUnsigned = IID == Intrinsic::umax || IID == Intrinsic::umin;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">      bool IsUnsigned = IID == Intrinsic::umax || IID == Intrinsic::umin;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">      CmpInst::Predicate Pred =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">      CmpInst::Predicate Pred =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">          IsUnsigned ? CmpInst::ICMP_UGT : CmpInst::ICMP_SGT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">          IsUnsigned ? CmpInst::ICMP_UGT : CmpInst::ICMP_SGT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">                                          Pred, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">                                          Pred, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">                                          Pred, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">                                          Pred, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">    case Intrinsic::sadd_sat:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">    case Intrinsic::sadd_sat:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">    case Intrinsic::ssub_sat: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">    case Intrinsic::ssub_sat: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">      Type *OpTy = StructType::create({RetTy, CondTy});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">      Type *OpTy = StructType::create({RetTy, CondTy});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">      Intrinsic::ID OverflowOp = IID == Intrinsic::sadd_sat</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">      Intrinsic::ID OverflowOp = IID == Intrinsic::sadd_sat</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">                                     ? Intrinsic::sadd_with_overflow</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">                                     ? Intrinsic::sadd_with_overflow</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">                                     : Intrinsic::ssub_with_overflow;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">                                     : Intrinsic::ssub_with_overflow;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">      CmpInst::Predicate Pred = CmpInst::ICMP_SGT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">      CmpInst::Predicate Pred = CmpInst::ICMP_SGT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">      // SatMax -> Overflow && SumDiff < 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">      // SatMax -> Overflow && SumDiff < 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">      // SatMin -> Overflow && SumDiff >= 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">      // SatMin -> Overflow && SumDiff >= 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(OverflowOp, OpTy, {RetTy, RetTy}, FMF,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(OverflowOp, OpTy, {RetTy, RetTy}, FMF,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">                                    nullptr, ScalarizationCostPassed);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">                                    nullptr, ScalarizationCostPassed);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">      Cost += thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">      Cost += thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">                                          Pred, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">                                          Pred, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">      Cost += 2 * thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">      Cost += 2 * thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">                                              CondTy, Pred, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">                                              CondTy, Pred, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">    case Intrinsic::uadd_sat:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">    case Intrinsic::uadd_sat:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">    case Intrinsic::usub_sat: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">    case Intrinsic::usub_sat: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">      Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">      Type *OpTy = StructType::create({RetTy, CondTy});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">      Type *OpTy = StructType::create({RetTy, CondTy});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">      Intrinsic::ID OverflowOp = IID == Intrinsic::uadd_sat</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">      Intrinsic::ID OverflowOp = IID == Intrinsic::uadd_sat</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">                                     ? Intrinsic::uadd_with_overflow</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">                                     ? Intrinsic::uadd_with_overflow</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">                                     : Intrinsic::usub_with_overflow;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">                                     : Intrinsic::usub_with_overflow;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(OverflowOp, OpTy, {RetTy, RetTy}, FMF,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(OverflowOp, OpTy, {RetTy, RetTy}, FMF,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine">                                    nullptr, ScalarizationCostPassed);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine">                                    nullptr, ScalarizationCostPassed);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">      Cost += thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">      Cost += thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">          thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">          thisT()->getCmpSelInstrCost(BinaryOperator::Select, RetTy, CondTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">                                      CmpInst::BAD_ICMP_PREDICATE, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">                                      CmpInst::BAD_ICMP_PREDICATE, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">    case Intrinsic::smul_fix:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">    case Intrinsic::smul_fix:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">    case Intrinsic::umul_fix: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">    case Intrinsic::umul_fix: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">      unsigned ExtSize = RetTy->getScalarSizeInBits() * 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">      unsigned ExtSize = RetTy->getScalarSizeInBits() * 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine">      Type *ExtTy = RetTy->getWithNewBitWidth(ExtSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine">      Type *ExtTy = RetTy->getWithNewBitWidth(ExtSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">      unsigned ExtOp =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">      unsigned ExtOp =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">          IID == Intrinsic::smul_fix ? Instruction::SExt : Instruction::ZExt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">          IID == Intrinsic::smul_fix ? Instruction::SExt : Instruction::ZExt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">      TTI::CastContextHint CCH = TTI::CastContextHint::None;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">      TTI::CastContextHint CCH = TTI::CastContextHint::None;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">      Cost += 2 * thisT()->getCastInstrCost(ExtOp, ExtTy, RetTy, CCH, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">      Cost += 2 * thisT()->getCastInstrCost(ExtOp, ExtTy, RetTy, CCH, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">          thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">          thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">      Cost += 2 * thisT()->getCastInstrCost(Instruction::Trunc, RetTy, ExtTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">      Cost += 2 * thisT()->getCastInstrCost(Instruction::Trunc, RetTy, ExtTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">                                            CCH, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">                                            CCH, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(Instruction::LShr, RetTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(Instruction::LShr, RetTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">                                              CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">                                              CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(Instruction::Shl, RetTy, CostKind,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(Instruction::Shl, RetTy, CostKind,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(Instruction::Or, RetTy, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(Instruction::Or, RetTy, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">    case Intrinsic::sadd_with_overflow:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">    case Intrinsic::sadd_with_overflow:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">    case Intrinsic::ssub_with_overflow: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">    case Intrinsic::ssub_with_overflow: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">      Type *SumTy = RetTy->getContainedType(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">      Type *SumTy = RetTy->getContainedType(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">      Type *OverflowTy = RetTy->getContainedType(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">      Type *OverflowTy = RetTy->getContainedType(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">      unsigned Opcode = IID == Intrinsic::sadd_with_overflow</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">      unsigned Opcode = IID == Intrinsic::sadd_with_overflow</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">                            ? BinaryOperator::Add</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">                            ? BinaryOperator::Add</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">                            : BinaryOperator::Sub;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">                            : BinaryOperator::Sub;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">      //   Add:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">      //   Add:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">      //   Overflow -> (Result < LHS) ^ (RHS < 0)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">      //   Overflow -> (Result < LHS) ^ (RHS < 0)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">      //   Sub:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">      //   Sub:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">      //   Overflow -> (Result < LHS) ^ (RHS > 0)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">      //   Overflow -> (Result < LHS) ^ (RHS > 0)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(Opcode, SumTy, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(Opcode, SumTy, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">      Cost += 2 * thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">      Cost += 2 * thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">                      Instruction::ICmp, SumTy, OverflowTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">                      Instruction::ICmp, SumTy, OverflowTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">                      CmpInst::ICMP_SGT, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">                      CmpInst::ICMP_SGT, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(BinaryOperator::Xor, OverflowTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(BinaryOperator::Xor, OverflowTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">                                              CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">                                              CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">    case Intrinsic::uadd_with_overflow:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">    case Intrinsic::uadd_with_overflow:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">    case Intrinsic::usub_with_overflow: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">    case Intrinsic::usub_with_overflow: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">      Type *SumTy = RetTy->getContainedType(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">      Type *SumTy = RetTy->getContainedType(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">      Type *OverflowTy = RetTy->getContainedType(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">      Type *OverflowTy = RetTy->getContainedType(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">      unsigned Opcode = IID == Intrinsic::uadd_with_overflow</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">      unsigned Opcode = IID == Intrinsic::uadd_with_overflow</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">                            ? BinaryOperator::Add</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">                            ? BinaryOperator::Add</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">                            : BinaryOperator::Sub;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">                            : BinaryOperator::Sub;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">      CmpInst::Predicate Pred = IID == Intrinsic::uadd_with_overflow</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">      CmpInst::Predicate Pred = IID == Intrinsic::uadd_with_overflow</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">                                    ? CmpInst::ICMP_ULT</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">                                    ? CmpInst::ICMP_ULT</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">                                    : CmpInst::ICMP_UGT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">                                    : CmpInst::ICMP_UGT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(Opcode, SumTy, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(Opcode, SumTy, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">          thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, SumTy, OverflowTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">          thisT()->getCmpSelInstrCost(BinaryOperator::ICmp, SumTy, OverflowTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine">                                      Pred, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine">                                      Pred, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">    case Intrinsic::smul_with_overflow:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">    case Intrinsic::smul_with_overflow:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">    case Intrinsic::umul_with_overflow: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">    case Intrinsic::umul_with_overflow: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">      Type *MulTy = RetTy->getContainedType(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">      Type *MulTy = RetTy->getContainedType(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">      Type *OverflowTy = RetTy->getContainedType(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">      Type *OverflowTy = RetTy->getContainedType(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">      unsigned ExtSize = MulTy->getScalarSizeInBits() * 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">      unsigned ExtSize = MulTy->getScalarSizeInBits() * 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">      Type *ExtTy = MulTy->getWithNewBitWidth(ExtSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">      Type *ExtTy = MulTy->getWithNewBitWidth(ExtSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">      bool IsSigned = IID == Intrinsic::smul_with_overflow;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">      bool IsSigned = IID == Intrinsic::smul_with_overflow;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">      unsigned ExtOp = IsSigned ? Instruction::SExt : Instruction::ZExt;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">      unsigned ExtOp = IsSigned ? Instruction::SExt : Instruction::ZExt;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">      TTI::CastContextHint CCH = TTI::CastContextHint::None;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">      TTI::CastContextHint CCH = TTI::CastContextHint::None;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">      Cost += 2 * thisT()->getCastInstrCost(ExtOp, ExtTy, MulTy, CCH, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">      Cost += 2 * thisT()->getCastInstrCost(ExtOp, ExtTy, MulTy, CCH, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">      Cost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">          thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">          thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">      Cost += 2 * thisT()->getCastInstrCost(Instruction::Trunc, MulTy, ExtTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">      Cost += 2 * thisT()->getCastInstrCost(Instruction::Trunc, MulTy, ExtTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">                                            CCH, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">                                            CCH, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(Instruction::LShr, ExtTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">      Cost += thisT()->getArithmeticInstrCost(Instruction::LShr, ExtTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">                                              CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">                                              CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">                                              {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">                                              {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">      if (IsSigned)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">      if (IsSigned)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine">        Cost += thisT()->getArithmeticInstrCost(Instruction::AShr, MulTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine">        Cost += thisT()->getArithmeticInstrCost(Instruction::AShr, MulTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">                                                CostKind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">                                                CostKind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">                                                {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">                                                {TTI::OK_AnyValue, TTI::OP_None},</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine">                                                {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine">                                                {TTI::OK_UniformConstantValue, TTI::OP_None});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">      Cost += thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">          BinaryOperator::ICmp, MulTy, OverflowTy, CmpInst::ICMP_NE, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">          BinaryOperator::ICmp, MulTy, OverflowTy, CmpInst::ICMP_NE, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">    case Intrinsic::fptosi_sat:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">    case Intrinsic::fptosi_sat:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">    case Intrinsic::fptoui_sat: {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">    case Intrinsic::fptoui_sat: {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">      if (Tys.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">      if (Tys.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">      Type *FromTy = Tys[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">      Type *FromTy = Tys[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">      bool IsSigned = IID == Intrinsic::fptosi_sat;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">      bool IsSigned = IID == Intrinsic::fptosi_sat;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">      InstructionCost Cost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs1(Intrinsic::minnum, FromTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs1(Intrinsic::minnum, FromTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">                                     {FromTy, FromTy});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">                                     {FromTy, FromTy});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">      Cost += thisT()->getIntrinsicInstrCost(Attrs1, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">      Cost += thisT()->getIntrinsicInstrCost(Attrs1, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs2(Intrinsic::maxnum, FromTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs2(Intrinsic::maxnum, FromTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">                                     {FromTy, FromTy});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">                                     {FromTy, FromTy});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">      Cost += thisT()->getIntrinsicInstrCost(Attrs2, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">      Cost += thisT()->getIntrinsicInstrCost(Attrs2, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine">      Cost += thisT()->getCastInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine">      Cost += thisT()->getCastInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">          IsSigned ? Instruction::FPToSI : Instruction::FPToUI, RetTy, FromTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">          IsSigned ? Instruction::FPToSI : Instruction::FPToUI, RetTy, FromTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">          TTI::CastContextHint::None, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">          TTI::CastContextHint::None, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">      if (IsSigned) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">      if (IsSigned) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">        Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">        Type *CondTy = RetTy->getWithNewBitWidth(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">        Cost += thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">        Cost += thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">            BinaryOperator::FCmp, FromTy, CondTy, CmpInst::FCMP_UNO, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">            BinaryOperator::FCmp, FromTy, CondTy, CmpInst::FCMP_UNO, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">        Cost += thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">        Cost += thisT()->getCmpSelInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">            BinaryOperator::Select, RetTy, CondTy, CmpInst::FCMP_UNO, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">            BinaryOperator::Select, RetTy, CondTy, CmpInst::FCMP_UNO, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">      return Cost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">    case Intrinsic::ctpop:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">    case Intrinsic::ctpop:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">      ISD = ISD::CTPOP;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">      ISD = ISD::CTPOP;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">      // In case of legalization use TCC_Expensive. This is cheaper than a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">      // In case of legalization use TCC_Expensive. This is cheaper than a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">      // library call but still not a cheap instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">      // library call but still not a cheap instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">      SingleCallCost = TargetTransformInfo::TCC_Expensive;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">      SingleCallCost = TargetTransformInfo::TCC_Expensive;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">    case Intrinsic::ctlz:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">    case Intrinsic::ctlz:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine">      ISD = ISD::CTLZ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine">      ISD = ISD::CTLZ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">    case Intrinsic::cttz:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">    case Intrinsic::cttz:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">      ISD = ISD::CTTZ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">      ISD = ISD::CTTZ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">    case Intrinsic::bswap:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">    case Intrinsic::bswap:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">      ISD = ISD::BSWAP;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">      ISD = ISD::BSWAP;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">    case Intrinsic::bitreverse:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">    case Intrinsic::bitreverse:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">      ISD = ISD::BITREVERSE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">      ISD = ISD::BITREVERSE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">    const TargetLoweringBase *TLI = getTLI();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(RetTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(RetTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">    if (TLI->isOperationLegalOrPromote(ISD, LT.second)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">    if (TLI->isOperationLegalOrPromote(ISD, LT.second)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">      if (IID == Intrinsic::fabs && LT.second.isFloatingPoint() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">      if (IID == Intrinsic::fabs && LT.second.isFloatingPoint() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">          TLI->isFAbsFree(LT.second)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">          TLI->isFAbsFree(LT.second)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">        return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">      // The operation is legal. Assume it costs 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">      // The operation is legal. Assume it costs 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine">      // If the type is split to multiple registers, assume that there is some</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine">      // If the type is split to multiple registers, assume that there is some</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">      // overhead to this.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">      // overhead to this.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">      // TODO: Once we have extract/insert subvector cost we need to use them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">      // TODO: Once we have extract/insert subvector cost we need to use them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">      if (LT.first > 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">      if (LT.first > 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">        return (LT.first * 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">        return (LT.first * 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">        return (LT.first * 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">        return (LT.first * 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">    } else if (!TLI->isOperationExpand(ISD, LT.second)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">    } else if (!TLI->isOperationExpand(ISD, LT.second)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">      // If the operation is custom lowered then assume</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">      // If the operation is custom lowered then assume</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">      // that the code is twice as expensive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">      // that the code is twice as expensive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">      return (LT.first * 2);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">      return (LT.first * 2);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine">    // If we can't lower fmuladd into an FMA estimate the cost as a floating</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine">    // If we can't lower fmuladd into an FMA estimate the cost as a floating</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">    // point mul followed by an add.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">    // point mul followed by an add.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">    if (IID == Intrinsic::fmuladd)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">    if (IID == Intrinsic::fmuladd)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">      return thisT()->getArithmeticInstrCost(BinaryOperator::FMul, RetTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">      return thisT()->getArithmeticInstrCost(BinaryOperator::FMul, RetTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine">                                             CostKind) +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine">                                             CostKind) +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">             thisT()->getArithmeticInstrCost(BinaryOperator::FAdd, RetTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">             thisT()->getArithmeticInstrCost(BinaryOperator::FAdd, RetTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine">                                             CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine">                                             CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">    if (IID == Intrinsic::experimental_constrained_fmuladd) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">    if (IID == Intrinsic::experimental_constrained_fmuladd) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">      IntrinsicCostAttributes FMulAttrs(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">      IntrinsicCostAttributes FMulAttrs(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">        Intrinsic::experimental_constrained_fmul, RetTy, Tys);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">        Intrinsic::experimental_constrained_fmul, RetTy, Tys);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">      IntrinsicCostAttributes FAddAttrs(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">      IntrinsicCostAttributes FAddAttrs(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">        Intrinsic::experimental_constrained_fadd, RetTy, Tys);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">        Intrinsic::experimental_constrained_fadd, RetTy, Tys);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">      return thisT()->getIntrinsicInstrCost(FMulAttrs, CostKind) +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">      return thisT()->getIntrinsicInstrCost(FMulAttrs, CostKind) +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">             thisT()->getIntrinsicInstrCost(FAddAttrs, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">             thisT()->getIntrinsicInstrCost(FAddAttrs, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">    // Else, assume that we need to scalarize this intrinsic. For math builtins</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">    // Else, assume that we need to scalarize this intrinsic. For math builtins</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">    // this will emit a costly libcall, adding call overhead and spills. Make it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">    // this will emit a costly libcall, adding call overhead and spills. Make it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">    // very expensive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">    // very expensive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine">    if (auto *RetVTy = dyn_cast<VectorType>(RetTy)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine">    if (auto *RetVTy = dyn_cast<VectorType>(RetTy)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">      // Scalable vectors cannot be scalarized, so return Invalid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">      // Scalable vectors cannot be scalarized, so return Invalid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(RetTy) || any_of(Tys, [](const Type *Ty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">      if (isa<ScalableVectorType>(RetTy) || any_of(Tys, [](const Type *Ty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">            return isa<ScalableVectorType>(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">            return isa<ScalableVectorType>(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">          }))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">          }))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">        return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">        return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">      InstructionCost ScalarizationCost =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">      InstructionCost ScalarizationCost =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">          SkipScalarizationCost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">          SkipScalarizationCost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine">              ? ScalarizationCostPassed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine">              ? ScalarizationCostPassed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">              : getScalarizationOverhead(RetVTy, /*Insert*/ true,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">              : getScalarizationOverhead(RetVTy, /*Insert*/ true,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">                                         /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">                                         /*Extract*/ false, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">      unsigned ScalarCalls = cast<FixedVectorType>(RetVTy)->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">      unsigned ScalarCalls = cast<FixedVectorType>(RetVTy)->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine">      SmallVector<Type *, 4> ScalarTys;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine">      SmallVector<Type *, 4> ScalarTys;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">        Type *Ty = Tys[i];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">        Type *Ty = Tys[i];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">        if (Ty->isVectorTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">        if (Ty->isVectorTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">          Ty = Ty->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">          Ty = Ty->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">        ScalarTys.push_back(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">        ScalarTys.push_back(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(IID, RetTy->getScalarType(), ScalarTys, FMF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(IID, RetTy->getScalarType(), ScalarTys, FMF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">      InstructionCost ScalarCost =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">      InstructionCost ScalarCost =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine">          thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine">          thisT()->getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">      for (unsigned i = 0, ie = Tys.size(); i != ie; ++i) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">        if (auto *VTy = dyn_cast<VectorType>(Tys[i])) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">        if (auto *VTy = dyn_cast<VectorType>(Tys[i])) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine">          if (!ICA.skipScalarizationCost())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine">          if (!ICA.skipScalarizationCost())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">            ScalarizationCost += getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">            ScalarizationCost += getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine">                VTy, /*Insert*/ false, /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine">                VTy, /*Insert*/ false, /*Extract*/ true, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">          ScalarCalls = std::max(ScalarCalls,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">          ScalarCalls = std::max(ScalarCalls,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">                                 cast<FixedVectorType>(VTy)->getNumElements());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">                                 cast<FixedVectorType>(VTy)->getNumElements());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">      return ScalarCalls * ScalarCost + ScalarizationCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">      return ScalarCalls * ScalarCost + ScalarizationCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">    // This is going to be turned into a library call, make it expensive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">    // This is going to be turned into a library call, make it expensive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">    return SingleCallCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">    return SingleCallCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">  /// Compute a cost of the given call instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">  /// Compute a cost of the given call instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">  /// Compute the cost of calling function F with return type RetTy and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">  /// Compute the cost of calling function F with return type RetTy and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">  /// argument types Tys. F might be nullptr, in this case the cost of an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">  /// argument types Tys. F might be nullptr, in this case the cost of an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine">  /// arbitrary call with the specified signature will be returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine">  /// arbitrary call with the specified signature will be returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">  /// This is used, for instance,  when we estimate call of a vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">  /// This is used, for instance,  when we estimate call of a vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">  /// counterpart of the given function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">  /// counterpart of the given function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">  /// \param F Called function, might be nullptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">  /// \param F Called function, might be nullptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">  /// \param RetTy Return value types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">  /// \param RetTy Return value types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">  /// \param Tys Argument types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">  /// \param Tys Argument types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">  /// \returns The cost of Call instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">  /// \returns The cost of Call instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">  InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">  InstructionCost getCallInstrCost(Function *F, Type *RetTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">                                   ArrayRef<Type *> Tys,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine">                                   TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine">                                   TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">    return 10;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">    return 10;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">  unsigned getNumberOfParts(Type *Tp) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">  unsigned getNumberOfParts(Type *Tp) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Tp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = getTypeLegalizationCost(Tp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine">    return LT.first.isValid() ? *LT.first.getValue() : 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine">    return LT.first.isValid() ? *LT.first.getValue() : 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">  InstructionCost getAddressComputationCost(Type *Ty, ScalarEvolution *,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">  InstructionCost getAddressComputationCost(Type *Ty, ScalarEvolution *,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">                                            const SCEV *) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">                                            const SCEV *) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">    return 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">  /// Try to calculate arithmetic and shuffle op costs for reduction intrinsics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">  /// Try to calculate arithmetic and shuffle op costs for reduction intrinsics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">  /// We're assuming that reduction operation are performing the following way:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">  /// We're assuming that reduction operation are performing the following way:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">  /// %val1 = shufflevector<n x t> %val, <n x t> %undef,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">  /// %val1 = shufflevector<n x t> %val, <n x t> %undef,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine">  /// <n x i32> <i32 n/2, i32 n/2 + 1, ..., i32 n, i32 undef, ..., i32 undef></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine">  /// <n x i32> <i32 n/2, i32 n/2 + 1, ..., i32 n, i32 undef, ..., i32 undef></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">  ///            \----------------v-------------/  \----------v------------/</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">  ///            \----------------v-------------/  \----------v------------/</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">  ///                            n/2 elements               n/2 elements</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">  ///                            n/2 elements               n/2 elements</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">  /// %red1 = op <n x t> %val, <n x t> val1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">  /// %red1 = op <n x t> %val, <n x t> val1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">  /// After this operation we have a vector %red1 where only the first n/2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">  /// After this operation we have a vector %red1 where only the first n/2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine">  /// elements are meaningful, the second n/2 elements are undefined and can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine">  /// elements are meaningful, the second n/2 elements are undefined and can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">  /// dropped. All other operations are actually working with the vector of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">  /// dropped. All other operations are actually working with the vector of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">  /// length n/2, not n, though the real vector length is still n.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">  /// length n/2, not n, though the real vector length is still n.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">  /// %val2 = shufflevector<n x t> %red1, <n x t> %undef,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">  /// %val2 = shufflevector<n x t> %red1, <n x t> %undef,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">  /// <n x i32> <i32 n/4, i32 n/4 + 1, ..., i32 n/2, i32 undef, ..., i32 undef></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">  /// <n x i32> <i32 n/4, i32 n/4 + 1, ..., i32 n/2, i32 undef, ..., i32 undef></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">  ///            \----------------v-------------/  \----------v------------/</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">  ///            \----------------v-------------/  \----------v------------/</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">  ///                            n/4 elements               3*n/4 elements</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">  ///                            n/4 elements               3*n/4 elements</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">  /// %red2 = op <n x t> %red1, <n x t> val2  - working with the vector of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">  /// %red2 = op <n x t> %red1, <n x t> val2  - working with the vector of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">  /// length n/2, the resulting vector has length n/4 etc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">  /// length n/2, the resulting vector has length n/4 etc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">  /// The cost model should take into account that the actual length of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">  /// The cost model should take into account that the actual length of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">  /// vector is reduced on each iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">  /// vector is reduced on each iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine">  InstructionCost getTreeReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine">  InstructionCost getTreeReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">                                       TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">                                       TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">    // Targets must implement a default value for the scalable case, since</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">    // Targets must implement a default value for the scalable case, since</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine">    // we don't know how many lanes the vector has.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine">    // we don't know how many lanes the vector has.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(Ty))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(Ty))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">    Type *ScalarTy = Ty->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">    Type *ScalarTy = Ty->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">    unsigned NumVecElts = cast<FixedVectorType>(Ty)->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">    unsigned NumVecElts = cast<FixedVectorType>(Ty)->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">    if ((Opcode == Instruction::Or || Opcode == Instruction::And) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">    if ((Opcode == Instruction::Or || Opcode == Instruction::And) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">        ScalarTy == IntegerType::getInt1Ty(Ty->getContext()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">        ScalarTy == IntegerType::getInt1Ty(Ty->getContext()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">        NumVecElts >= 2) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">        NumVecElts >= 2) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">      // Or reduction for i1 is represented as:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">      // Or reduction for i1 is represented as:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine">      // %val = bitcast <ReduxWidth x i1> to iReduxWidth</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine">      // %val = bitcast <ReduxWidth x i1> to iReduxWidth</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">      // %res = cmp ne iReduxWidth %val, 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">      // %res = cmp ne iReduxWidth %val, 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">      // And reduction for i1 is represented as:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">      // And reduction for i1 is represented as:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">      // %val = bitcast <ReduxWidth x i1> to iReduxWidth</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">      // %val = bitcast <ReduxWidth x i1> to iReduxWidth</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">      // %res = cmp eq iReduxWidth %val, 11111</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">      // %res = cmp eq iReduxWidth %val, 11111</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">      Type *ValTy = IntegerType::get(Ty->getContext(), NumVecElts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">      Type *ValTy = IntegerType::get(Ty->getContext(), NumVecElts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine">      return thisT()->getCastInstrCost(Instruction::BitCast, ValTy, Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine">      return thisT()->getCastInstrCost(Instruction::BitCast, ValTy, Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">                                       TTI::CastContextHint::None, CostKind) +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">                                       TTI::CastContextHint::None, CostKind) +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine">             thisT()->getCmpSelInstrCost(Instruction::ICmp, ValTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine">             thisT()->getCmpSelInstrCost(Instruction::ICmp, ValTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">                                         CmpInst::makeCmpResultType(ValTy),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">                                         CmpInst::makeCmpResultType(ValTy),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">                                         CmpInst::BAD_ICMP_PREDICATE, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">                                         CmpInst::BAD_ICMP_PREDICATE, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">    unsigned NumReduxLevels = Log2_32(NumVecElts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">    unsigned NumReduxLevels = Log2_32(NumVecElts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine">    InstructionCost ArithCost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine">    InstructionCost ArithCost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">    InstructionCost ShuffleCost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">    InstructionCost ShuffleCost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = thisT()->getTypeLegalizationCost(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = thisT()->getTypeLegalizationCost(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">    unsigned LongVectorCount = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">    unsigned LongVectorCount = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine">    unsigned MVTLen =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine">    unsigned MVTLen =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine">        LT.second.isVector() ? LT.second.getVectorNumElements() : 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine">        LT.second.isVector() ? LT.second.getVectorNumElements() : 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">    while (NumVecElts > MVTLen) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">    while (NumVecElts > MVTLen) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">      NumVecElts /= 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">      NumVecElts /= 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">      VectorType *SubTy = FixedVectorType::get(ScalarTy, NumVecElts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">      VectorType *SubTy = FixedVectorType::get(ScalarTy, NumVecElts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine">      ShuffleCost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine">      ShuffleCost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">          thisT()->getShuffleCost(TTI::SK_ExtractSubvector, Ty, std::nullopt,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">          thisT()->getShuffleCost(TTI::SK_ExtractSubvector, Ty, std::nullopt,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">                                  CostKind, NumVecElts, SubTy);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">                                  CostKind, NumVecElts, SubTy);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine">      ArithCost += thisT()->getArithmeticInstrCost(Opcode, SubTy, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine">      ArithCost += thisT()->getArithmeticInstrCost(Opcode, SubTy, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">      Ty = SubTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">      Ty = SubTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine">      ++LongVectorCount;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine">      ++LongVectorCount;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine">    NumReduxLevels -= LongVectorCount;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine">    NumReduxLevels -= LongVectorCount;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine">    // The minimal length of the vector is limited by the real length of vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine">    // The minimal length of the vector is limited by the real length of vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">    // operations performed on the current platform. That's why several final</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">    // operations performed on the current platform. That's why several final</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine">    // reduction operations are performed on the vectors with the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine">    // reduction operations are performed on the vectors with the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine">    // architecture-dependent length.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine">    // architecture-dependent length.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine">    // By default reductions need one shuffle per reduction level.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine">    // By default reductions need one shuffle per reduction level.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">    ShuffleCost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">    ShuffleCost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">        NumReduxLevels * thisT()->getShuffleCost(TTI::SK_PermuteSingleSrc, Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">        NumReduxLevels * thisT()->getShuffleCost(TTI::SK_PermuteSingleSrc, Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine">                                                 std::nullopt, CostKind, 0, Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine">                                                 std::nullopt, CostKind, 0, Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine">    ArithCost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine">    ArithCost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">        NumReduxLevels * thisT()->getArithmeticInstrCost(Opcode, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">        NumReduxLevels * thisT()->getArithmeticInstrCost(Opcode, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">    return ShuffleCost + ArithCost +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">    return ShuffleCost + ArithCost +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">           thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">           thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine">                                       CostKind, 0, nullptr, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine">                                       CostKind, 0, nullptr, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine">  /// Try to calculate the cost of performing strict (in-order) reductions,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine">  /// Try to calculate the cost of performing strict (in-order) reductions,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine">  /// which involves doing a sequence of floating point additions in lane</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine">  /// which involves doing a sequence of floating point additions in lane</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine">  /// order, starting with an initial value. For example, consider a scalar</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine">  /// order, starting with an initial value. For example, consider a scalar</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">  /// initial value 'InitVal' of type float and a vector of type <4 x float>:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">  /// initial value 'InitVal' of type float and a vector of type <4 x float>:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">  ///   Vector = <float %v0, float %v1, float %v2, float %v3></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">  ///   Vector = <float %v0, float %v1, float %v2, float %v3></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine">  ///   %add1 = %InitVal + %v0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine">  ///   %add1 = %InitVal + %v0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">  ///   %add2 = %add1 + %v1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">  ///   %add2 = %add1 + %v1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">  ///   %add3 = %add2 + %v2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">  ///   %add3 = %add2 + %v2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine">  ///   %add4 = %add3 + %v3</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine">  ///   %add4 = %add3 + %v3</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">  /// As a simple estimate we can say the cost of such a reduction is 4 times</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">  /// As a simple estimate we can say the cost of such a reduction is 4 times</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine">  /// the cost of a scalar FP addition. We can only estimate the costs for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine">  /// the cost of a scalar FP addition. We can only estimate the costs for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine">  /// fixed-width vectors here because for scalable vectors we do not know the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine">  /// fixed-width vectors here because for scalable vectors we do not know the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">  /// runtime number of operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">  /// runtime number of operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">  InstructionCost getOrderedReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">  InstructionCost getOrderedReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">                                          TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">                                          TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">    // Targets must implement a default value for the scalable case, since</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">    // Targets must implement a default value for the scalable case, since</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">    // we don't know how many lanes the vector has.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">    // we don't know how many lanes the vector has.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(Ty))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(Ty))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine">    auto *VTy = cast<FixedVectorType>(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine">    auto *VTy = cast<FixedVectorType>(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">    InstructionCost ExtractCost = getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">    InstructionCost ExtractCost = getScalarizationOverhead(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">        VTy, /*Insert=*/false, /*Extract=*/true, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">        VTy, /*Insert=*/false, /*Extract=*/true, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine">    InstructionCost ArithCost = thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine">    InstructionCost ArithCost = thisT()->getArithmeticInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine">        Opcode, VTy->getElementType(), CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine">        Opcode, VTy->getElementType(), CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">    ArithCost *= VTy->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">    ArithCost *= VTy->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">    return ExtractCost + ArithCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">    return ExtractCost + ArithCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">  InstructionCost getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">  InstructionCost getArithmeticReductionCost(unsigned Opcode, VectorType *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">                                             std::optional<FastMathFlags> FMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">                                             std::optional<FastMathFlags> FMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">                                             TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">                                             TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine">    assert(Ty && "Unknown reduction vector type");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine">    assert(Ty && "Unknown reduction vector type");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine">    if (TTI::requiresOrderedReduction(FMF))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine">    if (TTI::requiresOrderedReduction(FMF))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine">      return getOrderedReductionCost(Opcode, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine">      return getOrderedReductionCost(Opcode, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">    return getTreeReductionCost(Opcode, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">    return getTreeReductionCost(Opcode, Ty, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">  /// Try to calculate op costs for min/max reduction operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">  /// Try to calculate op costs for min/max reduction operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine">  /// \param CondTy Conditional type for the Select instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine">  /// \param CondTy Conditional type for the Select instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine">  InstructionCost getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine">  InstructionCost getMinMaxReductionCost(Intrinsic::ID IID, VectorType *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine">                                         FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine">                                         FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine">                                         TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine">                                         TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">    // Targets must implement a default value for the scalable case, since</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">    // Targets must implement a default value for the scalable case, since</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">    // we don't know how many lanes the vector has.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">    // we don't know how many lanes the vector has.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(Ty))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine">    if (isa<ScalableVectorType>(Ty))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">      return InstructionCost::getInvalid();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">    Type *ScalarTy = Ty->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">    Type *ScalarTy = Ty->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">    unsigned NumVecElts = cast<FixedVectorType>(Ty)->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">    unsigned NumVecElts = cast<FixedVectorType>(Ty)->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">    unsigned NumReduxLevels = Log2_32(NumVecElts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">    unsigned NumReduxLevels = Log2_32(NumVecElts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine">    InstructionCost MinMaxCost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine">    InstructionCost MinMaxCost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine">    InstructionCost ShuffleCost = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine">    InstructionCost ShuffleCost = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = thisT()->getTypeLegalizationCost(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">    std::pair<InstructionCost, MVT> LT = thisT()->getTypeLegalizationCost(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine">    unsigned LongVectorCount = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine">    unsigned LongVectorCount = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">    unsigned MVTLen =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">    unsigned MVTLen =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">        LT.second.isVector() ? LT.second.getVectorNumElements() : 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">        LT.second.isVector() ? LT.second.getVectorNumElements() : 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">    while (NumVecElts > MVTLen) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">    while (NumVecElts > MVTLen) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">      NumVecElts /= 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">      NumVecElts /= 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">      auto *SubTy = FixedVectorType::get(ScalarTy, NumVecElts);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">      auto *SubTy = FixedVectorType::get(ScalarTy, NumVecElts);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">      ShuffleCost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">      ShuffleCost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine">          thisT()->getShuffleCost(TTI::SK_ExtractSubvector, Ty, std::nullopt,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine">          thisT()->getShuffleCost(TTI::SK_ExtractSubvector, Ty, std::nullopt,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">                                  CostKind, NumVecElts, SubTy);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">                                  CostKind, NumVecElts, SubTy);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(IID, SubTy, {SubTy, SubTy}, FMF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">      IntrinsicCostAttributes Attrs(IID, SubTy, {SubTy, SubTy}, FMF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">      MinMaxCost += getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">      MinMaxCost += getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine">      Ty = SubTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine">      Ty = SubTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">      ++LongVectorCount;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">      ++LongVectorCount;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">    NumReduxLevels -= LongVectorCount;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">    NumReduxLevels -= LongVectorCount;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine">    // The minimal length of the vector is limited by the real length of vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine">    // The minimal length of the vector is limited by the real length of vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine">    // operations performed on the current platform. That's why several final</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine">    // operations performed on the current platform. That's why several final</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine">    // reduction opertions are perfomed on the vectors with the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine">    // reduction opertions are perfomed on the vectors with the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine">    // architecture-dependent length.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine">    // architecture-dependent length.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine">    ShuffleCost +=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine">    ShuffleCost +=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine">        NumReduxLevels * thisT()->getShuffleCost(TTI::SK_PermuteSingleSrc, Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine">        NumReduxLevels * thisT()->getShuffleCost(TTI::SK_PermuteSingleSrc, Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">                                                 std::nullopt, CostKind, 0, Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">                                                 std::nullopt, CostKind, 0, Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine">    IntrinsicCostAttributes Attrs(IID, Ty, {Ty, Ty}, FMF);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine">    IntrinsicCostAttributes Attrs(IID, Ty, {Ty, Ty}, FMF);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine">    MinMaxCost += NumReduxLevels * getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine">    MinMaxCost += NumReduxLevels * getIntrinsicInstrCost(Attrs, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">    // The last min/max should be in vector registers and we counted it above.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">    // The last min/max should be in vector registers and we counted it above.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine">    // So just need a single extractelement.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine">    // So just need a single extractelement.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">    return ShuffleCost + MinMaxCost +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">    return ShuffleCost + MinMaxCost +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine">           thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine">           thisT()->getVectorInstrCost(Instruction::ExtractElement, Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine">                                       CostKind, 0, nullptr, nullptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine">                                       CostKind, 0, nullptr, nullptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">  InstructionCost getExtendedReductionCost(unsigned Opcode, bool IsUnsigned,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">  InstructionCost getExtendedReductionCost(unsigned Opcode, bool IsUnsigned,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">                                           Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">                                           Type *ResTy, VectorType *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine">                                           FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine">                                           FastMathFlags FMF,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine">                                           TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">    // Without any native support, this is equivalent to the cost of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">    // Without any native support, this is equivalent to the cost of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine">    // vecreduce.opcode(ext(Ty A)).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine">    // vecreduce.opcode(ext(Ty A)).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine">    VectorType *ExtTy = VectorType::get(ResTy, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine">    VectorType *ExtTy = VectorType::get(ResTy, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">    InstructionCost RedCost =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">    InstructionCost RedCost =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine">        thisT()->getArithmeticReductionCost(Opcode, ExtTy, FMF, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine">        thisT()->getArithmeticReductionCost(Opcode, ExtTy, FMF, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine">    InstructionCost ExtCost = thisT()->getCastInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine">    InstructionCost ExtCost = thisT()->getCastInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">        IsUnsigned ? Instruction::ZExt : Instruction::SExt, ExtTy, Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">        IsUnsigned ? Instruction::ZExt : Instruction::SExt, ExtTy, Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine">        TTI::CastContextHint::None, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine">        TTI::CastContextHint::None, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine">    return RedCost + ExtCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine">    return RedCost + ExtCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine">  InstructionCost getMulAccReductionCost(bool IsUnsigned, Type *ResTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine">  InstructionCost getMulAccReductionCost(bool IsUnsigned, Type *ResTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine">                                         VectorType *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine">                                         VectorType *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">                                         TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">                                         TTI::TargetCostKind CostKind) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">    // Without any native support, this is equivalent to the cost of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">    // Without any native support, this is equivalent to the cost of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine">    // vecreduce.add(mul(ext(Ty A), ext(Ty B))) or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine">    // vecreduce.add(mul(ext(Ty A), ext(Ty B))) or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine">    // vecreduce.add(mul(A, B)).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine">    // vecreduce.add(mul(A, B)).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine">    VectorType *ExtTy = VectorType::get(ResTy, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine">    VectorType *ExtTy = VectorType::get(ResTy, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine">    InstructionCost RedCost = thisT()->getArithmeticReductionCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine">    InstructionCost RedCost = thisT()->getArithmeticReductionCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine">        Instruction::Add, ExtTy, std::nullopt, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine">        Instruction::Add, ExtTy, std::nullopt, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine">    InstructionCost ExtCost = thisT()->getCastInstrCost(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine">    InstructionCost ExtCost = thisT()->getCastInstrCost(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine">        IsUnsigned ? Instruction::ZExt : Instruction::SExt, ExtTy, Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine">        IsUnsigned ? Instruction::ZExt : Instruction::SExt, ExtTy, Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine">        TTI::CastContextHint::None, CostKind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine">        TTI::CastContextHint::None, CostKind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine">    InstructionCost MulCost =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine">    InstructionCost MulCost =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">        thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">        thisT()->getArithmeticInstrCost(Instruction::Mul, ExtTy, CostKind);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">    return RedCost + MulCost + 2 * ExtCost;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">    return RedCost + MulCost + 2 * ExtCost;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine">  InstructionCost getVectorSplitCost() { return 1; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine">  InstructionCost getVectorSplitCost() { return 1; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">/// Concrete BasicTTIImpl that can be used if no further customization</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">/// Concrete BasicTTIImpl that can be used if no further customization</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">/// is needed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">/// is needed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine">class BasicTTIImpl : public BasicTTIImplBase<BasicTTIImpl> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine">class BasicTTIImpl : public BasicTTIImplBase<BasicTTIImpl> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">  using BaseT = BasicTTIImplBase<BasicTTIImpl>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">  using BaseT = BasicTTIImplBase<BasicTTIImpl>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine">  friend class BasicTTIImplBase<BasicTTIImpl>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine">  friend class BasicTTIImplBase<BasicTTIImpl>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine">  const TargetSubtargetInfo *ST;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine">  const TargetSubtargetInfo *ST;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine">  const TargetLoweringBase *TLI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine">  const TargetLoweringBase *TLI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">  const TargetSubtargetInfo *getST() const { return ST; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">  const TargetSubtargetInfo *getST() const { return ST; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">  const TargetLoweringBase *getTLI() const { return TLI; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">  const TargetLoweringBase *getTLI() const { return TLI; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine">  explicit BasicTTIImpl(const TargetMachine *TM, const Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine">  explicit BasicTTIImpl(const TargetMachine *TM, const Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine">#endif // LLVM_CODEGEN_BASICTTIIMPL_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine">#endif // LLVM_CODEGEN_BASICTTIIMPL_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>