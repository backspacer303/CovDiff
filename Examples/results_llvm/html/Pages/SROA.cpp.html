<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>SROA.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- SROA.cpp - Scalar Replacement Of Aggregates ------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">/// \file</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">/// This transformation implements the well known scalar replacement of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">/// aggregates transformation. It tries to identify promotable elements of an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">/// aggregate alloca, and promote them to registers. It will also try to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">/// convert uses of an element (or set of elements) of an alloca into a vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">/// or bitfield-style integer scalar if appropriate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">/// It works to do this with minimal slicing of the alloca so that regions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">/// which are merely transferred in and out of external memory remain unchanged</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">/// and are not decomposed to scalar code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">/// Because this also performs alloca promotion, it can be thought of as also</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">/// serving the purpose of SSA formation. The algorithm iterates on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">/// function until all opportunities for promotion have been realized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/Transforms/Scalar/SROA.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/ADT/APInt.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/ADT/ArrayRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/ADT/PointerIntPair.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/ADT/STLExtras.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/ADT/SetVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/ADT/SmallBitVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/ADT/Statistic.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/ADT/StringRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/ADT/Twine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include "llvm/ADT/iterator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include "llvm/ADT/iterator_range.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include "llvm/Analysis/DomTreeUpdater.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include "llvm/Analysis/GlobalsModRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">#include "llvm/Analysis/Loads.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="">#include "llvm/Analysis/PtrUseVisitor.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">#include "llvm/Config/llvm-config.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="">#include "llvm/IR/BasicBlock.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">#include "llvm/IR/Constant.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">#include "llvm/IR/ConstantFolder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">#include "llvm/IR/Constants.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">#include "llvm/IR/DIBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">#include "llvm/IR/DataLayout.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">#include "llvm/IR/DebugInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">#include "llvm/IR/DebugInfoMetadata.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">#include "llvm/IR/DerivedTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">#include "llvm/IR/Dominators.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">#include "llvm/IR/GlobalAlias.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">#include "llvm/IR/IRBuilder.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">#include "llvm/IR/InstVisitor.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">#include "llvm/IR/Instruction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">#include "llvm/IR/IntrinsicInst.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">#include "llvm/IR/LLVMContext.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">#include "llvm/IR/Metadata.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">#include "llvm/IR/Module.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">#include "llvm/IR/Operator.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">#include "llvm/IR/PassManager.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="">#include "llvm/IR/Type.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">#include "llvm/IR/Use.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="">#include "llvm/IR/User.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">#include "llvm/IR/Value.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">#include "llvm/InitializePasses.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">#include "llvm/Support/Casting.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">#include "llvm/Support/CommandLine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">#include "llvm/Support/Compiler.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">#include "llvm/Support/Debug.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">#include "llvm/Support/ErrorHandling.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">#include "llvm/Support/raw_ostream.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">#include "llvm/Transforms/Scalar.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">#include "llvm/Transforms/Utils/Local.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">#include "llvm/Transforms/Utils/PromoteMemToReg.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">#include <algorithm></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">#include <cstddef></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">#include <cstring></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">#include <iterator></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">#include <string></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="">#include <tuple></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">#include <vector></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">using namespace llvm::sroa;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">#define DEBUG_TYPE "sroa"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">STATISTIC(NumAllocasAnalyzed, "Number of allocas analyzed for replacement");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">STATISTIC(NumAllocaPartitions, "Number of alloca partitions formed");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">STATISTIC(MaxPartitionsPerAlloca, "Maximum number of partitions per alloca");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">STATISTIC(NumAllocaPartitionUses, "Number of alloca partition uses rewritten");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">STATISTIC(MaxUsesPerAllocaPartition, "Maximum number of uses of a partition");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">STATISTIC(NumNewAllocas, "Number of new, smaller allocas introduced");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">STATISTIC(NumPromoted, "Number of allocas promoted to SSA values");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">STATISTIC(NumLoadsSpeculated, "Number of loads speculated to allow promotion");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">STATISTIC(NumLoadsPredicated,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">          "Number of loads rewritten into predicated loads to allow promotion");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">STATISTIC(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">    NumStoresPredicated,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">    "Number of stores rewritten into predicated loads to allow promotion");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">STATISTIC(NumDeleted, "Number of instructions deleted");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">STATISTIC(NumVectorized, "Number of vectorized aggregates");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">/// Hidden option to experiment with completely strict handling of inbounds</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">/// GEPs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">static cl::opt<bool> SROAStrictInbounds("sroa-strict-inbounds", cl::init(false),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">                                        cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">/// Disable running mem2reg during SROA in order to test or debug SROA.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">static cl::opt<bool> SROASkipMem2Reg("sroa-skip-mem2reg", cl::init(false),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">                                     cl::Hidden);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">/// Calculate the fragment of a variable to use when slicing a store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">/// based on the slice dimensions, existing fragment, and base storage</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">/// fragment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">/// Results:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">/// UseFrag - Use Target as the new fragment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">/// UseNoFrag - The new slice already covers the whole variable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">/// Skip - The new alloca slice doesn't include this variable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">/// FIXME: Can we use calculateFragmentIntersect instead?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">enum FragCalcResult { UseFrag, UseNoFrag, Skip };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">static FragCalcResult</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="uncoveredLine">calculateFragment(DILocalVariable *Variable,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="">                  uint64_t NewStorageSliceOffsetInBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="">                  uint64_t NewStorageSliceSizeInBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">                  std::optional<DIExpression::FragmentInfo> StorageFragment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">                  std::optional<DIExpression::FragmentInfo> CurrentFragment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">                  DIExpression::FragmentInfo &Target) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">  // If the base storage describes part of the variable apply the offset and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="">  // the size constraint.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="uncoveredLine">  if (StorageFragment) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="uncoveredLine">    Target.SizeInBits =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="uncoveredLine">        std::min(NewStorageSliceSizeInBits, StorageFragment->SizeInBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="uncoveredLine">    Target.OffsetInBits =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="uncoveredLine">        NewStorageSliceOffsetInBits + StorageFragment->OffsetInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="uncoveredLine">    Target.SizeInBits = NewStorageSliceSizeInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="uncoveredLine">    Target.OffsetInBits = NewStorageSliceOffsetInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="">  // If this slice extracts the entirety of an independent variable from a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">  // larger alloca, do not produce a fragment expression, as the variable is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">  // not fragmented.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="uncoveredLine">  if (!CurrentFragment) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="uncoveredLine">    if (auto Size = Variable->getSizeInBits()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">      // Treat the current fragment as covering the whole variable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="uncoveredLine">      CurrentFragment =  DIExpression::FragmentInfo(*Size, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="uncoveredLine">      if (Target == CurrentFragment)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="uncoveredLine">        return UseNoFrag;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">  // No additional work to do if there isn't a fragment already, or there is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">  // but it already exactly describes the new assignment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="uncoveredLine">  if (!CurrentFragment || *CurrentFragment == Target)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="uncoveredLine">    return UseFrag;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">  // Reject the target fragment if it doesn't fit wholly within the current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">  // fragment. TODO: We could instead chop up the target to fit in the case of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="">  // a partial overlap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="uncoveredLine">  if (Target.startInBits() < CurrentFragment->startInBits() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="uncoveredLine">      Target.endInBits() > CurrentFragment->endInBits())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="uncoveredLine">    return Skip;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">  // Target fits within the current fragment, return it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="uncoveredLine">  return UseFrag;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="uncoveredLine">static DebugVariable getAggregateVariable(DbgVariableIntrinsic *DVI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="uncoveredLine">  return DebugVariable(DVI->getVariable(), std::nullopt,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="uncoveredLine">                       DVI->getDebugLoc().getInlinedAt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">/// Find linked dbg.assign and generate a new one with the correct</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">/// FragmentInfo. Link Inst to the new dbg.assign.  If Value is nullptr the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="">/// value component is copied from the old dbg.assign to the new.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="">/// \param OldAlloca             Alloca for the variable before splitting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">/// \param IsSplit               True if the store (not necessarily alloca)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="">///                              is being split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">/// \param OldAllocaOffsetInBits Offset of the slice taken from OldAlloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">/// \param SliceSizeInBits       New number of bits being written to.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="">/// \param OldInst               Instruction that is being split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">/// \param Inst                  New instruction performing this part of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">///                              split store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">/// \param Dest                  Store destination.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="">/// \param Value                 Stored value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="">/// \param DL                    Datalayout.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="uncoveredLine">static void migrateDebugInfo(AllocaInst *OldAlloca, bool IsSplit,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="">                             uint64_t OldAllocaOffsetInBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">                             uint64_t SliceSizeInBits, Instruction *OldInst,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="">                             Instruction *Inst, Value *Dest, Value *Value,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">                             const DataLayout &DL) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="uncoveredLine">  auto MarkerRange = at::getAssignmentMarkers(OldInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">  // Nothing to do if OldInst has no linked dbg.assign intrinsics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="uncoveredLine">  if (MarkerRange.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "  migrateDebugInfo\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "    OldAlloca: " << *OldAlloca << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "    IsSplit: " << IsSplit << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "    OldAllocaOffsetInBits: " << OldAllocaOffsetInBits</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">                    << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "    SliceSizeInBits: " << SliceSizeInBits << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "    OldInst: " << *OldInst << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "    Inst: " << *Inst << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "    Dest: " << *Dest << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="uncoveredLine">  if (Value)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    Value: " << *Value << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">  /// Map of aggregate variables to their fragment associated with OldAlloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="">  DenseMap<DebugVariable, std::optional<DIExpression::FragmentInfo>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="uncoveredLine">      BaseFragments;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="uncoveredLine">  for (auto *DAI : at::getAssignmentMarkers(OldAlloca))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="uncoveredLine">    BaseFragments[getAggregateVariable(DAI)] =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="uncoveredLine">        DAI->getExpression()->getFragmentInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">  // The new inst needs a DIAssignID unique metadata tag (if OldInst has</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">  // one). It shouldn't already have one: assert this assumption.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="uncoveredLine">  assert(!Inst->getMetadata(LLVMContext::MD_DIAssignID));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="uncoveredLine">  DIAssignID *NewID = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="uncoveredLine">  auto &Ctx = Inst->getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="uncoveredLine">  DIBuilder DIB(*OldInst->getModule(), /*AllowUnresolved*/ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="uncoveredLine">  assert(OldAlloca->isStaticAlloca());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="uncoveredLine">  for (DbgAssignIntrinsic *DbgAssign : MarkerRange) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "      existing dbg.assign is: " << *DbgAssign</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">                      << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">    auto *Expr = DbgAssign->getExpression();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="uncoveredLine">    bool SetKillLocation = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="uncoveredLine">    if (IsSplit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="uncoveredLine">      std::optional<DIExpression::FragmentInfo> BaseFragment;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="">      {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">        auto R = BaseFragments.find(getAggregateVariable(DbgAssign));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="uncoveredLine">        if (R == BaseFragments.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="uncoveredLine">        BaseFragment = R->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">      std::optional<DIExpression::FragmentInfo> CurrentFragment =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="uncoveredLine">          Expr->getFragmentInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="">      DIExpression::FragmentInfo NewFragment;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">      FragCalcResult Result = calculateFragment(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="">          DbgAssign->getVariable(), OldAllocaOffsetInBits, SliceSizeInBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">          BaseFragment, CurrentFragment, NewFragment);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="uncoveredLine">      if (Result == Skip)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="uncoveredLine">      if (Result == UseFrag && !(NewFragment == CurrentFragment)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="uncoveredLine">        if (CurrentFragment) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">          // Rewrite NewFragment to be relative to the existing one (this is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="">          // what createFragmentExpression wants).  CalculateFragment has</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="">          // already resolved the size for us. FIXME: Should it return the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="">          // relative fragment too?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="uncoveredLine">          NewFragment.OffsetInBits -= CurrentFragment->OffsetInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">        // Add the new fragment info to the existing expression if possible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="uncoveredLine">        if (auto E = DIExpression::createFragmentExpression(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="uncoveredLine">                Expr, NewFragment.OffsetInBits, NewFragment.SizeInBits)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="uncoveredLine">          Expr = *E;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">          // Otherwise, add the new fragment info to an empty expression and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="">          // discard the value component of this dbg.assign as the value cannot</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">          // be computed with the new fragment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="uncoveredLine">          Expr = *DIExpression::createFragmentExpression(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="uncoveredLine">              DIExpression::get(Expr->getContext(), std::nullopt),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="uncoveredLine">              NewFragment.OffsetInBits, NewFragment.SizeInBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="uncoveredLine">          SetKillLocation = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">    // If we haven't created a DIAssignID ID do that now and attach it to Inst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="uncoveredLine">    if (!NewID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="uncoveredLine">      NewID = DIAssignID::getDistinct(Ctx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="uncoveredLine">      Inst->setMetadata(LLVMContext::MD_DIAssignID, NewID);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="uncoveredLine">    ::Value *NewValue = Value ? Value : DbgAssign->getValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="uncoveredLine">    auto *NewAssign = DIB.insertDbgAssign(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">        Inst, NewValue, DbgAssign->getVariable(), Expr, Dest,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="uncoveredLine">        DIExpression::get(Ctx, std::nullopt), DbgAssign->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="">    // If we've updated the value but the original dbg.assign has an arglist</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="">    // then kill it now - we can't use the requested new value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="">    // We can't replace the DIArgList with the new value as it'd leave</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">    // the DIExpression in an invalid state (DW_OP_LLVM_arg operands without</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="">    // an arglist). And we can't keep the DIArgList in case the linked store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="">    // is being split - in which case the DIArgList + expression may no longer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">    // be computing the correct value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="">    // This should be a very rare situation as it requires the value being</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="">    // stored to differ from the dbg.assign (i.e., the value has been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">    // represented differently in the debug intrinsic for some reason).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">    SetKillLocation |=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="uncoveredLine">        Value && (DbgAssign->hasArgList() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="uncoveredLine">                  !DbgAssign->getExpression()->isSingleLocationExpression());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="uncoveredLine">    if (SetKillLocation)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="uncoveredLine">      NewAssign->setKillLocation();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">    // We could use more precision here at the cost of some additional (code)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">    // complexity - if the original dbg.assign was adjacent to its store, we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">    // could position this new dbg.assign adjacent to its store rather than the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">    // old dbg.assgn. That would result in interleaved dbg.assigns rather than</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">    // what we get now:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">    //    split store !1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">    //    split store !2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">    //    dbg.assign !1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">    //    dbg.assign !2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">    // This (current behaviour) results results in debug assignments being</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">    // noted as slightly offset (in code) from the store. In practice this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">    // should have little effect on the debugging experience due to the fact</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">    // that all the split stores should get the same line number.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="uncoveredLine">    NewAssign->moveBefore(DbgAssign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="uncoveredLine">    NewAssign->setDebugLoc(DbgAssign->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Created new assign intrinsic: " << *NewAssign</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">                      << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">/// A custom IRBuilder inserter which prefixes all names, but only in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">/// Assert builds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">class IRBuilderPrefixedInserter final : public IRBuilderDefaultInserter {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">  std::string Prefix;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="uncoveredLine">  Twine getNameWithPrefix(const Twine &Name) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="uncoveredLine">    return Name.isTriviallyEmpty() ? Name : Prefix + Name;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="uncoveredLine">  void SetNamePrefix(const Twine &P) { Prefix = P.str(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="uncoveredLine">  void InsertHelper(Instruction *I, const Twine &Name, BasicBlock *BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">                    BasicBlock::iterator InsertPt) const override {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="uncoveredLine">    IRBuilderDefaultInserter::InsertHelper(I, getNameWithPrefix(Name), BB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">                                           InsertPt);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">/// Provide a type for IRBuilder that drops names in release builds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">using IRBuilderTy = IRBuilder<ConstantFolder, IRBuilderPrefixedInserter>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="">/// A used slice of an alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="">/// This structure represents a slice of an alloca used by some instruction. It</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">/// stores both the begin and end offsets of this use, a pointer to the use</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">/// itself, and a flag indicating whether we can classify the use as splittable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="">/// or not when forming partitions of the alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">class Slice {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="">  /// The beginning offset of the range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">  uint64_t BeginOffset = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">  /// The ending offset, not included in the range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">  uint64_t EndOffset = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">  /// Storage for both the use of this slice and whether it can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">  /// split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="">  PointerIntPair<Use *, 1, bool> UseAndIsSplittable;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="">  Slice() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">  Slice(uint64_t BeginOffset, uint64_t EndOffset, Use *U, bool IsSplittable)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="uncoveredLine">      : BeginOffset(BeginOffset), EndOffset(EndOffset),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">        UseAndIsSplittable(U, IsSplittable) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="uncoveredLine">  uint64_t beginOffset() const { return BeginOffset; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="uncoveredLine">  uint64_t endOffset() const { return EndOffset; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="uncoveredLine">  bool isSplittable() const { return UseAndIsSplittable.getInt(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="uncoveredLine">  void makeUnsplittable() { UseAndIsSplittable.setInt(false); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">  Use *getUse() const { return UseAndIsSplittable.getPointer(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="uncoveredLine">  bool isDead() const { return getUse() == nullptr; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="uncoveredLine">  void kill() { UseAndIsSplittable.setPointer(nullptr); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">  /// Support for ordering ranges.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">  /// This provides an ordering over ranges such that start offsets are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">  /// always increasing, and within equal start offsets, the end offsets are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="">  /// decreasing. Thus the spanning range comes first in a cluster with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">  /// same start position.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="uncoveredLine">  bool operator<(const Slice &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="uncoveredLine">    if (beginOffset() < RHS.beginOffset())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="uncoveredLine">    if (beginOffset() > RHS.beginOffset())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="uncoveredLine">    if (isSplittable() != RHS.isSplittable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="uncoveredLine">      return !isSplittable();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="uncoveredLine">    if (endOffset() > RHS.endOffset())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="">  /// Support comparison with a single offset to allow binary searches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="">  friend LLVM_ATTRIBUTE_UNUSED bool operator<(const Slice &LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">                                              uint64_t RHSOffset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">    return LHS.beginOffset() < RHSOffset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">  friend LLVM_ATTRIBUTE_UNUSED bool operator<(uint64_t LHSOffset,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">                                              const Slice &RHS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">    return LHSOffset < RHS.beginOffset();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">  bool operator==(const Slice &RHS) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">    return isSplittable() == RHS.isSplittable() &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">           beginOffset() == RHS.beginOffset() && endOffset() == RHS.endOffset();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">  bool operator!=(const Slice &RHS) const { return !operator==(RHS); }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">/// Representation of the alloca slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="">/// This class represents the slices of an alloca which are formed by its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">/// various uses. If a pointer escapes, we can't fully build a representation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">/// for the slices used and we reflect that in this structure. The uses are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">/// stored, sorted by increasing beginning offset and with unsplittable slices</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="">/// starting at a particular offset before splittable slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">class llvm::sroa::AllocaSlices {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">  /// Construct the slices of a particular alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">  AllocaSlices(const DataLayout &DL, AllocaInst &AI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="">  /// Test whether a pointer to the allocation escapes our analysis.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="">  /// If this is true, the slices are never fully built and should be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">  /// ignored.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="uncoveredLine">  bool isEscaped() const { return PointerEscapingInstr; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="">  /// Support for iterating over the slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">  /// @{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">  using iterator = SmallVectorImpl<Slice>::iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">  using range = iterator_range<iterator>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="uncoveredLine">  iterator begin() { return Slices.begin(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="uncoveredLine">  iterator end() { return Slices.end(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">  using const_iterator = SmallVectorImpl<Slice>::const_iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="">  using const_range = iterator_range<const_iterator>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="uncoveredLine">  const_iterator begin() const { return Slices.begin(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="uncoveredLine">  const_iterator end() const { return Slices.end(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">  /// @}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">  /// Erase a range of slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">  void erase(iterator Start, iterator Stop) { Slices.erase(Start, Stop); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="">  /// Insert new slices for this alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">  /// This moves the slices into the alloca's slices collection, and re-sorts</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">  /// everything so that the usual ordering properties of the alloca's slices</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">  /// hold.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="uncoveredLine">  void insert(ArrayRef<Slice> NewSlices) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="uncoveredLine">    int OldSize = Slices.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="uncoveredLine">    Slices.append(NewSlices.begin(), NewSlices.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="uncoveredLine">    auto SliceI = Slices.begin() + OldSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="uncoveredLine">    llvm::sort(SliceI, Slices.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="uncoveredLine">    std::inplace_merge(Slices.begin(), SliceI, Slices.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">  // Forward declare the iterator and range accessor for walking the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">  // partitions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">  class partition_iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">  iterator_range<partition_iterator> partitions();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="">  /// Access the dead users for this alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="uncoveredLine">  ArrayRef<Instruction *> getDeadUsers() const { return DeadUsers; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="">  /// Access Uses that should be dropped if the alloca is promotable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="uncoveredLine">  ArrayRef<Use *> getDeadUsesIfPromotable() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="uncoveredLine">    return DeadUseIfPromotable;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">  /// Access the dead operands referring to this alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">  /// These are operands which have cannot actually be used to refer to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">  /// alloca as they are outside its range and the user doesn't correct for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">  /// that. These mostly consist of PHI node inputs and the like which we just</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="">  /// need to replace with undef.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="uncoveredLine">  ArrayRef<Use *> getDeadOperands() const { return DeadOperands; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">  void print(raw_ostream &OS, const_iterator I, StringRef Indent = "  ") const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">  void printSlice(raw_ostream &OS, const_iterator I,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">                  StringRef Indent = "  ") const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="">  void printUse(raw_ostream &OS, const_iterator I,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">                StringRef Indent = "  ") const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">  void print(raw_ostream &OS) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">  void dump(const_iterator I) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="">  void dump() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">  template <typename DerivedT, typename RetT = void> class BuilderBase;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">  class SliceBuilder;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">  friend class AllocaSlices::SliceBuilder;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="">  /// Handle to alloca instruction to simplify method interfaces.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">  AllocaInst &AI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">  /// The instruction responsible for this alloca not having a known set</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">  /// of slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">  /// When an instruction (potentially) escapes the pointer to the alloca, we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">  /// store a pointer to that here and abort trying to form slices of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">  /// alloca. This will be null if the alloca slices are analyzed successfully.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">  Instruction *PointerEscapingInstr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">  /// The slices of the alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">  /// We store a vector of the slices formed by uses of the alloca here. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">  /// vector is sorted by increasing begin offset, and then the unsplittable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="">  /// slices before the splittable ones. See the Slice inner class for more</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">  /// details.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="">  SmallVector<Slice, 8> Slices;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="">  /// Instructions which will become dead if we rewrite the alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">  /// Note that these are not separated by slice. This is because we expect an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">  /// alloca to be completely rewritten or not rewritten at all. If rewritten,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">  /// all these instructions can simply be removed and replaced with poison as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="">  /// they come from outside of the allocated space.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">  SmallVector<Instruction *, 8> DeadUsers;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">  /// Uses which will become dead if can promote the alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">  SmallVector<Use *, 8> DeadUseIfPromotable;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">  /// Operands which will become dead if we rewrite the alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="">  /// These are operands that in their particular use can be replaced with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">  /// poison when we rewrite the alloca. These show up in out-of-bounds inputs</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">  /// to PHI nodes and the like. They aren't entirely dead (there might be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="">  /// a GEP back into the bounds using it elsewhere) and nor is the PHI, but we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">  /// want to swap this particular input for poison to simplify the use lists of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">  /// the alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="">  SmallVector<Use *, 8> DeadOperands;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">/// A partition of the slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">/// An ephemeral representation for a range of slices which can be viewed as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">/// a partition of the alloca. This range represents a span of the alloca's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">/// memory which cannot be split, and provides access to all of the slices</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="">/// overlapping some part of the partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">/// Objects of this type are produced by traversing the alloca's slices, but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">/// are only ephemeral and not persistent.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">class llvm::sroa::Partition {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">  friend class AllocaSlices;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">  friend class AllocaSlices::partition_iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">  using iterator = AllocaSlices::iterator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">  /// The beginning and ending offsets of the alloca for this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">  /// partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">  uint64_t BeginOffset = 0, EndOffset = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">  /// The start and end iterators of this partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">  iterator SI, SJ;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">  /// A collection of split slice tails overlapping the partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">  SmallVector<Slice *, 4> SplitTails;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">  /// Raw constructor builds an empty partition starting and ending at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">  /// the given iterator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="uncoveredLine">  Partition(iterator SI) : SI(SI), SJ(SI) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="">  /// The start offset of this partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="">  /// All of the contained slices start at or after this offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">  uint64_t beginOffset() const { return BeginOffset; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">  /// The end offset of this partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">  /// All of the contained slices end at or before this offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="uncoveredLine">  uint64_t endOffset() const { return EndOffset; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">  /// The size of the partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">  /// Note that this can never be zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="uncoveredLine">  uint64_t size() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="uncoveredLine">    assert(BeginOffset < EndOffset && "Partitions must span some bytes!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="uncoveredLine">    return EndOffset - BeginOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">  /// Test whether this partition contains no slices, and merely spans</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="">  /// a region occupied by split slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">  bool empty() const { return SI == SJ; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="">  /// \name Iterate slices that start within the partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">  /// These may be splittable or unsplittable. They have a begin offset >= the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">  /// partition begin offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">  /// @{</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">  // FIXME: We should probably define a "concat_iterator" helper and use that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">  // to stitch together pointee_iterators over the split tails and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">  // contiguous iterators of the partition. That would give a much nicer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">  // interface here. We could then additionally expose filtered iterators for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">  // split, unsplit, and unsplittable splices based on the usage patterns.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="uncoveredLine">  iterator begin() const { return SI; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="uncoveredLine">  iterator end() const { return SJ; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="">  /// @}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">  /// Get the sequence of split slice tails.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">  /// These tails are of slices which start before this partition but are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">  /// split and overlap into the partition. We accumulate these while forming</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">  /// partitions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="uncoveredLine">  ArrayRef<Slice *> splitSliceTails() const { return SplitTails; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">/// An iterator over partitions of the alloca's slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">/// This iterator implements the core algorithm for partitioning the alloca's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">/// slices. It is a forward iterator as we don't support backtracking for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">/// efficiency reasons, and re-use a single storage area to maintain the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">/// current set of split slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">/// It is templated on the slice iterator type to use so that it can operate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">/// with either const or non-const slice iterators.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">class AllocaSlices::partition_iterator</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">    : public iterator_facade_base<partition_iterator, std::forward_iterator_tag,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="">                                  Partition> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">  friend class AllocaSlices;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">  /// Most of the state for walking the partitions is held in a class</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">  /// with a nice interface for examining them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="">  Partition P;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">  /// We need to keep the end of the slices to know when to stop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">  AllocaSlices::iterator SE;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">  /// We also need to keep track of the maximum split end offset seen.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">  /// FIXME: Do we really?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">  uint64_t MaxSplitSliceEndOffset = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">  /// Sets the partition to be empty at given iterator, and sets the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="">  /// end iterator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="uncoveredLine">  partition_iterator(AllocaSlices::iterator SI, AllocaSlices::iterator SE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="uncoveredLine">      : P(SI), SE(SE) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">    // If not already at the end, advance our state to form the initial</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="">    // partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="uncoveredLine">    if (SI != SE)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="uncoveredLine">      advance();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">  /// Advance the iterator to the next partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">  /// Requires that the iterator not be at the end of the slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="uncoveredLine">  void advance() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="uncoveredLine">    assert((P.SI != SE || !P.SplitTails.empty()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="">           "Cannot advance past the end of the slices!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">    // Clear out any split uses which have ended.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="uncoveredLine">    if (!P.SplitTails.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="uncoveredLine">      if (P.EndOffset >= MaxSplitSliceEndOffset) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">        // If we've finished all splits, this is easy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="uncoveredLine">        P.SplitTails.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="uncoveredLine">        MaxSplitSliceEndOffset = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">        // Remove the uses which have ended in the prior partition. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="">        // cannot change the max split slice end because we just checked that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">        // the prior partition ended prior to that max.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="uncoveredLine">        llvm::erase_if(P.SplitTails,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="uncoveredLine">                       [&](Slice *S) { return S->endOffset() <= P.EndOffset; });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="uncoveredLine">        assert(llvm::any_of(P.SplitTails,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">                            [&](Slice *S) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">                              return S->endOffset() == MaxSplitSliceEndOffset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="">                            }) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">               "Could not find the current max split slice offset!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">        assert(llvm::all_of(P.SplitTails,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="">                            [&](Slice *S) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">                              return S->endOffset() <= MaxSplitSliceEndOffset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">                            }) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">               "Max split slice end offset is not actually the max!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">    // If P.SI is already at the end, then we've cleared the split tail and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">    // now have an end iterator.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="uncoveredLine">    if (P.SI == SE) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">      assert(P.SplitTails.empty() && "Failed to clear the split slices!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">    // If we had a non-empty partition previously, set up the state for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">    // subsequent partitions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="uncoveredLine">    if (P.SI != P.SJ) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="">      // Accumulate all the splittable slices which started in the old</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">      // partition into the split list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">      for (Slice &S : P)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="uncoveredLine">        if (S.isSplittable() && S.endOffset() > P.EndOffset) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="uncoveredLine">          P.SplitTails.push_back(&S);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="uncoveredLine">          MaxSplitSliceEndOffset =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="uncoveredLine">              std::max(S.endOffset(), MaxSplitSliceEndOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">      // Start from the end of the previous partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">      P.SI = P.SJ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">      // If P.SI is now at the end, we at most have a tail of split slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="uncoveredLine">      if (P.SI == SE) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="uncoveredLine">        P.BeginOffset = P.EndOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="uncoveredLine">        P.EndOffset = MaxSplitSliceEndOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">        return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="">      // If the we have split slices and the next slice is after a gap and is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="">      // not splittable immediately form an empty partition for the split</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">      // slices up until the next slice begins.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="uncoveredLine">      if (!P.SplitTails.empty() && P.SI->beginOffset() != P.EndOffset &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="uncoveredLine">          !P.SI->isSplittable()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">        P.BeginOffset = P.EndOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="uncoveredLine">        P.EndOffset = P.SI->beginOffset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="uncoveredLine">        return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">    // OK, we need to consume new slices. Set the end offset based on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="">    // current slice, and step SJ past it. The beginning offset of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="">    // partition is the beginning offset of the next slice unless we have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="">    // pre-existing split slices that are continuing, in which case we begin</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="">    // at the prior end offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="uncoveredLine">    P.BeginOffset = P.SplitTails.empty() ? P.SI->beginOffset() : P.EndOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="uncoveredLine">    P.EndOffset = P.SI->endOffset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="uncoveredLine">    ++P.SJ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">    // There are two strategies to form a partition based on whether the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">    // partition starts with an unsplittable slice or a splittable slice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="uncoveredLine">    if (!P.SI->isSplittable()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">      // When we're forming an unsplittable region, it must always start at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">      // the first slice and will extend through its end.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="uncoveredLine">      assert(P.BeginOffset == P.SI->beginOffset());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">      // Form a partition including all of the overlapping slices with this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">      // unsplittable slice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="uncoveredLine">      while (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="uncoveredLine">        if (!P.SJ->isSplittable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="uncoveredLine">          P.EndOffset = std::max(P.EndOffset, P.SJ->endOffset());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="uncoveredLine">        ++P.SJ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">      // We have a partition across a set of overlapping unsplittable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">      // partitions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">    // If we're starting with a splittable slice, then we need to form</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">    // a synthetic partition spanning it and any other overlapping splittable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">    // splices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="uncoveredLine">    assert(P.SI->isSplittable() && "Forming a splittable partition!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">    // Collect all of the overlapping splittable slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="uncoveredLine">    while (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="uncoveredLine">           P.SJ->isSplittable()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">      P.EndOffset = std::max(P.EndOffset, P.SJ->endOffset());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="uncoveredLine">      ++P.SJ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="">    // Back upiP.EndOffset if we ended the span early when encountering an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="">    // unsplittable slice. This synthesizes the early end offset of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">    // a partition spanning only splittable slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="uncoveredLine">    if (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">      assert(!P.SJ->isSplittable());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="uncoveredLine">      P.EndOffset = P.SJ->beginOffset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="uncoveredLine">  bool operator==(const partition_iterator &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="uncoveredLine">    assert(SE == RHS.SE &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="">           "End iterators don't match between compared partition iterators!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">    // The observed positions of partitions is marked by the P.SI iterator and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">    // the emptiness of the split slices. The latter is only relevant when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">    // P.SI == SE, as the end iterator will additionally have an empty split</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="">    // slices list, but the prior may have the same P.SI and a tail of split</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">    // slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="uncoveredLine">    if (P.SI == RHS.P.SI && P.SplitTails.empty() == RHS.P.SplitTails.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="uncoveredLine">      assert(P.SJ == RHS.P.SJ &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">             "Same set of slices formed two different sized partitions!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">      assert(P.SplitTails.size() == RHS.P.SplitTails.size() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="">             "Same slice position with differently sized non-empty split "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">             "slice tails!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="uncoveredLine">  partition_iterator &operator++() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="uncoveredLine">    advance();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="uncoveredLine">    return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="uncoveredLine">  Partition &operator*() { return P; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">/// A forward range over the partitions of the alloca's slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">/// This accesses an iterator range over the partitions of the alloca's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">/// slices. It computes these partitions on the fly based on the overlapping</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">/// offsets of the slices and the ability to split them. It will visit "empty"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">/// partitions to cover regions of the alloca only accessed via split</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">/// slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">iterator_range<AllocaSlices::partition_iterator> AllocaSlices::partitions() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="uncoveredLine">  return make_range(partition_iterator(begin(), end()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="uncoveredLine">                    partition_iterator(end(), end()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">static Value *foldSelectInst(SelectInst &SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="">  // If the condition being selected on is a constant or the same value is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="">  // being selected between, fold the select. Yes this does (rarely) happen</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">  // early on.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="uncoveredLine">  if (ConstantInt *CI = dyn_cast<ConstantInt>(SI.getCondition()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">    return SI.getOperand(1 + CI->isZero());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="uncoveredLine">  if (SI.getOperand(1) == SI.getOperand(2))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="uncoveredLine">    return SI.getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">/// A helper that folds a PHI node or a select.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="uncoveredLine">static Value *foldPHINodeOrSelectInst(Instruction &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="uncoveredLine">  if (PHINode *PN = dyn_cast<PHINode>(&I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">    // If PN merges together the same value, return that value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">    return PN->hasConstantValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="uncoveredLine">  return foldSelectInst(cast<SelectInst>(I));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="">/// Builder for the alloca slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">/// This class builds a set of alloca slices by recursively visiting the uses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="">/// of an alloca and making a slice for each load and store at each offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="">class AllocaSlices::SliceBuilder : public PtrUseVisitor<SliceBuilder> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">  friend class PtrUseVisitor<SliceBuilder>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="">  friend class InstVisitor<SliceBuilder>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">  using Base = PtrUseVisitor<SliceBuilder>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">  const uint64_t AllocSize;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">  AllocaSlices &AS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">  SmallDenseMap<Instruction *, unsigned> MemTransferSliceMap;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">  SmallDenseMap<Instruction *, uint64_t> PHIOrSelectSizes;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="">  /// Set to de-duplicate dead instructions found in the use walk.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="">  SmallPtrSet<Instruction *, 4> VisitedDeadInsts;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="uncoveredLine">  SliceBuilder(const DataLayout &DL, AllocaInst &AI, AllocaSlices &AS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">      : PtrUseVisitor<SliceBuilder>(DL),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="uncoveredLine">        AllocSize(DL.getTypeAllocSize(AI.getAllocatedType()).getFixedValue()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="uncoveredLine">        AS(AS) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="uncoveredLine">  void markAsDead(Instruction &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="uncoveredLine">    if (VisitedDeadInsts.insert(&I).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="uncoveredLine">      AS.DeadUsers.push_back(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="uncoveredLine">  void insertUse(Instruction &I, const APInt &Offset, uint64_t Size,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="">                 bool IsSplittable = false) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">    // Completely skip uses which have a zero size or start either before or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">    // past the end of the allocation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="uncoveredLine">    if (Size == 0 || Offset.uge(AllocSize)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "WARNING: Ignoring " << Size << " byte use @"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">                        << Offset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">                        << " which has zero size or starts outside of the "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">                        << AllocSize << " byte alloca:\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="">                        << "    alloca: " << AS.AI << "\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">                        << "       use: " << I << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="uncoveredLine">      return markAsDead(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="uncoveredLine">    uint64_t BeginOffset = Offset.getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="uncoveredLine">    uint64_t EndOffset = BeginOffset + Size;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">    // Clamp the end offset to the end of the allocation. Note that this is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">    // formulated to handle even the case where "BeginOffset + Size" overflows.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="">    // This may appear superficially to be something we could ignore entirely,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">    // but that is not so! There may be widened loads or PHI-node uses where</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="">    // some instructions are dead but not others. We can't completely ignore</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="">    // them, and so have to record at least the information here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="uncoveredLine">    assert(AllocSize >= BeginOffset); // Established above.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="uncoveredLine">    if (Size > AllocSize - BeginOffset) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "WARNING: Clamping a " << Size << " byte use @"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">                        << Offset << " to remain within the " << AllocSize</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">                        << " byte alloca:\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">                        << "    alloca: " << AS.AI << "\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="">                        << "       use: " << I << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">      EndOffset = AllocSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="uncoveredLine">    AS.Slices.push_back(Slice(BeginOffset, EndOffset, U, IsSplittable));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="uncoveredLine">  void visitBitCastInst(BitCastInst &BC) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="uncoveredLine">    if (BC.use_empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="uncoveredLine">      return markAsDead(BC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="uncoveredLine">    return Base::visitBitCastInst(BC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="uncoveredLine">  void visitAddrSpaceCastInst(AddrSpaceCastInst &ASC) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="uncoveredLine">    if (ASC.use_empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="uncoveredLine">      return markAsDead(ASC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="uncoveredLine">    return Base::visitAddrSpaceCastInst(ASC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="uncoveredLine">  void visitGetElementPtrInst(GetElementPtrInst &GEPI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="uncoveredLine">    if (GEPI.use_empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="uncoveredLine">      return markAsDead(GEPI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="uncoveredLine">    if (SROAStrictInbounds && GEPI.isInBounds()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">      // FIXME: This is a manually un-factored variant of the basic code inside</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">      // of GEPs with checking of the inbounds invariant specified in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">      // langref in a very strict sense. If we ever want to enable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">      // SROAStrictInbounds, this code should be factored cleanly into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="">      // PtrUseVisitor, but it is easier to experiment with SROAStrictInbounds</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="">      // by writing out the code here where we have the underlying allocation</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">      // size readily available.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="uncoveredLine">      APInt GEPOffset = Offset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="uncoveredLine">      const DataLayout &DL = GEPI.getModule()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="uncoveredLine">      for (gep_type_iterator GTI = gep_type_begin(GEPI),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="uncoveredLine">                             GTE = gep_type_end(GEPI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="uncoveredLine">           GTI != GTE; ++GTI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="uncoveredLine">        ConstantInt *OpC = dyn_cast<ConstantInt>(GTI.getOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="uncoveredLine">        if (!OpC)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="uncoveredLine">          break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="">        // Handle a struct index, which adds its field offset to the pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="uncoveredLine">        if (StructType *STy = GTI.getStructTypeOrNull()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="uncoveredLine">          unsigned ElementIdx = OpC->getZExtValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="uncoveredLine">          const StructLayout *SL = DL.getStructLayout(STy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">          GEPOffset +=</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="uncoveredLine">              APInt(Offset.getBitWidth(), SL->getElementOffset(ElementIdx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="">        } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="">          // For array or vector indices, scale the index by the size of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="">          // type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="uncoveredLine">          APInt Index = OpC->getValue().sextOrTrunc(Offset.getBitWidth());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">          GEPOffset +=</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="uncoveredLine">              Index *</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="uncoveredLine">              APInt(Offset.getBitWidth(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="uncoveredLine">                    DL.getTypeAllocSize(GTI.getIndexedType()).getFixedValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="uncoveredLine">        }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="">        // If this index has computed an intermediate pointer which is not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="">        // inbounds, then the result of the GEP is a poison value and we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="">        // delete it and all uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="uncoveredLine">        if (GEPOffset.ugt(AllocSize))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="uncoveredLine">          return markAsDead(GEPI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="uncoveredLine">    return Base::visitGetElementPtrInst(GEPI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="uncoveredLine">  void handleLoadOrStore(Type *Ty, Instruction &I, const APInt &Offset,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="">                         uint64_t Size, bool IsVolatile) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">    // We allow splitting of non-volatile loads and stores where the type is an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="">    // integer type. These may be used to implement 'memcpy' or other "transfer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">    // of bits" patterns.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="">    bool IsSplittable =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="uncoveredLine">        Ty->isIntegerTy() && !IsVolatile && DL.typeSizeEqualsStoreSize(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="uncoveredLine">    insertUse(I, Offset, Size, IsSplittable);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">  void visitLoadInst(LoadInst &LI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="uncoveredLine">    assert((!LI.isSimple() || LI.getType()->isSingleValueType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">           "All simple FCA loads should have been pre-split");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="uncoveredLine">    if (!IsOffsetKnown)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="uncoveredLine">      return PI.setAborted(&LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="uncoveredLine">    TypeSize Size = DL.getTypeStoreSize(LI.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="uncoveredLine">    if (Size.isScalable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="uncoveredLine">      return PI.setAborted(&LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="uncoveredLine">    return handleLoadOrStore(LI.getType(), LI, Offset, Size.getFixedValue(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="uncoveredLine">                             LI.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="uncoveredLine">  void visitStoreInst(StoreInst &SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="uncoveredLine">    Value *ValOp = SI.getValueOperand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="uncoveredLine">    if (ValOp == *U)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="uncoveredLine">      return PI.setEscapedAndAborted(&SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="uncoveredLine">    if (!IsOffsetKnown)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="uncoveredLine">      return PI.setAborted(&SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="uncoveredLine">    TypeSize StoreSize = DL.getTypeStoreSize(ValOp->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="uncoveredLine">    if (StoreSize.isScalable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="uncoveredLine">      return PI.setAborted(&SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="uncoveredLine">    uint64_t Size = StoreSize.getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="">    // If this memory access can be shown to *statically* extend outside the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="">    // bounds of the allocation, it's behavior is undefined, so simply</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="">    // ignore it. Note that this is more strict than the generic clamping</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="">    // behavior of insertUse. We also try to handle cases which might run the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">    // risk of overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="">    // FIXME: We should instead consider the pointer to have escaped if this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="">    // function is being instrumented for addressing bugs or race conditions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="uncoveredLine">    if (Size > AllocSize || Offset.ugt(AllocSize - Size)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "WARNING: Ignoring " << Size << " byte store @"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">                        << Offset << " which extends past the end of the "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">                        << AllocSize << " byte alloca:\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">                        << "    alloca: " << AS.AI << "\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="">                        << "       use: " << SI << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="uncoveredLine">      return markAsDead(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="uncoveredLine">    assert((!SI.isSimple() || ValOp->getType()->isSingleValueType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">           "All simple FCA stores should have been pre-split");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="uncoveredLine">    handleLoadOrStore(ValOp->getType(), SI, Offset, Size, SI.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="uncoveredLine">  void visitMemSetInst(MemSetInst &II) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="uncoveredLine">    assert(II.getRawDest() == *U && "Pointer use is not the destination?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="uncoveredLine">    ConstantInt *Length = dyn_cast<ConstantInt>(II.getLength());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="uncoveredLine">    if ((Length && Length->getValue() == 0) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="uncoveredLine">        (IsOffsetKnown && Offset.uge(AllocSize)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">      // Zero-length mem transfer intrinsics can be ignored entirely.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="uncoveredLine">      return markAsDead(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="uncoveredLine">    if (!IsOffsetKnown)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="uncoveredLine">      return PI.setAborted(&II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="uncoveredLine">    insertUse(II, Offset, Length ? Length->getLimitedValue()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="uncoveredLine">                                 : AllocSize - Offset.getLimitedValue(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">              (bool)Length);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="uncoveredLine">  void visitMemTransferInst(MemTransferInst &II) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="uncoveredLine">    ConstantInt *Length = dyn_cast<ConstantInt>(II.getLength());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="uncoveredLine">    if (Length && Length->getValue() == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="">      // Zero-length mem transfer intrinsics can be ignored entirely.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="uncoveredLine">      return markAsDead(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="">    // Because we can visit these intrinsics twice, also check to see if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="">    // first time marked this instruction as dead. If so, skip it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="uncoveredLine">    if (VisitedDeadInsts.count(&II))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="uncoveredLine">    if (!IsOffsetKnown)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="uncoveredLine">      return PI.setAborted(&II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="">    // This side of the transfer is completely out-of-bounds, and so we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="">    // nuke the entire transfer. However, we also need to nuke the other side</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="">    // if already added to our partitions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="">    // FIXME: Yet another place we really should bypass this when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">    // instrumenting for ASan.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="uncoveredLine">    if (Offset.uge(AllocSize)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">      SmallDenseMap<Instruction *, unsigned>::iterator MTPI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="uncoveredLine">          MemTransferSliceMap.find(&II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="uncoveredLine">      if (MTPI != MemTransferSliceMap.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="uncoveredLine">        AS.Slices[MTPI->second].kill();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="uncoveredLine">      return markAsDead(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="uncoveredLine">    uint64_t RawOffset = Offset.getLimitedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="uncoveredLine">    uint64_t Size = Length ? Length->getLimitedValue() : AllocSize - RawOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="">    // Check for the special case where the same exact value is used for both</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="">    // source and dest.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="uncoveredLine">    if (*U == II.getRawDest() && *U == II.getRawSource()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">      // For non-volatile transfers this is a no-op.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="uncoveredLine">      if (!II.isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="uncoveredLine">        return markAsDead(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="uncoveredLine">      return insertUse(II, Offset, Size, /*IsSplittable=*/false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="">    // If we have seen both source and destination for a mem transfer, then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="">    // they both point to the same alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">    bool Inserted;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="uncoveredLine">    SmallDenseMap<Instruction *, unsigned>::iterator MTPI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="uncoveredLine">    std::tie(MTPI, Inserted) =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="uncoveredLine">        MemTransferSliceMap.insert(std::make_pair(&II, AS.Slices.size()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="uncoveredLine">    unsigned PrevIdx = MTPI->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="uncoveredLine">    if (!Inserted) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="uncoveredLine">      Slice &PrevP = AS.Slices[PrevIdx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="">      // Check if the begin offsets match and this is a non-volatile transfer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="">      // In that case, we can completely elide the transfer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">      if (!II.isVolatile() && PrevP.beginOffset() == RawOffset) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="uncoveredLine">        PrevP.kill();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="uncoveredLine">        return markAsDead(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">      // Otherwise we have an offset transfer within the same alloca. We can't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">      // split those.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="uncoveredLine">      PrevP.makeUnsplittable();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">    // Insert the use now that we've fixed up the splittable nature.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="uncoveredLine">    insertUse(II, Offset, Size, /*IsSplittable=*/Inserted && Length);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="">    // Check that we ended up with a valid index in the map.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="uncoveredLine">    assert(AS.Slices[PrevIdx].getUse()->getUser() == &II &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="">           "Map index doesn't point back to a slice with this user.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="">  // Disable SRoA for any intrinsics except for lifetime invariants and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">  // invariant group.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="">  // FIXME: What about debug intrinsics? This matches old behavior, but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="">  // doesn't make sense.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">  void visitIntrinsicInst(IntrinsicInst &II) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="uncoveredLine">    if (II.isDroppable()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="uncoveredLine">      AS.DeadUseIfPromotable.push_back(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="uncoveredLine">    if (!IsOffsetKnown)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="uncoveredLine">      return PI.setAborted(&II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="uncoveredLine">    if (II.isLifetimeStartOrEnd()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="uncoveredLine">      ConstantInt *Length = cast<ConstantInt>(II.getArgOperand(0));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="uncoveredLine">      uint64_t Size = std::min(AllocSize - Offset.getLimitedValue(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="uncoveredLine">                               Length->getLimitedValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="uncoveredLine">      insertUse(II, Offset, Size, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="uncoveredLine">    if (II.isLaunderOrStripInvariantGroup()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="uncoveredLine">      enqueueUsers(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="uncoveredLine">    Base::visitIntrinsicInst(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="uncoveredLine">  Instruction *hasUnsafePHIOrSelectUse(Instruction *Root, uint64_t &Size) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="">    // We consider any PHI or select that results in a direct load or store of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="">    // the same offset to be a viable use for slicing purposes. These uses</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="">    // are considered unsplittable and the size is the maximum loaded or stored</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="">    // size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="uncoveredLine">    SmallPtrSet<Instruction *, 4> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="uncoveredLine">    SmallVector<std::pair<Instruction *, Instruction *>, 4> Uses;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="uncoveredLine">    Visited.insert(Root);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="uncoveredLine">    Uses.push_back(std::make_pair(cast<Instruction>(*U), Root));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="uncoveredLine">    const DataLayout &DL = Root->getModule()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="">    // If there are no loads or stores, the access is dead. We mark that as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">    // a size zero access.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="uncoveredLine">    Size = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">    do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="">      Instruction *I, *UsedI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="uncoveredLine">      std::tie(UsedI, I) = Uses.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="uncoveredLine">      if (LoadInst *LI = dyn_cast<LoadInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="uncoveredLine">        Size =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="uncoveredLine">            std::max(Size, DL.getTypeStoreSize(LI->getType()).getFixedValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="uncoveredLine">      if (StoreInst *SI = dyn_cast<StoreInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="uncoveredLine">        Value *Op = SI->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="uncoveredLine">        if (Op == UsedI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="uncoveredLine">          return SI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="uncoveredLine">        Size =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="uncoveredLine">            std::max(Size, DL.getTypeStoreSize(Op->getType()).getFixedValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="uncoveredLine">      if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="uncoveredLine">        if (!GEP->hasAllZeroIndices())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="uncoveredLine">          return GEP;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="uncoveredLine">      } else if (!isa<BitCastInst>(I) && !isa<PHINode>(I) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="uncoveredLine">                 !isa<SelectInst>(I) && !isa<AddrSpaceCastInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="uncoveredLine">        return I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="uncoveredLine">      for (User *U : I->users())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="uncoveredLine">        if (Visited.insert(cast<Instruction>(U)).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="uncoveredLine">          Uses.push_back(std::make_pair(I, cast<Instruction>(U)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="uncoveredLine">    } while (!Uses.empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="uncoveredLine">  void visitPHINodeOrSelectInst(Instruction &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="uncoveredLine">    assert(isa<PHINode>(I) || isa<SelectInst>(I));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="uncoveredLine">    if (I.use_empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="uncoveredLine">      return markAsDead(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="">    // If this is a PHI node before a catchswitch, we cannot insert any non-PHI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">    // instructions in this BB, which may be required during rewriting. Bail out</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="">    // on these cases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="uncoveredLine">    if (isa<PHINode>(I) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="uncoveredLine">        I.getParent()->getFirstInsertionPt() == I.getParent()->end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="uncoveredLine">      return PI.setAborted(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="">    // TODO: We could use simplifyInstruction here to fold PHINodes and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="">    // SelectInsts. However, doing so requires to change the current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="">    // dead-operand-tracking mechanism. For instance, suppose neither loading</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">    // from %U nor %other traps. Then "load (select undef, %U, %other)" does not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="">    // trap either.  However, if we simply replace %U with undef using the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">    // current dead-operand-tracking mechanism, "load (select undef, undef,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="">    // %other)" may trap because the select may return the first operand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">    // "undef".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="uncoveredLine">    if (Value *Result = foldPHINodeOrSelectInst(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="uncoveredLine">      if (Result == *U)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">        // If the result of the constant fold will be the pointer, recurse</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="">        // through the PHI/select as if we had RAUW'ed it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="uncoveredLine">        enqueueUsers(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">        // Otherwise the operand to the PHI/select is dead, and we can replace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">        // it with poison.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="uncoveredLine">        AS.DeadOperands.push_back(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="uncoveredLine">    if (!IsOffsetKnown)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="uncoveredLine">      return PI.setAborted(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">    // See if we already have computed info on this node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="uncoveredLine">    uint64_t &Size = PHIOrSelectSizes[&I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="uncoveredLine">    if (!Size) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">      // This is a new PHI/Select, check for an unsafe use of it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="uncoveredLine">      if (Instruction *UnsafeI = hasUnsafePHIOrSelectUse(&I, Size))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="uncoveredLine">        return PI.setAborted(UnsafeI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="">    // For PHI and select operands outside the alloca, we can't nuke the entire</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">    // phi or select -- the other side might still be relevant, so we special</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">    // case them here and use a separate structure to track the operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="">    // themselves which should be replaced with poison.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">    // FIXME: This should instead be escaped in the event we're instrumenting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">    // for address sanitization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="uncoveredLine">    if (Offset.uge(AllocSize)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="uncoveredLine">      AS.DeadOperands.push_back(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="uncoveredLine">      return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="uncoveredLine">    insertUse(I, Offset, Size);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="uncoveredLine">  void visitPHINode(PHINode &PN) { visitPHINodeOrSelectInst(PN); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="uncoveredLine">  void visitSelectInst(SelectInst &SI) { visitPHINodeOrSelectInst(SI); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="">  /// Disable SROA entirely if there are unhandled users of the alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="uncoveredLine">  void visitInstruction(Instruction &I) { PI.setAborted(&I); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="uncoveredLine">AllocaSlices::AllocaSlices(const DataLayout &DL, AllocaInst &AI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="">    :</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="uncoveredLine">      AI(AI),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="uncoveredLine">      PointerEscapingInstr(nullptr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="uncoveredLine">  SliceBuilder PB(DL, AI, *this);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="uncoveredLine">  SliceBuilder::PtrInfo PtrI = PB.visitPtr(AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="uncoveredLine">  if (PtrI.isEscaped() || PtrI.isAborted()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="">    // FIXME: We should sink the escape vs. abort info into the caller nicely,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">    // possibly by just storing the PtrInfo in the AllocaSlices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="uncoveredLine">    PointerEscapingInstr = PtrI.getEscapingInst() ? PtrI.getEscapingInst()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="uncoveredLine">                                                  : PtrI.getAbortingInst();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="uncoveredLine">    assert(PointerEscapingInstr && "Did not track a bad instruction");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="uncoveredLine">  llvm::erase_if(Slices, [](const Slice &S) { return S.isDead(); });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="">  // Sort the uses. This arranges for the offsets to be in ascending order,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">  // and the sizes to be in descending order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="uncoveredLine">  llvm::stable_sort(Slices);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="uncoveredLine">void AllocaSlices::print(raw_ostream &OS, const_iterator I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="">                         StringRef Indent) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="uncoveredLine">  printSlice(OS, I, Indent);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="uncoveredLine">  OS << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="uncoveredLine">  printUse(OS, I, Indent);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="uncoveredLine">void AllocaSlices::printSlice(raw_ostream &OS, const_iterator I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">                              StringRef Indent) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="uncoveredLine">  OS << Indent << "[" << I->beginOffset() << "," << I->endOffset() << ")"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="uncoveredLine">     << " slice #" << (I - begin())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="uncoveredLine">     << (I->isSplittable() ? " (splittable)" : "");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="uncoveredLine">void AllocaSlices::printUse(raw_ostream &OS, const_iterator I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">                            StringRef Indent) const {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="uncoveredLine">  OS << Indent << "  used by: " << *I->getUse()->getUser() << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="uncoveredLine">void AllocaSlices::print(raw_ostream &OS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="uncoveredLine">  if (PointerEscapingInstr) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="uncoveredLine">    OS << "Can't analyze slices for alloca: " << AI << "\n"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="uncoveredLine">       << "  A pointer to this alloca escaped by:\n"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="uncoveredLine">       << "  " << *PointerEscapingInstr << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="uncoveredLine">  OS << "Slices of alloca: " << AI << "\n";</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="uncoveredLine">  for (const_iterator I = begin(), E = end(); I != E; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="uncoveredLine">    print(OS, I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="uncoveredLine">LLVM_DUMP_METHOD void AllocaSlices::dump(const_iterator I) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="uncoveredLine">  print(dbgs(), I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="uncoveredLine">LLVM_DUMP_METHOD void AllocaSlices::dump() const { print(dbgs()); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="">#endif // !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">/// Walk the range of a partitioning looking for a common type to cover this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">/// sequence of slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="">static std::pair<Type *, IntegerType *></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="uncoveredLine">findCommonType(AllocaSlices::const_iterator B, AllocaSlices::const_iterator E,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="">               uint64_t EndOffset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="uncoveredLine">  Type *Ty = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="uncoveredLine">  bool TyIsCommon = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="uncoveredLine">  IntegerType *ITy = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="">  // Note that we need to look at *every* alloca slice's Use to ensure we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">  // always get consistent results regardless of the order of slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="uncoveredLine">  for (AllocaSlices::const_iterator I = B; I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="uncoveredLine">    Use *U = I->getUse();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="uncoveredLine">    if (isa<IntrinsicInst>(*U->getUser()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="uncoveredLine">    if (I->beginOffset() != B->beginOffset() || I->endOffset() != EndOffset)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="uncoveredLine">    Type *UserTy = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="uncoveredLine">    if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="uncoveredLine">      UserTy = LI->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="uncoveredLine">    } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="uncoveredLine">      UserTy = SI->getValueOperand()->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="uncoveredLine">    if (IntegerType *UserITy = dyn_cast_or_null<IntegerType>(UserTy)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="">      // If the type is larger than the partition, skip it. We only encounter</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="">      // this for split integer operations where we want to use the type of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="">      // entity causing the split. Also skip if the type is not a byte width</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="">      // multiple.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="uncoveredLine">      if (UserITy->getBitWidth() % 8 != 0 ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="uncoveredLine">          UserITy->getBitWidth() / 8 > (EndOffset - B->beginOffset()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="">      // Track the largest bitwidth integer type used in this way in case there</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="">      // is no common type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="uncoveredLine">      if (!ITy || ITy->getBitWidth() < UserITy->getBitWidth())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="uncoveredLine">        ITy = UserITy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="">    // To avoid depending on the order of slices, Ty and TyIsCommon must not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="">    // depend on types skipped above.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="uncoveredLine">    if (!UserTy || (Ty && Ty != UserTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="uncoveredLine">      TyIsCommon = false; // Give up on anything but an iN type.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="uncoveredLine">      Ty = UserTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="uncoveredLine">  return {TyIsCommon ? Ty : nullptr, ITy};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="">/// PHI instructions that use an alloca and are subsequently loaded can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="">/// rewritten to load both input pointers in the pred blocks and then PHI the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">/// results, allowing the load of the alloca to be promoted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="">/// From this:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">///   %P2 = phi [i32* %Alloca, i32* %Other]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="">///   %V = load i32* %P2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="">/// to:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="">///   %V1 = load i32* %Alloca      -> will be mem2reg'd</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="">///   ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="">///   %V2 = load i32* %Other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="">///   ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">///   %V = phi [i32 %V1, i32 %V2]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="">/// We can do this to a select if its only uses are loads and if the operands</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="">/// to the select can be loaded unconditionally.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="">/// FIXME: This should be hoisted into a generic utility, likely in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="">/// Transforms/Util/Local.h</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="uncoveredLine">static bool isSafePHIToSpeculate(PHINode &PN) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="uncoveredLine">  const DataLayout &DL = PN.getModule()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="">  // For now, we can only do this promotion if the load is in the same block</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="">  // as the PHI, and if there are no stores between the phi and load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="">  // TODO: Allow recursive phi users.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="">  // TODO: Allow stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="uncoveredLine">  BasicBlock *BB = PN.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="uncoveredLine">  Align MaxAlign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="uncoveredLine">  uint64_t APWidth = DL.getIndexTypeSizeInBits(PN.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="uncoveredLine">  Type *LoadType = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="uncoveredLine">  for (User *U : PN.users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="uncoveredLine">    LoadInst *LI = dyn_cast<LoadInst>(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="uncoveredLine">    if (!LI || !LI->isSimple())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="">    // For now we only allow loads in the same block as the PHI.  This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">    // a common case that happens when instcombine merges two loads through</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="">    // a PHI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="uncoveredLine">    if (LI->getParent() != BB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="uncoveredLine">    if (LoadType) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="uncoveredLine">      if (LoadType != LI->getType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="uncoveredLine">      LoadType = LI->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">    // Ensure that there are no instructions between the PHI and the load that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">    // could store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="uncoveredLine">    for (BasicBlock::iterator BBI(PN); &*BBI != LI; ++BBI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="uncoveredLine">      if (BBI->mayWriteToMemory())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="uncoveredLine">    MaxAlign = std::max(MaxAlign, LI->getAlign());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="uncoveredLine">  if (!LoadType)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="">  APInt LoadSize =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="uncoveredLine">      APInt(APWidth, DL.getTypeStoreSize(LoadType).getFixedValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="">  // We can only transform this if it is safe to push the loads into the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="">  // predecessor blocks. The only thing to watch out for is that we can't put</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="">  // a possibly trapping load in the predecessor if it is a critical edge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="uncoveredLine">  for (unsigned Idx = 0, Num = PN.getNumIncomingValues(); Idx != Num; ++Idx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="uncoveredLine">    Instruction *TI = PN.getIncomingBlock(Idx)->getTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="uncoveredLine">    Value *InVal = PN.getIncomingValue(Idx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="">    // If the value is produced by the terminator of the predecessor (an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="">    // invoke) or it has side-effects, there is no valid place to put a load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="">    // in the predecessor.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="uncoveredLine">    if (TI == InVal || TI->mayHaveSideEffects())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">    // If the predecessor has a single successor, then the edge isn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="">    // critical.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="uncoveredLine">    if (TI->getNumSuccessors() == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">    // If this pointer is always safe to load, or if we can prove that there</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">    // is already a load in the block, then we can move the load to the pred</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="">    // block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="uncoveredLine">    if (isSafeToLoadUnconditionally(InVal, MaxAlign, LoadSize, DL, TI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="uncoveredLine">static void speculatePHINodeLoads(IRBuilderTy &IRB, PHINode &PN) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "    original: " << PN << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="uncoveredLine">  LoadInst *SomeLoad = cast<LoadInst>(PN.user_back());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="uncoveredLine">  Type *LoadTy = SomeLoad->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="uncoveredLine">  IRB.SetInsertPoint(&PN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="uncoveredLine">  PHINode *NewPN = IRB.CreatePHI(LoadTy, PN.getNumIncomingValues(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="uncoveredLine">                                 PN.getName() + ".sroa.speculated");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="">  // Get the AA tags and alignment to use from one of the loads. It does not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="">  // matter which one we get and if any differ.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="uncoveredLine">  AAMDNodes AATags = SomeLoad->getAAMetadata();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="uncoveredLine">  Align Alignment = SomeLoad->getAlign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">  // Rewrite all loads of the PN to use the new PHI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="uncoveredLine">  while (!PN.use_empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="uncoveredLine">    LoadInst *LI = cast<LoadInst>(PN.user_back());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="uncoveredLine">    LI->replaceAllUsesWith(NewPN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="uncoveredLine">    LI->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="">  // Inject loads into all of the pred blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="uncoveredLine">  DenseMap<BasicBlock*, Value*> InjectedLoads;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="uncoveredLine">  for (unsigned Idx = 0, Num = PN.getNumIncomingValues(); Idx != Num; ++Idx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="uncoveredLine">    BasicBlock *Pred = PN.getIncomingBlock(Idx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="uncoveredLine">    Value *InVal = PN.getIncomingValue(Idx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="">    // A PHI node is allowed to have multiple (duplicated) entries for the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="">    // basic block, as long as the value is the same. So if we already injected</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="">    // a load in the predecessor, then we should reuse the same load for all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="">    // duplicated entries.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="uncoveredLine">    if (Value* V = InjectedLoads.lookup(Pred)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="uncoveredLine">      NewPN->addIncoming(V, Pred);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="uncoveredLine">    Instruction *TI = Pred->getTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="uncoveredLine">    IRB.SetInsertPoint(TI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="uncoveredLine">    LoadInst *Load = IRB.CreateAlignedLoad(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">        LoadTy, InVal, Alignment,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="uncoveredLine">        (PN.getName() + ".sroa.speculate.load." + Pred->getName()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="uncoveredLine">    ++NumLoadsSpeculated;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="uncoveredLine">    if (AATags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="uncoveredLine">      Load->setAAMetadata(AATags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="uncoveredLine">    NewPN->addIncoming(Load, Pred);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="uncoveredLine">    InjectedLoads[Pred] = Load;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "          speculated to: " << *NewPN << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="uncoveredLine">  PN.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="">sroa::SelectHandSpeculativity &</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="uncoveredLine">sroa::SelectHandSpeculativity::setAsSpeculatable(bool isTrueVal) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="uncoveredLine">  if (isTrueVal)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="uncoveredLine">    Bitfield::set<sroa::SelectHandSpeculativity::TrueVal>(Storage, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="uncoveredLine">    Bitfield::set<sroa::SelectHandSpeculativity::FalseVal>(Storage, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="uncoveredLine">  return *this;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="uncoveredLine">bool sroa::SelectHandSpeculativity::isSpeculatable(bool isTrueVal) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="">  return isTrueVal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="uncoveredLine">             ? Bitfield::get<sroa::SelectHandSpeculativity::TrueVal>(Storage)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="uncoveredLine">             : Bitfield::get<sroa::SelectHandSpeculativity::FalseVal>(Storage);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="uncoveredLine">bool sroa::SelectHandSpeculativity::areAllSpeculatable() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="uncoveredLine">  return isSpeculatable(/*isTrueVal=*/true) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="uncoveredLine">         isSpeculatable(/*isTrueVal=*/false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="uncoveredLine">bool sroa::SelectHandSpeculativity::areAnySpeculatable() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="uncoveredLine">  return isSpeculatable(/*isTrueVal=*/true) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="uncoveredLine">         isSpeculatable(/*isTrueVal=*/false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="uncoveredLine">bool sroa::SelectHandSpeculativity::areNoneSpeculatable() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="uncoveredLine">  return !areAnySpeculatable();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="">static sroa::SelectHandSpeculativity</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="uncoveredLine">isSafeLoadOfSelectToSpeculate(LoadInst &LI, SelectInst &SI, bool PreserveCFG) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="uncoveredLine">  assert(LI.isSimple() && "Only for simple loads");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="uncoveredLine">  sroa::SelectHandSpeculativity Spec;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="uncoveredLine">  const DataLayout &DL = SI.getModule()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="uncoveredLine">  for (Value *Value : {SI.getTrueValue(), SI.getFalseValue()})</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="uncoveredLine">    if (isSafeToLoadUnconditionally(Value, LI.getType(), LI.getAlign(), DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="">                                    &LI))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="uncoveredLine">      Spec.setAsSpeculatable(/*isTrueVal=*/Value == SI.getTrueValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="uncoveredLine">    else if (PreserveCFG)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="uncoveredLine">      return Spec;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="uncoveredLine">  return Spec;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="">std::optional<sroa::RewriteableMemOps></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="uncoveredLine">SROAPass::isSafeSelectToSpeculate(SelectInst &SI, bool PreserveCFG) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="uncoveredLine">  RewriteableMemOps Ops;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="uncoveredLine">  for (User *U : SI.users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="uncoveredLine">    if (auto *BC = dyn_cast<BitCastInst>(U); BC && BC->hasOneUse())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="uncoveredLine">      U = *BC->user_begin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="uncoveredLine">    if (auto *Store = dyn_cast<StoreInst>(U)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="">      // Note that atomic stores can be transformed; atomic semantics do not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="">      // have any meaning for a local alloca. Stores are not speculatable,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="">      // however, so if we can't turn it into a predicated store, we are done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="uncoveredLine">      if (Store->isVolatile() || PreserveCFG)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="uncoveredLine">        return {}; // Give up on this `select`.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="uncoveredLine">      Ops.emplace_back(Store);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="uncoveredLine">    auto *LI = dyn_cast<LoadInst>(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="">    // Note that atomic loads can be transformed;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="">    // atomic semantics do not have any meaning for a local alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="uncoveredLine">    if (!LI || LI->isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="uncoveredLine">      return {}; // Give up on this `select`.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="uncoveredLine">    PossiblySpeculatableLoad Load(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="uncoveredLine">    if (!LI->isSimple()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="">      // If the `load` is not simple, we can't speculatively execute it,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="">      // but we could handle this via a CFG modification. But can we?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="uncoveredLine">      if (PreserveCFG)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="uncoveredLine">        return {}; // Give up on this `select`.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="uncoveredLine">      Ops.emplace_back(Load);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="">    sroa::SelectHandSpeculativity Spec =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="uncoveredLine">        isSafeLoadOfSelectToSpeculate(*LI, SI, PreserveCFG);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="uncoveredLine">    if (PreserveCFG && !Spec.areAllSpeculatable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="uncoveredLine">      return {}; // Give up on this `select`.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="uncoveredLine">    Load.setInt(Spec);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="uncoveredLine">    Ops.emplace_back(Load);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="uncoveredLine">  return Ops;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="uncoveredLine">static void speculateSelectInstLoads(SelectInst &SI, LoadInst &LI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="">                                     IRBuilderTy &IRB) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "    original load: " << SI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="uncoveredLine">  Value *TV = SI.getTrueValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="uncoveredLine">  Value *FV = SI.getFalseValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="">  // Replace the given load of the select with a select of two loads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="uncoveredLine">  assert(LI.isSimple() && "We only speculate simple loads");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="uncoveredLine">  IRB.SetInsertPoint(&LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="">  LoadInst *TL =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="uncoveredLine">      IRB.CreateAlignedLoad(LI.getType(), TV, LI.getAlign(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="uncoveredLine">                            LI.getName() + ".sroa.speculate.load.true");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="">  LoadInst *FL =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="uncoveredLine">      IRB.CreateAlignedLoad(LI.getType(), FV, LI.getAlign(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="uncoveredLine">                            LI.getName() + ".sroa.speculate.load.false");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="uncoveredLine">  NumLoadsSpeculated += 2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="">  // Transfer alignment and AA info if present.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="uncoveredLine">  TL->setAlignment(LI.getAlign());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="uncoveredLine">  FL->setAlignment(LI.getAlign());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="uncoveredLine">  AAMDNodes Tags = LI.getAAMetadata();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="uncoveredLine">  if (Tags) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="uncoveredLine">    TL->setAAMetadata(Tags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="uncoveredLine">    FL->setAAMetadata(Tags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="uncoveredLine">  Value *V = IRB.CreateSelect(SI.getCondition(), TL, FL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="uncoveredLine">                              LI.getName() + ".sroa.speculated");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "          speculated to: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="uncoveredLine">  LI.replaceAllUsesWith(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="">template <typename T></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="uncoveredLine">static void rewriteMemOpOfSelect(SelectInst &SI, T &I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="">                                 sroa::SelectHandSpeculativity Spec,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="">                                 DomTreeUpdater &DTU) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="uncoveredLine">  assert((isa<LoadInst>(I) || isa<StoreInst>(I)) && "Only for load and store!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "    original mem op: " << I << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="uncoveredLine">  BasicBlock *Head = I.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="uncoveredLine">  Instruction *ThenTerm = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="uncoveredLine">  Instruction *ElseTerm = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="uncoveredLine">  if (Spec.areNoneSpeculatable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="uncoveredLine">    SplitBlockAndInsertIfThenElse(SI.getCondition(), &I, &ThenTerm, &ElseTerm,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="">                                  SI.getMetadata(LLVMContext::MD_prof), &DTU);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="">  else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="uncoveredLine">    SplitBlockAndInsertIfThen(SI.getCondition(), &I, /*Unreachable=*/false,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="">                              SI.getMetadata(LLVMContext::MD_prof), &DTU,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="">                              /*LI=*/nullptr, /*ThenBlock=*/nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="uncoveredLine">    if (Spec.isSpeculatable(/*isTrueVal=*/true))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="uncoveredLine">      cast<BranchInst>(Head->getTerminator())->swapSuccessors();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="uncoveredLine">  auto *HeadBI = cast<BranchInst>(Head->getTerminator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="uncoveredLine">  Spec = {}; // Do not use `Spec` beyond this point.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="uncoveredLine">  BasicBlock *Tail = I.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="uncoveredLine">  Tail->setName(Head->getName() + ".cont");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="">  PHINode *PN;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="uncoveredLine">  if (isa<LoadInst>(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="uncoveredLine">    PN = PHINode::Create(I.getType(), 2, "", &I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="uncoveredLine">  for (BasicBlock *SuccBB : successors(Head)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="uncoveredLine">    bool IsThen = SuccBB == HeadBI->getSuccessor(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="uncoveredLine">    int SuccIdx = IsThen ? 0 : 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="uncoveredLine">    auto *NewMemOpBB = SuccBB == Tail ? Head : SuccBB;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="uncoveredLine">    auto &CondMemOp = cast<T>(*I.clone());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="uncoveredLine">    if (NewMemOpBB != Head) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="uncoveredLine">      NewMemOpBB->setName(Head->getName() + (IsThen ? ".then" : ".else"));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="uncoveredLine">      if (isa<LoadInst>(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="uncoveredLine">        ++NumLoadsPredicated;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="uncoveredLine">        ++NumStoresPredicated;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="uncoveredLine">      CondMemOp.dropUBImplyingAttrsAndMetadata();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="uncoveredLine">      ++NumLoadsSpeculated;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="uncoveredLine">    CondMemOp.insertBefore(NewMemOpBB->getTerminator());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="uncoveredLine">    Value *Ptr = SI.getOperand(1 + SuccIdx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="uncoveredLine">    CondMemOp.setOperand(I.getPointerOperandIndex(), Ptr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="uncoveredLine">    if (isa<LoadInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="uncoveredLine">      CondMemOp.setName(I.getName() + (IsThen ? ".then" : ".else") + ".val");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="uncoveredLine">      PN->addIncoming(&CondMemOp, NewMemOpBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="">    } else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "                 to: " << CondMemOp << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="uncoveredLine">  if (isa<LoadInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="uncoveredLine">    PN->takeName(&I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "          to: " << *PN << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="uncoveredLine">    I.replaceAllUsesWith(PN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="uncoveredLine">static void rewriteMemOpOfSelect(SelectInst &SelInst, Instruction &I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="">                                 sroa::SelectHandSpeculativity Spec,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="">                                 DomTreeUpdater &DTU) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="uncoveredLine">  if (auto *LI = dyn_cast<LoadInst>(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="uncoveredLine">    rewriteMemOpOfSelect(SelInst, *LI, Spec, DTU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="uncoveredLine">  else if (auto *SI = dyn_cast<StoreInst>(&I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="uncoveredLine">    rewriteMemOpOfSelect(SelInst, *SI, Spec, DTU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="uncoveredLine">    llvm_unreachable_internal("Only for load and store.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="uncoveredLine">static bool rewriteSelectInstMemOps(SelectInst &SI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="">                                    const sroa::RewriteableMemOps &Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="">                                    IRBuilderTy &IRB, DomTreeUpdater *DTU) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="uncoveredLine">  bool CFGChanged = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "    original select: " << SI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="uncoveredLine">  for (const RewriteableMemOp &Op : Ops) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="uncoveredLine">    sroa::SelectHandSpeculativity Spec;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="">    Instruction *I;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="uncoveredLine">    if (auto *const *US = std::get_if<UnspeculatableStore>(&Op)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="uncoveredLine">      I = *US;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="uncoveredLine">      auto PSL = std::get<PossiblySpeculatableLoad>(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="uncoveredLine">      I = PSL.getPointer();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="uncoveredLine">      Spec = PSL.getInt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="uncoveredLine">    if (Spec.areAllSpeculatable()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="uncoveredLine">      speculateSelectInstLoads(SI, cast<LoadInst>(*I), IRB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="uncoveredLine">      assert(DTU && "Should not get here when not allowed to modify the CFG!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="uncoveredLine">      rewriteMemOpOfSelect(SI, *I, Spec, *DTU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="uncoveredLine">      CFGChanged = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="uncoveredLine">    I->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="uncoveredLine">  for (User *U : make_early_inc_range(SI.users()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="uncoveredLine">    cast<BitCastInst>(U)->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="uncoveredLine">  SI.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="uncoveredLine">  return CFGChanged;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="">/// Compute an adjusted pointer from Ptr by Offset bytes where the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="">/// resulting pointer has PointerTy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="uncoveredLine">static Value *getAdjustedPtr(IRBuilderTy &IRB, const DataLayout &DL, Value *Ptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="">                             APInt Offset, Type *PointerTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="">                             const Twine &NamePrefix) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="uncoveredLine">  if (Offset != 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="uncoveredLine">    Ptr = IRB.CreateInBoundsGEP(IRB.getInt8Ty(), Ptr, IRB.getInt(Offset),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="uncoveredLine">                                NamePrefix + "sroa_idx");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="uncoveredLine">  return IRB.CreatePointerBitCastOrAddrSpaceCast(Ptr, PointerTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="uncoveredLine">                                                 NamePrefix + "sroa_cast");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="">/// Compute the adjusted alignment for a load or store from an offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="uncoveredLine">static Align getAdjustedAlignment(Instruction *I, uint64_t Offset) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="uncoveredLine">  return commonAlignment(getLoadStoreAlignment(I), Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="">/// Test whether we can convert a value from the old to the new type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="">/// This predicate should be used to guard calls to convertValue in order to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="">/// ensure that we only try to convert viable values. The strategy is that we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="">/// will peel off single element struct and array wrappings to get to an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="">/// underlying value, and convert that value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="uncoveredLine">static bool canConvertValue(const DataLayout &DL, Type *OldTy, Type *NewTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="uncoveredLine">  if (OldTy == NewTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="">  // For integer types, we can't handle any bit-width differences. This would</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="">  // break both vector conversions with extension and introduce endianness</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="">  // issues when in conjunction with loads and stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="uncoveredLine">  if (isa<IntegerType>(OldTy) && isa<IntegerType>(NewTy)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="uncoveredLine">    assert(cast<IntegerType>(OldTy)->getBitWidth() !=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="">               cast<IntegerType>(NewTy)->getBitWidth() &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="">           "We can't have the same bitwidth for different int types");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="uncoveredLine">  if (DL.getTypeSizeInBits(NewTy).getFixedValue() !=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="uncoveredLine">      DL.getTypeSizeInBits(OldTy).getFixedValue())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="uncoveredLine">  if (!NewTy->isSingleValueType() || !OldTy->isSingleValueType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="">  // We can convert pointers to integers and vice-versa. Same for vectors</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="">  // of pointers and integers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="uncoveredLine">  OldTy = OldTy->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="uncoveredLine">  NewTy = NewTy->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="uncoveredLine">  if (NewTy->isPointerTy() || OldTy->isPointerTy()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="uncoveredLine">    if (NewTy->isPointerTy() && OldTy->isPointerTy()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="uncoveredLine">      unsigned OldAS = OldTy->getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="uncoveredLine">      unsigned NewAS = NewTy->getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="">      // Convert pointers if they are pointers from the same address space or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="">      // different integral (not non-integral) address spaces with the same</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="">      // pointer size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="uncoveredLine">      return OldAS == NewAS ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="uncoveredLine">             (!DL.isNonIntegralAddressSpace(OldAS) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="uncoveredLine">              !DL.isNonIntegralAddressSpace(NewAS) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="uncoveredLine">              DL.getPointerSize(OldAS) == DL.getPointerSize(NewAS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="">    // We can convert integers to integral pointers, but not to non-integral</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="">    // pointers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="uncoveredLine">    if (OldTy->isIntegerTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="uncoveredLine">      return !DL.isNonIntegralPointerType(NewTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="">    // We can convert integral pointers to integers, but non-integral pointers</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="">    // need to remain pointers.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="uncoveredLine">    if (!DL.isNonIntegralPointerType(OldTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="uncoveredLine">      return NewTy->isIntegerTy();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="uncoveredLine">  if (OldTy->isTargetExtTy() || NewTy->isTargetExtTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="">/// Generic routine to convert an SSA value to a value of a different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">/// type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="">/// This will try various different casting techniques, such as bitcasts,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="">/// inttoptr, and ptrtoint casts. Use the \c canConvertValue predicate to test</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="">/// two types for viability with this routine.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="uncoveredLine">static Value *convertValue(const DataLayout &DL, IRBuilderTy &IRB, Value *V,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="">                           Type *NewTy) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="uncoveredLine">  Type *OldTy = V->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="uncoveredLine">  assert(canConvertValue(DL, OldTy, NewTy) && "Value not convertable to type");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="uncoveredLine">  if (OldTy == NewTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="uncoveredLine">  assert(!(isa<IntegerType>(OldTy) && isa<IntegerType>(NewTy)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="">         "Integer types must be the exact same to convert.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="">  // See if we need inttoptr for this type pair. May require additional bitcast.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="uncoveredLine">  if (OldTy->isIntOrIntVectorTy() && NewTy->isPtrOrPtrVectorTy()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="">    // Expand <2 x i32> to i8* --> <2 x i32> to i64 to i8*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="">    // Expand i128 to <2 x i8*> --> i128 to <2 x i64> to <2 x i8*></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">    // Expand <4 x i32> to <2 x i8*> --> <4 x i32> to <2 x i64> to <2 x i8*></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="">    // Directly handle i64 to i8*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="uncoveredLine">    return IRB.CreateIntToPtr(IRB.CreateBitCast(V, DL.getIntPtrType(NewTy)),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="uncoveredLine">                              NewTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="">  // See if we need ptrtoint for this type pair. May require additional bitcast.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="uncoveredLine">  if (OldTy->isPtrOrPtrVectorTy() && NewTy->isIntOrIntVectorTy()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="">    // Expand <2 x i8*> to i128 --> <2 x i8*> to <2 x i64> to i128</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="">    // Expand i8* to <2 x i32> --> i8* to i64 to <2 x i32></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="">    // Expand <2 x i8*> to <4 x i32> --> <2 x i8*> to <2 x i64> to <4 x i32></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="">    // Expand i8* to i64 --> i8* to i64 to i64</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="uncoveredLine">    return IRB.CreateBitCast(IRB.CreatePtrToInt(V, DL.getIntPtrType(OldTy)),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="uncoveredLine">                             NewTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="uncoveredLine">  if (OldTy->isPtrOrPtrVectorTy() && NewTy->isPtrOrPtrVectorTy()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="uncoveredLine">    unsigned OldAS = OldTy->getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="uncoveredLine">    unsigned NewAS = NewTy->getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="">    // To convert pointers with different address spaces (they are already</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="">    // checked convertible, i.e. they have the same pointer size), so far we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="">    // cannot use `bitcast` (which has restrict on the same address space) or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="">    // `addrspacecast` (which is not always no-op casting). Instead, use a pair</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="">    // of no-op `ptrtoint`/`inttoptr` casts through an integer with the same bit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="">    // size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="uncoveredLine">    if (OldAS != NewAS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="uncoveredLine">      assert(DL.getPointerSize(OldAS) == DL.getPointerSize(NewAS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="uncoveredLine">      return IRB.CreateIntToPtr(IRB.CreatePtrToInt(V, DL.getIntPtrType(OldTy)),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="uncoveredLine">                                NewTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="uncoveredLine">  return IRB.CreateBitCast(V, NewTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="">/// Test whether the given slice use can be promoted to a vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="">/// This function is called to test each entry in a partition which is slated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="">/// for a single slice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="uncoveredLine">static bool isVectorPromotionViableForSlice(Partition &P, const Slice &S,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="">                                            VectorType *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="">                                            uint64_t ElementSize,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="">                                            const DataLayout &DL) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="">  // First validate the slice offsets.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="">  uint64_t BeginOffset =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="uncoveredLine">      std::max(S.beginOffset(), P.beginOffset()) - P.beginOffset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="uncoveredLine">  uint64_t BeginIndex = BeginOffset / ElementSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="uncoveredLine">  if (BeginIndex * ElementSize != BeginOffset ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="uncoveredLine">      BeginIndex >= cast<FixedVectorType>(Ty)->getNumElements())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="">  uint64_t EndOffset =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="uncoveredLine">      std::min(S.endOffset(), P.endOffset()) - P.beginOffset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="uncoveredLine">  uint64_t EndIndex = EndOffset / ElementSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="uncoveredLine">  if (EndIndex * ElementSize != EndOffset ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="uncoveredLine">      EndIndex > cast<FixedVectorType>(Ty)->getNumElements())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="uncoveredLine">  assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="uncoveredLine">  uint64_t NumElements = EndIndex - BeginIndex;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="">  Type *SliceTy = (NumElements == 1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="uncoveredLine">                      ? Ty->getElementType()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="uncoveredLine">                      : FixedVectorType::get(Ty->getElementType(), NumElements);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="">  Type *SplitIntTy =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="uncoveredLine">      Type::getIntNTy(Ty->getContext(), NumElements * ElementSize * 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="uncoveredLine">  Use *U = S.getUse();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="uncoveredLine">  if (MemIntrinsic *MI = dyn_cast<MemIntrinsic>(U->getUser())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="uncoveredLine">    if (MI->isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="uncoveredLine">    if (!S.isSplittable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="uncoveredLine">      return false; // Skip any unsplittable intrinsics.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="uncoveredLine">  } else if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(U->getUser())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="uncoveredLine">    if (!II->isLifetimeStartOrEnd() && !II->isDroppable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="uncoveredLine">  } else if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="uncoveredLine">    if (LI->isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="uncoveredLine">    Type *LTy = LI->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="">    // Disable vector promotion when there are loads or stores of an FCA.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="uncoveredLine">    if (LTy->isStructTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="uncoveredLine">    if (P.beginOffset() > S.beginOffset() || P.endOffset() < S.endOffset()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="uncoveredLine">      assert(LTy->isIntegerTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="uncoveredLine">      LTy = SplitIntTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="uncoveredLine">    if (!canConvertValue(DL, SliceTy, LTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="uncoveredLine">  } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="uncoveredLine">    if (SI->isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="uncoveredLine">    Type *STy = SI->getValueOperand()->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="">    // Disable vector promotion when there are loads or stores of an FCA.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="uncoveredLine">    if (STy->isStructTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="uncoveredLine">    if (P.beginOffset() > S.beginOffset() || P.endOffset() < S.endOffset()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="uncoveredLine">      assert(STy->isIntegerTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="uncoveredLine">      STy = SplitIntTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="uncoveredLine">    if (!canConvertValue(DL, STy, SliceTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="">/// Test whether a vector type is viable for promotion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="">/// This implements the necessary checking for \c isVectorPromotionViable over</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="">/// all slices of the alloca for the given VectorType.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="uncoveredLine">static bool checkVectorTypeForPromotion(Partition &P, VectorType *VTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="">                                        const DataLayout &DL) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="">  uint64_t ElementSize =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="uncoveredLine">      DL.getTypeSizeInBits(VTy->getElementType()).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="">  // While the definition of LLVM vectors is bitpacked, we don't support sizes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="">  // that aren't byte sized.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="uncoveredLine">  if (ElementSize % 8)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="uncoveredLine">  assert((DL.getTypeSizeInBits(VTy).getFixedValue() % 8) == 0 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="">         "vector size not a multiple of element size?");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="uncoveredLine">  ElementSize /= 8;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="uncoveredLine">  for (const Slice &S : P)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="uncoveredLine">    if (!isVectorPromotionViableForSlice(P, S, VTy, ElementSize, DL))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="uncoveredLine">  for (const Slice *S : P.splitSliceTails())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="uncoveredLine">    if (!isVectorPromotionViableForSlice(P, *S, VTy, ElementSize, DL))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="">/// Test whether the given alloca partitioning and range of slices can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="">/// promoted to a vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="">/// This is a quick test to check whether we can rewrite a particular alloca</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="">/// partition (and its newly formed alloca) into a vector alloca with only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="">/// whole-vector loads and stores such that it could be promoted to a vector</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="">/// SSA value. We only can ensure this for a limited set of operations, and we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="">/// don't want to do the rewrites unless we are confident that the result will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="">/// be promotable, so we have an early test here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="uncoveredLine">static VectorType *isVectorPromotionViable(Partition &P, const DataLayout &DL) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="">  // Collect the candidate types for vector-based promotion. Also track whether</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="">  // we have different element types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="uncoveredLine">  SmallVector<VectorType *, 4> CandidateTys;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="uncoveredLine">  SetVector<Type *> LoadStoreTys;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="uncoveredLine">  Type *CommonEltTy = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="uncoveredLine">  VectorType *CommonVecPtrTy = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="uncoveredLine">  bool HaveVecPtrTy = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="uncoveredLine">  bool HaveCommonEltTy = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="uncoveredLine">  bool HaveCommonVecPtrTy = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="uncoveredLine">  auto CheckCandidateType = [&](Type *Ty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="uncoveredLine">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="">      // Return if bitcast to vectors is different for total size in bits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="uncoveredLine">      if (!CandidateTys.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="uncoveredLine">        VectorType *V = CandidateTys[0];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="uncoveredLine">        if (DL.getTypeSizeInBits(VTy).getFixedValue() !=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="uncoveredLine">            DL.getTypeSizeInBits(V).getFixedValue()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="uncoveredLine">          CandidateTys.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="uncoveredLine">          return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="uncoveredLine">      CandidateTys.push_back(VTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="uncoveredLine">      Type *EltTy = VTy->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="uncoveredLine">      if (!CommonEltTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="uncoveredLine">        CommonEltTy = EltTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="uncoveredLine">      else if (CommonEltTy != EltTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="uncoveredLine">        HaveCommonEltTy = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="uncoveredLine">      if (EltTy->isPointerTy()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="uncoveredLine">        HaveVecPtrTy = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="uncoveredLine">        if (!CommonVecPtrTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="uncoveredLine">          CommonVecPtrTy = VTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="uncoveredLine">        else if (CommonVecPtrTy != VTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="uncoveredLine">          HaveCommonVecPtrTy = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="uncoveredLine">  };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="">  // Put load and store types into a set for de-duplication.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="uncoveredLine">  for (const Slice &S : P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="">    Type *Ty;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="uncoveredLine">    if (auto *LI = dyn_cast<LoadInst>(S.getUse()->getUser()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="uncoveredLine">      Ty = LI->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="uncoveredLine">    else if (auto *SI = dyn_cast<StoreInst>(S.getUse()->getUser()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="uncoveredLine">      Ty = SI->getValueOperand()->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="uncoveredLine">    LoadStoreTys.insert(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="">    // Consider any loads or stores that are the exact size of the slice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="uncoveredLine">    if (S.beginOffset() == P.beginOffset() && S.endOffset() == P.endOffset())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="uncoveredLine">      CheckCandidateType(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="">  // Consider additional vector types where the element type size is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="">  // multiple of load/store element size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="uncoveredLine">  for (Type *Ty : LoadStoreTys) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="uncoveredLine">    if (!VectorType::isValidElementType(Ty))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="uncoveredLine">    unsigned TypeSize = DL.getTypeSizeInBits(Ty).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="">    // Make a copy of CandidateTys and iterate through it, because we might</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="">    // append to CandidateTys in the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="uncoveredLine">    SmallVector<VectorType *, 4> CandidateTysCopy = CandidateTys;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="uncoveredLine">    for (VectorType *&VTy : CandidateTysCopy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="uncoveredLine">      unsigned VectorSize = DL.getTypeSizeInBits(VTy).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="">      unsigned ElementSize =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="uncoveredLine">          DL.getTypeSizeInBits(VTy->getElementType()).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="uncoveredLine">      if (TypeSize != VectorSize && TypeSize != ElementSize &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="uncoveredLine">          VectorSize % TypeSize == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="uncoveredLine">        VectorType *NewVTy = VectorType::get(Ty, VectorSize / TypeSize, false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="uncoveredLine">        CheckCandidateType(NewVTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="">  // If we didn't find a vector type, nothing to do here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="uncoveredLine">  if (CandidateTys.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="">  // Pointer-ness is sticky, if we had a vector-of-pointers candidate type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="">  // then we should choose it, not some other alternative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="">  // But, we can't perform a no-op pointer address space change via bitcast,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="">  // so if we didn't have a common pointer element type, bail.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="uncoveredLine">  if (HaveVecPtrTy && !HaveCommonVecPtrTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="">  // Try to pick the "best" element type out of the choices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="uncoveredLine">  if (!HaveCommonEltTy && HaveVecPtrTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="">    // If there was a pointer element type, there's really only one choice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="uncoveredLine">    CandidateTys.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="uncoveredLine">    CandidateTys.push_back(CommonVecPtrTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="uncoveredLine">  } else if (!HaveCommonEltTy && !HaveVecPtrTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="">    // Integer-ify vector types.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="uncoveredLine">    for (VectorType *&VTy : CandidateTys) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="uncoveredLine">      if (!VTy->getElementType()->isIntegerTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="uncoveredLine">        VTy = cast<VectorType>(VTy->getWithNewType(IntegerType::getIntNTy(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="">            VTy->getContext(), VTy->getScalarSizeInBits())));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="">    // Rank the remaining candidate vector types. This is easy because we know</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="">    // they're all integer vectors. We sort by ascending number of elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="uncoveredLine">    auto RankVectorTypesComp = [&DL](VectorType *RHSTy, VectorType *LHSTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="">      (void)DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="uncoveredLine">      assert(DL.getTypeSizeInBits(RHSTy).getFixedValue() ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="">                 DL.getTypeSizeInBits(LHSTy).getFixedValue() &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="">             "Cannot have vector types of different sizes!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="uncoveredLine">      assert(RHSTy->getElementType()->isIntegerTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="">             "All non-integer types eliminated!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="uncoveredLine">      assert(LHSTy->getElementType()->isIntegerTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="">             "All non-integer types eliminated!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="uncoveredLine">      return cast<FixedVectorType>(RHSTy)->getNumElements() <</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="uncoveredLine">             cast<FixedVectorType>(LHSTy)->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="uncoveredLine">    };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="uncoveredLine">    auto RankVectorTypesEq = [&DL](VectorType *RHSTy, VectorType *LHSTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="">      (void)DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="uncoveredLine">      assert(DL.getTypeSizeInBits(RHSTy).getFixedValue() ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="">                 DL.getTypeSizeInBits(LHSTy).getFixedValue() &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="">             "Cannot have vector types of different sizes!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="uncoveredLine">      assert(RHSTy->getElementType()->isIntegerTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="">             "All non-integer types eliminated!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="uncoveredLine">      assert(LHSTy->getElementType()->isIntegerTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="">             "All non-integer types eliminated!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="uncoveredLine">      return cast<FixedVectorType>(RHSTy)->getNumElements() ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="uncoveredLine">             cast<FixedVectorType>(LHSTy)->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="uncoveredLine">    };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="uncoveredLine">    llvm::sort(CandidateTys, RankVectorTypesComp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="uncoveredLine">    CandidateTys.erase(std::unique(CandidateTys.begin(), CandidateTys.end(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="">                                   RankVectorTypesEq),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="uncoveredLine">                       CandidateTys.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="uncoveredLine">  } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="">// The only way to have the same element type in every vector type is to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="">// have the same vector type. Check that and remove all but one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="uncoveredLine">    for (VectorType *VTy : CandidateTys) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="uncoveredLine">      assert(VTy->getElementType() == CommonEltTy &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="">             "Unaccounted for element type!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="uncoveredLine">      assert(VTy == CandidateTys[0] &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="">             "Different vector types with the same element type!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="uncoveredLine">    CandidateTys.resize(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="">  // FIXME: hack. Do we have a named constant for this?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="">  // SDAG SDNode can't have more than 65535 operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="uncoveredLine">  llvm::erase_if(CandidateTys, [](VectorType *VTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="uncoveredLine">    return cast<FixedVectorType>(VTy)->getNumElements() ></td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="uncoveredLine">           std::numeric_limits<unsigned short>::max();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="uncoveredLine">  for (VectorType *VTy : CandidateTys)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="uncoveredLine">    if (checkVectorTypeForPromotion(P, VTy, DL))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="uncoveredLine">      return VTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="uncoveredLine">  return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="">/// Test whether a slice of an alloca is valid for integer widening.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="">/// This implements the necessary checking for the \c isIntegerWideningViable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="">/// test below on a single slice of the alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="uncoveredLine">static bool isIntegerWideningViableForSlice(const Slice &S,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="">                                            uint64_t AllocBeginOffset,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="">                                            Type *AllocaTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="">                                            const DataLayout &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="">                                            bool &WholeAllocaOp) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="uncoveredLine">  uint64_t Size = DL.getTypeStoreSize(AllocaTy).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="uncoveredLine">  uint64_t RelBegin = S.beginOffset() - AllocBeginOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="uncoveredLine">  uint64_t RelEnd = S.endOffset() - AllocBeginOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="uncoveredLine">  Use *U = S.getUse();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="">  // Lifetime intrinsics operate over the whole alloca whose sizes are usually</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="">  // larger than other load/store slices (RelEnd > Size). But lifetime are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="">  // always promotable and should not impact other slices' promotability of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="">  // partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="uncoveredLine">  if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(U->getUser())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="uncoveredLine">    if (II->isLifetimeStartOrEnd() || II->isDroppable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="">  // We can't reasonably handle cases where the load or store extends past</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="">  // the end of the alloca's type and into its padding.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="uncoveredLine">  if (RelEnd > Size)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="uncoveredLine">  if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="uncoveredLine">    if (LI->isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="">    // We can't handle loads that extend past the allocated memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="uncoveredLine">    if (DL.getTypeStoreSize(LI->getType()).getFixedValue() > Size)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="">    // So far, AllocaSliceRewriter does not support widening split slice tails</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="">    // in rewriteIntegerLoad.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="uncoveredLine">    if (S.beginOffset() < AllocBeginOffset)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="">    // Note that we don't count vector loads or stores as whole-alloca</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="">    // operations which enable integer widening because we would prefer to use</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="">    // vector widening instead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="uncoveredLine">    if (!isa<VectorType>(LI->getType()) && RelBegin == 0 && RelEnd == Size)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="uncoveredLine">      WholeAllocaOp = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="uncoveredLine">    if (IntegerType *ITy = dyn_cast<IntegerType>(LI->getType())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="uncoveredLine">      if (ITy->getBitWidth() < DL.getTypeStoreSizeInBits(ITy).getFixedValue())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="uncoveredLine">    } else if (RelBegin != 0 || RelEnd != Size ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="uncoveredLine">               !canConvertValue(DL, AllocaTy, LI->getType())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="">      // Non-integer loads need to be convertible from the alloca type so that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="">      // they are promotable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="uncoveredLine">  } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="uncoveredLine">    Type *ValueTy = SI->getValueOperand()->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="uncoveredLine">    if (SI->isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="">    // We can't handle stores that extend past the allocated memory.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="uncoveredLine">    if (DL.getTypeStoreSize(ValueTy).getFixedValue() > Size)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="">    // So far, AllocaSliceRewriter does not support widening split slice tails</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="">    // in rewriteIntegerStore.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="uncoveredLine">    if (S.beginOffset() < AllocBeginOffset)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="">    // Note that we don't count vector loads or stores as whole-alloca</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="">    // operations which enable integer widening because we would prefer to use</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="">    // vector widening instead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="uncoveredLine">    if (!isa<VectorType>(ValueTy) && RelBegin == 0 && RelEnd == Size)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="uncoveredLine">      WholeAllocaOp = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="uncoveredLine">    if (IntegerType *ITy = dyn_cast<IntegerType>(ValueTy)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="uncoveredLine">      if (ITy->getBitWidth() < DL.getTypeStoreSizeInBits(ITy).getFixedValue())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="uncoveredLine">    } else if (RelBegin != 0 || RelEnd != Size ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="uncoveredLine">               !canConvertValue(DL, ValueTy, AllocaTy)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="">      // Non-integer stores need to be convertible to the alloca type so that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="">      // they are promotable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="uncoveredLine">  } else if (MemIntrinsic *MI = dyn_cast<MemIntrinsic>(U->getUser())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="uncoveredLine">    if (MI->isVolatile() || !isa<Constant>(MI->getLength()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="uncoveredLine">    if (!S.isSplittable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="uncoveredLine">      return false; // Skip any unsplittable intrinsics.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="">/// Test whether the given alloca partition's integer operations can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="">/// widened to promotable ones.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="">/// This is a quick test to check whether we can rewrite the integer loads and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="">/// stores to a particular alloca into wider loads and stores and be able to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="">/// promote the resulting alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="uncoveredLine">static bool isIntegerWideningViable(Partition &P, Type *AllocaTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="">                                    const DataLayout &DL) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="uncoveredLine">  uint64_t SizeInBits = DL.getTypeSizeInBits(AllocaTy).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="">  // Don't create integer types larger than the maximum bitwidth.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="uncoveredLine">  if (SizeInBits > IntegerType::MAX_INT_BITS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="">  // Don't try to handle allocas with bit-padding.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="uncoveredLine">  if (SizeInBits != DL.getTypeStoreSizeInBits(AllocaTy).getFixedValue())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="">  // We need to ensure that an integer type with the appropriate bitwidth can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="">  // be converted to the alloca type, whatever that is. We don't want to force</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="">  // the alloca itself to have an integer type if there is a more suitable one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="uncoveredLine">  Type *IntTy = Type::getIntNTy(AllocaTy->getContext(), SizeInBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="uncoveredLine">  if (!canConvertValue(DL, AllocaTy, IntTy) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="uncoveredLine">      !canConvertValue(DL, IntTy, AllocaTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="">  // While examining uses, we ensure that the alloca has a covering load or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="">  // store. We don't want to widen the integer operations only to fail to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="">  // promote due to some other unsplittable entry (which we may make splittable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="">  // later). However, if there are only splittable uses, go ahead and assume</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="">  // that we cover the alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="">  // FIXME: We shouldn't consider split slices that happen to start in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="">  // partition here...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="uncoveredLine">  bool WholeAllocaOp = P.empty() && DL.isLegalInteger(SizeInBits);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="uncoveredLine">  for (const Slice &S : P)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="uncoveredLine">    if (!isIntegerWideningViableForSlice(S, P.beginOffset(), AllocaTy, DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="">                                         WholeAllocaOp))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="uncoveredLine">  for (const Slice *S : P.splitSliceTails())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="uncoveredLine">    if (!isIntegerWideningViableForSlice(*S, P.beginOffset(), AllocaTy, DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="">                                         WholeAllocaOp))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="uncoveredLine">  return WholeAllocaOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="uncoveredLine">static Value *extractInteger(const DataLayout &DL, IRBuilderTy &IRB, Value *V,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="">                             IntegerType *Ty, uint64_t Offset,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="">                             const Twine &Name) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "       start: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="uncoveredLine">  IntegerType *IntTy = cast<IntegerType>(V->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="uncoveredLine">  assert(DL.getTypeStoreSize(Ty).getFixedValue() + Offset <=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="">             DL.getTypeStoreSize(IntTy).getFixedValue() &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="">         "Element extends past full value");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="uncoveredLine">  uint64_t ShAmt = 8 * Offset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="uncoveredLine">  if (DL.isBigEndian())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="uncoveredLine">    ShAmt = 8 * (DL.getTypeStoreSize(IntTy).getFixedValue() -</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="uncoveredLine">                 DL.getTypeStoreSize(Ty).getFixedValue() - Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="uncoveredLine">  if (ShAmt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="uncoveredLine">    V = IRB.CreateLShr(V, ShAmt, Name + ".shift");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "     shifted: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="uncoveredLine">  assert(Ty->getBitWidth() <= IntTy->getBitWidth() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="">         "Cannot extract to a larger integer!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="uncoveredLine">  if (Ty != IntTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="uncoveredLine">    V = IRB.CreateTrunc(V, Ty, Name + ".trunc");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "     trunced: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="uncoveredLine">  return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="uncoveredLine">static Value *insertInteger(const DataLayout &DL, IRBuilderTy &IRB, Value *Old,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="">                            Value *V, uint64_t Offset, const Twine &Name) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="uncoveredLine">  IntegerType *IntTy = cast<IntegerType>(Old->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="uncoveredLine">  IntegerType *Ty = cast<IntegerType>(V->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="uncoveredLine">  assert(Ty->getBitWidth() <= IntTy->getBitWidth() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="">         "Cannot insert a larger integer!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "       start: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="uncoveredLine">  if (Ty != IntTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="uncoveredLine">    V = IRB.CreateZExt(V, IntTy, Name + ".ext");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    extended: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="uncoveredLine">  assert(DL.getTypeStoreSize(Ty).getFixedValue() + Offset <=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="">             DL.getTypeStoreSize(IntTy).getFixedValue() &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="">         "Element store outside of alloca store");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="uncoveredLine">  uint64_t ShAmt = 8 * Offset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="uncoveredLine">  if (DL.isBigEndian())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="uncoveredLine">    ShAmt = 8 * (DL.getTypeStoreSize(IntTy).getFixedValue() -</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="uncoveredLine">                 DL.getTypeStoreSize(Ty).getFixedValue() - Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="uncoveredLine">  if (ShAmt) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="uncoveredLine">    V = IRB.CreateShl(V, ShAmt, Name + ".shift");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "     shifted: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="uncoveredLine">  if (ShAmt || Ty->getBitWidth() < IntTy->getBitWidth()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="uncoveredLine">    APInt Mask = ~Ty->getMask().zext(IntTy->getBitWidth()).shl(ShAmt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="uncoveredLine">    Old = IRB.CreateAnd(Old, Mask, Name + ".mask");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "      masked: " << *Old << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="uncoveredLine">    V = IRB.CreateOr(Old, V, Name + ".insert");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    inserted: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="uncoveredLine">  return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="uncoveredLine">static Value *extractVector(IRBuilderTy &IRB, Value *V, unsigned BeginIndex,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="">                            unsigned EndIndex, const Twine &Name) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="uncoveredLine">  auto *VecTy = cast<FixedVectorType>(V->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="uncoveredLine">  unsigned NumElements = EndIndex - BeginIndex;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="uncoveredLine">  assert(NumElements <= VecTy->getNumElements() && "Too many elements!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="uncoveredLine">  if (NumElements == VecTy->getNumElements())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="uncoveredLine">  if (NumElements == 1) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="uncoveredLine">    V = IRB.CreateExtractElement(V, IRB.getInt32(BeginIndex),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="uncoveredLine">                                 Name + ".extract");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "     extract: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="uncoveredLine">  auto Mask = llvm::to_vector<8>(llvm::seq<int>(BeginIndex, EndIndex));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="uncoveredLine">  V = IRB.CreateShuffleVector(V, Mask, Name + ".extract");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "     shuffle: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="uncoveredLine">  return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="uncoveredLine">static Value *insertVector(IRBuilderTy &IRB, Value *Old, Value *V,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="">                           unsigned BeginIndex, const Twine &Name) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="uncoveredLine">  VectorType *VecTy = cast<VectorType>(Old->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="uncoveredLine">  assert(VecTy && "Can only insert a vector into a vector");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="uncoveredLine">  VectorType *Ty = dyn_cast<VectorType>(V->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="uncoveredLine">  if (!Ty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="">    // Single element to insert.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="uncoveredLine">    V = IRB.CreateInsertElement(Old, V, IRB.getInt32(BeginIndex),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="uncoveredLine">                                Name + ".insert");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "     insert: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="uncoveredLine">  assert(cast<FixedVectorType>(Ty)->getNumElements() <=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="">             cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="">         "Too many elements!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="uncoveredLine">  if (cast<FixedVectorType>(Ty)->getNumElements() ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="uncoveredLine">      cast<FixedVectorType>(VecTy)->getNumElements()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="uncoveredLine">    assert(V->getType() == VecTy && "Vector type mismatch");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="uncoveredLine">  unsigned EndIndex = BeginIndex + cast<FixedVectorType>(Ty)->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="">  // When inserting a smaller vector into the larger to store, we first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="">  // use a shuffle vector to widen it with undef elements, and then</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="">  // a second shuffle vector to select between the loaded vector and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="">  // incoming vector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="uncoveredLine">  SmallVector<int, 8> Mask;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="uncoveredLine">  Mask.reserve(cast<FixedVectorType>(VecTy)->getNumElements());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i != cast<FixedVectorType>(VecTy)->getNumElements(); ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="uncoveredLine">    if (i >= BeginIndex && i < EndIndex)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="uncoveredLine">      Mask.push_back(i - BeginIndex);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="uncoveredLine">      Mask.push_back(-1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="uncoveredLine">  V = IRB.CreateShuffleVector(V, Mask, Name + ".expand");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "    shuffle: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="uncoveredLine">  SmallVector<Constant *, 8> Mask2;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="uncoveredLine">  Mask2.reserve(cast<FixedVectorType>(VecTy)->getNumElements());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="uncoveredLine">  for (unsigned i = 0; i != cast<FixedVectorType>(VecTy)->getNumElements(); ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="uncoveredLine">    Mask2.push_back(IRB.getInt1(i >= BeginIndex && i < EndIndex));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="uncoveredLine">  V = IRB.CreateSelect(ConstantVector::get(Mask2), V, Old, Name + "blend");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "    blend: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="uncoveredLine">  return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="">/// Visitor to rewrite instructions using p particular slice of an alloca</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="">/// to use a new alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="">/// Also implements the rewriting to vector-based accesses when the partition</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="">/// passes the isVectorPromotionViable predicate. Most of the rewriting logic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="">/// lives here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="">class llvm::sroa::AllocaSliceRewriter</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="">    : public InstVisitor<AllocaSliceRewriter, bool> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="">  // Befriend the base class so it can delegate to private visit methods.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="">  friend class InstVisitor<AllocaSliceRewriter, bool>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="">  using Base = InstVisitor<AllocaSliceRewriter, bool>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="">  const DataLayout &DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="">  AllocaSlices &AS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="">  SROAPass &Pass;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="">  AllocaInst &OldAI, &NewAI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="">  const uint64_t NewAllocaBeginOffset, NewAllocaEndOffset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="">  Type *NewAllocaTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="">  // This is a convenience and flag variable that will be null unless the new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="">  // alloca's integer operations should be widened to this integer type due to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="">  // passing isIntegerWideningViable above. If it is non-null, the desired</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="">  // integer type will be stored here for easy access during rewriting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="">  IntegerType *IntTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="">  // If we are rewriting an alloca partition which can be written as pure</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="">  // vector operations, we stash extra information here. When VecTy is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="">  // non-null, we have some strict guarantees about the rewritten alloca:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="">  //   - The new alloca is exactly the size of the vector type here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="">  //   - The accesses all either map to the entire vector or to a single</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="">  //     element.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="">  //   - The set of accessing instructions is only one of those handled above</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="">  //     in isVectorPromotionViable. Generally these are the same access kinds</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="">  //     which are promotable via mem2reg.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="">  VectorType *VecTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="">  Type *ElementTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="">  uint64_t ElementSize;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="">  // The original offset of the slice currently being rewritten relative to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="">  // the original alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="">  uint64_t BeginOffset = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="">  uint64_t EndOffset = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="">  // The new offsets of the slice currently being rewritten relative to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="">  // original alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="">  uint64_t NewBeginOffset = 0, NewEndOffset = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="">  uint64_t SliceSize = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="">  bool IsSplittable = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="">  bool IsSplit = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="">  Use *OldUse = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="">  Instruction *OldPtr = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="">  // Track post-rewrite users which are PHI nodes and Selects.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="">  SmallSetVector<PHINode *, 8> &PHIUsers;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="">  SmallSetVector<SelectInst *, 8> &SelectUsers;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="">  // Utility IR builder, whose name prefix is setup for each visited use, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="">  // the insertion point is set to point to the user.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="">  IRBuilderTy IRB;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="">  // Return the new alloca, addrspacecasted if required to avoid changing the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="">  // addrspace of a volatile access.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="uncoveredLine">  Value *getPtrToNewAI(unsigned AddrSpace, bool IsVolatile) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="uncoveredLine">    if (!IsVolatile || AddrSpace == NewAI.getType()->getPointerAddressSpace())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="uncoveredLine">      return &NewAI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="uncoveredLine">    Type *AccessTy = NewAI.getAllocatedType()->getPointerTo(AddrSpace);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="uncoveredLine">    return IRB.CreateAddrSpaceCast(&NewAI, AccessTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="uncoveredLine">  AllocaSliceRewriter(const DataLayout &DL, AllocaSlices &AS, SROAPass &Pass,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="">                      AllocaInst &OldAI, AllocaInst &NewAI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="">                      uint64_t NewAllocaBeginOffset,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="">                      uint64_t NewAllocaEndOffset, bool IsIntegerPromotable,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="">                      VectorType *PromotableVecTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="">                      SmallSetVector<PHINode *, 8> &PHIUsers,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="">                      SmallSetVector<SelectInst *, 8> &SelectUsers)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="uncoveredLine">      : DL(DL), AS(AS), Pass(Pass), OldAI(OldAI), NewAI(NewAI),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="uncoveredLine">        NewAllocaBeginOffset(NewAllocaBeginOffset),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="uncoveredLine">        NewAllocaEndOffset(NewAllocaEndOffset),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="uncoveredLine">        NewAllocaTy(NewAI.getAllocatedType()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="uncoveredLine">        IntTy(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="">            IsIntegerPromotable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="uncoveredLine">                ? Type::getIntNTy(NewAI.getContext(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="uncoveredLine">                                  DL.getTypeSizeInBits(NewAI.getAllocatedType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="uncoveredLine">                                      .getFixedValue())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="">                : nullptr),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="uncoveredLine">        VecTy(PromotableVecTy),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="uncoveredLine">        ElementTy(VecTy ? VecTy->getElementType() : nullptr),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="uncoveredLine">        ElementSize(VecTy ? DL.getTypeSizeInBits(ElementTy).getFixedValue() / 8</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="">                          : 0),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="uncoveredLine">        PHIUsers(PHIUsers), SelectUsers(SelectUsers),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="uncoveredLine">        IRB(NewAI.getContext(), ConstantFolder()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="uncoveredLine">    if (VecTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="uncoveredLine">      assert((DL.getTypeSizeInBits(ElementTy).getFixedValue() % 8) == 0 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="">             "Only multiple-of-8 sized vector elements are viable");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="uncoveredLine">      ++NumVectorized;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="uncoveredLine">    assert((!IntTy && !VecTy) || (IntTy && !VecTy) || (!IntTy && VecTy));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="uncoveredLine">  bool visit(AllocaSlices::const_iterator I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="uncoveredLine">    bool CanSROA = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="uncoveredLine">    BeginOffset = I->beginOffset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="uncoveredLine">    EndOffset = I->endOffset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="uncoveredLine">    IsSplittable = I->isSplittable();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="uncoveredLine">    IsSplit =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="uncoveredLine">        BeginOffset < NewAllocaBeginOffset || EndOffset > NewAllocaEndOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "  rewriting " << (IsSplit ? "split " : ""));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="uncoveredLine">    LLVM_DEBUG(AS.printSlice(dbgs(), I, ""));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="">    // Compute the intersecting offset range.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="uncoveredLine">    assert(BeginOffset < NewAllocaEndOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="uncoveredLine">    assert(EndOffset > NewAllocaBeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="uncoveredLine">    NewBeginOffset = std::max(BeginOffset, NewAllocaBeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="uncoveredLine">    NewEndOffset = std::min(EndOffset, NewAllocaEndOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="uncoveredLine">    SliceSize = NewEndOffset - NewBeginOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "   Begin:(" << BeginOffset << ", " << EndOffset</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="">                      << ") NewBegin:(" << NewBeginOffset << ", "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="">                      << NewEndOffset << ") NewAllocaBegin:("</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="">                      << NewAllocaBeginOffset << ", " << NewAllocaEndOffset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="">                      << ")\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="uncoveredLine">    assert(IsSplit || NewBeginOffset == BeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="uncoveredLine">    OldUse = I->getUse();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="uncoveredLine">    OldPtr = cast<Instruction>(OldUse->get());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="uncoveredLine">    Instruction *OldUserI = cast<Instruction>(OldUse->getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="uncoveredLine">    IRB.SetInsertPoint(OldUserI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="uncoveredLine">    IRB.SetCurrentDebugLocation(OldUserI->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="uncoveredLine">    IRB.getInserter().SetNamePrefix(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="uncoveredLine">        Twine(NewAI.getName()) + "." + Twine(BeginOffset) + ".");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="uncoveredLine">    CanSROA &= visit(cast<Instruction>(OldUse->getUser()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="uncoveredLine">    if (VecTy || IntTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="uncoveredLine">      assert(CanSROA);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="uncoveredLine">    return CanSROA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="">  // Make sure the other visit overloads are visible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="">  using Base::visit;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="">  // Every instruction which can end up as a user must have a rewrite rule.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="uncoveredLine">  bool visitInstruction(Instruction &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    !!!! Cannot rewrite: " << I << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="uncoveredLine">    llvm_unreachable("No rewrite rule for this instruction!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="uncoveredLine">  Value *getNewAllocaSlicePtr(IRBuilderTy &IRB, Type *PointerTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="">    // Note that the offset computation can use BeginOffset or NewBeginOffset</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="">    // interchangeably for unsplit slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="uncoveredLine">    assert(IsSplit || BeginOffset == NewBeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="uncoveredLine">    uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="uncoveredLine">    StringRef OldName = OldPtr->getName();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="">    // Skip through the last '.sroa.' component of the name.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="uncoveredLine">    size_t LastSROAPrefix = OldName.rfind(".sroa.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="uncoveredLine">    if (LastSROAPrefix != StringRef::npos) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="uncoveredLine">      OldName = OldName.substr(LastSROAPrefix + strlen(".sroa."));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="">      // Look for an SROA slice index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="uncoveredLine">      size_t IndexEnd = OldName.find_first_not_of("0123456789");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="uncoveredLine">      if (IndexEnd != StringRef::npos && OldName[IndexEnd] == '.') {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="">        // Strip the index and look for the offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="uncoveredLine">        OldName = OldName.substr(IndexEnd + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="uncoveredLine">        size_t OffsetEnd = OldName.find_first_not_of("0123456789");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="uncoveredLine">        if (OffsetEnd != StringRef::npos && OldName[OffsetEnd] == '.')</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="">          // Strip the offset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="uncoveredLine">          OldName = OldName.substr(OffsetEnd + 1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="">    // Strip any SROA suffixes as well.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="uncoveredLine">    OldName = OldName.substr(0, OldName.find(".sroa_"));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="uncoveredLine">    return getAdjustedPtr(IRB, DL, &NewAI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="uncoveredLine">                          APInt(DL.getIndexTypeSizeInBits(PointerTy), Offset),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="">                          PointerTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="uncoveredLine">                          Twine(OldName) + "."</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="">#else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="">                          Twine()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="uncoveredLine">                          );</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="">  /// Compute suitable alignment to access this slice of the *new*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="">  /// alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="">  /// You can optionally pass a type to this routine and if that type's ABI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="">  /// alignment is itself suitable, this will return zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="uncoveredLine">  Align getSliceAlign() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="uncoveredLine">    return commonAlignment(NewAI.getAlign(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="uncoveredLine">                           NewBeginOffset - NewAllocaBeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="uncoveredLine">  unsigned getIndex(uint64_t Offset) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="uncoveredLine">    assert(VecTy && "Can only call getIndex when rewriting a vector");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="uncoveredLine">    uint64_t RelOffset = Offset - NewAllocaBeginOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="uncoveredLine">    assert(RelOffset / ElementSize < UINT32_MAX && "Index out of bounds");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="uncoveredLine">    uint32_t Index = RelOffset / ElementSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="uncoveredLine">    assert(Index * ElementSize == RelOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="uncoveredLine">    return Index;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="uncoveredLine">  void deleteIfTriviallyDead(Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="uncoveredLine">    Instruction *I = cast<Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="uncoveredLine">    if (isInstructionTriviallyDead(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="uncoveredLine">      Pass.DeadInsts.push_back(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="uncoveredLine">  Value *rewriteVectorizedLoadInst(LoadInst &LI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="uncoveredLine">    unsigned BeginIndex = getIndex(NewBeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="uncoveredLine">    unsigned EndIndex = getIndex(NewEndOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="uncoveredLine">    assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="uncoveredLine">    LoadInst *Load = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="uncoveredLine">                                           NewAI.getAlign(), "load");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="uncoveredLine">    Load->copyMetadata(LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="">                            LLVMContext::MD_access_group});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="uncoveredLine">    return extractVector(IRB, Load, BeginIndex, EndIndex, "vec");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="uncoveredLine">  Value *rewriteIntegerLoad(LoadInst &LI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="uncoveredLine">    assert(IntTy && "We cannot insert an integer to the alloca");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="uncoveredLine">    assert(!LI.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="uncoveredLine">    Value *V = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="uncoveredLine">                                     NewAI.getAlign(), "load");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="uncoveredLine">    V = convertValue(DL, IRB, V, IntTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="uncoveredLine">    assert(NewBeginOffset >= NewAllocaBeginOffset && "Out of bounds offset");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="uncoveredLine">    uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="uncoveredLine">    if (Offset > 0 || NewEndOffset < NewAllocaEndOffset) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="uncoveredLine">      IntegerType *ExtractTy = Type::getIntNTy(LI.getContext(), SliceSize * 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="uncoveredLine">      V = extractInteger(DL, IRB, V, ExtractTy, Offset, "extract");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="">    // It is possible that the extracted type is not the load type. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="">    // happens if there is a load past the end of the alloca, and as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="">    // a consequence the slice is narrower but still a candidate for integer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="">    // lowering. To handle this case, we just zero extend the extracted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="">    // integer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="uncoveredLine">    assert(cast<IntegerType>(LI.getType())->getBitWidth() >= SliceSize * 8 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="">           "Can only handle an extract for an overly wide load");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="uncoveredLine">    if (cast<IntegerType>(LI.getType())->getBitWidth() > SliceSize * 8)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="uncoveredLine">      V = IRB.CreateZExt(V, LI.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="uncoveredLine">  bool visitLoadInst(LoadInst &LI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    original: " << LI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="uncoveredLine">    Value *OldOp = LI.getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="uncoveredLine">    assert(OldOp == OldPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="uncoveredLine">    AAMDNodes AATags = LI.getAAMetadata();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="uncoveredLine">    unsigned AS = LI.getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="uncoveredLine">    Type *TargetTy = IsSplit ? Type::getIntNTy(LI.getContext(), SliceSize * 8)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="uncoveredLine">                             : LI.getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="">    const bool IsLoadPastEnd =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="uncoveredLine">        DL.getTypeStoreSize(TargetTy).getFixedValue() > SliceSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="uncoveredLine">    bool IsPtrAdjusted = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="">    Value *V;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="uncoveredLine">    if (VecTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="uncoveredLine">      V = rewriteVectorizedLoadInst(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="uncoveredLine">    } else if (IntTy && LI.getType()->isIntegerTy()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="uncoveredLine">      V = rewriteIntegerLoad(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="uncoveredLine">    } else if (NewBeginOffset == NewAllocaBeginOffset &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="uncoveredLine">               NewEndOffset == NewAllocaEndOffset &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="uncoveredLine">               (canConvertValue(DL, NewAllocaTy, TargetTy) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="uncoveredLine">                (IsLoadPastEnd && NewAllocaTy->isIntegerTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="uncoveredLine">                 TargetTy->isIntegerTy()))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="">      Value *NewPtr =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="uncoveredLine">          getPtrToNewAI(LI.getPointerAddressSpace(), LI.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="uncoveredLine">      LoadInst *NewLI = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), NewPtr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="uncoveredLine">                                              NewAI.getAlign(), LI.isVolatile(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="uncoveredLine">                                              LI.getName());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="uncoveredLine">      if (LI.isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="uncoveredLine">        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="uncoveredLine">      if (NewLI->isAtomic())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="uncoveredLine">        NewLI->setAlignment(LI.getAlign());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="">      // Copy any metadata that is valid for the new load. This may require</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="">      // conversion to a different kind of metadata, e.g. !nonnull might change</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="">      // to !range or vice versa.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="uncoveredLine">      copyMetadataForLoad(*NewLI, LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="">      // Do this after copyMetadataForLoad() to preserve the TBAA shift.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="uncoveredLine">      if (AATags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="uncoveredLine">        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="">      // Try to preserve nonnull metadata</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="uncoveredLine">      V = NewLI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="">      // If this is an integer load past the end of the slice (which means the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="">      // bytes outside the slice are undef or this load is dead) just forcibly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="">      // fix the integer size with correct handling of endianness.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="uncoveredLine">      if (auto *AITy = dyn_cast<IntegerType>(NewAllocaTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="uncoveredLine">        if (auto *TITy = dyn_cast<IntegerType>(TargetTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="uncoveredLine">          if (AITy->getBitWidth() < TITy->getBitWidth()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="uncoveredLine">            V = IRB.CreateZExt(V, TITy, "load.ext");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="uncoveredLine">            if (DL.isBigEndian())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="uncoveredLine">              V = IRB.CreateShl(V, TITy->getBitWidth() - AITy->getBitWidth(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="">                                "endian_shift");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="uncoveredLine">      Type *LTy = TargetTy->getPointerTo(AS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="">      LoadInst *NewLI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="uncoveredLine">          IRB.CreateAlignedLoad(TargetTy, getNewAllocaSlicePtr(IRB, LTy),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="uncoveredLine">                                getSliceAlign(), LI.isVolatile(), LI.getName());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="uncoveredLine">      if (AATags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="uncoveredLine">        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="uncoveredLine">      if (LI.isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="uncoveredLine">        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="uncoveredLine">      NewLI->copyMetadata(LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="">                               LLVMContext::MD_access_group});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="uncoveredLine">      V = NewLI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="uncoveredLine">      IsPtrAdjusted = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="uncoveredLine">    V = convertValue(DL, IRB, V, TargetTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="uncoveredLine">    if (IsSplit) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="uncoveredLine">      assert(!LI.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="uncoveredLine">      assert(LI.getType()->isIntegerTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="">             "Only integer type loads and stores are split");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="uncoveredLine">      assert(SliceSize < DL.getTypeStoreSize(LI.getType()).getFixedValue() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="">             "Split load isn't smaller than original load");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="uncoveredLine">      assert(DL.typeSizeEqualsStoreSize(LI.getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="">             "Non-byte-multiple bit width");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="">      // Move the insertion point just past the load so that we can refer to it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="uncoveredLine">      IRB.SetInsertPoint(&*std::next(BasicBlock::iterator(&LI)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="">      // Create a placeholder value with the same type as LI to use as the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="">      // basis for the new value. This allows us to replace the uses of LI with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="">      // the computed value, and then replace the placeholder with LI, leaving</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="">      // LI only used for this computation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="">      Value *Placeholder = new LoadInst(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="uncoveredLine">          LI.getType(), PoisonValue::get(LI.getType()->getPointerTo(AS)), "",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="uncoveredLine">          false, Align(1));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="uncoveredLine">      V = insertInteger(DL, IRB, Placeholder, V, NewBeginOffset - BeginOffset,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="">                        "insert");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="uncoveredLine">      LI.replaceAllUsesWith(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="uncoveredLine">      Placeholder->replaceAllUsesWith(&LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="uncoveredLine">      Placeholder->deleteValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="uncoveredLine">      LI.replaceAllUsesWith(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="uncoveredLine">    Pass.DeadInsts.push_back(&LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="uncoveredLine">    deleteIfTriviallyDead(OldOp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "          to: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="uncoveredLine">    return !LI.isVolatile() && !IsPtrAdjusted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="uncoveredLine">  bool rewriteVectorizedStoreInst(Value *V, StoreInst &SI, Value *OldOp,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="">                                  AAMDNodes AATags) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="">    // Capture V for the purpose of debug-info accounting once it's converted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="">    // to a vector store.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="uncoveredLine">    Value *OrigV = V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="uncoveredLine">    if (V->getType() != VecTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="uncoveredLine">      unsigned BeginIndex = getIndex(NewBeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="uncoveredLine">      unsigned EndIndex = getIndex(NewEndOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="uncoveredLine">      assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="uncoveredLine">      unsigned NumElements = EndIndex - BeginIndex;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="uncoveredLine">      assert(NumElements <= cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="">             "Too many elements!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="">      Type *SliceTy = (NumElements == 1)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="uncoveredLine">                          ? ElementTy</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="uncoveredLine">                          : FixedVectorType::get(ElementTy, NumElements);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="uncoveredLine">      if (V->getType() != SliceTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="uncoveredLine">        V = convertValue(DL, IRB, V, SliceTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="">      // Mix in the existing elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="uncoveredLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="uncoveredLine">                                         NewAI.getAlign(), "load");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="uncoveredLine">      V = insertVector(IRB, Old, V, BeginIndex, "vec");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="uncoveredLine">    StoreInst *Store = IRB.CreateAlignedStore(V, &NewAI, NewAI.getAlign());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="uncoveredLine">    Store->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="">                             LLVMContext::MD_access_group});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="uncoveredLine">    if (AATags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="uncoveredLine">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="uncoveredLine">    Pass.DeadInsts.push_back(&SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="">    // NOTE: Careful to use OrigV rather than V.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="uncoveredLine">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="">                     Store, Store->getPointerOperand(), OrigV, DL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="uncoveredLine">  bool rewriteIntegerStore(Value *V, StoreInst &SI, AAMDNodes AATags) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="uncoveredLine">    assert(IntTy && "We cannot extract an integer from the alloca");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="uncoveredLine">    assert(!SI.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="uncoveredLine">    if (DL.getTypeSizeInBits(V->getType()).getFixedValue() !=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="uncoveredLine">        IntTy->getBitWidth()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="uncoveredLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="uncoveredLine">                                         NewAI.getAlign(), "oldload");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="uncoveredLine">      Old = convertValue(DL, IRB, Old, IntTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="uncoveredLine">      assert(BeginOffset >= NewAllocaBeginOffset && "Out of bounds offset");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="uncoveredLine">      uint64_t Offset = BeginOffset - NewAllocaBeginOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="uncoveredLine">      V = insertInteger(DL, IRB, Old, SI.getValueOperand(), Offset, "insert");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="uncoveredLine">    V = convertValue(DL, IRB, V, NewAllocaTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="uncoveredLine">    StoreInst *Store = IRB.CreateAlignedStore(V, &NewAI, NewAI.getAlign());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="uncoveredLine">    Store->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="">                             LLVMContext::MD_access_group});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="uncoveredLine">    if (AATags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="uncoveredLine">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="uncoveredLine">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="">                     Store, Store->getPointerOperand(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="">                     Store->getValueOperand(), DL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="uncoveredLine">    Pass.DeadInsts.push_back(&SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="uncoveredLine">  bool visitStoreInst(StoreInst &SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="uncoveredLine">    Value *OldOp = SI.getOperand(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="uncoveredLine">    assert(OldOp == OldPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="uncoveredLine">    AAMDNodes AATags = SI.getAAMetadata();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="uncoveredLine">    Value *V = SI.getValueOperand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="">    // Strip all inbounds GEPs and pointer casts to try to dig out any root</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="">    // alloca that should be re-examined after promoting this alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="uncoveredLine">    if (V->getType()->isPointerTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="uncoveredLine">      if (AllocaInst *AI = dyn_cast<AllocaInst>(V->stripInBoundsOffsets()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="uncoveredLine">        Pass.PostPromotionWorklist.insert(AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="uncoveredLine">    if (SliceSize < DL.getTypeStoreSize(V->getType()).getFixedValue()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="uncoveredLine">      assert(!SI.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="uncoveredLine">      assert(V->getType()->isIntegerTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="">             "Only integer type loads and stores are split");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="uncoveredLine">      assert(DL.typeSizeEqualsStoreSize(V->getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="">             "Non-byte-multiple bit width");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="uncoveredLine">      IntegerType *NarrowTy = Type::getIntNTy(SI.getContext(), SliceSize * 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="uncoveredLine">      V = extractInteger(DL, IRB, V, NarrowTy, NewBeginOffset - BeginOffset,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="">                         "extract");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="uncoveredLine">    if (VecTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="uncoveredLine">      return rewriteVectorizedStoreInst(V, SI, OldOp, AATags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="uncoveredLine">    if (IntTy && V->getType()->isIntegerTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="uncoveredLine">      return rewriteIntegerStore(V, SI, AATags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="">    const bool IsStorePastEnd =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="uncoveredLine">        DL.getTypeStoreSize(V->getType()).getFixedValue() > SliceSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="">    StoreInst *NewSI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="uncoveredLine">    if (NewBeginOffset == NewAllocaBeginOffset &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="uncoveredLine">        NewEndOffset == NewAllocaEndOffset &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="uncoveredLine">        (canConvertValue(DL, V->getType(), NewAllocaTy) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="uncoveredLine">         (IsStorePastEnd && NewAllocaTy->isIntegerTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="uncoveredLine">          V->getType()->isIntegerTy()))) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="">      // If this is an integer store past the end of slice (and thus the bytes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="">      // past that point are irrelevant or this is unreachable), truncate the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="">      // value prior to storing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="uncoveredLine">      if (auto *VITy = dyn_cast<IntegerType>(V->getType()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="uncoveredLine">        if (auto *AITy = dyn_cast<IntegerType>(NewAllocaTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="uncoveredLine">          if (VITy->getBitWidth() > AITy->getBitWidth()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="uncoveredLine">            if (DL.isBigEndian())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="uncoveredLine">              V = IRB.CreateLShr(V, VITy->getBitWidth() - AITy->getBitWidth(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="">                                 "endian_shift");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="uncoveredLine">            V = IRB.CreateTrunc(V, AITy, "load.trunc");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="uncoveredLine">      V = convertValue(DL, IRB, V, NewAllocaTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="">      Value *NewPtr =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="uncoveredLine">          getPtrToNewAI(SI.getPointerAddressSpace(), SI.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="">      NewSI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="uncoveredLine">          IRB.CreateAlignedStore(V, NewPtr, NewAI.getAlign(), SI.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="uncoveredLine">      unsigned AS = SI.getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="uncoveredLine">      Value *NewPtr = getNewAllocaSlicePtr(IRB, V->getType()->getPointerTo(AS));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="">      NewSI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="uncoveredLine">          IRB.CreateAlignedStore(V, NewPtr, getSliceAlign(), SI.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="uncoveredLine">    NewSI->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="">                             LLVMContext::MD_access_group});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="uncoveredLine">    if (AATags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="uncoveredLine">      NewSI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="uncoveredLine">    if (SI.isVolatile())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="uncoveredLine">      NewSI->setAtomic(SI.getOrdering(), SI.getSyncScopeID());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="uncoveredLine">    if (NewSI->isAtomic())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="uncoveredLine">      NewSI->setAlignment(SI.getAlign());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="uncoveredLine">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="">                     NewSI, NewSI->getPointerOperand(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="">                     NewSI->getValueOperand(), DL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="uncoveredLine">    Pass.DeadInsts.push_back(&SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="uncoveredLine">    deleteIfTriviallyDead(OldOp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "          to: " << *NewSI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="uncoveredLine">    return NewSI->getPointerOperand() == &NewAI &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="uncoveredLine">           NewSI->getValueOperand()->getType() == NewAllocaTy &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="uncoveredLine">           !SI.isVolatile();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="">  /// Compute an integer value from splatting an i8 across the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="">  /// number of bytes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="">  /// Note that this routine assumes an i8 is a byte. If that isn't true, don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="">  /// call this routine.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="">  /// FIXME: Heed the advice above.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="">  /// \param V The i8 value to splat.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="">  /// \param Size The number of bytes in the output (assuming i8 is one byte)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="uncoveredLine">  Value *getIntegerSplat(Value *V, unsigned Size) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="uncoveredLine">    assert(Size > 0 && "Expected a positive number of bytes.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="uncoveredLine">    IntegerType *VTy = cast<IntegerType>(V->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="uncoveredLine">    assert(VTy->getBitWidth() == 8 && "Expected an i8 value for the byte");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="uncoveredLine">    if (Size == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="uncoveredLine">      return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="uncoveredLine">    Type *SplatIntTy = Type::getIntNTy(VTy->getContext(), Size * 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="uncoveredLine">    V = IRB.CreateMul(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="">        IRB.CreateZExt(V, SplatIntTy, "zext"),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="uncoveredLine">        IRB.CreateUDiv(Constant::getAllOnesValue(SplatIntTy),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="uncoveredLine">                       IRB.CreateZExt(Constant::getAllOnesValue(V->getType()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="">                                      SplatIntTy)),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="">        "isplat");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="">  /// Compute a vector splat for a given element value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="uncoveredLine">  Value *getVectorSplat(Value *V, unsigned NumElements) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="uncoveredLine">    V = IRB.CreateVectorSplat(NumElements, V, "vsplat");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "       splat: " << *V << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="uncoveredLine">    return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="uncoveredLine">  bool visitMemSetInst(MemSetInst &II) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="uncoveredLine">    assert(II.getRawDest() == OldPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="uncoveredLine">    AAMDNodes AATags = II.getAAMetadata();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="">    // If the memset has a variable size, it cannot be split, just adjust the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="">    // pointer to the new alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="uncoveredLine">    if (!isa<ConstantInt>(II.getLength())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="uncoveredLine">      assert(!IsSplit);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="uncoveredLine">      assert(NewBeginOffset == BeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="uncoveredLine">      II.setDest(getNewAllocaSlicePtr(IRB, OldPtr->getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="uncoveredLine">      II.setDestAlignment(getSliceAlign());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="">      // In theory we should call migrateDebugInfo here. However, we do not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="">      // emit dbg.assign intrinsics for mem intrinsics storing through non-</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="">      // constant geps, or storing a variable number of bytes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="uncoveredLine">      assert(at::getAssignmentMarkers(&II).empty() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="">             "AT: Unexpected link to non-const GEP");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="uncoveredLine">      deleteIfTriviallyDead(OldPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="">    // Record this instruction for deletion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="uncoveredLine">    Pass.DeadInsts.push_back(&II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="uncoveredLine">    Type *AllocaTy = NewAI.getAllocatedType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="uncoveredLine">    Type *ScalarTy = AllocaTy->getScalarType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class="uncoveredLine">    const bool CanContinue = [&]() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="uncoveredLine">      if (VecTy || IntTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="uncoveredLine">        return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class="uncoveredLine">      if (BeginOffset > NewAllocaBeginOffset ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class="uncoveredLine">          EndOffset < NewAllocaEndOffset)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="">      // Length must be in range for FixedVectorType.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="uncoveredLine">      auto *C = cast<ConstantInt>(II.getLength());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="uncoveredLine">      const uint64_t Len = C->getLimitedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="uncoveredLine">      if (Len > std::numeric_limits<unsigned>::max())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="uncoveredLine">        return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="uncoveredLine">      auto *Int8Ty = IntegerType::getInt8Ty(NewAI.getContext());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="uncoveredLine">      auto *SrcTy = FixedVectorType::get(Int8Ty, Len);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="uncoveredLine">      return canConvertValue(DL, SrcTy, AllocaTy) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="uncoveredLine">             DL.isLegalInteger(DL.getTypeSizeInBits(ScalarTy).getFixedValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="uncoveredLine">    }();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="">    // If this doesn't map cleanly onto the alloca type, and that type isn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="">    // a single value type, just emit a memset.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="uncoveredLine">    if (!CanContinue) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class="uncoveredLine">      Type *SizeTy = II.getLength()->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="uncoveredLine">      Constant *Size = ConstantInt::get(SizeTy, NewEndOffset - NewBeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="uncoveredLine">      MemIntrinsic *New = cast<MemIntrinsic>(IRB.CreateMemSet(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="uncoveredLine">          getNewAllocaSlicePtr(IRB, OldPtr->getType()), II.getValue(), Size,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="uncoveredLine">          MaybeAlign(getSliceAlign()), II.isVolatile()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="uncoveredLine">      if (AATags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="uncoveredLine">        New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="uncoveredLine">      migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="">                       New, New->getRawDest(), nullptr, DL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="">    // If we can represent this as a simple value, we have to build the actual</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="">    // value to store, which requires expanding the byte present in memset to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="">    // a sensible representation for the alloca type. This is essentially</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="">    // splatting the byte to a sufficiently wide integer, splatting it across</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="">    // any desired vector width, and bitcasting to the final type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="">    Value *V;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="uncoveredLine">    if (VecTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="">      // If this is a memset of a vectorized alloca, insert it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="uncoveredLine">      assert(ElementTy == ScalarTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="uncoveredLine">      unsigned BeginIndex = getIndex(NewBeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="uncoveredLine">      unsigned EndIndex = getIndex(NewEndOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class="uncoveredLine">      assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="uncoveredLine">      unsigned NumElements = EndIndex - BeginIndex;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="uncoveredLine">      assert(NumElements <= cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="">             "Too many elements!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="uncoveredLine">      Value *Splat = getIntegerSplat(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="uncoveredLine">          II.getValue(), DL.getTypeSizeInBits(ElementTy).getFixedValue() / 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="uncoveredLine">      Splat = convertValue(DL, IRB, Splat, ElementTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="uncoveredLine">      if (NumElements > 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="uncoveredLine">        Splat = getVectorSplat(Splat, NumElements);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="uncoveredLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class="uncoveredLine">                                         NewAI.getAlign(), "oldload");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="uncoveredLine">      V = insertVector(IRB, Old, Splat, BeginIndex, "vec");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="uncoveredLine">    } else if (IntTy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="">      // If this is a memset on an alloca where we can widen stores, insert the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="">      // set integer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="uncoveredLine">      assert(!II.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="uncoveredLine">      uint64_t Size = NewEndOffset - NewBeginOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="uncoveredLine">      V = getIntegerSplat(II.getValue(), Size);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="uncoveredLine">      if (IntTy && (BeginOffset != NewAllocaBeginOffset ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="uncoveredLine">                    EndOffset != NewAllocaBeginOffset)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="uncoveredLine">        Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="uncoveredLine">                                           NewAI.getAlign(), "oldload");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="uncoveredLine">        Old = convertValue(DL, IRB, Old, IntTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="uncoveredLine">        uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="uncoveredLine">        V = insertInteger(DL, IRB, Old, V, Offset, "insert");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="uncoveredLine">      } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="uncoveredLine">        assert(V->getType() == IntTy &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="">               "Wrong type for an alloca wide integer!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="uncoveredLine">      V = convertValue(DL, IRB, V, AllocaTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="">      // Established these invariants above.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="uncoveredLine">      assert(NewBeginOffset == NewAllocaBeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="uncoveredLine">      assert(NewEndOffset == NewAllocaEndOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3080</td>
    <td class="uncoveredLine">      V = getIntegerSplat(II.getValue(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3081</td>
    <td class="uncoveredLine">                          DL.getTypeSizeInBits(ScalarTy).getFixedValue() / 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3082</td>
    <td class="uncoveredLine">      if (VectorType *AllocaVecTy = dyn_cast<VectorType>(AllocaTy))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3083</td>
    <td class="uncoveredLine">        V = getVectorSplat(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3084</td>
    <td class="">            V, cast<FixedVectorType>(AllocaVecTy)->getNumElements());</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3085</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3086</td>
    <td class="uncoveredLine">      V = convertValue(DL, IRB, V, AllocaTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3087</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3088</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3089</td>
    <td class="uncoveredLine">    Value *NewPtr = getPtrToNewAI(II.getDestAddressSpace(), II.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3090</td>
    <td class="">    StoreInst *New =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3091</td>
    <td class="uncoveredLine">        IRB.CreateAlignedStore(V, NewPtr, NewAI.getAlign(), II.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3092</td>
    <td class="uncoveredLine">    New->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3093</td>
    <td class="">                           LLVMContext::MD_access_group});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3094</td>
    <td class="uncoveredLine">    if (AATags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3095</td>
    <td class="uncoveredLine">      New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3096</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3097</td>
    <td class="uncoveredLine">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3098</td>
    <td class="">                     New, New->getPointerOperand(), V, DL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3099</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3100</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3101</td>
    <td class="uncoveredLine">    return !II.isVolatile();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3102</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3104</td>
    <td class="uncoveredLine">  bool visitMemTransferInst(MemTransferInst &II) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3105</td>
    <td class="">    // Rewriting of memory transfer instructions can be a bit tricky. We break</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3106</td>
    <td class="">    // them into two categories: split intrinsics and unsplit intrinsics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3107</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3108</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3109</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3110</td>
    <td class="uncoveredLine">    AAMDNodes AATags = II.getAAMetadata();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3112</td>
    <td class="uncoveredLine">    bool IsDest = &II.getRawDestUse() == OldUse;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3113</td>
    <td class="uncoveredLine">    assert((IsDest && II.getRawDest() == OldPtr) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3114</td>
    <td class="">           (!IsDest && II.getRawSource() == OldPtr));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3115</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3116</td>
    <td class="uncoveredLine">    Align SliceAlign = getSliceAlign();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3117</td>
    <td class="">    // For unsplit intrinsics, we simply modify the source and destination</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3118</td>
    <td class="">    // pointers in place. This isn't just an optimization, it is a matter of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3119</td>
    <td class="">    // correctness. With unsplit intrinsics we may be dealing with transfers</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3120</td>
    <td class="">    // within a single alloca before SROA ran, or with transfers that have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3121</td>
    <td class="">    // a variable length. We may also be dealing with memmove instead of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3122</td>
    <td class="">    // memcpy, and so simply updating the pointers is the necessary for us to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3123</td>
    <td class="">    // update both source and dest of a single call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3124</td>
    <td class="uncoveredLine">    if (!IsSplittable) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3125</td>
    <td class="uncoveredLine">      Value *AdjustedPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3126</td>
    <td class="uncoveredLine">      if (IsDest) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3127</td>
    <td class="">        // Update the address component of linked dbg.assigns.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3128</td>
    <td class="uncoveredLine">        for (auto *DAI : at::getAssignmentMarkers(&II)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3129</td>
    <td class="uncoveredLine">          if (any_of(DAI->location_ops(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3130</td>
    <td class="uncoveredLine">                     [&](Value *V) { return V == II.getDest(); }) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3131</td>
    <td class="uncoveredLine">              DAI->getAddress() == II.getDest())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3132</td>
    <td class="uncoveredLine">            DAI->replaceVariableLocationOp(II.getDest(), AdjustedPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3133</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3134</td>
    <td class="uncoveredLine">        II.setDest(AdjustedPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3135</td>
    <td class="uncoveredLine">        II.setDestAlignment(SliceAlign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3136</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3137</td>
    <td class="uncoveredLine">        II.setSource(AdjustedPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3138</td>
    <td class="uncoveredLine">        II.setSourceAlignment(SliceAlign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3139</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3140</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3141</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "          to: " << II << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3142</td>
    <td class="uncoveredLine">      deleteIfTriviallyDead(OldPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3143</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3144</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3145</td>
    <td class="">    // For split transfer intrinsics we have an incredibly useful assurance:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3146</td>
    <td class="">    // the source and destination do not reside within the same alloca, and at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3147</td>
    <td class="">    // least one of them does not escape. This means that we can replace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3148</td>
    <td class="">    // memmove with memcpy, and we don't need to worry about all manner of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3149</td>
    <td class="">    // downsides to splitting and transforming the operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3150</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3151</td>
    <td class="">    // If this doesn't map cleanly onto the alloca type, and that type isn't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3152</td>
    <td class="">    // a single value type, just emit a memcpy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3153</td>
    <td class="">    bool EmitMemCpy =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3154</td>
    <td class="uncoveredLine">        !VecTy && !IntTy &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3155</td>
    <td class="uncoveredLine">        (BeginOffset > NewAllocaBeginOffset || EndOffset < NewAllocaEndOffset ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3156</td>
    <td class="uncoveredLine">         SliceSize !=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3157</td>
    <td class="uncoveredLine">             DL.getTypeStoreSize(NewAI.getAllocatedType()).getFixedValue() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3158</td>
    <td class="uncoveredLine">         !NewAI.getAllocatedType()->isSingleValueType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3159</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3160</td>
    <td class="">    // If we're just going to emit a memcpy, the alloca hasn't changed, and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3161</td>
    <td class="">    // size hasn't been shrunk based on analysis of the viable range, this is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3162</td>
    <td class="">    // a no-op.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3163</td>
    <td class="uncoveredLine">    if (EmitMemCpy && &OldAI == &NewAI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3164</td>
    <td class="">      // Ensure the start lines up.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3165</td>
    <td class="uncoveredLine">      assert(NewBeginOffset == BeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3166</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3167</td>
    <td class="">      // Rewrite the size as needed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3168</td>
    <td class="uncoveredLine">      if (NewEndOffset != EndOffset)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3169</td>
    <td class="uncoveredLine">        II.setLength(ConstantInt::get(II.getLength()->getType(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3170</td>
    <td class="uncoveredLine">                                      NewEndOffset - NewBeginOffset));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3171</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3172</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3173</td>
    <td class="">    // Record this instruction for deletion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3174</td>
    <td class="uncoveredLine">    Pass.DeadInsts.push_back(&II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3176</td>
    <td class="">    // Strip all inbounds GEPs and pointer casts to try to dig out any root</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3177</td>
    <td class="">    // alloca that should be re-examined after rewriting this instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3178</td>
    <td class="uncoveredLine">    Value *OtherPtr = IsDest ? II.getRawSource() : II.getRawDest();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3179</td>
    <td class="uncoveredLine">    if (AllocaInst *AI =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3180</td>
    <td class="uncoveredLine">            dyn_cast<AllocaInst>(OtherPtr->stripInBoundsOffsets())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3181</td>
    <td class="uncoveredLine">      assert(AI != &OldAI && AI != &NewAI &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3182</td>
    <td class="">             "Splittable transfers cannot reach the same alloca on both ends.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3183</td>
    <td class="uncoveredLine">      Pass.Worklist.insert(AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3184</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3186</td>
    <td class="uncoveredLine">    Type *OtherPtrTy = OtherPtr->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3187</td>
    <td class="uncoveredLine">    unsigned OtherAS = OtherPtrTy->getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3188</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3189</td>
    <td class="">    // Compute the relative offset for the other pointer within the transfer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3190</td>
    <td class="uncoveredLine">    unsigned OffsetWidth = DL.getIndexSizeInBits(OtherAS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3191</td>
    <td class="uncoveredLine">    APInt OtherOffset(OffsetWidth, NewBeginOffset - BeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3192</td>
    <td class="">    Align OtherAlign =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3193</td>
    <td class="uncoveredLine">        (IsDest ? II.getSourceAlign() : II.getDestAlign()).valueOrOne();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3194</td>
    <td class="">    OtherAlign =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3195</td>
    <td class="uncoveredLine">        commonAlignment(OtherAlign, OtherOffset.zextOrTrunc(64).getZExtValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3196</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3197</td>
    <td class="uncoveredLine">    if (EmitMemCpy) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3198</td>
    <td class="">      // Compute the other pointer, folding as much as possible to produce</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3199</td>
    <td class="">      // a single, simple GEP in most cases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3200</td>
    <td class="uncoveredLine">      OtherPtr = getAdjustedPtr(IRB, DL, OtherPtr, OtherOffset, OtherPtrTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3201</td>
    <td class="uncoveredLine">                                OtherPtr->getName() + ".");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3202</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3203</td>
    <td class="uncoveredLine">      Value *OurPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3204</td>
    <td class="uncoveredLine">      Type *SizeTy = II.getLength()->getType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3205</td>
    <td class="uncoveredLine">      Constant *Size = ConstantInt::get(SizeTy, NewEndOffset - NewBeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3206</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3207</td>
    <td class="">      Value *DestPtr, *SrcPtr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3208</td>
    <td class="uncoveredLine">      MaybeAlign DestAlign, SrcAlign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3209</td>
    <td class="">      // Note: IsDest is true iff we're copying into the new alloca slice</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3210</td>
    <td class="uncoveredLine">      if (IsDest) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3211</td>
    <td class="uncoveredLine">        DestPtr = OurPtr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3212</td>
    <td class="uncoveredLine">        DestAlign = SliceAlign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3213</td>
    <td class="uncoveredLine">        SrcPtr = OtherPtr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3214</td>
    <td class="uncoveredLine">        SrcAlign = OtherAlign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3215</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3216</td>
    <td class="uncoveredLine">        DestPtr = OtherPtr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3217</td>
    <td class="uncoveredLine">        DestAlign = OtherAlign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3218</td>
    <td class="uncoveredLine">        SrcPtr = OurPtr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3219</td>
    <td class="uncoveredLine">        SrcAlign = SliceAlign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3220</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3221</td>
    <td class="uncoveredLine">      CallInst *New = IRB.CreateMemCpy(DestPtr, DestAlign, SrcPtr, SrcAlign,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3222</td>
    <td class="uncoveredLine">                                       Size, II.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3223</td>
    <td class="uncoveredLine">      if (AATags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3224</td>
    <td class="uncoveredLine">        New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3226</td>
    <td class="uncoveredLine">      APInt Offset(DL.getIndexTypeSizeInBits(DestPtr->getType()), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3227</td>
    <td class="uncoveredLine">      if (IsDest) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3228</td>
    <td class="uncoveredLine">        migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3229</td>
    <td class="">                         &II, New, DestPtr, nullptr, DL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3230</td>
    <td class="uncoveredLine">      } else if (AllocaInst *Base = dyn_cast<AllocaInst>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3231</td>
    <td class="">                     DestPtr->stripAndAccumulateConstantOffsets(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3232</td>
    <td class="">                         DL, Offset, /*AllowNonInbounds*/ true))) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3233</td>
    <td class="uncoveredLine">        migrateDebugInfo(Base, IsSplit, Offset.getZExtValue() * 8,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3234</td>
    <td class="uncoveredLine">                         SliceSize * 8, &II, New, DestPtr, nullptr, DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3235</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3236</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3237</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3238</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3239</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3240</td>
    <td class="uncoveredLine">    bool IsWholeAlloca = NewBeginOffset == NewAllocaBeginOffset &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3241</td>
    <td class="uncoveredLine">                         NewEndOffset == NewAllocaEndOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3242</td>
    <td class="uncoveredLine">    uint64_t Size = NewEndOffset - NewBeginOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3243</td>
    <td class="uncoveredLine">    unsigned BeginIndex = VecTy ? getIndex(NewBeginOffset) : 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3244</td>
    <td class="uncoveredLine">    unsigned EndIndex = VecTy ? getIndex(NewEndOffset) : 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3245</td>
    <td class="uncoveredLine">    unsigned NumElements = EndIndex - BeginIndex;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3246</td>
    <td class="">    IntegerType *SubIntTy =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3247</td>
    <td class="uncoveredLine">        IntTy ? Type::getIntNTy(IntTy->getContext(), Size * 8) : nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3249</td>
    <td class="">    // Reset the other pointer type to match the register type we're going to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3250</td>
    <td class="">    // use, but using the address space of the original other pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3251</td>
    <td class="">    Type *OtherTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3252</td>
    <td class="uncoveredLine">    if (VecTy && !IsWholeAlloca) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3253</td>
    <td class="uncoveredLine">      if (NumElements == 1)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3254</td>
    <td class="uncoveredLine">        OtherTy = VecTy->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3255</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3256</td>
    <td class="uncoveredLine">        OtherTy = FixedVectorType::get(VecTy->getElementType(), NumElements);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3257</td>
    <td class="uncoveredLine">    } else if (IntTy && !IsWholeAlloca) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3258</td>
    <td class="uncoveredLine">      OtherTy = SubIntTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3259</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3260</td>
    <td class="uncoveredLine">      OtherTy = NewAllocaTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3261</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3262</td>
    <td class="uncoveredLine">    OtherPtrTy = OtherTy->getPointerTo(OtherAS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3264</td>
    <td class="uncoveredLine">    Value *AdjPtr = getAdjustedPtr(IRB, DL, OtherPtr, OtherOffset, OtherPtrTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3265</td>
    <td class="uncoveredLine">                                   OtherPtr->getName() + ".");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3266</td>
    <td class="uncoveredLine">    MaybeAlign SrcAlign = OtherAlign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3267</td>
    <td class="uncoveredLine">    MaybeAlign DstAlign = SliceAlign;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3268</td>
    <td class="uncoveredLine">    if (!IsDest)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3269</td>
    <td class="uncoveredLine">      std::swap(SrcAlign, DstAlign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3270</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3271</td>
    <td class="">    Value *SrcPtr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3272</td>
    <td class="">    Value *DstPtr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3273</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3274</td>
    <td class="uncoveredLine">    if (IsDest) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3275</td>
    <td class="uncoveredLine">      DstPtr = getPtrToNewAI(II.getDestAddressSpace(), II.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3276</td>
    <td class="uncoveredLine">      SrcPtr = AdjPtr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3277</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3278</td>
    <td class="uncoveredLine">      DstPtr = AdjPtr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3279</td>
    <td class="uncoveredLine">      SrcPtr = getPtrToNewAI(II.getSourceAddressSpace(), II.isVolatile());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3280</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3281</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3282</td>
    <td class="">    Value *Src;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3283</td>
    <td class="uncoveredLine">    if (VecTy && !IsWholeAlloca && !IsDest) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3284</td>
    <td class="uncoveredLine">      Src = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3285</td>
    <td class="uncoveredLine">                                  NewAI.getAlign(), "load");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3286</td>
    <td class="uncoveredLine">      Src = extractVector(IRB, Src, BeginIndex, EndIndex, "vec");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3287</td>
    <td class="uncoveredLine">    } else if (IntTy && !IsWholeAlloca && !IsDest) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3288</td>
    <td class="uncoveredLine">      Src = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3289</td>
    <td class="uncoveredLine">                                  NewAI.getAlign(), "load");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3290</td>
    <td class="uncoveredLine">      Src = convertValue(DL, IRB, Src, IntTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3291</td>
    <td class="uncoveredLine">      uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3292</td>
    <td class="uncoveredLine">      Src = extractInteger(DL, IRB, Src, SubIntTy, Offset, "extract");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3293</td>
    <td class="uncoveredLine">    } else {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3294</td>
    <td class="uncoveredLine">      LoadInst *Load = IRB.CreateAlignedLoad(OtherTy, SrcPtr, SrcAlign,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3295</td>
    <td class="uncoveredLine">                                             II.isVolatile(), "copyload");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3296</td>
    <td class="uncoveredLine">      Load->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3297</td>
    <td class="">                              LLVMContext::MD_access_group});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3298</td>
    <td class="uncoveredLine">      if (AATags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3299</td>
    <td class="uncoveredLine">        Load->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3300</td>
    <td class="uncoveredLine">      Src = Load;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3301</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3302</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3303</td>
    <td class="uncoveredLine">    if (VecTy && !IsWholeAlloca && IsDest) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3304</td>
    <td class="uncoveredLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3305</td>
    <td class="uncoveredLine">                                         NewAI.getAlign(), "oldload");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3306</td>
    <td class="uncoveredLine">      Src = insertVector(IRB, Old, Src, BeginIndex, "vec");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3307</td>
    <td class="uncoveredLine">    } else if (IntTy && !IsWholeAlloca && IsDest) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3308</td>
    <td class="uncoveredLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3309</td>
    <td class="uncoveredLine">                                         NewAI.getAlign(), "oldload");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3310</td>
    <td class="uncoveredLine">      Old = convertValue(DL, IRB, Old, IntTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3311</td>
    <td class="uncoveredLine">      uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3312</td>
    <td class="uncoveredLine">      Src = insertInteger(DL, IRB, Old, Src, Offset, "insert");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3313</td>
    <td class="uncoveredLine">      Src = convertValue(DL, IRB, Src, NewAllocaTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3314</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3316</td>
    <td class="uncoveredLine">    StoreInst *Store = cast<StoreInst>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3317</td>
    <td class="uncoveredLine">        IRB.CreateAlignedStore(Src, DstPtr, DstAlign, II.isVolatile()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3318</td>
    <td class="uncoveredLine">    Store->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3319</td>
    <td class="">                             LLVMContext::MD_access_group});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3320</td>
    <td class="uncoveredLine">    if (AATags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3321</td>
    <td class="uncoveredLine">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3322</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3323</td>
    <td class="uncoveredLine">    APInt Offset(DL.getIndexTypeSizeInBits(DstPtr->getType()), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3324</td>
    <td class="uncoveredLine">    if (IsDest) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3325</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3326</td>
    <td class="uncoveredLine">      migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3327</td>
    <td class="">                       Store, DstPtr, Src, DL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3328</td>
    <td class="uncoveredLine">    } else if (AllocaInst *Base = dyn_cast<AllocaInst>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3329</td>
    <td class="">                   DstPtr->stripAndAccumulateConstantOffsets(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3330</td>
    <td class="">                       DL, Offset, /*AllowNonInbounds*/ true))) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3331</td>
    <td class="uncoveredLine">      migrateDebugInfo(Base, IsSplit, Offset.getZExtValue() * 8, SliceSize * 8,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3332</td>
    <td class="">                       &II, Store, DstPtr, Src, DL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3333</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3334</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3335</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3336</td>
    <td class="uncoveredLine">    return !II.isVolatile();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3337</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3338</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3339</td>
    <td class="uncoveredLine">  bool visitIntrinsicInst(IntrinsicInst &II) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3340</td>
    <td class="uncoveredLine">    assert((II.isLifetimeStartOrEnd() || II.isDroppable()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3341</td>
    <td class="">           "Unexpected intrinsic!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3342</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3343</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3344</td>
    <td class="">    // Record this instruction for deletion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3345</td>
    <td class="uncoveredLine">    Pass.DeadInsts.push_back(&II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3346</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3347</td>
    <td class="uncoveredLine">    if (II.isDroppable()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3348</td>
    <td class="uncoveredLine">      assert(II.getIntrinsicID() == Intrinsic::assume && "Expected assume");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3349</td>
    <td class="">      // TODO For now we forget assumed information, this can be improved.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3350</td>
    <td class="uncoveredLine">      OldPtr->dropDroppableUsesIn(II);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3351</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3352</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3353</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3354</td>
    <td class="uncoveredLine">    assert(II.getArgOperand(1) == OldPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3355</td>
    <td class="">    // Lifetime intrinsics are only promotable if they cover the whole alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3356</td>
    <td class="">    // Therefore, we drop lifetime intrinsics which don't cover the whole</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3357</td>
    <td class="">    // alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3358</td>
    <td class="">    // (In theory, intrinsics which partially cover an alloca could be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3359</td>
    <td class="">    // promoted, but PromoteMemToReg doesn't handle that case.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3360</td>
    <td class="">    // FIXME: Check whether the alloca is promotable before dropping the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3361</td>
    <td class="">    // lifetime intrinsics?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3362</td>
    <td class="uncoveredLine">    if (NewBeginOffset != NewAllocaBeginOffset ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3363</td>
    <td class="uncoveredLine">        NewEndOffset != NewAllocaEndOffset)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3364</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3365</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3366</td>
    <td class="">    ConstantInt *Size =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3367</td>
    <td class="uncoveredLine">        ConstantInt::get(cast<IntegerType>(II.getArgOperand(0)->getType()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3368</td>
    <td class="uncoveredLine">                         NewEndOffset - NewBeginOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3369</td>
    <td class="">    // Lifetime intrinsics always expect an i8* so directly get such a pointer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3370</td>
    <td class="">    // for the new alloca slice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3371</td>
    <td class="uncoveredLine">    Type *PointerTy = IRB.getInt8PtrTy(OldPtr->getType()->getPointerAddressSpace());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3372</td>
    <td class="uncoveredLine">    Value *Ptr = getNewAllocaSlicePtr(IRB, PointerTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3373</td>
    <td class="">    Value *New;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3374</td>
    <td class="uncoveredLine">    if (II.getIntrinsicID() == Intrinsic::lifetime_start)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3375</td>
    <td class="uncoveredLine">      New = IRB.CreateLifetimeStart(Ptr, Size);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3376</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3377</td>
    <td class="uncoveredLine">      New = IRB.CreateLifetimeEnd(Ptr, Size);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3378</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3379</td>
    <td class="">    (void)New;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3380</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3381</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3382</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3383</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3384</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3385</td>
    <td class="uncoveredLine">  void fixLoadStoreAlign(Instruction &Root) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3386</td>
    <td class="">    // This algorithm implements the same visitor loop as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3387</td>
    <td class="">    // hasUnsafePHIOrSelectUse, and fixes the alignment of each load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3388</td>
    <td class="">    // or store found.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3389</td>
    <td class="uncoveredLine">    SmallPtrSet<Instruction *, 4> Visited;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3390</td>
    <td class="uncoveredLine">    SmallVector<Instruction *, 4> Uses;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3391</td>
    <td class="uncoveredLine">    Visited.insert(&Root);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3392</td>
    <td class="uncoveredLine">    Uses.push_back(&Root);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3393</td>
    <td class="">    do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3394</td>
    <td class="uncoveredLine">      Instruction *I = Uses.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3395</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3396</td>
    <td class="uncoveredLine">      if (LoadInst *LI = dyn_cast<LoadInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3397</td>
    <td class="uncoveredLine">        LI->setAlignment(std::min(LI->getAlign(), getSliceAlign()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3398</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3399</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3400</td>
    <td class="uncoveredLine">      if (StoreInst *SI = dyn_cast<StoreInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3401</td>
    <td class="uncoveredLine">        SI->setAlignment(std::min(SI->getAlign(), getSliceAlign()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3402</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3403</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3404</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3405</td>
    <td class="uncoveredLine">      assert(isa<BitCastInst>(I) || isa<AddrSpaceCastInst>(I) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3406</td>
    <td class="">             isa<PHINode>(I) || isa<SelectInst>(I) ||</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3407</td>
    <td class="">             isa<GetElementPtrInst>(I));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3408</td>
    <td class="uncoveredLine">      for (User *U : I->users())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3409</td>
    <td class="uncoveredLine">        if (Visited.insert(cast<Instruction>(U)).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3410</td>
    <td class="uncoveredLine">          Uses.push_back(cast<Instruction>(U));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3411</td>
    <td class="uncoveredLine">    } while (!Uses.empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3412</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3413</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3414</td>
    <td class="uncoveredLine">  bool visitPHINode(PHINode &PN) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3415</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    original: " << PN << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3416</td>
    <td class="uncoveredLine">    assert(BeginOffset >= NewAllocaBeginOffset && "PHIs are unsplittable");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3417</td>
    <td class="uncoveredLine">    assert(EndOffset <= NewAllocaEndOffset && "PHIs are unsplittable");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3418</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3419</td>
    <td class="">    // We would like to compute a new pointer in only one place, but have it be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3420</td>
    <td class="">    // as local as possible to the PHI. To do that, we re-use the location of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3421</td>
    <td class="">    // the old pointer, which necessarily must be in the right position to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3422</td>
    <td class="">    // dominate the PHI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3423</td>
    <td class="uncoveredLine">    IRBuilderBase::InsertPointGuard Guard(IRB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3424</td>
    <td class="uncoveredLine">    if (isa<PHINode>(OldPtr))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3425</td>
    <td class="uncoveredLine">      IRB.SetInsertPoint(&*OldPtr->getParent()->getFirstInsertionPt());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3426</td>
    <td class="">    else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3427</td>
    <td class="uncoveredLine">      IRB.SetInsertPoint(OldPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3428</td>
    <td class="uncoveredLine">    IRB.SetCurrentDebugLocation(OldPtr->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3429</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3430</td>
    <td class="uncoveredLine">    Value *NewPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3431</td>
    <td class="">    // Replace the operands which were using the old pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3432</td>
    <td class="uncoveredLine">    std::replace(PN.op_begin(), PN.op_end(), cast<Value>(OldPtr), NewPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3433</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3434</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "          to: " << PN << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3435</td>
    <td class="uncoveredLine">    deleteIfTriviallyDead(OldPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3436</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3437</td>
    <td class="">    // Fix the alignment of any loads or stores using this PHI node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3438</td>
    <td class="uncoveredLine">    fixLoadStoreAlign(PN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3439</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3440</td>
    <td class="">    // PHIs can't be promoted on their own, but often can be speculated. We</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3441</td>
    <td class="">    // check the speculation outside of the rewriter so that we see the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3442</td>
    <td class="">    // fully-rewritten alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3443</td>
    <td class="uncoveredLine">    PHIUsers.insert(&PN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3444</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3445</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3446</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3447</td>
    <td class="uncoveredLine">  bool visitSelectInst(SelectInst &SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3448</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3449</td>
    <td class="uncoveredLine">    assert((SI.getTrueValue() == OldPtr || SI.getFalseValue() == OldPtr) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3450</td>
    <td class="">           "Pointer isn't an operand!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3451</td>
    <td class="uncoveredLine">    assert(BeginOffset >= NewAllocaBeginOffset && "Selects are unsplittable");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3452</td>
    <td class="uncoveredLine">    assert(EndOffset <= NewAllocaEndOffset && "Selects are unsplittable");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3453</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3454</td>
    <td class="uncoveredLine">    Value *NewPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3455</td>
    <td class="">    // Replace the operands which were using the old pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3456</td>
    <td class="uncoveredLine">    if (SI.getOperand(1) == OldPtr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3457</td>
    <td class="uncoveredLine">      SI.setOperand(1, NewPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3458</td>
    <td class="uncoveredLine">    if (SI.getOperand(2) == OldPtr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3459</td>
    <td class="uncoveredLine">      SI.setOperand(2, NewPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3460</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3461</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "          to: " << SI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3462</td>
    <td class="uncoveredLine">    deleteIfTriviallyDead(OldPtr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3464</td>
    <td class="">    // Fix the alignment of any loads or stores using this select.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3465</td>
    <td class="uncoveredLine">    fixLoadStoreAlign(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3467</td>
    <td class="">    // Selects can't be promoted on their own, but often can be speculated. We</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3468</td>
    <td class="">    // check the speculation outside of the rewriter so that we see the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3469</td>
    <td class="">    // fully-rewritten alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3470</td>
    <td class="uncoveredLine">    SelectUsers.insert(&SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3471</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3472</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3473</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3474</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3475</td>
    <td class="">namespace {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3476</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3477</td>
    <td class="">/// Visitor to rewrite aggregate loads and stores as scalar.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3478</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3479</td>
    <td class="">/// This pass aggressively rewrites all aggregate loads and stores on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3480</td>
    <td class="">/// a particular pointer (or any pointer derived from it which we can identify)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3481</td>
    <td class="">/// with scalar loads and stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3482</td>
    <td class="">class AggLoadStoreRewriter : public InstVisitor<AggLoadStoreRewriter, bool> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3483</td>
    <td class="">  // Befriend the base class so it can delegate to private visit methods.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3484</td>
    <td class="">  friend class InstVisitor<AggLoadStoreRewriter, bool>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3485</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3486</td>
    <td class="">  /// Queue of pointer uses to analyze and potentially rewrite.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3487</td>
    <td class="">  SmallVector<Use *, 8> Queue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3489</td>
    <td class="">  /// Set to prevent us from cycling with phi nodes and loops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3490</td>
    <td class="">  SmallPtrSet<User *, 8> Visited;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3491</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3492</td>
    <td class="">  /// The current pointer use being rewritten. This is used to dig up the used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3493</td>
    <td class="">  /// value (as opposed to the user).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3494</td>
    <td class="">  Use *U = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3496</td>
    <td class="">  /// Used to calculate offsets, and hence alignment, of subobjects.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3497</td>
    <td class="">  const DataLayout &DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3498</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3499</td>
    <td class="">  IRBuilderTy &IRB;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3500</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3501</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3502</td>
    <td class="uncoveredLine">  AggLoadStoreRewriter(const DataLayout &DL, IRBuilderTy &IRB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3503</td>
    <td class="uncoveredLine">      : DL(DL), IRB(IRB) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3504</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3505</td>
    <td class="">  /// Rewrite loads and stores through a pointer and all pointers derived from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3506</td>
    <td class="">  /// it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3507</td>
    <td class="uncoveredLine">  bool rewrite(Instruction &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3508</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "  Rewriting FCA loads and stores...\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3509</td>
    <td class="uncoveredLine">    enqueueUsers(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3510</td>
    <td class="uncoveredLine">    bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3511</td>
    <td class="uncoveredLine">    while (!Queue.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3512</td>
    <td class="uncoveredLine">      U = Queue.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3513</td>
    <td class="uncoveredLine">      Changed |= visit(cast<Instruction>(U->getUser()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3514</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3515</td>
    <td class="uncoveredLine">    return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3516</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3517</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3518</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3519</td>
    <td class="">  /// Enqueue all the users of the given instruction for further processing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3520</td>
    <td class="">  /// This uses a set to de-duplicate users.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3521</td>
    <td class="uncoveredLine">  void enqueueUsers(Instruction &I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3522</td>
    <td class="uncoveredLine">    for (Use &U : I.uses())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3523</td>
    <td class="uncoveredLine">      if (Visited.insert(U.getUser()).second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3524</td>
    <td class="uncoveredLine">        Queue.push_back(&U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3525</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3526</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3527</td>
    <td class="">  // Conservative default is to not rewrite anything.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3528</td>
    <td class="uncoveredLine">  bool visitInstruction(Instruction &I) { return false; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3529</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3530</td>
    <td class="">  /// Generic recursive split emission class.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3531</td>
    <td class="">  template <typename Derived> class OpSplitter {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3532</td>
    <td class="">  protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3533</td>
    <td class="">    /// The builder used to form new instructions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3534</td>
    <td class="">    IRBuilderTy &IRB;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3535</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3536</td>
    <td class="">    /// The indices which to be used with insert- or extractvalue to select the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3537</td>
    <td class="">    /// appropriate value within the aggregate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3538</td>
    <td class="">    SmallVector<unsigned, 4> Indices;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3539</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3540</td>
    <td class="">    /// The indices to a GEP instruction which will move Ptr to the correct slot</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3541</td>
    <td class="">    /// within the aggregate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3542</td>
    <td class="">    SmallVector<Value *, 4> GEPIndices;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3543</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3544</td>
    <td class="">    /// The base pointer of the original op, used as a base for GEPing the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3545</td>
    <td class="">    /// split operations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3546</td>
    <td class="">    Value *Ptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3547</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3548</td>
    <td class="">    /// The base pointee type being GEPed into.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3549</td>
    <td class="">    Type *BaseTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3550</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3551</td>
    <td class="">    /// Known alignment of the base pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3552</td>
    <td class="">    Align BaseAlign;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3553</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3554</td>
    <td class="">    /// To calculate offset of each component so we can correctly deduce</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3555</td>
    <td class="">    /// alignments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3556</td>
    <td class="">    const DataLayout &DL;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3557</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3558</td>
    <td class="">    /// Initialize the splitter with an insertion point, Ptr and start with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3559</td>
    <td class="">    /// single zero GEP index.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3560</td>
    <td class="uncoveredLine">    OpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3561</td>
    <td class="">               Align BaseAlign, const DataLayout &DL, IRBuilderTy &IRB)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3562</td>
    <td class="uncoveredLine">        : IRB(IRB), GEPIndices(1, IRB.getInt32(0)), Ptr(Ptr), BaseTy(BaseTy),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3563</td>
    <td class="uncoveredLine">          BaseAlign(BaseAlign), DL(DL) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3564</td>
    <td class="uncoveredLine">      IRB.SetInsertPoint(InsertionPoint);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3565</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3566</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3567</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3568</td>
    <td class="">    /// Generic recursive split emission routine.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3569</td>
    <td class="">    ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3570</td>
    <td class="">    /// This method recursively splits an aggregate op (load or store) into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3571</td>
    <td class="">    /// scalar or vector ops. It splits recursively until it hits a single value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3572</td>
    <td class="">    /// and emits that single value operation via the template argument.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3573</td>
    <td class="">    ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3574</td>
    <td class="">    /// The logic of this routine relies on GEPs and insertvalue and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3575</td>
    <td class="">    /// extractvalue all operating with the same fundamental index list, merely</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3576</td>
    <td class="">    /// formatted differently (GEPs need actual values).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3577</td>
    <td class="">    ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3578</td>
    <td class="">    /// \param Ty  The type being split recursively into smaller ops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3579</td>
    <td class="">    /// \param Agg The aggregate value being built up or stored, depending on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3580</td>
    <td class="">    /// whether this is splitting a load or a store respectively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3581</td>
    <td class="uncoveredLine">    void emitSplitOps(Type *Ty, Value *&Agg, const Twine &Name) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3582</td>
    <td class="uncoveredLine">      if (Ty->isSingleValueType()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3583</td>
    <td class="uncoveredLine">        unsigned Offset = DL.getIndexedOffsetInType(BaseTy, GEPIndices);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3584</td>
    <td class="uncoveredLine">        return static_cast<Derived *>(this)->emitFunc(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3585</td>
    <td class="uncoveredLine">            Ty, Agg, commonAlignment(BaseAlign, Offset), Name);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3586</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3587</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3588</td>
    <td class="uncoveredLine">      if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3589</td>
    <td class="uncoveredLine">        unsigned OldSize = Indices.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3590</td>
    <td class="">        (void)OldSize;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3591</td>
    <td class="uncoveredLine">        for (unsigned Idx = 0, Size = ATy->getNumElements(); Idx != Size;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3592</td>
    <td class="">             ++Idx) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3593</td>
    <td class="uncoveredLine">          assert(Indices.size() == OldSize && "Did not return to the old size");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3594</td>
    <td class="uncoveredLine">          Indices.push_back(Idx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3595</td>
    <td class="uncoveredLine">          GEPIndices.push_back(IRB.getInt32(Idx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3596</td>
    <td class="uncoveredLine">          emitSplitOps(ATy->getElementType(), Agg, Name + "." + Twine(Idx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3597</td>
    <td class="uncoveredLine">          GEPIndices.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3598</td>
    <td class="uncoveredLine">          Indices.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3599</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3600</td>
    <td class="uncoveredLine">        return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3601</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3602</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3603</td>
    <td class="uncoveredLine">      if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3604</td>
    <td class="uncoveredLine">        unsigned OldSize = Indices.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3605</td>
    <td class="">        (void)OldSize;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3606</td>
    <td class="uncoveredLine">        for (unsigned Idx = 0, Size = STy->getNumElements(); Idx != Size;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3607</td>
    <td class="">             ++Idx) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3608</td>
    <td class="uncoveredLine">          assert(Indices.size() == OldSize && "Did not return to the old size");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3609</td>
    <td class="uncoveredLine">          Indices.push_back(Idx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3610</td>
    <td class="uncoveredLine">          GEPIndices.push_back(IRB.getInt32(Idx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3611</td>
    <td class="uncoveredLine">          emitSplitOps(STy->getElementType(Idx), Agg, Name + "." + Twine(Idx));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3612</td>
    <td class="uncoveredLine">          GEPIndices.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3613</td>
    <td class="uncoveredLine">          Indices.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3614</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3615</td>
    <td class="uncoveredLine">        return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3616</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3617</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3618</td>
    <td class="uncoveredLine">      llvm_unreachable("Only arrays and structs are aggregate loadable types");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3619</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3620</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3621</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3622</td>
    <td class="">  struct LoadOpSplitter : public OpSplitter<LoadOpSplitter> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3623</td>
    <td class="">    AAMDNodes AATags;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3624</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3625</td>
    <td class="uncoveredLine">    LoadOpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3626</td>
    <td class="">                   AAMDNodes AATags, Align BaseAlign, const DataLayout &DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3627</td>
    <td class="">                   IRBuilderTy &IRB)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3628</td>
    <td class="">        : OpSplitter<LoadOpSplitter>(InsertionPoint, Ptr, BaseTy, BaseAlign, DL,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3629</td>
    <td class="">                                     IRB),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3630</td>
    <td class="uncoveredLine">          AATags(AATags) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3631</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3632</td>
    <td class="">    /// Emit a leaf load of a single value. This is called at the leaves of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3633</td>
    <td class="">    /// recursive emission to actually load values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3634</td>
    <td class="uncoveredLine">    void emitFunc(Type *Ty, Value *&Agg, Align Alignment, const Twine &Name) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3635</td>
    <td class="uncoveredLine">      assert(Ty->isSingleValueType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3636</td>
    <td class="">      // Load the single value and insert it using the indices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3637</td>
    <td class="">      Value *GEP =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3638</td>
    <td class="uncoveredLine">          IRB.CreateInBoundsGEP(BaseTy, Ptr, GEPIndices, Name + ".gep");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3639</td>
    <td class="">      LoadInst *Load =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3640</td>
    <td class="uncoveredLine">          IRB.CreateAlignedLoad(Ty, GEP, Alignment, Name + ".load");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3641</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3642</td>
    <td class="">      APInt Offset(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3643</td>
    <td class="uncoveredLine">          DL.getIndexSizeInBits(Ptr->getType()->getPointerAddressSpace()), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3644</td>
    <td class="uncoveredLine">      if (AATags &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3645</td>
    <td class="uncoveredLine">          GEPOperator::accumulateConstantOffset(BaseTy, GEPIndices, DL, Offset))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3646</td>
    <td class="uncoveredLine">        Load->setAAMetadata(AATags.shift(Offset.getZExtValue()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3648</td>
    <td class="uncoveredLine">      Agg = IRB.CreateInsertValue(Agg, Load, Indices, Name + ".insert");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3649</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "          to: " << *Load << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3650</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3651</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3652</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3653</td>
    <td class="uncoveredLine">  bool visitLoadInst(LoadInst &LI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3654</td>
    <td class="uncoveredLine">    assert(LI.getPointerOperand() == *U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3655</td>
    <td class="uncoveredLine">    if (!LI.isSimple() || LI.getType()->isSingleValueType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3656</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3658</td>
    <td class="">    // We have an aggregate being loaded, split it apart.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3659</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    original: " << LI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3660</td>
    <td class="uncoveredLine">    LoadOpSplitter Splitter(&LI, *U, LI.getType(), LI.getAAMetadata(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3661</td>
    <td class="uncoveredLine">                            getAdjustedAlignment(&LI, 0), DL, IRB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3662</td>
    <td class="uncoveredLine">    Value *V = PoisonValue::get(LI.getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3663</td>
    <td class="uncoveredLine">    Splitter.emitSplitOps(LI.getType(), V, LI.getName() + ".fca");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3664</td>
    <td class="uncoveredLine">    Visited.erase(&LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3665</td>
    <td class="uncoveredLine">    LI.replaceAllUsesWith(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3666</td>
    <td class="uncoveredLine">    LI.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3667</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3668</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3669</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3670</td>
    <td class="">  struct StoreOpSplitter : public OpSplitter<StoreOpSplitter> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3671</td>
    <td class="uncoveredLine">    StoreOpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3672</td>
    <td class="">                    AAMDNodes AATags, StoreInst *AggStore, Align BaseAlign,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3673</td>
    <td class="">                    const DataLayout &DL, IRBuilderTy &IRB)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3674</td>
    <td class="">        : OpSplitter<StoreOpSplitter>(InsertionPoint, Ptr, BaseTy, BaseAlign,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3675</td>
    <td class="">                                      DL, IRB),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3676</td>
    <td class="uncoveredLine">          AATags(AATags), AggStore(AggStore) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3677</td>
    <td class="">    AAMDNodes AATags;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3678</td>
    <td class="">    StoreInst *AggStore;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3679</td>
    <td class="">    /// Emit a leaf store of a single value. This is called at the leaves of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3680</td>
    <td class="">    /// recursive emission to actually produce stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3681</td>
    <td class="uncoveredLine">    void emitFunc(Type *Ty, Value *&Agg, Align Alignment, const Twine &Name) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3682</td>
    <td class="uncoveredLine">      assert(Ty->isSingleValueType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3683</td>
    <td class="">      // Extract the single value and store it using the indices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3684</td>
    <td class="">      //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3685</td>
    <td class="">      // The gep and extractvalue values are factored out of the CreateStore</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3686</td>
    <td class="">      // call to make the output independent of the argument evaluation order.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3687</td>
    <td class="">      Value *ExtractValue =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3688</td>
    <td class="uncoveredLine">          IRB.CreateExtractValue(Agg, Indices, Name + ".extract");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3689</td>
    <td class="">      Value *InBoundsGEP =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3690</td>
    <td class="uncoveredLine">          IRB.CreateInBoundsGEP(BaseTy, Ptr, GEPIndices, Name + ".gep");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3691</td>
    <td class="">      StoreInst *Store =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3692</td>
    <td class="uncoveredLine">          IRB.CreateAlignedStore(ExtractValue, InBoundsGEP, Alignment);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3693</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3694</td>
    <td class="">      APInt Offset(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3695</td>
    <td class="uncoveredLine">          DL.getIndexSizeInBits(Ptr->getType()->getPointerAddressSpace()), 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3696</td>
    <td class="uncoveredLine">      GEPOperator::accumulateConstantOffset(BaseTy, GEPIndices, DL, Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3697</td>
    <td class="uncoveredLine">      if (AATags)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3698</td>
    <td class="uncoveredLine">        Store->setAAMetadata(AATags.shift(Offset.getZExtValue()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3699</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3700</td>
    <td class="">      // migrateDebugInfo requires the base Alloca. Walk to it from this gep.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3701</td>
    <td class="">      // If we cannot (because there's an intervening non-const or unbounded</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3702</td>
    <td class="">      // gep) then we wouldn't expect to see dbg.assign intrinsics linked to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3703</td>
    <td class="">      // this instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3704</td>
    <td class="uncoveredLine">      Value *Base = AggStore->getPointerOperand()->stripInBoundsOffsets();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3705</td>
    <td class="uncoveredLine">      if (auto *OldAI = dyn_cast<AllocaInst>(Base)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3706</td>
    <td class="">        uint64_t SizeInBits =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3707</td>
    <td class="uncoveredLine">            DL.getTypeSizeInBits(Store->getValueOperand()->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3708</td>
    <td class="uncoveredLine">        migrateDebugInfo(OldAI, /*IsSplit*/ true, Offset.getZExtValue() * 8,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3709</td>
    <td class="uncoveredLine">                         SizeInBits, AggStore, Store,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3710</td>
    <td class="">                         Store->getPointerOperand(), Store->getValueOperand(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3711</td>
    <td class="">                         DL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3712</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3713</td>
    <td class="uncoveredLine">        assert(at::getAssignmentMarkers(Store).empty() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3714</td>
    <td class="">               "AT: unexpected debug.assign linked to store through "</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3715</td>
    <td class="">               "unbounded GEP");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3716</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3717</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3718</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3719</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3720</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3721</td>
    <td class="uncoveredLine">  bool visitStoreInst(StoreInst &SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3722</td>
    <td class="uncoveredLine">    if (!SI.isSimple() || SI.getPointerOperand() != *U)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3723</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3724</td>
    <td class="uncoveredLine">    Value *V = SI.getValueOperand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3725</td>
    <td class="uncoveredLine">    if (V->getType()->isSingleValueType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3726</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3727</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3728</td>
    <td class="">    // We have an aggregate being stored, split it apart.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3729</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3730</td>
    <td class="uncoveredLine">    StoreOpSplitter Splitter(&SI, *U, V->getType(), SI.getAAMetadata(), &SI,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3731</td>
    <td class="uncoveredLine">                             getAdjustedAlignment(&SI, 0), DL, IRB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3732</td>
    <td class="uncoveredLine">    Splitter.emitSplitOps(V->getType(), V, V->getName() + ".fca");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3733</td>
    <td class="uncoveredLine">    Visited.erase(&SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3734</td>
    <td class="">    // The stores replacing SI each have markers describing fragments of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3735</td>
    <td class="">    // assignment so delete the assignment markers linked to SI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3736</td>
    <td class="uncoveredLine">    at::deleteAssignmentMarkers(&SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3737</td>
    <td class="uncoveredLine">    SI.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3738</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3739</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3740</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3741</td>
    <td class="uncoveredLine">  bool visitBitCastInst(BitCastInst &BC) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3742</td>
    <td class="uncoveredLine">    enqueueUsers(BC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3743</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3744</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3745</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3746</td>
    <td class="uncoveredLine">  bool visitAddrSpaceCastInst(AddrSpaceCastInst &ASC) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3747</td>
    <td class="uncoveredLine">    enqueueUsers(ASC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3748</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3749</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3750</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3751</td>
    <td class="">  // Fold gep (select cond, ptr1, ptr2) => select cond, gep(ptr1), gep(ptr2)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3752</td>
    <td class="uncoveredLine">  bool foldGEPSelect(GetElementPtrInst &GEPI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3753</td>
    <td class="uncoveredLine">    if (!GEPI.hasAllConstantIndices())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3754</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3755</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3756</td>
    <td class="uncoveredLine">    SelectInst *Sel = cast<SelectInst>(GEPI.getPointerOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3757</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3758</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "  Rewriting gep(select) -> select(gep):"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3759</td>
    <td class="">                      << "\n    original: " << *Sel</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3760</td>
    <td class="">                      << "\n              " << GEPI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3761</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3762</td>
    <td class="uncoveredLine">    IRB.SetInsertPoint(&GEPI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3763</td>
    <td class="uncoveredLine">    SmallVector<Value *, 4> Index(GEPI.indices());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3764</td>
    <td class="uncoveredLine">    bool IsInBounds = GEPI.isInBounds();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3765</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3766</td>
    <td class="uncoveredLine">    Type *Ty = GEPI.getSourceElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3767</td>
    <td class="uncoveredLine">    Value *True = Sel->getTrueValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3768</td>
    <td class="uncoveredLine">    Value *NTrue = IRB.CreateGEP(Ty, True, Index, True->getName() + ".sroa.gep",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3769</td>
    <td class="">                                 IsInBounds);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3770</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3771</td>
    <td class="uncoveredLine">    Value *False = Sel->getFalseValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3772</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3773</td>
    <td class="uncoveredLine">    Value *NFalse = IRB.CreateGEP(Ty, False, Index,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3774</td>
    <td class="uncoveredLine">                                  False->getName() + ".sroa.gep", IsInBounds);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3775</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3776</td>
    <td class="uncoveredLine">    Value *NSel = IRB.CreateSelect(Sel->getCondition(), NTrue, NFalse,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3777</td>
    <td class="uncoveredLine">                                   Sel->getName() + ".sroa.sel");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3778</td>
    <td class="uncoveredLine">    Visited.erase(&GEPI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3779</td>
    <td class="uncoveredLine">    GEPI.replaceAllUsesWith(NSel);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3780</td>
    <td class="uncoveredLine">    GEPI.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3781</td>
    <td class="uncoveredLine">    Instruction *NSelI = cast<Instruction>(NSel);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3782</td>
    <td class="uncoveredLine">    Visited.insert(NSelI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3783</td>
    <td class="uncoveredLine">    enqueueUsers(*NSelI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3784</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3785</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "\n          to: " << *NTrue</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3786</td>
    <td class="">                      << "\n              " << *NFalse</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3787</td>
    <td class="">                      << "\n              " << *NSel << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3788</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3789</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3790</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3791</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3792</td>
    <td class="">  // Fold gep (phi ptr1, ptr2) => phi gep(ptr1), gep(ptr2)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3793</td>
    <td class="uncoveredLine">  bool foldGEPPhi(GetElementPtrInst &GEPI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3794</td>
    <td class="uncoveredLine">    if (!GEPI.hasAllConstantIndices())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3795</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3796</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3797</td>
    <td class="uncoveredLine">    PHINode *PHI = cast<PHINode>(GEPI.getPointerOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3798</td>
    <td class="uncoveredLine">    if (GEPI.getParent() != PHI->getParent() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3799</td>
    <td class="uncoveredLine">        llvm::any_of(PHI->incoming_values(), [](Value *In)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3800</td>
    <td class="uncoveredLine">          { Instruction *I = dyn_cast<Instruction>(In);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3801</td>
    <td class="uncoveredLine">            return !I || isa<GetElementPtrInst>(I) || isa<PHINode>(I) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3802</td>
    <td class="uncoveredLine">                   succ_empty(I->getParent()) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3803</td>
    <td class="uncoveredLine">                   !I->getParent()->isLegalToHoistInto();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3804</td>
    <td class="">          }))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3805</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3806</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3807</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "  Rewriting gep(phi) -> phi(gep):"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3808</td>
    <td class="">                      << "\n    original: " << *PHI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3809</td>
    <td class="">                      << "\n              " << GEPI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3810</td>
    <td class="">                      << "\n          to: ");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3811</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3812</td>
    <td class="uncoveredLine">    SmallVector<Value *, 4> Index(GEPI.indices());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3813</td>
    <td class="uncoveredLine">    bool IsInBounds = GEPI.isInBounds();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3814</td>
    <td class="uncoveredLine">    IRB.SetInsertPoint(GEPI.getParent()->getFirstNonPHI());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3815</td>
    <td class="uncoveredLine">    PHINode *NewPN = IRB.CreatePHI(GEPI.getType(), PHI->getNumIncomingValues(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3816</td>
    <td class="uncoveredLine">                                   PHI->getName() + ".sroa.phi");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3817</td>
    <td class="uncoveredLine">    for (unsigned I = 0, E = PHI->getNumIncomingValues(); I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3818</td>
    <td class="uncoveredLine">      BasicBlock *B = PHI->getIncomingBlock(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3819</td>
    <td class="uncoveredLine">      Value *NewVal = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3820</td>
    <td class="uncoveredLine">      int Idx = NewPN->getBasicBlockIndex(B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3821</td>
    <td class="uncoveredLine">      if (Idx >= 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3822</td>
    <td class="uncoveredLine">        NewVal = NewPN->getIncomingValue(Idx);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3823</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3824</td>
    <td class="uncoveredLine">        Instruction *In = cast<Instruction>(PHI->getIncomingValue(I));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3825</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3826</td>
    <td class="uncoveredLine">        IRB.SetInsertPoint(In->getParent(), std::next(In->getIterator()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3827</td>
    <td class="uncoveredLine">        Type *Ty = GEPI.getSourceElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3828</td>
    <td class="uncoveredLine">        NewVal = IRB.CreateGEP(Ty, In, Index, In->getName() + ".sroa.gep",</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3829</td>
    <td class="">                               IsInBounds);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3830</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3831</td>
    <td class="uncoveredLine">      NewPN->addIncoming(NewVal, B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3832</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3833</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3834</td>
    <td class="uncoveredLine">    Visited.erase(&GEPI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3835</td>
    <td class="uncoveredLine">    GEPI.replaceAllUsesWith(NewPN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3836</td>
    <td class="uncoveredLine">    GEPI.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3837</td>
    <td class="uncoveredLine">    Visited.insert(NewPN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3838</td>
    <td class="uncoveredLine">    enqueueUsers(*NewPN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3839</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3840</td>
    <td class="uncoveredLine">    LLVM_DEBUG(for (Value *In : NewPN->incoming_values())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3841</td>
    <td class="">                 dbgs() << "\n              " << *In;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3842</td>
    <td class="">               dbgs() << "\n              " << *NewPN << '\n');</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3843</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3844</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3845</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3846</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3847</td>
    <td class="uncoveredLine">  bool visitGetElementPtrInst(GetElementPtrInst &GEPI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3848</td>
    <td class="uncoveredLine">    if (isa<SelectInst>(GEPI.getPointerOperand()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3849</td>
    <td class="uncoveredLine">        foldGEPSelect(GEPI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3850</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3851</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3852</td>
    <td class="uncoveredLine">    if (isa<PHINode>(GEPI.getPointerOperand()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3853</td>
    <td class="uncoveredLine">        foldGEPPhi(GEPI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3854</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3855</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3856</td>
    <td class="uncoveredLine">    enqueueUsers(GEPI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3857</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3858</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3859</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3860</td>
    <td class="uncoveredLine">  bool visitPHINode(PHINode &PN) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3861</td>
    <td class="uncoveredLine">    enqueueUsers(PN);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3862</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3863</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3864</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3865</td>
    <td class="uncoveredLine">  bool visitSelectInst(SelectInst &SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3866</td>
    <td class="uncoveredLine">    enqueueUsers(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3867</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3868</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3869</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3870</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3871</td>
    <td class="">} // end anonymous namespace</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3872</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3873</td>
    <td class="">/// Strip aggregate type wrapping.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3874</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3875</td>
    <td class="">/// This removes no-op aggregate types wrapping an underlying type. It will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3876</td>
    <td class="">/// strip as many layers of types as it can without changing either the type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3877</td>
    <td class="">/// size or the allocated size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3878</td>
    <td class="uncoveredLine">static Type *stripAggregateTypeWrapping(const DataLayout &DL, Type *Ty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3879</td>
    <td class="uncoveredLine">  if (Ty->isSingleValueType())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3880</td>
    <td class="uncoveredLine">    return Ty;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3881</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3882</td>
    <td class="uncoveredLine">  uint64_t AllocSize = DL.getTypeAllocSize(Ty).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3883</td>
    <td class="uncoveredLine">  uint64_t TypeSize = DL.getTypeSizeInBits(Ty).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3884</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3885</td>
    <td class="">  Type *InnerTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3886</td>
    <td class="uncoveredLine">  if (ArrayType *ArrTy = dyn_cast<ArrayType>(Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3887</td>
    <td class="uncoveredLine">    InnerTy = ArrTy->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3888</td>
    <td class="uncoveredLine">  } else if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3889</td>
    <td class="uncoveredLine">    const StructLayout *SL = DL.getStructLayout(STy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3890</td>
    <td class="uncoveredLine">    unsigned Index = SL->getElementContainingOffset(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3891</td>
    <td class="uncoveredLine">    InnerTy = STy->getElementType(Index);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3892</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3893</td>
    <td class="uncoveredLine">    return Ty;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3894</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3895</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3896</td>
    <td class="uncoveredLine">  if (AllocSize > DL.getTypeAllocSize(InnerTy).getFixedValue() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3897</td>
    <td class="uncoveredLine">      TypeSize > DL.getTypeSizeInBits(InnerTy).getFixedValue())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3898</td>
    <td class="uncoveredLine">    return Ty;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3899</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3900</td>
    <td class="uncoveredLine">  return stripAggregateTypeWrapping(DL, InnerTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3901</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3902</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3903</td>
    <td class="">/// Try to find a partition of the aggregate type passed in for a given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3904</td>
    <td class="">/// offset and size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3905</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3906</td>
    <td class="">/// This recurses through the aggregate type and tries to compute a subtype</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3907</td>
    <td class="">/// based on the offset and size. When the offset and size span a sub-section</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3908</td>
    <td class="">/// of an array, it will even compute a new array type for that sub-section,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3909</td>
    <td class="">/// and the same for structs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3910</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3911</td>
    <td class="">/// Note that this routine is very strict and tries to find a partition of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3912</td>
    <td class="">/// type which produces the *exact* right offset and size. It is not forgiving</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3913</td>
    <td class="">/// when the size or offset cause either end of type-based partition to be off.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3914</td>
    <td class="">/// Also, this is a best-effort routine. It is reasonable to give up and not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3915</td>
    <td class="">/// return a type if necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3916</td>
    <td class="uncoveredLine">static Type *getTypePartition(const DataLayout &DL, Type *Ty, uint64_t Offset,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3917</td>
    <td class="">                              uint64_t Size) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3918</td>
    <td class="uncoveredLine">  if (Offset == 0 && DL.getTypeAllocSize(Ty).getFixedValue() == Size)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3919</td>
    <td class="uncoveredLine">    return stripAggregateTypeWrapping(DL, Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3920</td>
    <td class="uncoveredLine">  if (Offset > DL.getTypeAllocSize(Ty).getFixedValue() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3921</td>
    <td class="uncoveredLine">      (DL.getTypeAllocSize(Ty).getFixedValue() - Offset) < Size)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3922</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3923</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3924</td>
    <td class="uncoveredLine">  if (isa<ArrayType>(Ty) || isa<VectorType>(Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3925</td>
    <td class="">     Type *ElementTy;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3926</td>
    <td class="">     uint64_t TyNumElements;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3927</td>
    <td class="uncoveredLine">     if (auto *AT = dyn_cast<ArrayType>(Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3928</td>
    <td class="uncoveredLine">       ElementTy = AT->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3929</td>
    <td class="uncoveredLine">       TyNumElements = AT->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3930</td>
    <td class="">     } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3931</td>
    <td class="">       // FIXME: This isn't right for vectors with non-byte-sized or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3932</td>
    <td class="">       // non-power-of-two sized elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3933</td>
    <td class="uncoveredLine">       auto *VT = cast<FixedVectorType>(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3934</td>
    <td class="uncoveredLine">       ElementTy = VT->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3935</td>
    <td class="uncoveredLine">       TyNumElements = VT->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3936</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3937</td>
    <td class="uncoveredLine">    uint64_t ElementSize = DL.getTypeAllocSize(ElementTy).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3938</td>
    <td class="uncoveredLine">    uint64_t NumSkippedElements = Offset / ElementSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3939</td>
    <td class="uncoveredLine">    if (NumSkippedElements >= TyNumElements)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3940</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3941</td>
    <td class="uncoveredLine">    Offset -= NumSkippedElements * ElementSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3942</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3943</td>
    <td class="">    // First check if we need to recurse.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3944</td>
    <td class="uncoveredLine">    if (Offset > 0 || Size < ElementSize) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3945</td>
    <td class="">      // Bail if the partition ends in a different array element.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3946</td>
    <td class="uncoveredLine">      if ((Offset + Size) > ElementSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3947</td>
    <td class="uncoveredLine">        return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3948</td>
    <td class="">      // Recurse through the element type trying to peel off offset bytes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3949</td>
    <td class="uncoveredLine">      return getTypePartition(DL, ElementTy, Offset, Size);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3950</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3951</td>
    <td class="uncoveredLine">    assert(Offset == 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3952</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3953</td>
    <td class="uncoveredLine">    if (Size == ElementSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3954</td>
    <td class="uncoveredLine">      return stripAggregateTypeWrapping(DL, ElementTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3955</td>
    <td class="uncoveredLine">    assert(Size > ElementSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3956</td>
    <td class="uncoveredLine">    uint64_t NumElements = Size / ElementSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3957</td>
    <td class="uncoveredLine">    if (NumElements * ElementSize != Size)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3958</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3959</td>
    <td class="uncoveredLine">    return ArrayType::get(ElementTy, NumElements);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3960</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3961</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3962</td>
    <td class="uncoveredLine">  StructType *STy = dyn_cast<StructType>(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3963</td>
    <td class="uncoveredLine">  if (!STy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3964</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3965</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3966</td>
    <td class="uncoveredLine">  const StructLayout *SL = DL.getStructLayout(STy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3967</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3968</td>
    <td class="uncoveredLine">  if (SL->getSizeInBits().isScalable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3969</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3970</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3971</td>
    <td class="uncoveredLine">  if (Offset >= SL->getSizeInBytes())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3972</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3973</td>
    <td class="uncoveredLine">  uint64_t EndOffset = Offset + Size;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3974</td>
    <td class="uncoveredLine">  if (EndOffset > SL->getSizeInBytes())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3975</td>
    <td class="uncoveredLine">    return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3976</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3977</td>
    <td class="uncoveredLine">  unsigned Index = SL->getElementContainingOffset(Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3978</td>
    <td class="uncoveredLine">  Offset -= SL->getElementOffset(Index);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3979</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3980</td>
    <td class="uncoveredLine">  Type *ElementTy = STy->getElementType(Index);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3981</td>
    <td class="uncoveredLine">  uint64_t ElementSize = DL.getTypeAllocSize(ElementTy).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3982</td>
    <td class="uncoveredLine">  if (Offset >= ElementSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3983</td>
    <td class="uncoveredLine">    return nullptr; // The offset points into alignment padding.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3984</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3985</td>
    <td class="">  // See if any partition must be contained by the element.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3986</td>
    <td class="uncoveredLine">  if (Offset > 0 || Size < ElementSize) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3987</td>
    <td class="uncoveredLine">    if ((Offset + Size) > ElementSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3988</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3989</td>
    <td class="uncoveredLine">    return getTypePartition(DL, ElementTy, Offset, Size);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3990</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3991</td>
    <td class="uncoveredLine">  assert(Offset == 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3993</td>
    <td class="uncoveredLine">  if (Size == ElementSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3994</td>
    <td class="uncoveredLine">    return stripAggregateTypeWrapping(DL, ElementTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3995</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3996</td>
    <td class="uncoveredLine">  StructType::element_iterator EI = STy->element_begin() + Index,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3997</td>
    <td class="uncoveredLine">                               EE = STy->element_end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3998</td>
    <td class="uncoveredLine">  if (EndOffset < SL->getSizeInBytes()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3999</td>
    <td class="uncoveredLine">    unsigned EndIndex = SL->getElementContainingOffset(EndOffset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4000</td>
    <td class="uncoveredLine">    if (Index == EndIndex)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4001</td>
    <td class="uncoveredLine">      return nullptr; // Within a single element and its padding.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4002</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4003</td>
    <td class="">    // Don't try to form "natural" types if the elements don't line up with the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4004</td>
    <td class="">    // expected size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4005</td>
    <td class="">    // FIXME: We could potentially recurse down through the last element in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4006</td>
    <td class="">    // sub-struct to find a natural end point.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4007</td>
    <td class="uncoveredLine">    if (SL->getElementOffset(EndIndex) != EndOffset)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4008</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4009</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4010</td>
    <td class="uncoveredLine">    assert(Index < EndIndex);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4011</td>
    <td class="uncoveredLine">    EE = STy->element_begin() + EndIndex;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4012</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4013</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4014</td>
    <td class="">  // Try to build up a sub-structure.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4015</td>
    <td class="">  StructType *SubTy =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4016</td>
    <td class="uncoveredLine">      StructType::get(STy->getContext(), ArrayRef(EI, EE), STy->isPacked());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4017</td>
    <td class="uncoveredLine">  const StructLayout *SubSL = DL.getStructLayout(SubTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4018</td>
    <td class="uncoveredLine">  if (Size != SubSL->getSizeInBytes())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4019</td>
    <td class="uncoveredLine">    return nullptr; // The sub-struct doesn't have quite the size needed.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4020</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4021</td>
    <td class="uncoveredLine">  return SubTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4022</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4023</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4024</td>
    <td class="">/// Pre-split loads and stores to simplify rewriting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4025</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4026</td>
    <td class="">/// We want to break up the splittable load+store pairs as much as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4027</td>
    <td class="">/// possible. This is important to do as a preprocessing step, as once we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4028</td>
    <td class="">/// start rewriting the accesses to partitions of the alloca we lose the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4029</td>
    <td class="">/// necessary information to correctly split apart paired loads and stores</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4030</td>
    <td class="">/// which both point into this alloca. The case to consider is something like</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4031</td>
    <td class="">/// the following:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4032</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4033</td>
    <td class="">///   %a = alloca [12 x i8]</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4034</td>
    <td class="">///   %gep1 = getelementptr i8, ptr %a, i32 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4035</td>
    <td class="">///   %gep2 = getelementptr i8, ptr %a, i32 4</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4036</td>
    <td class="">///   %gep3 = getelementptr i8, ptr %a, i32 8</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4037</td>
    <td class="">///   store float 0.0, ptr %gep1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4038</td>
    <td class="">///   store float 1.0, ptr %gep2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4039</td>
    <td class="">///   %v = load i64, ptr %gep1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4040</td>
    <td class="">///   store i64 %v, ptr %gep2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4041</td>
    <td class="">///   %f1 = load float, ptr %gep2</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4042</td>
    <td class="">///   %f2 = load float, ptr %gep3</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4043</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4044</td>
    <td class="">/// Here we want to form 3 partitions of the alloca, each 4 bytes large, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4045</td>
    <td class="">/// promote everything so we recover the 2 SSA values that should have been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4046</td>
    <td class="">/// there all along.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4047</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4048</td>
    <td class="">/// \returns true if any changes are made.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4049</td>
    <td class="uncoveredLine">bool SROAPass::presplitLoadsAndStores(AllocaInst &AI, AllocaSlices &AS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4050</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Pre-splitting loads and stores\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4051</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4052</td>
    <td class="">  // Track the loads and stores which are candidates for pre-splitting here, in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4053</td>
    <td class="">  // the order they first appear during the partition scan. These give stable</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4054</td>
    <td class="">  // iteration order and a basis for tracking which loads and stores we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4055</td>
    <td class="">  // actually split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4056</td>
    <td class="uncoveredLine">  SmallVector<LoadInst *, 4> Loads;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4057</td>
    <td class="uncoveredLine">  SmallVector<StoreInst *, 4> Stores;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4058</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4059</td>
    <td class="">  // We need to accumulate the splits required of each load or store where we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4060</td>
    <td class="">  // can find them via a direct lookup. This is important to cross-check loads</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4061</td>
    <td class="">  // and stores against each other. We also track the slice so that we can kill</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4062</td>
    <td class="">  // all the slices that end up split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4063</td>
    <td class="">  struct SplitOffsets {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4064</td>
    <td class="">    Slice *S;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4065</td>
    <td class="">    std::vector<uint64_t> Splits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4066</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4067</td>
    <td class="uncoveredLine">  SmallDenseMap<Instruction *, SplitOffsets, 8> SplitOffsetsMap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4068</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4069</td>
    <td class="">  // Track loads out of this alloca which cannot, for any reason, be pre-split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4070</td>
    <td class="">  // This is important as we also cannot pre-split stores of those loads!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4071</td>
    <td class="">  // FIXME: This is all pretty gross. It means that we can be more aggressive</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4072</td>
    <td class="">  // in pre-splitting when the load feeding the store happens to come from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4073</td>
    <td class="">  // a separate alloca. Put another way, the effectiveness of SROA would be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4074</td>
    <td class="">  // decreased by a frontend which just concatenated all of its local allocas</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4075</td>
    <td class="">  // into one big flat alloca. But defeating such patterns is exactly the job</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4076</td>
    <td class="">  // SROA is tasked with! Sadly, to not have this discrepancy we would have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4077</td>
    <td class="">  // change store pre-splitting to actually force pre-splitting of the load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4078</td>
    <td class="">  // that feeds it *and all stores*. That makes pre-splitting much harder, but</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4079</td>
    <td class="">  // maybe it would make it more principled?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4080</td>
    <td class="uncoveredLine">  SmallPtrSet<LoadInst *, 8> UnsplittableLoads;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4081</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4082</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "  Searching for candidate loads and stores\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4083</td>
    <td class="uncoveredLine">  for (auto &P : AS.partitions()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4084</td>
    <td class="uncoveredLine">    for (Slice &S : P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4085</td>
    <td class="uncoveredLine">      Instruction *I = cast<Instruction>(S.getUse()->getUser());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4086</td>
    <td class="uncoveredLine">      if (!S.isSplittable() || S.endOffset() <= P.endOffset()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4087</td>
    <td class="">        // If this is a load we have to track that it can't participate in any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4088</td>
    <td class="">        // pre-splitting. If this is a store of a load we have to track that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4089</td>
    <td class="">        // that load also can't participate in any pre-splitting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4090</td>
    <td class="uncoveredLine">        if (auto *LI = dyn_cast<LoadInst>(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4091</td>
    <td class="uncoveredLine">          UnsplittableLoads.insert(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4092</td>
    <td class="uncoveredLine">        else if (auto *SI = dyn_cast<StoreInst>(I))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4093</td>
    <td class="uncoveredLine">          if (auto *LI = dyn_cast<LoadInst>(SI->getValueOperand()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4094</td>
    <td class="uncoveredLine">            UnsplittableLoads.insert(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4095</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4096</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4097</td>
    <td class="uncoveredLine">      assert(P.endOffset() > S.beginOffset() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4098</td>
    <td class="">             "Empty or backwards partition!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4099</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4100</td>
    <td class="">      // Determine if this is a pre-splittable slice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4101</td>
    <td class="uncoveredLine">      if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4102</td>
    <td class="uncoveredLine">        assert(!LI->isVolatile() && "Cannot split volatile loads!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4103</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4104</td>
    <td class="">        // The load must be used exclusively to store into other pointers for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4105</td>
    <td class="">        // us to be able to arbitrarily pre-split it. The stores must also be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4106</td>
    <td class="">        // simple to avoid changing semantics.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4107</td>
    <td class="uncoveredLine">        auto IsLoadSimplyStored = [](LoadInst *LI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4108</td>
    <td class="uncoveredLine">          for (User *LU : LI->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4109</td>
    <td class="uncoveredLine">            auto *SI = dyn_cast<StoreInst>(LU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4110</td>
    <td class="uncoveredLine">            if (!SI || !SI->isSimple())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4111</td>
    <td class="uncoveredLine">              return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4112</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4113</td>
    <td class="uncoveredLine">          return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4114</td>
    <td class="">        };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4115</td>
    <td class="uncoveredLine">        if (!IsLoadSimplyStored(LI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4116</td>
    <td class="uncoveredLine">          UnsplittableLoads.insert(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4117</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4118</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4119</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4120</td>
    <td class="uncoveredLine">        Loads.push_back(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4121</td>
    <td class="uncoveredLine">      } else if (auto *SI = dyn_cast<StoreInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4122</td>
    <td class="uncoveredLine">        if (S.getUse() != &SI->getOperandUse(SI->getPointerOperandIndex()))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4123</td>
    <td class="">          // Skip stores *of* pointers. FIXME: This shouldn't even be possible!</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4124</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4125</td>
    <td class="uncoveredLine">        auto *StoredLoad = dyn_cast<LoadInst>(SI->getValueOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4126</td>
    <td class="uncoveredLine">        if (!StoredLoad || !StoredLoad->isSimple())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4127</td>
    <td class="uncoveredLine">          continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4128</td>
    <td class="uncoveredLine">        assert(!SI->isVolatile() && "Cannot split volatile stores!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4129</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4130</td>
    <td class="uncoveredLine">        Stores.push_back(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4131</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4132</td>
    <td class="">        // Other uses cannot be pre-split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4133</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4134</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4135</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4136</td>
    <td class="">      // Record the initial split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4137</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "    Candidate: " << *I << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4138</td>
    <td class="uncoveredLine">      auto &Offsets = SplitOffsetsMap[I];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4139</td>
    <td class="uncoveredLine">      assert(Offsets.Splits.empty() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4140</td>
    <td class="">             "Should not have splits the first time we see an instruction!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4141</td>
    <td class="uncoveredLine">      Offsets.S = &S;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4142</td>
    <td class="uncoveredLine">      Offsets.Splits.push_back(P.endOffset() - S.beginOffset());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4143</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4144</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4145</td>
    <td class="">    // Now scan the already split slices, and add a split for any of them which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4146</td>
    <td class="">    // we're going to pre-split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4147</td>
    <td class="uncoveredLine">    for (Slice *S : P.splitSliceTails()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4148</td>
    <td class="">      auto SplitOffsetsMapI =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4149</td>
    <td class="uncoveredLine">          SplitOffsetsMap.find(cast<Instruction>(S->getUse()->getUser()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4150</td>
    <td class="uncoveredLine">      if (SplitOffsetsMapI == SplitOffsetsMap.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4151</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4152</td>
    <td class="uncoveredLine">      auto &Offsets = SplitOffsetsMapI->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4154</td>
    <td class="uncoveredLine">      assert(Offsets.S == S && "Found a mismatched slice!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4155</td>
    <td class="uncoveredLine">      assert(!Offsets.Splits.empty() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4156</td>
    <td class="">             "Cannot have an empty set of splits on the second partition!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4157</td>
    <td class="uncoveredLine">      assert(Offsets.Splits.back() ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4158</td>
    <td class="">                 P.beginOffset() - Offsets.S->beginOffset() &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4159</td>
    <td class="">             "Previous split does not end where this one begins!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4161</td>
    <td class="">      // Record each split. The last partition's end isn't needed as the size</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4162</td>
    <td class="">      // of the slice dictates that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4163</td>
    <td class="uncoveredLine">      if (S->endOffset() > P.endOffset())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4164</td>
    <td class="uncoveredLine">        Offsets.Splits.push_back(P.endOffset() - Offsets.S->beginOffset());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4165</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4166</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4167</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4168</td>
    <td class="">  // We may have split loads where some of their stores are split stores. For</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4169</td>
    <td class="">  // such loads and stores, we can only pre-split them if their splits exactly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4170</td>
    <td class="">  // match relative to their starting offset. We have to verify this prior to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4171</td>
    <td class="">  // any rewriting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4172</td>
    <td class="uncoveredLine">  llvm::erase_if(Stores, [&UnsplittableLoads, &SplitOffsetsMap](StoreInst *SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4173</td>
    <td class="">    // Lookup the load we are storing in our map of split</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4174</td>
    <td class="">    // offsets.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4175</td>
    <td class="uncoveredLine">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4176</td>
    <td class="">    // If it was completely unsplittable, then we're done,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4177</td>
    <td class="">    // and this store can't be pre-split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4178</td>
    <td class="uncoveredLine">    if (UnsplittableLoads.count(LI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4179</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4180</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4181</td>
    <td class="uncoveredLine">    auto LoadOffsetsI = SplitOffsetsMap.find(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4182</td>
    <td class="uncoveredLine">    if (LoadOffsetsI == SplitOffsetsMap.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4183</td>
    <td class="uncoveredLine">      return false; // Unrelated loads are definitely safe.</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4184</td>
    <td class="uncoveredLine">    auto &LoadOffsets = LoadOffsetsI->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4185</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4186</td>
    <td class="">    // Now lookup the store's offsets.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4187</td>
    <td class="uncoveredLine">    auto &StoreOffsets = SplitOffsetsMap[SI];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4188</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4189</td>
    <td class="">    // If the relative offsets of each split in the load and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4190</td>
    <td class="">    // store match exactly, then we can split them and we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4191</td>
    <td class="">    // don't need to remove them here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4192</td>
    <td class="uncoveredLine">    if (LoadOffsets.Splits == StoreOffsets.Splits)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4193</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4194</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4195</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "    Mismatched splits for load and store:\n"</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4196</td>
    <td class="">                      << "      " << *LI << "\n"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4197</td>
    <td class="">                      << "      " << *SI << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4199</td>
    <td class="">    // We've found a store and load that we need to split</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4200</td>
    <td class="">    // with mismatched relative splits. Just give up on them</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4201</td>
    <td class="">    // and remove both instructions from our list of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4202</td>
    <td class="">    // candidates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4203</td>
    <td class="uncoveredLine">    UnsplittableLoads.insert(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4204</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4205</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4206</td>
    <td class="">  // Now we have to go *back* through all the stores, because a later store may</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4207</td>
    <td class="">  // have caused an earlier store's load to become unsplittable and if it is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4208</td>
    <td class="">  // unsplittable for the later store, then we can't rely on it being split in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4209</td>
    <td class="">  // the earlier store either.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4210</td>
    <td class="uncoveredLine">  llvm::erase_if(Stores, [&UnsplittableLoads](StoreInst *SI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4211</td>
    <td class="uncoveredLine">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4212</td>
    <td class="uncoveredLine">    return UnsplittableLoads.count(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4213</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4214</td>
    <td class="">  // Once we've established all the loads that can't be split for some reason,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4215</td>
    <td class="">  // filter any that made it into our list out.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4216</td>
    <td class="uncoveredLine">  llvm::erase_if(Loads, [&UnsplittableLoads](LoadInst *LI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4217</td>
    <td class="uncoveredLine">    return UnsplittableLoads.count(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4218</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4219</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4220</td>
    <td class="">  // If no loads or stores are left, there is no pre-splitting to be done for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4221</td>
    <td class="">  // this alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4222</td>
    <td class="uncoveredLine">  if (Loads.empty() && Stores.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4223</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4224</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4225</td>
    <td class="">  // From here on, we can't fail and will be building new accesses, so rig up</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4226</td>
    <td class="">  // an IR builder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4227</td>
    <td class="uncoveredLine">  IRBuilderTy IRB(&AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4228</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4229</td>
    <td class="">  // Collect the new slices which we will merge into the alloca slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4230</td>
    <td class="uncoveredLine">  SmallVector<Slice, 4> NewSlices;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4232</td>
    <td class="">  // Track any allocas we end up splitting loads and stores for so we iterate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4233</td>
    <td class="">  // on them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4234</td>
    <td class="uncoveredLine">  SmallPtrSet<AllocaInst *, 4> ResplitPromotableAllocas;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4235</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4236</td>
    <td class="">  // At this point, we have collected all of the loads and stores we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4237</td>
    <td class="">  // pre-split, and the specific splits needed for them. We actually do the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4238</td>
    <td class="">  // splitting in a specific order in order to handle when one of the loads in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4239</td>
    <td class="">  // the value operand to one of the stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4240</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4241</td>
    <td class="">  // First, we rewrite all of the split loads, and just accumulate each split</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4242</td>
    <td class="">  // load in a parallel structure. We also build the slices for them and append</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4243</td>
    <td class="">  // them to the alloca slices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4244</td>
    <td class="uncoveredLine">  SmallDenseMap<LoadInst *, std::vector<LoadInst *>, 1> SplitLoadsMap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4245</td>
    <td class="uncoveredLine">  std::vector<LoadInst *> SplitLoads;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4246</td>
    <td class="uncoveredLine">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4247</td>
    <td class="uncoveredLine">  for (LoadInst *LI : Loads) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4248</td>
    <td class="uncoveredLine">    SplitLoads.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4249</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4250</td>
    <td class="uncoveredLine">    auto &Offsets = SplitOffsetsMap[LI];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4251</td>
    <td class="uncoveredLine">    unsigned SliceSize = Offsets.S->endOffset() - Offsets.S->beginOffset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4252</td>
    <td class="uncoveredLine">    assert(LI->getType()->getIntegerBitWidth() % 8 == 0 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4253</td>
    <td class="">           "Load must have type size equal to store size");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4254</td>
    <td class="uncoveredLine">    assert(LI->getType()->getIntegerBitWidth() / 8 >= SliceSize &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4255</td>
    <td class="">           "Load must be >= slice size");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4256</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4257</td>
    <td class="uncoveredLine">    uint64_t BaseOffset = Offsets.S->beginOffset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4258</td>
    <td class="uncoveredLine">    assert(BaseOffset + SliceSize > BaseOffset &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4259</td>
    <td class="">           "Cannot represent alloca access size using 64-bit integers!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4260</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4261</td>
    <td class="uncoveredLine">    Instruction *BasePtr = cast<Instruction>(LI->getPointerOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4262</td>
    <td class="uncoveredLine">    IRB.SetInsertPoint(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4264</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "  Splitting load: " << *LI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4265</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4266</td>
    <td class="uncoveredLine">    uint64_t PartOffset = 0, PartSize = Offsets.Splits.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4267</td>
    <td class="uncoveredLine">    int Idx = 0, Size = Offsets.Splits.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4268</td>
    <td class="">    for (;;) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4269</td>
    <td class="uncoveredLine">      auto *PartTy = Type::getIntNTy(LI->getContext(), PartSize * 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4270</td>
    <td class="uncoveredLine">      auto AS = LI->getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4271</td>
    <td class="uncoveredLine">      auto *PartPtrTy = PartTy->getPointerTo(AS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4272</td>
    <td class="uncoveredLine">      LoadInst *PLoad = IRB.CreateAlignedLoad(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4273</td>
    <td class="">          PartTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4274</td>
    <td class="">          getAdjustedPtr(IRB, DL, BasePtr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4275</td>
    <td class="uncoveredLine">                         APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4276</td>
    <td class="uncoveredLine">                         PartPtrTy, BasePtr->getName() + "."),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4277</td>
    <td class="">          getAdjustedAlignment(LI, PartOffset),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4278</td>
    <td class="uncoveredLine">          /*IsVolatile*/ false, LI->getName());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4279</td>
    <td class="uncoveredLine">      PLoad->copyMetadata(*LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4280</td>
    <td class="">                                LLVMContext::MD_access_group});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4281</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4282</td>
    <td class="">      // Append this load onto the list of split loads so we can find it later</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4283</td>
    <td class="">      // to rewrite the stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4284</td>
    <td class="uncoveredLine">      SplitLoads.push_back(PLoad);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4285</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4286</td>
    <td class="">      // Now build a new slice for the alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4287</td>
    <td class="uncoveredLine">      NewSlices.push_back(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4288</td>
    <td class="uncoveredLine">          Slice(BaseOffset + PartOffset, BaseOffset + PartOffset + PartSize,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4289</td>
    <td class="uncoveredLine">                &PLoad->getOperandUse(PLoad->getPointerOperandIndex()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4290</td>
    <td class="">                /*IsSplittable*/ false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4291</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "    new slice [" << NewSlices.back().beginOffset()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4292</td>
    <td class="">                        << ", " << NewSlices.back().endOffset()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4293</td>
    <td class="">                        << "): " << *PLoad << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4294</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4295</td>
    <td class="">      // See if we've handled all the splits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4296</td>
    <td class="uncoveredLine">      if (Idx >= Size)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4297</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4298</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4299</td>
    <td class="">      // Setup the next partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4300</td>
    <td class="uncoveredLine">      PartOffset = Offsets.Splits[Idx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4301</td>
    <td class="uncoveredLine">      ++Idx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4302</td>
    <td class="uncoveredLine">      PartSize = (Idx < Size ? Offsets.Splits[Idx] : SliceSize) - PartOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4303</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4305</td>
    <td class="">    // Now that we have the split loads, do the slow walk over all uses of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4306</td>
    <td class="">    // load and rewrite them as split stores, or save the split loads to use</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4307</td>
    <td class="">    // below if the store is going to be split there anyways.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4308</td>
    <td class="uncoveredLine">    bool DeferredStores = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4309</td>
    <td class="uncoveredLine">    for (User *LU : LI->users()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4310</td>
    <td class="uncoveredLine">      StoreInst *SI = cast<StoreInst>(LU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4311</td>
    <td class="uncoveredLine">      if (!Stores.empty() && SplitOffsetsMap.count(SI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4312</td>
    <td class="uncoveredLine">        DeferredStores = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4313</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "    Deferred splitting of store: " << *SI</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4314</td>
    <td class="">                          << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4315</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4316</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4317</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4318</td>
    <td class="uncoveredLine">      Value *StoreBasePtr = SI->getPointerOperand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4319</td>
    <td class="uncoveredLine">      IRB.SetInsertPoint(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4320</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4321</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "    Splitting store of load: " << *SI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4322</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4323</td>
    <td class="uncoveredLine">      for (int Idx = 0, Size = SplitLoads.size(); Idx < Size; ++Idx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4324</td>
    <td class="uncoveredLine">        LoadInst *PLoad = SplitLoads[Idx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4325</td>
    <td class="uncoveredLine">        uint64_t PartOffset = Idx == 0 ? 0 : Offsets.Splits[Idx - 1];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4326</td>
    <td class="">        auto *PartPtrTy =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4327</td>
    <td class="uncoveredLine">            PLoad->getType()->getPointerTo(SI->getPointerAddressSpace());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4328</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4329</td>
    <td class="uncoveredLine">        auto AS = SI->getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4330</td>
    <td class="uncoveredLine">        StoreInst *PStore = IRB.CreateAlignedStore(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4331</td>
    <td class="">            PLoad,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4332</td>
    <td class="">            getAdjustedPtr(IRB, DL, StoreBasePtr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4333</td>
    <td class="uncoveredLine">                           APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4334</td>
    <td class="uncoveredLine">                           PartPtrTy, StoreBasePtr->getName() + "."),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4335</td>
    <td class="">            getAdjustedAlignment(SI, PartOffset),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4336</td>
    <td class="">            /*IsVolatile*/ false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4337</td>
    <td class="uncoveredLine">        PStore->copyMetadata(*SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4338</td>
    <td class="">                                   LLVMContext::MD_access_group,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4339</td>
    <td class="">                                   LLVMContext::MD_DIAssignID});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4340</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "      +" << PartOffset << ":" << *PStore << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4341</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4342</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4343</td>
    <td class="">      // We want to immediately iterate on any allocas impacted by splitting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4344</td>
    <td class="">      // this store, and we have to track any promotable alloca (indicated by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4345</td>
    <td class="">      // a direct store) as needing to be resplit because it is no longer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4346</td>
    <td class="">      // promotable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4347</td>
    <td class="uncoveredLine">      if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(StoreBasePtr)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4348</td>
    <td class="uncoveredLine">        ResplitPromotableAllocas.insert(OtherAI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4349</td>
    <td class="uncoveredLine">        Worklist.insert(OtherAI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4350</td>
    <td class="uncoveredLine">      } else if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4351</td>
    <td class="uncoveredLine">                     StoreBasePtr->stripInBoundsOffsets())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4352</td>
    <td class="uncoveredLine">        Worklist.insert(OtherAI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4353</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4354</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4355</td>
    <td class="">      // Mark the original store as dead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4356</td>
    <td class="uncoveredLine">      DeadInsts.push_back(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4357</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4358</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4359</td>
    <td class="">    // Save the split loads if there are deferred stores among the users.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4360</td>
    <td class="uncoveredLine">    if (DeferredStores)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4361</td>
    <td class="uncoveredLine">      SplitLoadsMap.insert(std::make_pair(LI, std::move(SplitLoads)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4363</td>
    <td class="">    // Mark the original load as dead and kill the original slice.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4364</td>
    <td class="uncoveredLine">    DeadInsts.push_back(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4365</td>
    <td class="uncoveredLine">    Offsets.S->kill();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4366</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4368</td>
    <td class="">  // Second, we rewrite all of the split stores. At this point, we know that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4369</td>
    <td class="">  // all loads from this alloca have been split already. For stores of such</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4370</td>
    <td class="">  // loads, we can simply look up the pre-existing split loads. For stores of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4371</td>
    <td class="">  // other loads, we split those loads first and then write split stores of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4372</td>
    <td class="">  // them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4373</td>
    <td class="uncoveredLine">  for (StoreInst *SI : Stores) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4374</td>
    <td class="uncoveredLine">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4375</td>
    <td class="uncoveredLine">    IntegerType *Ty = cast<IntegerType>(LI->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4376</td>
    <td class="uncoveredLine">    assert(Ty->getBitWidth() % 8 == 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4377</td>
    <td class="uncoveredLine">    uint64_t StoreSize = Ty->getBitWidth() / 8;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4378</td>
    <td class="uncoveredLine">    assert(StoreSize > 0 && "Cannot have a zero-sized integer store!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4379</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4380</td>
    <td class="uncoveredLine">    auto &Offsets = SplitOffsetsMap[SI];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4381</td>
    <td class="uncoveredLine">    assert(StoreSize == Offsets.S->endOffset() - Offsets.S->beginOffset() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4382</td>
    <td class="">           "Slice size should always match load size exactly!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4383</td>
    <td class="uncoveredLine">    uint64_t BaseOffset = Offsets.S->beginOffset();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4384</td>
    <td class="uncoveredLine">    assert(BaseOffset + StoreSize > BaseOffset &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4385</td>
    <td class="">           "Cannot represent alloca access size using 64-bit integers!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4386</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4387</td>
    <td class="uncoveredLine">    Value *LoadBasePtr = LI->getPointerOperand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4388</td>
    <td class="uncoveredLine">    Instruction *StoreBasePtr = cast<Instruction>(SI->getPointerOperand());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4390</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "  Splitting store: " << *SI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4391</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4392</td>
    <td class="">    // Check whether we have an already split load.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4393</td>
    <td class="uncoveredLine">    auto SplitLoadsMapI = SplitLoadsMap.find(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4394</td>
    <td class="uncoveredLine">    std::vector<LoadInst *> *SplitLoads = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4395</td>
    <td class="uncoveredLine">    if (SplitLoadsMapI != SplitLoadsMap.end()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4396</td>
    <td class="uncoveredLine">      SplitLoads = &SplitLoadsMapI->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4397</td>
    <td class="uncoveredLine">      assert(SplitLoads->size() == Offsets.Splits.size() + 1 &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4398</td>
    <td class="">             "Too few split loads for the number of splits in the store!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4399</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4400</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "          of load: " << *LI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4401</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4402</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4403</td>
    <td class="uncoveredLine">    uint64_t PartOffset = 0, PartSize = Offsets.Splits.front();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4404</td>
    <td class="uncoveredLine">    int Idx = 0, Size = Offsets.Splits.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4405</td>
    <td class="">    for (;;) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4406</td>
    <td class="uncoveredLine">      auto *PartTy = Type::getIntNTy(Ty->getContext(), PartSize * 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4407</td>
    <td class="uncoveredLine">      auto *LoadPartPtrTy = PartTy->getPointerTo(LI->getPointerAddressSpace());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4408</td>
    <td class="uncoveredLine">      auto *StorePartPtrTy = PartTy->getPointerTo(SI->getPointerAddressSpace());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4409</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4410</td>
    <td class="">      // Either lookup a split load or create one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4411</td>
    <td class="">      LoadInst *PLoad;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4412</td>
    <td class="uncoveredLine">      if (SplitLoads) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4413</td>
    <td class="uncoveredLine">        PLoad = (*SplitLoads)[Idx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4414</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4415</td>
    <td class="uncoveredLine">        IRB.SetInsertPoint(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4416</td>
    <td class="uncoveredLine">        auto AS = LI->getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4417</td>
    <td class="uncoveredLine">        PLoad = IRB.CreateAlignedLoad(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4418</td>
    <td class="">            PartTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4419</td>
    <td class="">            getAdjustedPtr(IRB, DL, LoadBasePtr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4420</td>
    <td class="uncoveredLine">                           APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4421</td>
    <td class="uncoveredLine">                           LoadPartPtrTy, LoadBasePtr->getName() + "."),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4422</td>
    <td class="">            getAdjustedAlignment(LI, PartOffset),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4423</td>
    <td class="uncoveredLine">            /*IsVolatile*/ false, LI->getName());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4424</td>
    <td class="uncoveredLine">        PLoad->copyMetadata(*LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4425</td>
    <td class="">                                  LLVMContext::MD_access_group});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4426</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4427</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4428</td>
    <td class="">      // And store this partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4429</td>
    <td class="uncoveredLine">      IRB.SetInsertPoint(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4430</td>
    <td class="uncoveredLine">      auto AS = SI->getPointerAddressSpace();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4431</td>
    <td class="uncoveredLine">      StoreInst *PStore = IRB.CreateAlignedStore(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4432</td>
    <td class="">          PLoad,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4433</td>
    <td class="">          getAdjustedPtr(IRB, DL, StoreBasePtr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4434</td>
    <td class="uncoveredLine">                         APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4435</td>
    <td class="uncoveredLine">                         StorePartPtrTy, StoreBasePtr->getName() + "."),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4436</td>
    <td class="">          getAdjustedAlignment(SI, PartOffset),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4437</td>
    <td class="">          /*IsVolatile*/ false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4438</td>
    <td class="uncoveredLine">      PStore->copyMetadata(*SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4439</td>
    <td class="">                                 LLVMContext::MD_access_group});</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4440</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4441</td>
    <td class="">      // Now build a new slice for the alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4442</td>
    <td class="uncoveredLine">      NewSlices.push_back(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4443</td>
    <td class="uncoveredLine">          Slice(BaseOffset + PartOffset, BaseOffset + PartOffset + PartSize,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4444</td>
    <td class="uncoveredLine">                &PStore->getOperandUse(PStore->getPointerOperandIndex()),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4445</td>
    <td class="">                /*IsSplittable*/ false));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4446</td>
    <td class="uncoveredLine">      LLVM_DEBUG(dbgs() << "    new slice [" << NewSlices.back().beginOffset()</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4447</td>
    <td class="">                        << ", " << NewSlices.back().endOffset()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4448</td>
    <td class="">                        << "): " << *PStore << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4449</td>
    <td class="uncoveredLine">      if (!SplitLoads) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4450</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "      of split load: " << *PLoad << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4451</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4452</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4453</td>
    <td class="">      // See if we've finished all the splits.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4454</td>
    <td class="uncoveredLine">      if (Idx >= Size)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4455</td>
    <td class="uncoveredLine">        break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4456</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4457</td>
    <td class="">      // Setup the next partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4458</td>
    <td class="uncoveredLine">      PartOffset = Offsets.Splits[Idx];</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4459</td>
    <td class="uncoveredLine">      ++Idx;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4460</td>
    <td class="uncoveredLine">      PartSize = (Idx < Size ? Offsets.Splits[Idx] : StoreSize) - PartOffset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4461</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4463</td>
    <td class="">    // We want to immediately iterate on any allocas impacted by splitting</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4464</td>
    <td class="">    // this load, which is only relevant if it isn't a load of this alloca and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4465</td>
    <td class="">    // thus we didn't already split the loads above. We also have to keep track</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4466</td>
    <td class="">    // of any promotable allocas we split loads on as they can no longer be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4467</td>
    <td class="">    // promoted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4468</td>
    <td class="uncoveredLine">    if (!SplitLoads) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4469</td>
    <td class="uncoveredLine">      if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(LoadBasePtr)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4470</td>
    <td class="uncoveredLine">        assert(OtherAI != &AI && "We can't re-split our own alloca!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4471</td>
    <td class="uncoveredLine">        ResplitPromotableAllocas.insert(OtherAI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4472</td>
    <td class="uncoveredLine">        Worklist.insert(OtherAI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4473</td>
    <td class="uncoveredLine">      } else if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4474</td>
    <td class="uncoveredLine">                     LoadBasePtr->stripInBoundsOffsets())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4475</td>
    <td class="uncoveredLine">        assert(OtherAI != &AI && "We can't re-split our own alloca!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4476</td>
    <td class="uncoveredLine">        Worklist.insert(OtherAI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4477</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4478</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4479</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4480</td>
    <td class="">    // Mark the original store as dead now that we've split it up and kill its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4481</td>
    <td class="">    // slice. Note that we leave the original load in place unless this store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4482</td>
    <td class="">    // was its only use. It may in turn be split up if it is an alloca load</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4483</td>
    <td class="">    // for some other alloca, but it may be a normal load. This may introduce</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4484</td>
    <td class="">    // redundant loads, but where those can be merged the rest of the optimizer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4485</td>
    <td class="">    // should handle the merging, and this uncovers SSA splits which is more</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4486</td>
    <td class="">    // important. In practice, the original loads will almost always be fully</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4487</td>
    <td class="">    // split and removed eventually, and the splits will be merged by any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4488</td>
    <td class="">    // trivial CSE, including instcombine.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4489</td>
    <td class="uncoveredLine">    if (LI->hasOneUse()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4490</td>
    <td class="uncoveredLine">      assert(*LI->user_begin() == SI && "Single use isn't this store!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4491</td>
    <td class="uncoveredLine">      DeadInsts.push_back(LI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4492</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4493</td>
    <td class="uncoveredLine">    DeadInsts.push_back(SI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4494</td>
    <td class="uncoveredLine">    Offsets.S->kill();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4495</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4496</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4497</td>
    <td class="">  // Remove the killed slices that have ben pre-split.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4498</td>
    <td class="uncoveredLine">  llvm::erase_if(AS, [](const Slice &S) { return S.isDead(); });</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4499</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4500</td>
    <td class="">  // Insert our new slices. This will sort and merge them into the sorted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4501</td>
    <td class="">  // sequence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4502</td>
    <td class="uncoveredLine">  AS.insert(NewSlices);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4503</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4504</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "  Pre-split slices:\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4505</td>
    <td class="">#ifndef NDEBUG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4506</td>
    <td class="uncoveredLine">  for (auto I = AS.begin(), E = AS.end(); I != E; ++I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4507</td>
    <td class="uncoveredLine">    LLVM_DEBUG(AS.print(dbgs(), I, "    "));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4508</td>
    <td class="">#endif</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4509</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4510</td>
    <td class="">  // Finally, don't try to promote any allocas that new require re-splitting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4511</td>
    <td class="">  // They have already been added to the worklist above.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4512</td>
    <td class="uncoveredLine">  llvm::erase_if(PromotableAllocas, [&](AllocaInst *AI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4513</td>
    <td class="uncoveredLine">    return ResplitPromotableAllocas.count(AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4514</td>
    <td class="">  });</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4515</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4516</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4517</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4518</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4519</td>
    <td class="">/// Rewrite an alloca partition's users.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4520</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4521</td>
    <td class="">/// This routine drives both of the rewriting goals of the SROA pass. It tries</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4522</td>
    <td class="">/// to rewrite uses of an alloca partition to be conducive for SSA value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4523</td>
    <td class="">/// promotion. If the partition needs a new, more refined alloca, this will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4524</td>
    <td class="">/// build that new alloca, preserving as much type information as possible, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4525</td>
    <td class="">/// rewrite the uses of the old alloca to point at the new one and have the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4526</td>
    <td class="">/// appropriate new offsets. It also evaluates how successful the rewrite was</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4527</td>
    <td class="">/// at enabling promotion and if it was successful queues the alloca to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4528</td>
    <td class="">/// promoted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4529</td>
    <td class="uncoveredLine">AllocaInst *SROAPass::rewritePartition(AllocaInst &AI, AllocaSlices &AS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4530</td>
    <td class="">                                       Partition &P) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4531</td>
    <td class="">  // Try to compute a friendly type for this partition of the alloca. This</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4532</td>
    <td class="">  // won't always succeed, in which case we fall back to a legal integer type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4533</td>
    <td class="">  // or an i8 array of an appropriate size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4534</td>
    <td class="uncoveredLine">  Type *SliceTy = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4535</td>
    <td class="uncoveredLine">  VectorType *SliceVecTy = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4536</td>
    <td class="uncoveredLine">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4537</td>
    <td class="">  std::pair<Type *, IntegerType *> CommonUseTy =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4538</td>
    <td class="uncoveredLine">      findCommonType(P.begin(), P.end(), P.endOffset());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4539</td>
    <td class="">  // Do all uses operate on the same type?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4540</td>
    <td class="uncoveredLine">  if (CommonUseTy.first)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4541</td>
    <td class="uncoveredLine">    if (DL.getTypeAllocSize(CommonUseTy.first).getFixedValue() >= P.size()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4542</td>
    <td class="uncoveredLine">      SliceTy = CommonUseTy.first;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4543</td>
    <td class="uncoveredLine">      SliceVecTy = dyn_cast<VectorType>(SliceTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4544</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4545</td>
    <td class="">  // If not, can we find an appropriate subtype in the original allocated type?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4546</td>
    <td class="uncoveredLine">  if (!SliceTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4547</td>
    <td class="uncoveredLine">    if (Type *TypePartitionTy = getTypePartition(DL, AI.getAllocatedType(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4548</td>
    <td class="">                                                 P.beginOffset(), P.size()))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4549</td>
    <td class="uncoveredLine">      SliceTy = TypePartitionTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4550</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4551</td>
    <td class="">  // If still not, can we use the largest bitwidth integer type used?</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4552</td>
    <td class="uncoveredLine">  if (!SliceTy && CommonUseTy.second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4553</td>
    <td class="uncoveredLine">    if (DL.getTypeAllocSize(CommonUseTy.second).getFixedValue() >= P.size()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4554</td>
    <td class="uncoveredLine">      SliceTy = CommonUseTy.second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4555</td>
    <td class="uncoveredLine">      SliceVecTy = dyn_cast<VectorType>(SliceTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4556</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4557</td>
    <td class="uncoveredLine">  if ((!SliceTy || (SliceTy->isArrayTy() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4558</td>
    <td class="uncoveredLine">                    SliceTy->getArrayElementType()->isIntegerTy())) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4559</td>
    <td class="uncoveredLine">      DL.isLegalInteger(P.size() * 8)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4560</td>
    <td class="uncoveredLine">    SliceTy = Type::getIntNTy(*C, P.size() * 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4561</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4563</td>
    <td class="">  // If the common use types are not viable for promotion then attempt to find</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4564</td>
    <td class="">  // another type that is viable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4565</td>
    <td class="uncoveredLine">  if (SliceVecTy && !checkVectorTypeForPromotion(P, SliceVecTy, DL))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4566</td>
    <td class="uncoveredLine">    if (Type *TypePartitionTy = getTypePartition(DL, AI.getAllocatedType(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4567</td>
    <td class="">                                                 P.beginOffset(), P.size())) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4568</td>
    <td class="uncoveredLine">      VectorType *TypePartitionVecTy = dyn_cast<VectorType>(TypePartitionTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4569</td>
    <td class="uncoveredLine">      if (TypePartitionVecTy &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4570</td>
    <td class="uncoveredLine">          checkVectorTypeForPromotion(P, TypePartitionVecTy, DL))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4571</td>
    <td class="uncoveredLine">        SliceTy = TypePartitionTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4572</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4573</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4574</td>
    <td class="uncoveredLine">  if (!SliceTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4575</td>
    <td class="uncoveredLine">    SliceTy = ArrayType::get(Type::getInt8Ty(*C), P.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4576</td>
    <td class="uncoveredLine">  assert(DL.getTypeAllocSize(SliceTy).getFixedValue() >= P.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4577</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4578</td>
    <td class="uncoveredLine">  bool IsIntegerPromotable = isIntegerWideningViable(P, SliceTy, DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4579</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4580</td>
    <td class="">  VectorType *VecTy =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4581</td>
    <td class="uncoveredLine">      IsIntegerPromotable ? nullptr : isVectorPromotionViable(P, DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4582</td>
    <td class="uncoveredLine">  if (VecTy)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4583</td>
    <td class="uncoveredLine">    SliceTy = VecTy;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4584</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4585</td>
    <td class="">  // Check for the case where we're going to rewrite to a new alloca of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4586</td>
    <td class="">  // exact same type as the original, and with the same access offsets. In that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4587</td>
    <td class="">  // case, re-use the existing alloca, but still run through the rewriter to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4588</td>
    <td class="">  // perform phi and select speculation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4589</td>
    <td class="">  // P.beginOffset() can be non-zero even with the same type in a case with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4590</td>
    <td class="">  // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4591</td>
    <td class="">  AllocaInst *NewAI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4592</td>
    <td class="uncoveredLine">  if (SliceTy == AI.getAllocatedType() && P.beginOffset() == 0) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4593</td>
    <td class="uncoveredLine">    NewAI = &AI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4594</td>
    <td class="">    // FIXME: We should be able to bail at this point with "nothing changed".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4595</td>
    <td class="">    // FIXME: We might want to defer PHI speculation until after here.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4596</td>
    <td class="">    // FIXME: return nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4597</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4598</td>
    <td class="">    // Make sure the alignment is compatible with P.beginOffset().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4599</td>
    <td class="uncoveredLine">    const Align Alignment = commonAlignment(AI.getAlign(), P.beginOffset());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4600</td>
    <td class="">    // If we will get at least this much alignment from the type alone, leave</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4601</td>
    <td class="">    // the alloca's alignment unconstrained.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4602</td>
    <td class="uncoveredLine">    const bool IsUnconstrained = Alignment <= DL.getABITypeAlign(SliceTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4603</td>
    <td class="uncoveredLine">    NewAI = new AllocaInst(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4604</td>
    <td class="uncoveredLine">        SliceTy, AI.getAddressSpace(), nullptr,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4605</td>
    <td class="uncoveredLine">        IsUnconstrained ? DL.getPrefTypeAlign(SliceTy) : Alignment,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4606</td>
    <td class="uncoveredLine">        AI.getName() + ".sroa." + Twine(P.begin() - AS.begin()), &AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4607</td>
    <td class="">    // Copy the old AI debug location over to the new one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4608</td>
    <td class="uncoveredLine">    NewAI->setDebugLoc(AI.getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4609</td>
    <td class="uncoveredLine">    ++NumNewAllocas;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4610</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4611</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4612</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "Rewriting alloca partition "</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4613</td>
    <td class="">                    << "[" << P.beginOffset() << "," << P.endOffset()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4614</td>
    <td class="">                    << ") to: " << *NewAI << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4615</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4616</td>
    <td class="">  // Track the high watermark on the worklist as it is only relevant for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4617</td>
    <td class="">  // promoted allocas. We will reset it to this point if the alloca is not in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4618</td>
    <td class="">  // fact scheduled for promotion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4619</td>
    <td class="uncoveredLine">  unsigned PPWOldSize = PostPromotionWorklist.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4620</td>
    <td class="uncoveredLine">  unsigned NumUses = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4621</td>
    <td class="uncoveredLine">  SmallSetVector<PHINode *, 8> PHIUsers;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4622</td>
    <td class="uncoveredLine">  SmallSetVector<SelectInst *, 8> SelectUsers;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4623</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4624</td>
    <td class="">  AllocaSliceRewriter Rewriter(DL, AS, *this, AI, *NewAI, P.beginOffset(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4625</td>
    <td class="">                               P.endOffset(), IsIntegerPromotable, VecTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4626</td>
    <td class="uncoveredLine">                               PHIUsers, SelectUsers);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4627</td>
    <td class="uncoveredLine">  bool Promotable = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4628</td>
    <td class="uncoveredLine">  for (Slice *S : P.splitSliceTails()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4629</td>
    <td class="uncoveredLine">    Promotable &= Rewriter.visit(S);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4630</td>
    <td class="uncoveredLine">    ++NumUses;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4631</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4632</td>
    <td class="uncoveredLine">  for (Slice &S : P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4633</td>
    <td class="uncoveredLine">    Promotable &= Rewriter.visit(&S);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4634</td>
    <td class="uncoveredLine">    ++NumUses;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4635</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4636</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4637</td>
    <td class="uncoveredLine">  NumAllocaPartitionUses += NumUses;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4638</td>
    <td class="uncoveredLine">  MaxUsesPerAllocaPartition.updateMax(NumUses);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4639</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4640</td>
    <td class="">  // Now that we've processed all the slices in the new partition, check if any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4641</td>
    <td class="">  // PHIs or Selects would block promotion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4642</td>
    <td class="uncoveredLine">  for (PHINode *PHI : PHIUsers)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4643</td>
    <td class="uncoveredLine">    if (!isSafePHIToSpeculate(*PHI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4644</td>
    <td class="uncoveredLine">      Promotable = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4645</td>
    <td class="uncoveredLine">      PHIUsers.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4646</td>
    <td class="uncoveredLine">      SelectUsers.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4647</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4648</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4649</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4650</td>
    <td class="">  SmallVector<std::pair<SelectInst *, RewriteableMemOps>, 2></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4651</td>
    <td class="uncoveredLine">      NewSelectsToRewrite;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4652</td>
    <td class="uncoveredLine">  NewSelectsToRewrite.reserve(SelectUsers.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4653</td>
    <td class="uncoveredLine">  for (SelectInst *Sel : SelectUsers) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4654</td>
    <td class="">    std::optional<RewriteableMemOps> Ops =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4655</td>
    <td class="uncoveredLine">        isSafeSelectToSpeculate(*Sel, PreserveCFG);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4656</td>
    <td class="uncoveredLine">    if (!Ops) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4657</td>
    <td class="uncoveredLine">      Promotable = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4658</td>
    <td class="uncoveredLine">      PHIUsers.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4659</td>
    <td class="uncoveredLine">      SelectUsers.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4660</td>
    <td class="uncoveredLine">      NewSelectsToRewrite.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4661</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4662</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4663</td>
    <td class="uncoveredLine">    NewSelectsToRewrite.emplace_back(std::make_pair(Sel, *Ops));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4664</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4665</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4666</td>
    <td class="uncoveredLine">  if (Promotable) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4667</td>
    <td class="uncoveredLine">    for (Use *U : AS.getDeadUsesIfPromotable()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4668</td>
    <td class="uncoveredLine">      auto *OldInst = dyn_cast<Instruction>(U->get());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4669</td>
    <td class="uncoveredLine">      Value::dropDroppableUse(*U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4670</td>
    <td class="uncoveredLine">      if (OldInst)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4671</td>
    <td class="uncoveredLine">        if (isInstructionTriviallyDead(OldInst))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4672</td>
    <td class="uncoveredLine">          DeadInsts.push_back(OldInst);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4673</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4674</td>
    <td class="uncoveredLine">    if (PHIUsers.empty() && SelectUsers.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4675</td>
    <td class="">      // Promote the alloca.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4676</td>
    <td class="uncoveredLine">      PromotableAllocas.push_back(NewAI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4677</td>
    <td class="">    } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4678</td>
    <td class="">      // If we have either PHIs or Selects to speculate, add them to those</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4679</td>
    <td class="">      // worklists and re-queue the new alloca so that we promote in on the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4680</td>
    <td class="">      // next iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4681</td>
    <td class="uncoveredLine">      for (PHINode *PHIUser : PHIUsers)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4682</td>
    <td class="uncoveredLine">        SpeculatablePHIs.insert(PHIUser);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4683</td>
    <td class="uncoveredLine">      SelectsToRewrite.reserve(SelectsToRewrite.size() +</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4684</td>
    <td class="uncoveredLine">                               NewSelectsToRewrite.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4685</td>
    <td class="uncoveredLine">      for (auto &&KV : llvm::make_range(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4686</td>
    <td class="">               std::make_move_iterator(NewSelectsToRewrite.begin()),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4687</td>
    <td class="uncoveredLine">               std::make_move_iterator(NewSelectsToRewrite.end())))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4688</td>
    <td class="uncoveredLine">        SelectsToRewrite.insert(std::move(KV));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4689</td>
    <td class="uncoveredLine">      Worklist.insert(NewAI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4690</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4691</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4692</td>
    <td class="">    // Drop any post-promotion work items if promotion didn't happen.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4693</td>
    <td class="uncoveredLine">    while (PostPromotionWorklist.size() > PPWOldSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4694</td>
    <td class="uncoveredLine">      PostPromotionWorklist.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4695</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4696</td>
    <td class="">    // We couldn't promote and we didn't create a new partition, nothing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4697</td>
    <td class="">    // happened.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4698</td>
    <td class="uncoveredLine">    if (NewAI == &AI)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4699</td>
    <td class="uncoveredLine">      return nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4700</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4701</td>
    <td class="">    // If we can't promote the alloca, iterate on it to check for new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4702</td>
    <td class="">    // refinements exposed by splitting the current alloca. Don't iterate on an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4703</td>
    <td class="">    // alloca which didn't actually change and didn't get promoted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4704</td>
    <td class="uncoveredLine">    Worklist.insert(NewAI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4705</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4706</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4707</td>
    <td class="uncoveredLine">  return NewAI;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4708</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4709</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4710</td>
    <td class="">/// Walks the slices of an alloca and form partitions based on them,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4711</td>
    <td class="">/// rewriting each of their uses.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4712</td>
    <td class="uncoveredLine">bool SROAPass::splitAlloca(AllocaInst &AI, AllocaSlices &AS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4713</td>
    <td class="uncoveredLine">  if (AS.begin() == AS.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4714</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4715</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4716</td>
    <td class="uncoveredLine">  unsigned NumPartitions = 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4717</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4718</td>
    <td class="uncoveredLine">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4719</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4720</td>
    <td class="">  // First try to pre-split loads and stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4721</td>
    <td class="uncoveredLine">  Changed |= presplitLoadsAndStores(AI, AS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4722</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4723</td>
    <td class="">  // Now that we have identified any pre-splitting opportunities,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4724</td>
    <td class="">  // mark loads and stores unsplittable except for the following case.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4725</td>
    <td class="">  // We leave a slice splittable if all other slices are disjoint or fully</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4726</td>
    <td class="">  // included in the slice, such as whole-alloca loads and stores.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4727</td>
    <td class="">  // If we fail to split these during pre-splitting, we want to force them</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4728</td>
    <td class="">  // to be rewritten into a partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4729</td>
    <td class="uncoveredLine">  bool IsSorted = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4730</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4731</td>
    <td class="">  uint64_t AllocaSize =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4732</td>
    <td class="uncoveredLine">      DL.getTypeAllocSize(AI.getAllocatedType()).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4733</td>
    <td class="uncoveredLine">  const uint64_t MaxBitVectorSize = 1024;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4734</td>
    <td class="uncoveredLine">  if (AllocaSize <= MaxBitVectorSize) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4735</td>
    <td class="">    // If a byte boundary is included in any load or store, a slice starting or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4736</td>
    <td class="">    // ending at the boundary is not splittable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4737</td>
    <td class="uncoveredLine">    SmallBitVector SplittableOffset(AllocaSize + 1, true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4738</td>
    <td class="uncoveredLine">    for (Slice &S : AS)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4739</td>
    <td class="uncoveredLine">      for (unsigned O = S.beginOffset() + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4740</td>
    <td class="uncoveredLine">           O < S.endOffset() && O < AllocaSize; O++)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4741</td>
    <td class="uncoveredLine">        SplittableOffset.reset(O);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4742</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4743</td>
    <td class="uncoveredLine">    for (Slice &S : AS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4744</td>
    <td class="uncoveredLine">      if (!S.isSplittable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4745</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4746</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4747</td>
    <td class="uncoveredLine">      if ((S.beginOffset() > AllocaSize || SplittableOffset[S.beginOffset()]) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4748</td>
    <td class="uncoveredLine">          (S.endOffset() > AllocaSize || SplittableOffset[S.endOffset()]))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4749</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4750</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4751</td>
    <td class="uncoveredLine">      if (isa<LoadInst>(S.getUse()->getUser()) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4752</td>
    <td class="uncoveredLine">          isa<StoreInst>(S.getUse()->getUser())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4753</td>
    <td class="uncoveredLine">        S.makeUnsplittable();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4754</td>
    <td class="uncoveredLine">        IsSorted = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4755</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4756</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4757</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4758</td>
    <td class="">  else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4759</td>
    <td class="">    // We only allow whole-alloca splittable loads and stores</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4760</td>
    <td class="">    // for a large alloca to avoid creating too large BitVector.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4761</td>
    <td class="uncoveredLine">    for (Slice &S : AS) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4762</td>
    <td class="uncoveredLine">      if (!S.isSplittable())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4763</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4764</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4765</td>
    <td class="uncoveredLine">      if (S.beginOffset() == 0 && S.endOffset() >= AllocaSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4766</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4767</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4768</td>
    <td class="uncoveredLine">      if (isa<LoadInst>(S.getUse()->getUser()) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4769</td>
    <td class="uncoveredLine">          isa<StoreInst>(S.getUse()->getUser())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4770</td>
    <td class="uncoveredLine">        S.makeUnsplittable();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4771</td>
    <td class="uncoveredLine">        IsSorted = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4772</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4773</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4774</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4775</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4776</td>
    <td class="uncoveredLine">  if (!IsSorted)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4777</td>
    <td class="uncoveredLine">    llvm::sort(AS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4779</td>
    <td class="">  /// Describes the allocas introduced by rewritePartition in order to migrate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4780</td>
    <td class="">  /// the debug info.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4781</td>
    <td class="">  struct Fragment {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4782</td>
    <td class="">    AllocaInst *Alloca;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4783</td>
    <td class="">    uint64_t Offset;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4784</td>
    <td class="">    uint64_t Size;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4785</td>
    <td class="uncoveredLine">    Fragment(AllocaInst *AI, uint64_t O, uint64_t S)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4786</td>
    <td class="uncoveredLine">      : Alloca(AI), Offset(O), Size(S) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4787</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4788</td>
    <td class="uncoveredLine">  SmallVector<Fragment, 4> Fragments;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4789</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4790</td>
    <td class="">  // Rewrite each partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4791</td>
    <td class="uncoveredLine">  for (auto &P : AS.partitions()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4792</td>
    <td class="uncoveredLine">    if (AllocaInst *NewAI = rewritePartition(AI, AS, P)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4793</td>
    <td class="uncoveredLine">      Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4794</td>
    <td class="uncoveredLine">      if (NewAI != &AI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4795</td>
    <td class="uncoveredLine">        uint64_t SizeOfByte = 8;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4796</td>
    <td class="">        uint64_t AllocaSize =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4797</td>
    <td class="uncoveredLine">            DL.getTypeSizeInBits(NewAI->getAllocatedType()).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4798</td>
    <td class="">        // Don't include any padding.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4799</td>
    <td class="uncoveredLine">        uint64_t Size = std::min(AllocaSize, P.size() * SizeOfByte);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4800</td>
    <td class="uncoveredLine">        Fragments.push_back(Fragment(NewAI, P.beginOffset() * SizeOfByte, Size));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4801</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4802</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4803</td>
    <td class="uncoveredLine">    ++NumPartitions;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4804</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4805</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4806</td>
    <td class="uncoveredLine">  NumAllocaPartitions += NumPartitions;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4807</td>
    <td class="uncoveredLine">  MaxPartitionsPerAlloca.updateMax(NumPartitions);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4808</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4809</td>
    <td class="">  // Migrate debug information from the old alloca to the new alloca(s)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4810</td>
    <td class="">  // and the individual partitions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4811</td>
    <td class="uncoveredLine">  TinyPtrVector<DbgVariableIntrinsic *> DbgVariables;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4812</td>
    <td class="uncoveredLine">  for (auto *DbgDeclare : FindDbgDeclareUses(&AI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4813</td>
    <td class="uncoveredLine">    DbgVariables.push_back(DbgDeclare);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4814</td>
    <td class="uncoveredLine">  for (auto *DbgAssign : at::getAssignmentMarkers(&AI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4815</td>
    <td class="uncoveredLine">    DbgVariables.push_back(DbgAssign);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4816</td>
    <td class="uncoveredLine">  for (DbgVariableIntrinsic *DbgVariable : DbgVariables) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4817</td>
    <td class="uncoveredLine">    auto *Expr = DbgVariable->getExpression();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4818</td>
    <td class="uncoveredLine">    DIBuilder DIB(*AI.getModule(), /*AllowUnresolved*/ false);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4819</td>
    <td class="">    uint64_t AllocaSize =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4820</td>
    <td class="uncoveredLine">        DL.getTypeSizeInBits(AI.getAllocatedType()).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4821</td>
    <td class="uncoveredLine">    for (auto Fragment : Fragments) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4822</td>
    <td class="">      // Create a fragment expression describing the new partition or reuse AI's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4823</td>
    <td class="">      // expression if there is only one partition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4824</td>
    <td class="uncoveredLine">      auto *FragmentExpr = Expr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4825</td>
    <td class="uncoveredLine">      if (Fragment.Size < AllocaSize || Expr->isFragment()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4826</td>
    <td class="">        // If this alloca is already a scalar replacement of a larger aggregate,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4827</td>
    <td class="">        // Fragment.Offset describes the offset inside the scalar.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4828</td>
    <td class="uncoveredLine">        auto ExprFragment = Expr->getFragmentInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4829</td>
    <td class="uncoveredLine">        uint64_t Offset = ExprFragment ? ExprFragment->OffsetInBits : 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4830</td>
    <td class="uncoveredLine">        uint64_t Start = Offset + Fragment.Offset;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4831</td>
    <td class="uncoveredLine">        uint64_t Size = Fragment.Size;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4832</td>
    <td class="uncoveredLine">        if (ExprFragment) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4833</td>
    <td class="">          uint64_t AbsEnd =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4834</td>
    <td class="uncoveredLine">              ExprFragment->OffsetInBits + ExprFragment->SizeInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4835</td>
    <td class="uncoveredLine">          if (Start >= AbsEnd) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4836</td>
    <td class="">            // No need to describe a SROAed padding.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4837</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4838</td>
    <td class="">          }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4839</td>
    <td class="uncoveredLine">          Size = std::min(Size, AbsEnd - Start);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4840</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4841</td>
    <td class="">        // The new, smaller fragment is stenciled out from the old fragment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4842</td>
    <td class="uncoveredLine">        if (auto OrigFragment = FragmentExpr->getFragmentInfo()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4843</td>
    <td class="uncoveredLine">          assert(Start >= OrigFragment->OffsetInBits &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4844</td>
    <td class="">                 "new fragment is outside of original fragment");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4845</td>
    <td class="uncoveredLine">          Start -= OrigFragment->OffsetInBits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4846</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4847</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4848</td>
    <td class="">        // The alloca may be larger than the variable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4849</td>
    <td class="uncoveredLine">        auto VarSize = DbgVariable->getVariable()->getSizeInBits();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4850</td>
    <td class="uncoveredLine">        if (VarSize) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4851</td>
    <td class="uncoveredLine">          if (Size > *VarSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4852</td>
    <td class="uncoveredLine">            Size = *VarSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4853</td>
    <td class="uncoveredLine">          if (Size == 0 || Start + Size > *VarSize)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4854</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4855</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4856</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4857</td>
    <td class="">        // Avoid creating a fragment expression that covers the entire variable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4858</td>
    <td class="uncoveredLine">        if (!VarSize || *VarSize != Size) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4859</td>
    <td class="uncoveredLine">          if (auto E =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4860</td>
    <td class="uncoveredLine">                  DIExpression::createFragmentExpression(Expr, Start, Size))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4861</td>
    <td class="uncoveredLine">            FragmentExpr = *E;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4862</td>
    <td class="">          else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4863</td>
    <td class="uncoveredLine">            continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4864</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4865</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4866</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4867</td>
    <td class="">      // Remove any existing intrinsics on the new alloca describing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4868</td>
    <td class="">      // the variable fragment.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4869</td>
    <td class="uncoveredLine">      for (DbgDeclareInst *OldDII : FindDbgDeclareUses(Fragment.Alloca)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4870</td>
    <td class="uncoveredLine">        auto SameVariableFragment = [](const DbgVariableIntrinsic *LHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4871</td>
    <td class="">                                       const DbgVariableIntrinsic *RHS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4872</td>
    <td class="uncoveredLine">          return LHS->getVariable() == RHS->getVariable() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4873</td>
    <td class="uncoveredLine">                 LHS->getDebugLoc()->getInlinedAt() ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4874</td>
    <td class="uncoveredLine">                     RHS->getDebugLoc()->getInlinedAt();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4875</td>
    <td class="">        };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4876</td>
    <td class="uncoveredLine">        if (SameVariableFragment(OldDII, DbgVariable))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4877</td>
    <td class="uncoveredLine">          OldDII->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4878</td>
    <td class="uncoveredLine">      }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4879</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4880</td>
    <td class="uncoveredLine">      if (auto *DbgAssign = dyn_cast<DbgAssignIntrinsic>(DbgVariable)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4881</td>
    <td class="uncoveredLine">        if (!Fragment.Alloca->hasMetadata(LLVMContext::MD_DIAssignID)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4882</td>
    <td class="uncoveredLine">          Fragment.Alloca->setMetadata(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4883</td>
    <td class="">              LLVMContext::MD_DIAssignID,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4884</td>
    <td class="uncoveredLine">              DIAssignID::getDistinct(AI.getContext()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4885</td>
    <td class="">        }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4886</td>
    <td class="uncoveredLine">        auto *NewAssign = DIB.insertDbgAssign(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4887</td>
    <td class="uncoveredLine">            Fragment.Alloca, DbgAssign->getValue(), DbgAssign->getVariable(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4888</td>
    <td class="uncoveredLine">            FragmentExpr, Fragment.Alloca, DbgAssign->getAddressExpression(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4889</td>
    <td class="uncoveredLine">            DbgAssign->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4890</td>
    <td class="uncoveredLine">        NewAssign->setDebugLoc(DbgAssign->getDebugLoc());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4891</td>
    <td class="uncoveredLine">        LLVM_DEBUG(dbgs() << "Created new assign intrinsic: " << *NewAssign</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4892</td>
    <td class="">                          << "\n");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4893</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4894</td>
    <td class="uncoveredLine">        DIB.insertDeclare(Fragment.Alloca, DbgVariable->getVariable(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4895</td>
    <td class="uncoveredLine">                          FragmentExpr, DbgVariable->getDebugLoc(), &AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4896</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4897</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4898</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4899</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4900</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4901</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4902</td>
    <td class="">/// Clobber a use with poison, deleting the used value if it becomes dead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4903</td>
    <td class="uncoveredLine">void SROAPass::clobberUse(Use &U) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4904</td>
    <td class="uncoveredLine">  Value *OldV = U;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4905</td>
    <td class="">  // Replace the use with an poison value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4906</td>
    <td class="uncoveredLine">  U = PoisonValue::get(OldV->getType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4907</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4908</td>
    <td class="">  // Check for this making an instruction dead. We have to garbage collect</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4909</td>
    <td class="">  // all the dead instructions to ensure the uses of any alloca end up being</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4910</td>
    <td class="">  // minimal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4911</td>
    <td class="uncoveredLine">  if (Instruction *OldI = dyn_cast<Instruction>(OldV))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4912</td>
    <td class="uncoveredLine">    if (isInstructionTriviallyDead(OldI)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4913</td>
    <td class="uncoveredLine">      DeadInsts.push_back(OldI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4914</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4915</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4916</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4917</td>
    <td class="">/// Analyze an alloca for SROA.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4918</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4919</td>
    <td class="">/// This analyzes the alloca to ensure we can reason about it, builds</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4920</td>
    <td class="">/// the slices of the alloca, and then hands it off to be split and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4921</td>
    <td class="">/// rewritten as needed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4922</td>
    <td class="">std::pair<bool /*Changed*/, bool /*CFGChanged*/></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4923</td>
    <td class="uncoveredLine">SROAPass::runOnAlloca(AllocaInst &AI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4924</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4925</td>
    <td class="uncoveredLine">  bool CFGChanged = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4926</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4927</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "SROA alloca: " << AI << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4928</td>
    <td class="uncoveredLine">  ++NumAllocasAnalyzed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4929</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4930</td>
    <td class="">  // Special case dead allocas, as they're trivial.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4931</td>
    <td class="uncoveredLine">  if (AI.use_empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4932</td>
    <td class="uncoveredLine">    AI.eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4933</td>
    <td class="uncoveredLine">    Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4934</td>
    <td class="uncoveredLine">    return {Changed, CFGChanged};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4935</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4936</td>
    <td class="uncoveredLine">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4937</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4938</td>
    <td class="">  // Skip alloca forms that this analysis can't handle.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4939</td>
    <td class="uncoveredLine">  auto *AT = AI.getAllocatedType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4940</td>
    <td class="uncoveredLine">  TypeSize Size = DL.getTypeAllocSize(AT);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4941</td>
    <td class="uncoveredLine">  if (AI.isArrayAllocation() || !AT->isSized() || Size.isScalable() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4942</td>
    <td class="uncoveredLine">      Size.getFixedValue() == 0)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4943</td>
    <td class="uncoveredLine">    return {Changed, CFGChanged};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4944</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4945</td>
    <td class="">  // First, split any FCA loads and stores touching this alloca to promote</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4946</td>
    <td class="">  // better splitting and promotion opportunities.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4947</td>
    <td class="uncoveredLine">  IRBuilderTy IRB(&AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4948</td>
    <td class="uncoveredLine">  AggLoadStoreRewriter AggRewriter(DL, IRB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4949</td>
    <td class="uncoveredLine">  Changed |= AggRewriter.rewrite(AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4950</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4951</td>
    <td class="">  // Build the slices using a recursive instruction-visiting builder.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4952</td>
    <td class="uncoveredLine">  AllocaSlices AS(DL, AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4953</td>
    <td class="uncoveredLine">  LLVM_DEBUG(AS.print(dbgs()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4954</td>
    <td class="uncoveredLine">  if (AS.isEscaped())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4955</td>
    <td class="uncoveredLine">    return {Changed, CFGChanged};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4956</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4957</td>
    <td class="">  // Delete all the dead users of this alloca before splitting and rewriting it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4958</td>
    <td class="uncoveredLine">  for (Instruction *DeadUser : AS.getDeadUsers()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4959</td>
    <td class="">    // Free up everything used by this instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4960</td>
    <td class="uncoveredLine">    for (Use &DeadOp : DeadUser->operands())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4961</td>
    <td class="uncoveredLine">      clobberUse(DeadOp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4962</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4963</td>
    <td class="">    // Now replace the uses of this instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4964</td>
    <td class="uncoveredLine">    DeadUser->replaceAllUsesWith(PoisonValue::get(DeadUser->getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4965</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4966</td>
    <td class="">    // And mark it for deletion.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4967</td>
    <td class="uncoveredLine">    DeadInsts.push_back(DeadUser);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4968</td>
    <td class="uncoveredLine">    Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4969</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4970</td>
    <td class="uncoveredLine">  for (Use *DeadOp : AS.getDeadOperands()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4971</td>
    <td class="uncoveredLine">    clobberUse(*DeadOp);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4972</td>
    <td class="uncoveredLine">    Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4973</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4974</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4975</td>
    <td class="">  // No slices to split. Leave the dead alloca for a later pass to clean up.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4976</td>
    <td class="uncoveredLine">  if (AS.begin() == AS.end())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4977</td>
    <td class="uncoveredLine">    return {Changed, CFGChanged};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4978</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4979</td>
    <td class="uncoveredLine">  Changed |= splitAlloca(AI, AS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4980</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4981</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "  Speculating PHIs\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4982</td>
    <td class="uncoveredLine">  while (!SpeculatablePHIs.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4983</td>
    <td class="uncoveredLine">    speculatePHINodeLoads(IRB, *SpeculatablePHIs.pop_back_val());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4984</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4985</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "  Rewriting Selects\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4986</td>
    <td class="uncoveredLine">  auto RemainingSelectsToRewrite = SelectsToRewrite.takeVector();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4987</td>
    <td class="uncoveredLine">  while (!RemainingSelectsToRewrite.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4988</td>
    <td class="uncoveredLine">    const auto [K, V] = RemainingSelectsToRewrite.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4989</td>
    <td class="uncoveredLine">    CFGChanged |=</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4990</td>
    <td class="uncoveredLine">        rewriteSelectInstMemOps(*K, V, IRB, PreserveCFG ? nullptr : DTU);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4991</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4992</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4993</td>
    <td class="uncoveredLine">  return {Changed, CFGChanged};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4994</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4995</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4996</td>
    <td class="">/// Delete the dead instructions accumulated in this run.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4997</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4998</td>
    <td class="">/// Recursively deletes the dead instructions we've accumulated. This is done</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4999</td>
    <td class="">/// at the very end to maximize locality of the recursive delete and to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5000</td>
    <td class="">/// minimize the problems of invalidated instruction pointers as such pointers</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5001</td>
    <td class="">/// are used heavily in the intermediate stages of the algorithm.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5002</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5003</td>
    <td class="">/// We also record the alloca instructions deleted here so that they aren't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5004</td>
    <td class="">/// subsequently handed to mem2reg to promote.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5005</td>
    <td class="uncoveredLine">bool SROAPass::deleteDeadInstructions(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5006</td>
    <td class="">    SmallPtrSetImpl<AllocaInst *> &DeletedAllocas) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5007</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5008</td>
    <td class="uncoveredLine">  while (!DeadInsts.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5009</td>
    <td class="uncoveredLine">    Instruction *I = dyn_cast_or_null<Instruction>(DeadInsts.pop_back_val());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5010</td>
    <td class="uncoveredLine">    if (!I)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5011</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5012</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Deleting dead instruction: " << *I << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5013</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5014</td>
    <td class="">    // If the instruction is an alloca, find the possible dbg.declare connected</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5015</td>
    <td class="">    // to it, and remove it too. We must do this before calling RAUW or we will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5016</td>
    <td class="">    // not be able to find it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5017</td>
    <td class="uncoveredLine">    if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5018</td>
    <td class="uncoveredLine">      DeletedAllocas.insert(AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5019</td>
    <td class="uncoveredLine">      for (DbgDeclareInst *OldDII : FindDbgDeclareUses(AI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5020</td>
    <td class="uncoveredLine">        OldDII->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5021</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5022</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5023</td>
    <td class="uncoveredLine">    at::deleteAssignmentMarkers(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5024</td>
    <td class="uncoveredLine">    I->replaceAllUsesWith(UndefValue::get(I->getType()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5025</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5026</td>
    <td class="uncoveredLine">    for (Use &Operand : I->operands())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5027</td>
    <td class="uncoveredLine">      if (Instruction *U = dyn_cast<Instruction>(Operand)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5028</td>
    <td class="">        // Zero out the operand and see if it becomes trivially dead.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5029</td>
    <td class="uncoveredLine">        Operand = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5030</td>
    <td class="uncoveredLine">        if (isInstructionTriviallyDead(U))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5031</td>
    <td class="uncoveredLine">          DeadInsts.push_back(U);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5032</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5033</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5034</td>
    <td class="uncoveredLine">    ++NumDeleted;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5035</td>
    <td class="uncoveredLine">    I->eraseFromParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5036</td>
    <td class="uncoveredLine">    Changed = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5037</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5038</td>
    <td class="uncoveredLine">  return Changed;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5039</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5040</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5041</td>
    <td class="">/// Promote the allocas, using the best available technique.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5042</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5043</td>
    <td class="">/// This attempts to promote whatever allocas have been identified as viable in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5044</td>
    <td class="">/// the PromotableAllocas list. If that list is empty, there is nothing to do.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5045</td>
    <td class="">/// This function returns whether any promotion occurred.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5046</td>
    <td class="uncoveredLine">bool SROAPass::promoteAllocas(Function &F) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5047</td>
    <td class="uncoveredLine">  if (PromotableAllocas.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5048</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5049</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5050</td>
    <td class="uncoveredLine">  NumPromoted += PromotableAllocas.size();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5051</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5052</td>
    <td class="uncoveredLine">  if (SROASkipMem2Reg) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5053</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Not promoting allocas with mem2reg!\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5054</td>
    <td class="">  } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5055</td>
    <td class="uncoveredLine">    LLVM_DEBUG(dbgs() << "Promoting allocas with mem2reg...\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5056</td>
    <td class="uncoveredLine">    PromoteMemToReg(PromotableAllocas, DTU->getDomTree(), AC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5057</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5058</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5059</td>
    <td class="uncoveredLine">  PromotableAllocas.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5060</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5061</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5062</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5063</td>
    <td class="uncoveredLine">PreservedAnalyses SROAPass::runImpl(Function &F, DomTreeUpdater &RunDTU,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5064</td>
    <td class="">                                    AssumptionCache &RunAC) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5065</td>
    <td class="uncoveredLine">  LLVM_DEBUG(dbgs() << "SROA function: " << F.getName() << "\n");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5066</td>
    <td class="uncoveredLine">  C = &F.getContext();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5067</td>
    <td class="uncoveredLine">  DTU = &RunDTU;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5068</td>
    <td class="uncoveredLine">  AC = &RunAC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5069</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5070</td>
    <td class="uncoveredLine">  const DataLayout &DL = F.getParent()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5071</td>
    <td class="uncoveredLine">  BasicBlock &EntryBB = F.getEntryBlock();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5072</td>
    <td class="uncoveredLine">  for (BasicBlock::iterator I = EntryBB.begin(), E = std::prev(EntryBB.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5073</td>
    <td class="uncoveredLine">       I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5074</td>
    <td class="uncoveredLine">    if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5075</td>
    <td class="uncoveredLine">      if (DL.getTypeAllocSize(AI->getAllocatedType()).isScalable() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5076</td>
    <td class="uncoveredLine">          isAllocaPromotable(AI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5077</td>
    <td class="uncoveredLine">        PromotableAllocas.push_back(AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5078</td>
    <td class="">      else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5079</td>
    <td class="uncoveredLine">        Worklist.insert(AI);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5080</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5081</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5082</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5083</td>
    <td class="uncoveredLine">  bool Changed = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5084</td>
    <td class="uncoveredLine">  bool CFGChanged = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5085</td>
    <td class="">  // A set of deleted alloca instruction pointers which should be removed from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5086</td>
    <td class="">  // the list of promotable allocas.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5087</td>
    <td class="uncoveredLine">  SmallPtrSet<AllocaInst *, 4> DeletedAllocas;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5088</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5089</td>
    <td class="">  do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5090</td>
    <td class="uncoveredLine">    while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5091</td>
    <td class="uncoveredLine">      auto [IterationChanged, IterationCFGChanged] =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5092</td>
    <td class="uncoveredLine">          runOnAlloca(*Worklist.pop_back_val());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5093</td>
    <td class="uncoveredLine">      Changed |= IterationChanged;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5094</td>
    <td class="uncoveredLine">      CFGChanged |= IterationCFGChanged;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5095</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5096</td>
    <td class="uncoveredLine">      Changed |= deleteDeadInstructions(DeletedAllocas);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5097</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5098</td>
    <td class="">      // Remove the deleted allocas from various lists so that we don't try to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5099</td>
    <td class="">      // continue processing them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5100</td>
    <td class="uncoveredLine">      if (!DeletedAllocas.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5101</td>
    <td class="uncoveredLine">        auto IsInSet = [&](AllocaInst *AI) { return DeletedAllocas.count(AI); };</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5102</td>
    <td class="uncoveredLine">        Worklist.remove_if(IsInSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5103</td>
    <td class="uncoveredLine">        PostPromotionWorklist.remove_if(IsInSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5104</td>
    <td class="uncoveredLine">        llvm::erase_if(PromotableAllocas, IsInSet);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5105</td>
    <td class="uncoveredLine">        DeletedAllocas.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5106</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5107</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5108</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5109</td>
    <td class="uncoveredLine">    Changed |= promoteAllocas(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5110</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5111</td>
    <td class="uncoveredLine">    Worklist = PostPromotionWorklist;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5112</td>
    <td class="uncoveredLine">    PostPromotionWorklist.clear();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5113</td>
    <td class="uncoveredLine">  } while (!Worklist.empty());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5114</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5115</td>
    <td class="uncoveredLine">  assert((!CFGChanged || Changed) && "Can not only modify the CFG.");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5116</td>
    <td class="uncoveredLine">  assert((!CFGChanged || !PreserveCFG) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5117</td>
    <td class="">         "Should not have modified the CFG when told to preserve it.");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5118</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5119</td>
    <td class="uncoveredLine">  if (!Changed)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5120</td>
    <td class="uncoveredLine">    return PreservedAnalyses::all();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5121</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5122</td>
    <td class="uncoveredLine">  if (isAssignmentTrackingEnabled(*F.getParent())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5123</td>
    <td class="uncoveredLine">    for (auto &BB : F)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5124</td>
    <td class="uncoveredLine">      RemoveRedundantDbgInstrs(&BB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5125</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5126</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5127</td>
    <td class="uncoveredLine">  PreservedAnalyses PA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5128</td>
    <td class="uncoveredLine">  if (!CFGChanged)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5129</td>
    <td class="uncoveredLine">    PA.preserveSet<CFGAnalyses>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5130</td>
    <td class="uncoveredLine">  PA.preserve<DominatorTreeAnalysis>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5131</td>
    <td class="uncoveredLine">  return PA;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5132</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5133</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5134</td>
    <td class="uncoveredLine">PreservedAnalyses SROAPass::runImpl(Function &F, DominatorTree &RunDT,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5135</td>
    <td class="">                                    AssumptionCache &RunAC) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5136</td>
    <td class="uncoveredLine">  DomTreeUpdater DTU(RunDT, DomTreeUpdater::UpdateStrategy::Lazy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5137</td>
    <td class="uncoveredLine">  return runImpl(F, DTU, RunAC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5138</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5139</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5140</td>
    <td class="uncoveredLine">PreservedAnalyses SROAPass::run(Function &F, FunctionAnalysisManager &AM) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5141</td>
    <td class="uncoveredLine">  DominatorTree &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5142</td>
    <td class="uncoveredLine">  AssumptionCache &AC = AM.getResult<AssumptionAnalysis>(F);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5143</td>
    <td class="uncoveredLine">  return runImpl(F, DT, AC);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5144</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5146</td>
    <td class="uncoveredLine">void SROAPass::printPipeline(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5147</td>
    <td class="">    raw_ostream &OS, function_ref<StringRef(StringRef)> MapClassName2PassName) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5148</td>
    <td class="uncoveredLine">  static_cast<PassInfoMixin<SROAPass> *>(this)->printPipeline(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5149</td>
    <td class="">      OS, MapClassName2PassName);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5150</td>
    <td class="uncoveredLine">  OS << (PreserveCFG ? "<preserve-cfg>" : "<modify-cfg>");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5151</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5152</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5153</td>
    <td class="uncoveredLine">SROAPass::SROAPass(SROAOptions PreserveCFG_)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5154</td>
    <td class="uncoveredLine">    : PreserveCFG(PreserveCFG_ == SROAOptions::PreserveCFG) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5155</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5156</td>
    <td class="">/// A legacy pass for the legacy pass manager that wraps the \c SROA pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5157</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5158</td>
    <td class="">/// This is in the llvm namespace purely to allow it to be a friend of the \c</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5159</td>
    <td class="">/// SROA pass.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5160</td>
    <td class="">class llvm::sroa::SROALegacyPass : public FunctionPass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5161</td>
    <td class="">  /// The SROA implementation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5162</td>
    <td class="">  SROAPass Impl;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5163</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5164</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5165</td>
    <td class="">  static char ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5166</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5167</td>
    <td class="uncoveredLine">  SROALegacyPass(SROAOptions PreserveCFG = SROAOptions::PreserveCFG)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5168</td>
    <td class="uncoveredLine">      : FunctionPass(ID), Impl(PreserveCFG) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5169</td>
    <td class="uncoveredLine">    initializeSROALegacyPassPass(*PassRegistry::getPassRegistry());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5170</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5171</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5172</td>
    <td class="uncoveredLine">  bool runOnFunction(Function &F) override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5173</td>
    <td class="uncoveredLine">    if (skipFunction(F))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5174</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5176</td>
    <td class="">    auto PA = Impl.runImpl(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5177</td>
    <td class="uncoveredLine">        F, getAnalysis<DominatorTreeWrapperPass>().getDomTree(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5178</td>
    <td class="uncoveredLine">        getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5179</td>
    <td class="uncoveredLine">    return !PA.areAllPreserved();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5180</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5182</td>
    <td class="uncoveredLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5183</td>
    <td class="uncoveredLine">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5184</td>
    <td class="uncoveredLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5185</td>
    <td class="uncoveredLine">    AU.addPreserved<GlobalsAAWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5186</td>
    <td class="uncoveredLine">    AU.addPreserved<DominatorTreeWrapperPass>();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5187</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5188</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5189</td>
    <td class="uncoveredLine">  StringRef getPassName() const override { return "SROA"; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5190</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5191</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5192</td>
    <td class="">char SROALegacyPass::ID = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5193</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5194</td>
    <td class="uncoveredLine">FunctionPass *llvm::createSROAPass(bool PreserveCFG) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5195</td>
    <td class="">  return new SROALegacyPass(PreserveCFG ? SROAOptions::PreserveCFG</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5196</td>
    <td class="uncoveredLine">                                        : SROAOptions::ModifyCFG);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5197</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5199</td>
    <td class="coveredLine">INITIALIZE_PASS_BEGIN(SROALegacyPass, "sroa",</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5200</td>
    <td class="">                      "Scalar Replacement Of Aggregates", false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5201</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5202</td>
    <td class="coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5203</td>
    <td class="coveredLine">INITIALIZE_PASS_END(SROALegacyPass, "sroa", "Scalar Replacement Of Aggregates",</td>
    <td>4</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5204</td>
    <td class="">                    false, false)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5205</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_1L17calculateFragmentEPN4llvm15DILocalVariableEmmSt8optionalINS0_12DIExpression12FragmentInfoEES6_RS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_1L20getAggregateVariableEPN4llvm20DbgVariableIntrinsicE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_1L16migrateDebugInfoEPN4llvm10AllocaInstEbmmPNS0_11InstructionES4_PNS0_5ValueES6_RKNS0_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_125IRBuilderPrefixedInserter17getNameWithPrefixERKN4llvm5TwineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_125IRBuilderPrefixedInserter13SetNamePrefixERKN4llvm5TwineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_125IRBuilderPrefixedInserter12InsertHelperEPN4llvm11InstructionERKNS1_5TwineEPNS1_10BasicBlockENS1_14ilist_iteratorINS1_12ilist_detail12node_optionsIS2_Lb1ELb0EvEELb0ELb0EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_15SliceC2EmmPN4llvm3UseEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_15Slice11beginOffsetEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_15Slice9endOffsetEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_15Slice12isSplittableEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_15Slice16makeUnsplittableEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_15Slice6getUseEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_15Slice6isDeadEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_15Slice4killEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK12_GLOBAL__N_15SliceltERKS0_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa12AllocaSlices9isEscapedEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa12AllocaSlices5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa12AllocaSlices3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices5eraseEPN12_GLOBAL__N_15SliceES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices6insertENS_8ArrayRefIN12_GLOBAL__N_15SliceEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa12AllocaSlices12getDeadUsersEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa12AllocaSlices23getDeadUsesIfPromotableEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa12AllocaSlices15getDeadOperandsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa9PartitionC2EPN12_GLOBAL__N_15SliceE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa9Partition11beginOffsetEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa9Partition9endOffsetEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa9Partition4sizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa9Partition5emptyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa9Partition5beginEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa9Partition3endEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa9Partition15splitSliceTailsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices18partition_iteratorC2EPN12_GLOBAL__N_15SliceES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices18partition_iterator7advanceEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm4sroa12AllocaSlices18partition_iterator7advanceEvENKUlPN12_GLOBAL__N_15SliceEE_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm4sroa12AllocaSlices18partition_iterator7advanceEvENKUlPN12_GLOBAL__N_15SliceEE0_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm4sroa12AllocaSlices18partition_iterator7advanceEvENKUlPN12_GLOBAL__N_15SliceEE1_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa12AllocaSlices18partition_iteratoreqERKS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices18partition_iteratorppEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices18partition_iteratordeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices10partitionsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL14foldSelectInstRN4llvm10SelectInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL23foldPHINodeOrSelectInstRN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilderC2ERKNS_10DataLayoutERNS_10AllocaInstERS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder10markAsDeadERNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder9insertUseERNS_11InstructionERKNS_5APIntEmb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder16visitBitCastInstERNS_11BitCastInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder22visitAddrSpaceCastInstERNS_17AddrSpaceCastInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder22visitGetElementPtrInstERNS_17GetElementPtrInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder17handleLoadOrStoreEPNS_4TypeERNS_11InstructionERKNS_5APIntEmb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder13visitLoadInstERNS_8LoadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder14visitStoreInstERNS_9StoreInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder15visitMemSetInstERNS_10MemSetInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder20visitMemTransferInstERNS_15MemTransferInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder18visitIntrinsicInstERNS_13IntrinsicInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder23hasUnsafePHIOrSelectUseEPNS_11InstructionERm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder24visitPHINodeOrSelectInstERNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder12visitPHINodeERNS_7PHINodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder15visitSelectInstERNS_10SelectInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlices12SliceBuilder16visitInstructionERNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa12AllocaSlicesC2ERKNS_10DataLayoutERNS_10AllocaInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm4sroa12AllocaSlicesC4ERKNS_10DataLayoutERNS_10AllocaInstEENKUlRKN12_GLOBAL__N_15SliceEE_clESA_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa12AllocaSlices5printERNS_11raw_ostreamEPKN12_GLOBAL__N_15SliceENS_9StringRefE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa12AllocaSlices10printSliceERNS_11raw_ostreamEPKN12_GLOBAL__N_15SliceENS_9StringRefE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa12AllocaSlices8printUseERNS_11raw_ostreamEPKN12_GLOBAL__N_15SliceENS_9StringRefE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa12AllocaSlices5printERNS_11raw_ostreamE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa12AllocaSlices4dumpEPKN12_GLOBAL__N_15SliceE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa12AllocaSlices4dumpEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL14findCommonTypePKN12_GLOBAL__N_15SliceES2_m</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL20isSafePHIToSpeculateRN4llvm7PHINodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL21speculatePHINodeLoadsRN4llvm9IRBuilderINS_14ConstantFolderEN12_GLOBAL__N_125IRBuilderPrefixedInserterEEERNS_7PHINodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa23SelectHandSpeculativity17setAsSpeculatableEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa23SelectHandSpeculativity14isSpeculatableEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa23SelectHandSpeculativity18areAllSpeculatableEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa23SelectHandSpeculativity18areAnySpeculatableEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa23SelectHandSpeculativity19areNoneSpeculatableEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL29isSafeLoadOfSelectToSpeculateRN4llvm8LoadInstERNS_10SelectInstEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8SROAPass23isSafeSelectToSpeculateERNS_10SelectInstEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL24speculateSelectInstLoadsRN4llvm10SelectInstERNS_8LoadInstERNS_9IRBuilderINS_14ConstantFolderEN12_GLOBAL__N_125IRBuilderPrefixedInserterEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_Z20rewriteMemOpOfSelectIN4llvm9StoreInstEEvRNS0_10SelectInstERT_NS0_4sroa23SelectHandSpeculativityERNS0_14DomTreeUpdaterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_Z20rewriteMemOpOfSelectIN4llvm8LoadInstEEvRNS0_10SelectInstERT_NS0_4sroa23SelectHandSpeculativityERNS0_14DomTreeUpdaterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL20rewriteMemOpOfSelectRN4llvm10SelectInstERNS_11InstructionENS_4sroa23SelectHandSpeculativityERNS_14DomTreeUpdaterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL23rewriteSelectInstMemOpsRN4llvm10SelectInstERKNS_11SmallVectorISt7variantIJNS_14PointerIntPairIPNS_8LoadInstELj2ENS_4sroa23SelectHandSpeculativityENS_21PointerLikeTypeTraitsIS6_EENS_18PointerIntPairInfoIS6_Lj2ESA_EEEEPNS_9StoreInstEEELj2EEERNS_9IRBuilderINS_14ConstantFolderEN12_GLOBAL__N_125IRBuilderPrefixedInserterEEEPNS_14DomTreeUpdaterE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL14getAdjustedPtrRN4llvm9IRBuilderINS_14ConstantFolderEN12_GLOBAL__N_125IRBuilderPrefixedInserterEEERKNS_10DataLayoutEPNS_5ValueENS_5APIntEPNS_4TypeERKNS_5TwineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL20getAdjustedAlignmentPN4llvm11InstructionEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL15canConvertValueRKN4llvm10DataLayoutEPNS_4TypeES4_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL12convertValueRKN4llvm10DataLayoutERNS_9IRBuilderINS_14ConstantFolderEN12_GLOBAL__N_125IRBuilderPrefixedInserterEEEPNS_5ValueEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL31isVectorPromotionViableForSliceRN4llvm4sroa9PartitionERKN12_GLOBAL__N_15SliceEPNS_10VectorTypeEmRKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL27checkVectorTypeForPromotionRN4llvm4sroa9PartitionEPNS_10VectorTypeERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL23isVectorPromotionViableRN4llvm4sroa9PartitionERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZL23isVectorPromotionViableRN4llvm4sroa9PartitionERKNS_10DataLayoutEENKUlPNS_4TypeEE_clES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZL23isVectorPromotionViableRN4llvm4sroa9PartitionERKNS_10DataLayoutEENKUlPNS_10VectorTypeES7_E0_clES7_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZL23isVectorPromotionViableRN4llvm4sroa9PartitionERKNS_10DataLayoutEENKUlPNS_10VectorTypeES7_E1_clES7_S7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZL23isVectorPromotionViableRN4llvm4sroa9PartitionERKNS_10DataLayoutEENKUlPNS_10VectorTypeEE2_clES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL31isIntegerWideningViableForSliceRKN12_GLOBAL__N_15SliceEmPN4llvm4TypeERKNS3_10DataLayoutERb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL23isIntegerWideningViableRN4llvm4sroa9PartitionEPNS_4TypeERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL14extractIntegerRKN4llvm10DataLayoutERNS_9IRBuilderINS_14ConstantFolderEN12_GLOBAL__N_125IRBuilderPrefixedInserterEEEPNS_5ValueEPNS_11IntegerTypeEmRKNS_5TwineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL13insertIntegerRKN4llvm10DataLayoutERNS_9IRBuilderINS_14ConstantFolderEN12_GLOBAL__N_125IRBuilderPrefixedInserterEEEPNS_5ValueESA_mRKNS_5TwineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL13extractVectorRN4llvm9IRBuilderINS_14ConstantFolderEN12_GLOBAL__N_125IRBuilderPrefixedInserterEEEPNS_5ValueEjjRKNS_5TwineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL12insertVectorRN4llvm9IRBuilderINS_14ConstantFolderEN12_GLOBAL__N_125IRBuilderPrefixedInserterEEEPNS_5ValueES7_jRKNS_5TwineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter13getPtrToNewAIEjb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriterC2ERKNS_10DataLayoutERNS0_12AllocaSlicesERNS_8SROAPassERNS_10AllocaInstESA_mmbPNS_10VectorTypeERNS_14SmallSetVectorIPNS_7PHINodeELj8EEERNSD_IPNS_10SelectInstELj8EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter5visitEPKN12_GLOBAL__N_15SliceE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter16visitInstructionERNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter20getNewAllocaSlicePtrERNS_9IRBuilderINS_14ConstantFolderEN12_GLOBAL__N_125IRBuilderPrefixedInserterEEEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter13getSliceAlignEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter8getIndexEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter21deleteIfTriviallyDeadEPNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter25rewriteVectorizedLoadInstERNS_8LoadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter18rewriteIntegerLoadERNS_8LoadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter13visitLoadInstERNS_8LoadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter26rewriteVectorizedStoreInstEPNS_5ValueERNS_9StoreInstES3_NS_9AAMDNodesE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter19rewriteIntegerStoreEPNS_5ValueERNS_9StoreInstENS_9AAMDNodesE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter14visitStoreInstERNS_9StoreInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter15getIntegerSplatEPNS_5ValueEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter14getVectorSplatEPNS_5ValueEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter15visitMemSetInstERNS_10MemSetInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm4sroa19AllocaSliceRewriter15visitMemSetInstERNS_10MemSetInstEENKUlvE_clEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter20visitMemTransferInstERNS_15MemTransferInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm4sroa19AllocaSliceRewriter20visitMemTransferInstERNS_15MemTransferInstEENKUlPNS_5ValueEE_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter18visitIntrinsicInstERNS_13IntrinsicInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter17fixLoadStoreAlignERNS_11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter12visitPHINodeERNS_7PHINodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa19AllocaSliceRewriter15visitSelectInstERNS_10SelectInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriterC2ERKN4llvm10DataLayoutERNS1_9IRBuilderINS1_14ConstantFolderENS_25IRBuilderPrefixedInserterEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter7rewriteERN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter12enqueueUsersERN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter16visitInstructionERN4llvm11InstructionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter10OpSplitterINS0_15StoreOpSplitterEEC2EPN4llvm11InstructionEPNS4_5ValueEPNS4_4TypeENS4_5AlignERKNS4_10DataLayoutERNS4_9IRBuilderINS4_14ConstantFolderENS_25IRBuilderPrefixedInserterEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter10OpSplitterINS0_14LoadOpSplitterEEC2EPN4llvm11InstructionEPNS4_5ValueEPNS4_4TypeENS4_5AlignERKNS4_10DataLayoutERNS4_9IRBuilderINS4_14ConstantFolderENS_25IRBuilderPrefixedInserterEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter10OpSplitterINS0_15StoreOpSplitterEE12emitSplitOpsEPN4llvm4TypeERPNS4_5ValueERKNS4_5TwineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter10OpSplitterINS0_14LoadOpSplitterEE12emitSplitOpsEPN4llvm4TypeERPNS4_5ValueERKNS4_5TwineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter14LoadOpSplitterC2EPN4llvm11InstructionEPNS2_5ValueEPNS2_4TypeENS2_9AAMDNodesENS2_5AlignERKNS2_10DataLayoutERNS2_9IRBuilderINS2_14ConstantFolderENS_25IRBuilderPrefixedInserterEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter14LoadOpSplitter8emitFuncEPN4llvm4TypeERPNS2_5ValueENS2_5AlignERKNS2_5TwineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter13visitLoadInstERN4llvm8LoadInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter15StoreOpSplitterC2EPN4llvm11InstructionEPNS2_5ValueEPNS2_4TypeENS2_9AAMDNodesEPNS2_9StoreInstENS2_5AlignERKNS2_10DataLayoutERNS2_9IRBuilderINS2_14ConstantFolderENS_25IRBuilderPrefixedInserterEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter15StoreOpSplitter8emitFuncEPN4llvm4TypeERPNS2_5ValueENS2_5AlignERKNS2_5TwineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter14visitStoreInstERN4llvm9StoreInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter16visitBitCastInstERN4llvm11BitCastInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter22visitAddrSpaceCastInstERN4llvm17AddrSpaceCastInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter13foldGEPSelectERN4llvm17GetElementPtrInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter10foldGEPPhiERN4llvm17GetElementPtrInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN12_GLOBAL__N_120AggLoadStoreRewriter10foldGEPPhiERN4llvm17GetElementPtrInstEENKUlPNS1_5ValueEE_clES5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter22visitGetElementPtrInstERN4llvm17GetElementPtrInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter12visitPHINodeERN4llvm7PHINodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN12_GLOBAL__N_120AggLoadStoreRewriter15visitSelectInstERN4llvm10SelectInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL26stripAggregateTypeWrappingRKN4llvm10DataLayoutEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL16getTypePartitionRKN4llvm10DataLayoutEPNS_4TypeEmm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8SROAPass22presplitLoadsAndStoresERNS_10AllocaInstERNS_4sroa12AllocaSlicesE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8SROAPass22presplitLoadsAndStoresERNS_10AllocaInstERNS_4sroa12AllocaSlicesEENKUlPNS_8LoadInstEE_clES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8SROAPass22presplitLoadsAndStoresERNS_10AllocaInstERNS_4sroa12AllocaSlicesEENKUlPNS_9StoreInstEE0_clES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8SROAPass22presplitLoadsAndStoresERNS_10AllocaInstERNS_4sroa12AllocaSlicesEENKUlPNS_9StoreInstEE1_clES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8SROAPass22presplitLoadsAndStoresERNS_10AllocaInstERNS_4sroa12AllocaSlicesEENKUlPNS_8LoadInstEE2_clES7_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8SROAPass22presplitLoadsAndStoresERNS_10AllocaInstERNS_4sroa12AllocaSlicesEENKUlRKN12_GLOBAL__N_15SliceEE3_clES9_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8SROAPass22presplitLoadsAndStoresERNS_10AllocaInstERNS_4sroa12AllocaSlicesEENKUlPS1_E4_clES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8SROAPass16rewritePartitionERNS_10AllocaInstERNS_4sroa12AllocaSlicesERNS3_9PartitionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8SROAPass11splitAllocaERNS_10AllocaInstERNS_4sroa12AllocaSlicesE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8SROAPass11splitAllocaERNS_10AllocaInstERNS_4sroa12AllocaSlicesEEN8FragmentC2EPS1_mm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8SROAPass11splitAllocaERNS_10AllocaInstERNS_4sroa12AllocaSlicesEENKUlPKNS_20DbgVariableIntrinsicES8_E_clES8_S8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8SROAPass10clobberUseERNS_3UseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8SROAPass11runOnAllocaERNS_10AllocaInstE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8SROAPass22deleteDeadInstructionsERNS_15SmallPtrSetImplIPNS_10AllocaInstEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8SROAPass14promoteAllocasERNS_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8SROAPass7runImplERNS_8FunctionERNS_14DomTreeUpdaterERNS_15AssumptionCacheE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZZN4llvm8SROAPass7runImplERNS_8FunctionERNS_14DomTreeUpdaterERNS_15AssumptionCacheEENKUlPNS_10AllocaInstEE_clES8_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8SROAPass7runImplERNS_8FunctionERNS_13DominatorTreeERNS_15AssumptionCacheE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8SROAPass3runERNS_8FunctionERNS_15AnalysisManagerIS1_JEEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8SROAPass13printPipelineERNS_11raw_ostreamENS_12function_refIFNS_9StringRefES4_EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm8SROAPassC2ENS_11SROAOptionsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa14SROALegacyPassC2ENS_11SROAOptionsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4sroa14SROALegacyPass13runOnFunctionERNS_8FunctionE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa14SROALegacyPass16getAnalysisUsageERNS_13AnalysisUsageE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4sroa14SROALegacyPass11getPassNameEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm14createSROAPassEb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL32initializeSROALegacyPassPassOnceRN4llvm12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm28initializeSROALegacyPassPassERNS_12PassRegistryE</td>
    <td class="numberOfCalls">2</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- SROA.cpp - Scalar Replacement Of Aggregates ------------------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- SROA.cpp - Scalar Replacement Of Aggregates ------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">/// \file</td>
    <td class="lineNumber">8</td>
    <td class="codeline">/// \file</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">/// This transformation implements the well known scalar replacement of</td>
    <td class="lineNumber">9</td>
    <td class="codeline">/// This transformation implements the well known scalar replacement of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">/// aggregates transformation. It tries to identify promotable elements of an</td>
    <td class="lineNumber">10</td>
    <td class="codeline">/// aggregates transformation. It tries to identify promotable elements of an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">/// aggregate alloca, and promote them to registers. It will also try to</td>
    <td class="lineNumber">11</td>
    <td class="codeline">/// aggregate alloca, and promote them to registers. It will also try to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">/// convert uses of an element (or set of elements) of an alloca into a vector</td>
    <td class="lineNumber">12</td>
    <td class="codeline">/// convert uses of an element (or set of elements) of an alloca into a vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">/// or bitfield-style integer scalar if appropriate.</td>
    <td class="lineNumber">13</td>
    <td class="codeline">/// or bitfield-style integer scalar if appropriate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">///</td>
    <td class="lineNumber">14</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">/// It works to do this with minimal slicing of the alloca so that regions</td>
    <td class="lineNumber">15</td>
    <td class="codeline">/// It works to do this with minimal slicing of the alloca so that regions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">/// which are merely transferred in and out of external memory remain unchanged</td>
    <td class="lineNumber">16</td>
    <td class="codeline">/// which are merely transferred in and out of external memory remain unchanged</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">/// and are not decomposed to scalar code.</td>
    <td class="lineNumber">17</td>
    <td class="codeline">/// and are not decomposed to scalar code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">///</td>
    <td class="lineNumber">18</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">/// Because this also performs alloca promotion, it can be thought of as also</td>
    <td class="lineNumber">19</td>
    <td class="codeline">/// Because this also performs alloca promotion, it can be thought of as also</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">/// serving the purpose of SSA formation. The algorithm iterates on the</td>
    <td class="lineNumber">20</td>
    <td class="codeline">/// serving the purpose of SSA formation. The algorithm iterates on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">/// function until all opportunities for promotion have been realized.</td>
    <td class="lineNumber">21</td>
    <td class="codeline">/// function until all opportunities for promotion have been realized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">///</td>
    <td class="lineNumber">22</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">23</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline"></td>
    <td class="lineNumber">24</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Transforms/Scalar/SROA.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Transforms/Scalar/SROA.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/ADT/PointerIntPair.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/ADT/PointerIntPair.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/ADT/STLExtras.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/ADT/SetVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/ADT/SmallBitVector.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/ADT/SmallBitVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/ADT/Statistic.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/ADT/StringRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/ADT/Twine.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/ADT/Twine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/ADT/iterator.h"</td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/ADT/iterator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include "llvm/ADT/iterator_range.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include "llvm/Analysis/AssumptionCache.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/Analysis/DomTreeUpdater.h"</td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include "llvm/Analysis/DomTreeUpdater.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/Analysis/GlobalsModRef.h"</td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include "llvm/Analysis/GlobalsModRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/Analysis/Loads.h"</td>
    <td class="lineNumber">43</td>
    <td class="codeline">#include "llvm/Analysis/Loads.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/Analysis/PtrUseVisitor.h"</td>
    <td class="lineNumber">44</td>
    <td class="codeline">#include "llvm/Analysis/PtrUseVisitor.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">45</td>
    <td class="codeline">#include "llvm/Config/llvm-config.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">46</td>
    <td class="codeline">#include "llvm/IR/BasicBlock.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">47</td>
    <td class="codeline">#include "llvm/IR/Constant.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/IR/ConstantFolder.h"</td>
    <td class="lineNumber">48</td>
    <td class="codeline">#include "llvm/IR/ConstantFolder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">49</td>
    <td class="codeline">#include "llvm/IR/Constants.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/IR/DIBuilder.h"</td>
    <td class="lineNumber">50</td>
    <td class="codeline">#include "llvm/IR/DIBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">51</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/IR/DebugInfo.h"</td>
    <td class="lineNumber">52</td>
    <td class="codeline">#include "llvm/IR/DebugInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/IR/DebugInfoMetadata.h"</td>
    <td class="lineNumber">53</td>
    <td class="codeline">#include "llvm/IR/DebugInfoMetadata.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">54</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">55</td>
    <td class="codeline">#include "llvm/IR/Dominators.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">56</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
    <td class="lineNumber">57</td>
    <td class="codeline">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">#include "llvm/IR/GlobalAlias.h"</td>
    <td class="lineNumber">58</td>
    <td class="codeline">#include "llvm/IR/GlobalAlias.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">59</td>
    <td class="codeline">#include "llvm/IR/IRBuilder.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">#include "llvm/IR/InstVisitor.h"</td>
    <td class="lineNumber">60</td>
    <td class="codeline">#include "llvm/IR/InstVisitor.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">61</td>
    <td class="codeline">#include "llvm/IR/Instruction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">62</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">63</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">64</td>
    <td class="codeline">#include "llvm/IR/LLVMContext.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">#include "llvm/IR/Metadata.h"</td>
    <td class="lineNumber">65</td>
    <td class="codeline">#include "llvm/IR/Metadata.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">66</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">67</td>
    <td class="codeline">#include "llvm/IR/Operator.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">68</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">69</td>
    <td class="codeline">#include "llvm/IR/Type.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">#include "llvm/IR/Use.h"</td>
    <td class="lineNumber">70</td>
    <td class="codeline">#include "llvm/IR/Use.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline">#include "llvm/IR/User.h"</td>
    <td class="lineNumber">71</td>
    <td class="codeline">#include "llvm/IR/User.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">72</td>
    <td class="codeline">#include "llvm/IR/Value.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">73</td>
    <td class="codeline">#include "llvm/InitializePasses.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">74</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">75</td>
    <td class="codeline">#include "llvm/Support/Casting.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">76</td>
    <td class="codeline">#include "llvm/Support/CommandLine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">77</td>
    <td class="codeline">#include "llvm/Support/Compiler.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">78</td>
    <td class="codeline">#include "llvm/Support/Debug.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">79</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">80</td>
    <td class="codeline">#include "llvm/Support/raw_ostream.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">#include "llvm/Transforms/Scalar.h"</td>
    <td class="lineNumber">81</td>
    <td class="codeline">#include "llvm/Transforms/Scalar.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">82</td>
    <td class="codeline">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">83</td>
    <td class="codeline">#include "llvm/Transforms/Utils/Local.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">#include "llvm/Transforms/Utils/PromoteMemToReg.h"</td>
    <td class="lineNumber">84</td>
    <td class="codeline">#include "llvm/Transforms/Utils/PromoteMemToReg.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">#include <algorithm></td>
    <td class="lineNumber">85</td>
    <td class="codeline">#include <algorithm></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">86</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">#include <cstddef></td>
    <td class="lineNumber">87</td>
    <td class="codeline">#include <cstddef></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">88</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">#include <cstring></td>
    <td class="lineNumber">89</td>
    <td class="codeline">#include <cstring></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">#include <iterator></td>
    <td class="lineNumber">90</td>
    <td class="codeline">#include <iterator></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">#include <string></td>
    <td class="lineNumber">91</td>
    <td class="codeline">#include <string></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">#include <tuple></td>
    <td class="lineNumber">92</td>
    <td class="codeline">#include <tuple></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">93</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">#include <vector></td>
    <td class="lineNumber">94</td>
    <td class="codeline">#include <vector></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline"></td>
    <td class="lineNumber">95</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">96</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">using namespace llvm::sroa;</td>
    <td class="lineNumber">97</td>
    <td class="codeline">using namespace llvm::sroa;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline"></td>
    <td class="lineNumber">98</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">#define DEBUG_TYPE "sroa"</td>
    <td class="lineNumber">99</td>
    <td class="codeline">#define DEBUG_TYPE "sroa"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline"></td>
    <td class="lineNumber">100</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">STATISTIC(NumAllocasAnalyzed, "Number of allocas analyzed for replacement");</td>
    <td class="lineNumber">101</td>
    <td class="codeline">STATISTIC(NumAllocasAnalyzed, "Number of allocas analyzed for replacement");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">STATISTIC(NumAllocaPartitions, "Number of alloca partitions formed");</td>
    <td class="lineNumber">102</td>
    <td class="codeline">STATISTIC(NumAllocaPartitions, "Number of alloca partitions formed");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">STATISTIC(MaxPartitionsPerAlloca, "Maximum number of partitions per alloca");</td>
    <td class="lineNumber">103</td>
    <td class="codeline">STATISTIC(MaxPartitionsPerAlloca, "Maximum number of partitions per alloca");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">STATISTIC(NumAllocaPartitionUses, "Number of alloca partition uses rewritten");</td>
    <td class="lineNumber">104</td>
    <td class="codeline">STATISTIC(NumAllocaPartitionUses, "Number of alloca partition uses rewritten");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">STATISTIC(MaxUsesPerAllocaPartition, "Maximum number of uses of a partition");</td>
    <td class="lineNumber">105</td>
    <td class="codeline">STATISTIC(MaxUsesPerAllocaPartition, "Maximum number of uses of a partition");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">STATISTIC(NumNewAllocas, "Number of new, smaller allocas introduced");</td>
    <td class="lineNumber">106</td>
    <td class="codeline">STATISTIC(NumNewAllocas, "Number of new, smaller allocas introduced");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">STATISTIC(NumPromoted, "Number of allocas promoted to SSA values");</td>
    <td class="lineNumber">107</td>
    <td class="codeline">STATISTIC(NumPromoted, "Number of allocas promoted to SSA values");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">STATISTIC(NumLoadsSpeculated, "Number of loads speculated to allow promotion");</td>
    <td class="lineNumber">108</td>
    <td class="codeline">STATISTIC(NumLoadsSpeculated, "Number of loads speculated to allow promotion");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">STATISTIC(NumLoadsPredicated,</td>
    <td class="lineNumber">109</td>
    <td class="codeline">STATISTIC(NumLoadsPredicated,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">          "Number of loads rewritten into predicated loads to allow promotion");</td>
    <td class="lineNumber">110</td>
    <td class="codeline">          "Number of loads rewritten into predicated loads to allow promotion");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">STATISTIC(</td>
    <td class="lineNumber">111</td>
    <td class="codeline">STATISTIC(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">    NumStoresPredicated,</td>
    <td class="lineNumber">112</td>
    <td class="codeline">    NumStoresPredicated,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">    "Number of stores rewritten into predicated loads to allow promotion");</td>
    <td class="lineNumber">113</td>
    <td class="codeline">    "Number of stores rewritten into predicated loads to allow promotion");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">STATISTIC(NumDeleted, "Number of instructions deleted");</td>
    <td class="lineNumber">114</td>
    <td class="codeline">STATISTIC(NumDeleted, "Number of instructions deleted");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">STATISTIC(NumVectorized, "Number of vectorized aggregates");</td>
    <td class="lineNumber">115</td>
    <td class="codeline">STATISTIC(NumVectorized, "Number of vectorized aggregates");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
    <td class="lineNumber">116</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">/// Hidden option to experiment with completely strict handling of inbounds</td>
    <td class="lineNumber">117</td>
    <td class="codeline">/// Hidden option to experiment with completely strict handling of inbounds</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">/// GEPs.</td>
    <td class="lineNumber">118</td>
    <td class="codeline">/// GEPs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">static cl::opt<bool> SROAStrictInbounds("sroa-strict-inbounds", cl::init(false),</td>
    <td class="lineNumber">119</td>
    <td class="codeline">static cl::opt<bool> SROAStrictInbounds("sroa-strict-inbounds", cl::init(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">                                        cl::Hidden);</td>
    <td class="lineNumber">120</td>
    <td class="codeline">                                        cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">/// Disable running mem2reg during SROA in order to test or debug SROA.</td>
    <td class="lineNumber">121</td>
    <td class="codeline">/// Disable running mem2reg during SROA in order to test or debug SROA.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">static cl::opt<bool> SROASkipMem2Reg("sroa-skip-mem2reg", cl::init(false),</td>
    <td class="lineNumber">122</td>
    <td class="codeline">static cl::opt<bool> SROASkipMem2Reg("sroa-skip-mem2reg", cl::init(false),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">                                     cl::Hidden);</td>
    <td class="lineNumber">123</td>
    <td class="codeline">                                     cl::Hidden);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">124</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
    <td class="lineNumber">125</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">/// Calculate the fragment of a variable to use when slicing a store</td>
    <td class="lineNumber">126</td>
    <td class="codeline">/// Calculate the fragment of a variable to use when slicing a store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">/// based on the slice dimensions, existing fragment, and base storage</td>
    <td class="lineNumber">127</td>
    <td class="codeline">/// based on the slice dimensions, existing fragment, and base storage</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">/// fragment.</td>
    <td class="lineNumber">128</td>
    <td class="codeline">/// fragment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">/// Results:</td>
    <td class="lineNumber">129</td>
    <td class="codeline">/// Results:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">/// UseFrag - Use Target as the new fragment.</td>
    <td class="lineNumber">130</td>
    <td class="codeline">/// UseFrag - Use Target as the new fragment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">/// UseNoFrag - The new slice already covers the whole variable.</td>
    <td class="lineNumber">131</td>
    <td class="codeline">/// UseNoFrag - The new slice already covers the whole variable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">/// Skip - The new alloca slice doesn't include this variable.</td>
    <td class="lineNumber">132</td>
    <td class="codeline">/// Skip - The new alloca slice doesn't include this variable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">/// FIXME: Can we use calculateFragmentIntersect instead?</td>
    <td class="lineNumber">133</td>
    <td class="codeline">/// FIXME: Can we use calculateFragmentIntersect instead?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">enum FragCalcResult { UseFrag, UseNoFrag, Skip };</td>
    <td class="lineNumber">134</td>
    <td class="codeline">enum FragCalcResult { UseFrag, UseNoFrag, Skip };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">static FragCalcResult</td>
    <td class="lineNumber">135</td>
    <td class="codeline">static FragCalcResult</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">calculateFragment(DILocalVariable *Variable,</td>
    <td class="lineNumber">136</td>
    <td class="codeline">calculateFragment(DILocalVariable *Variable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline">                  uint64_t NewStorageSliceOffsetInBits,</td>
    <td class="lineNumber">137</td>
    <td class="codeline">                  uint64_t NewStorageSliceOffsetInBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">                  uint64_t NewStorageSliceSizeInBits,</td>
    <td class="lineNumber">138</td>
    <td class="codeline">                  uint64_t NewStorageSliceSizeInBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">                  std::optional<DIExpression::FragmentInfo> StorageFragment,</td>
    <td class="lineNumber">139</td>
    <td class="codeline">                  std::optional<DIExpression::FragmentInfo> StorageFragment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">                  std::optional<DIExpression::FragmentInfo> CurrentFragment,</td>
    <td class="lineNumber">140</td>
    <td class="codeline">                  std::optional<DIExpression::FragmentInfo> CurrentFragment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">                  DIExpression::FragmentInfo &Target) {</td>
    <td class="lineNumber">141</td>
    <td class="codeline">                  DIExpression::FragmentInfo &Target) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">  // If the base storage describes part of the variable apply the offset and</td>
    <td class="lineNumber">142</td>
    <td class="codeline">  // If the base storage describes part of the variable apply the offset and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">  // the size constraint.</td>
    <td class="lineNumber">143</td>
    <td class="codeline">  // the size constraint.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  if (StorageFragment) {</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  if (StorageFragment) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">    Target.SizeInBits =</td>
    <td class="lineNumber">145</td>
    <td class="codeline">    Target.SizeInBits =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">        std::min(NewStorageSliceSizeInBits, StorageFragment->SizeInBits);</td>
    <td class="lineNumber">146</td>
    <td class="codeline">        std::min(NewStorageSliceSizeInBits, StorageFragment->SizeInBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">    Target.OffsetInBits =</td>
    <td class="lineNumber">147</td>
    <td class="codeline">    Target.OffsetInBits =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline">        NewStorageSliceOffsetInBits + StorageFragment->OffsetInBits;</td>
    <td class="lineNumber">148</td>
    <td class="codeline">        NewStorageSliceOffsetInBits + StorageFragment->OffsetInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">149</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">    Target.SizeInBits = NewStorageSliceSizeInBits;</td>
    <td class="lineNumber">150</td>
    <td class="codeline">    Target.SizeInBits = NewStorageSliceSizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">    Target.OffsetInBits = NewStorageSliceOffsetInBits;</td>
    <td class="lineNumber">151</td>
    <td class="codeline">    Target.OffsetInBits = NewStorageSliceOffsetInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">152</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">  // If this slice extracts the entirety of an independent variable from a</td>
    <td class="lineNumber">154</td>
    <td class="codeline">  // If this slice extracts the entirety of an independent variable from a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">  // larger alloca, do not produce a fragment expression, as the variable is</td>
    <td class="lineNumber">155</td>
    <td class="codeline">  // larger alloca, do not produce a fragment expression, as the variable is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">  // not fragmented.</td>
    <td class="lineNumber">156</td>
    <td class="codeline">  // not fragmented.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">  if (!CurrentFragment) {</td>
    <td class="lineNumber">157</td>
    <td class="codeline">  if (!CurrentFragment) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">    if (auto Size = Variable->getSizeInBits()) {</td>
    <td class="lineNumber">158</td>
    <td class="codeline">    if (auto Size = Variable->getSizeInBits()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">      // Treat the current fragment as covering the whole variable.</td>
    <td class="lineNumber">159</td>
    <td class="codeline">      // Treat the current fragment as covering the whole variable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">      CurrentFragment =  DIExpression::FragmentInfo(*Size, 0);</td>
    <td class="lineNumber">160</td>
    <td class="codeline">      CurrentFragment =  DIExpression::FragmentInfo(*Size, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">      if (Target == CurrentFragment)</td>
    <td class="lineNumber">161</td>
    <td class="codeline">      if (Target == CurrentFragment)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">        return UseNoFrag;</td>
    <td class="lineNumber">162</td>
    <td class="codeline">        return UseNoFrag;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">163</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline"></td>
    <td class="lineNumber">165</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">  // No additional work to do if there isn't a fragment already, or there is</td>
    <td class="lineNumber">166</td>
    <td class="codeline">  // No additional work to do if there isn't a fragment already, or there is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">  // but it already exactly describes the new assignment.</td>
    <td class="lineNumber">167</td>
    <td class="codeline">  // but it already exactly describes the new assignment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">  if (!CurrentFragment || *CurrentFragment == Target)</td>
    <td class="lineNumber">168</td>
    <td class="codeline">  if (!CurrentFragment || *CurrentFragment == Target)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">    return UseFrag;</td>
    <td class="lineNumber">169</td>
    <td class="codeline">    return UseFrag;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline"></td>
    <td class="lineNumber">170</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">  // Reject the target fragment if it doesn't fit wholly within the current</td>
    <td class="lineNumber">171</td>
    <td class="codeline">  // Reject the target fragment if it doesn't fit wholly within the current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  // fragment. TODO: We could instead chop up the target to fit in the case of</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  // fragment. TODO: We could instead chop up the target to fit in the case of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">  // a partial overlap.</td>
    <td class="lineNumber">173</td>
    <td class="codeline">  // a partial overlap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">  if (Target.startInBits() < CurrentFragment->startInBits() ||</td>
    <td class="lineNumber">174</td>
    <td class="codeline">  if (Target.startInBits() < CurrentFragment->startInBits() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">      Target.endInBits() > CurrentFragment->endInBits())</td>
    <td class="lineNumber">175</td>
    <td class="codeline">      Target.endInBits() > CurrentFragment->endInBits())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">    return Skip;</td>
    <td class="lineNumber">176</td>
    <td class="codeline">    return Skip;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
    <td class="lineNumber">177</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  // Target fits within the current fragment, return it.</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  // Target fits within the current fragment, return it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  return UseFrag;</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  return UseFrag;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">}</td>
    <td class="lineNumber">180</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
    <td class="lineNumber">181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">static DebugVariable getAggregateVariable(DbgVariableIntrinsic *DVI) {</td>
    <td class="lineNumber">182</td>
    <td class="codeline">static DebugVariable getAggregateVariable(DbgVariableIntrinsic *DVI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">  return DebugVariable(DVI->getVariable(), std::nullopt,</td>
    <td class="lineNumber">183</td>
    <td class="codeline">  return DebugVariable(DVI->getVariable(), std::nullopt,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">                       DVI->getDebugLoc().getInlinedAt());</td>
    <td class="lineNumber">184</td>
    <td class="codeline">                       DVI->getDebugLoc().getInlinedAt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">}</td>
    <td class="lineNumber">185</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline"></td>
    <td class="lineNumber">186</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">/// Find linked dbg.assign and generate a new one with the correct</td>
    <td class="lineNumber">187</td>
    <td class="codeline">/// Find linked dbg.assign and generate a new one with the correct</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">/// FragmentInfo. Link Inst to the new dbg.assign.  If Value is nullptr the</td>
    <td class="lineNumber">188</td>
    <td class="codeline">/// FragmentInfo. Link Inst to the new dbg.assign.  If Value is nullptr the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">/// value component is copied from the old dbg.assign to the new.</td>
    <td class="lineNumber">189</td>
    <td class="codeline">/// value component is copied from the old dbg.assign to the new.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">/// \param OldAlloca             Alloca for the variable before splitting.</td>
    <td class="lineNumber">190</td>
    <td class="codeline">/// \param OldAlloca             Alloca for the variable before splitting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">/// \param IsSplit               True if the store (not necessarily alloca)</td>
    <td class="lineNumber">191</td>
    <td class="codeline">/// \param IsSplit               True if the store (not necessarily alloca)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">///                              is being split.</td>
    <td class="lineNumber">192</td>
    <td class="codeline">///                              is being split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">/// \param OldAllocaOffsetInBits Offset of the slice taken from OldAlloca.</td>
    <td class="lineNumber">193</td>
    <td class="codeline">/// \param OldAllocaOffsetInBits Offset of the slice taken from OldAlloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">/// \param SliceSizeInBits       New number of bits being written to.</td>
    <td class="lineNumber">194</td>
    <td class="codeline">/// \param SliceSizeInBits       New number of bits being written to.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">/// \param OldInst               Instruction that is being split.</td>
    <td class="lineNumber">195</td>
    <td class="codeline">/// \param OldInst               Instruction that is being split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">/// \param Inst                  New instruction performing this part of the</td>
    <td class="lineNumber">196</td>
    <td class="codeline">/// \param Inst                  New instruction performing this part of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">///                              split store.</td>
    <td class="lineNumber">197</td>
    <td class="codeline">///                              split store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">/// \param Dest                  Store destination.</td>
    <td class="lineNumber">198</td>
    <td class="codeline">/// \param Dest                  Store destination.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">/// \param Value                 Stored value.</td>
    <td class="lineNumber">199</td>
    <td class="codeline">/// \param Value                 Stored value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">/// \param DL                    Datalayout.</td>
    <td class="lineNumber">200</td>
    <td class="codeline">/// \param DL                    Datalayout.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">static void migrateDebugInfo(AllocaInst *OldAlloca, bool IsSplit,</td>
    <td class="lineNumber">201</td>
    <td class="codeline">static void migrateDebugInfo(AllocaInst *OldAlloca, bool IsSplit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">                             uint64_t OldAllocaOffsetInBits,</td>
    <td class="lineNumber">202</td>
    <td class="codeline">                             uint64_t OldAllocaOffsetInBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">                             uint64_t SliceSizeInBits, Instruction *OldInst,</td>
    <td class="lineNumber">203</td>
    <td class="codeline">                             uint64_t SliceSizeInBits, Instruction *OldInst,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">                             Instruction *Inst, Value *Dest, Value *Value,</td>
    <td class="lineNumber">204</td>
    <td class="codeline">                             Instruction *Inst, Value *Dest, Value *Value,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">                             const DataLayout &DL) {</td>
    <td class="lineNumber">205</td>
    <td class="codeline">                             const DataLayout &DL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  auto MarkerRange = at::getAssignmentMarkers(OldInst);</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  auto MarkerRange = at::getAssignmentMarkers(OldInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  // Nothing to do if OldInst has no linked dbg.assign intrinsics.</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  // Nothing to do if OldInst has no linked dbg.assign intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">  if (MarkerRange.empty())</td>
    <td class="lineNumber">208</td>
    <td class="codeline">  if (MarkerRange.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">209</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
    <td class="lineNumber">210</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  migrateDebugInfo\n");</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  migrateDebugInfo\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    OldAlloca: " << *OldAlloca << "\n");</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    OldAlloca: " << *OldAlloca << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    IsSplit: " << IsSplit << "\n");</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    IsSplit: " << IsSplit << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    OldAllocaOffsetInBits: " << OldAllocaOffsetInBits</td>
    <td class="lineNumber">214</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    OldAllocaOffsetInBits: " << OldAllocaOffsetInBits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">                    << "\n");</td>
    <td class="lineNumber">215</td>
    <td class="codeline">                    << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    SliceSizeInBits: " << SliceSizeInBits << "\n");</td>
    <td class="lineNumber">216</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    SliceSizeInBits: " << SliceSizeInBits << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    OldInst: " << *OldInst << "\n");</td>
    <td class="lineNumber">217</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    OldInst: " << *OldInst << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    Inst: " << *Inst << "\n");</td>
    <td class="lineNumber">218</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    Inst: " << *Inst << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    Dest: " << *Dest << "\n");</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    Dest: " << *Dest << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline">  if (Value)</td>
    <td class="lineNumber">220</td>
    <td class="codeline">  if (Value)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    Value: " << *Value << "\n");</td>
    <td class="lineNumber">221</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    Value: " << *Value << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline"></td>
    <td class="lineNumber">222</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  /// Map of aggregate variables to their fragment associated with OldAlloca.</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  /// Map of aggregate variables to their fragment associated with OldAlloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">  DenseMap<DebugVariable, std::optional<DIExpression::FragmentInfo>></td>
    <td class="lineNumber">224</td>
    <td class="codeline">  DenseMap<DebugVariable, std::optional<DIExpression::FragmentInfo>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">      BaseFragments;</td>
    <td class="lineNumber">225</td>
    <td class="codeline">      BaseFragments;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">  for (auto *DAI : at::getAssignmentMarkers(OldAlloca))</td>
    <td class="lineNumber">226</td>
    <td class="codeline">  for (auto *DAI : at::getAssignmentMarkers(OldAlloca))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">    BaseFragments[getAggregateVariable(DAI)] =</td>
    <td class="lineNumber">227</td>
    <td class="codeline">    BaseFragments[getAggregateVariable(DAI)] =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">        DAI->getExpression()->getFragmentInfo();</td>
    <td class="lineNumber">228</td>
    <td class="codeline">        DAI->getExpression()->getFragmentInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
    <td class="lineNumber">229</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  // The new inst needs a DIAssignID unique metadata tag (if OldInst has</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  // The new inst needs a DIAssignID unique metadata tag (if OldInst has</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  // one). It shouldn't already have one: assert this assumption.</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  // one). It shouldn't already have one: assert this assumption.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">  assert(!Inst->getMetadata(LLVMContext::MD_DIAssignID));</td>
    <td class="lineNumber">232</td>
    <td class="codeline">  assert(!Inst->getMetadata(LLVMContext::MD_DIAssignID));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline">  DIAssignID *NewID = nullptr;</td>
    <td class="lineNumber">233</td>
    <td class="codeline">  DIAssignID *NewID = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">  auto &Ctx = Inst->getContext();</td>
    <td class="lineNumber">234</td>
    <td class="codeline">  auto &Ctx = Inst->getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  DIBuilder DIB(*OldInst->getModule(), /*AllowUnresolved*/ false);</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  DIBuilder DIB(*OldInst->getModule(), /*AllowUnresolved*/ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">  assert(OldAlloca->isStaticAlloca());</td>
    <td class="lineNumber">236</td>
    <td class="codeline">  assert(OldAlloca->isStaticAlloca());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline"></td>
    <td class="lineNumber">237</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">  for (DbgAssignIntrinsic *DbgAssign : MarkerRange) {</td>
    <td class="lineNumber">238</td>
    <td class="codeline">  for (DbgAssignIntrinsic *DbgAssign : MarkerRange) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "      existing dbg.assign is: " << *DbgAssign</td>
    <td class="lineNumber">239</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "      existing dbg.assign is: " << *DbgAssign</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">                      << "\n");</td>
    <td class="lineNumber">240</td>
    <td class="codeline">                      << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">    auto *Expr = DbgAssign->getExpression();</td>
    <td class="lineNumber">241</td>
    <td class="codeline">    auto *Expr = DbgAssign->getExpression();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">    bool SetKillLocation = false;</td>
    <td class="lineNumber">242</td>
    <td class="codeline">    bool SetKillLocation = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline"></td>
    <td class="lineNumber">243</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">    if (IsSplit) {</td>
    <td class="lineNumber">244</td>
    <td class="codeline">    if (IsSplit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">      std::optional<DIExpression::FragmentInfo> BaseFragment;</td>
    <td class="lineNumber">245</td>
    <td class="codeline">      std::optional<DIExpression::FragmentInfo> BaseFragment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">      {</td>
    <td class="lineNumber">246</td>
    <td class="codeline">      {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">        auto R = BaseFragments.find(getAggregateVariable(DbgAssign));</td>
    <td class="lineNumber">247</td>
    <td class="codeline">        auto R = BaseFragments.find(getAggregateVariable(DbgAssign));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">        if (R == BaseFragments.end())</td>
    <td class="lineNumber">248</td>
    <td class="codeline">        if (R == BaseFragments.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">249</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">        BaseFragment = R->second;</td>
    <td class="lineNumber">250</td>
    <td class="codeline">        BaseFragment = R->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">251</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">      std::optional<DIExpression::FragmentInfo> CurrentFragment =</td>
    <td class="lineNumber">252</td>
    <td class="codeline">      std::optional<DIExpression::FragmentInfo> CurrentFragment =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">          Expr->getFragmentInfo();</td>
    <td class="lineNumber">253</td>
    <td class="codeline">          Expr->getFragmentInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">      DIExpression::FragmentInfo NewFragment;</td>
    <td class="lineNumber">254</td>
    <td class="codeline">      DIExpression::FragmentInfo NewFragment;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">      FragCalcResult Result = calculateFragment(</td>
    <td class="lineNumber">255</td>
    <td class="codeline">      FragCalcResult Result = calculateFragment(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">          DbgAssign->getVariable(), OldAllocaOffsetInBits, SliceSizeInBits,</td>
    <td class="lineNumber">256</td>
    <td class="codeline">          DbgAssign->getVariable(), OldAllocaOffsetInBits, SliceSizeInBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">          BaseFragment, CurrentFragment, NewFragment);</td>
    <td class="lineNumber">257</td>
    <td class="codeline">          BaseFragment, CurrentFragment, NewFragment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline"></td>
    <td class="lineNumber">258</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline">      if (Result == Skip)</td>
    <td class="lineNumber">259</td>
    <td class="codeline">      if (Result == Skip)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">260</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">      if (Result == UseFrag && !(NewFragment == CurrentFragment)) {</td>
    <td class="lineNumber">261</td>
    <td class="codeline">      if (Result == UseFrag && !(NewFragment == CurrentFragment)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">        if (CurrentFragment) {</td>
    <td class="lineNumber">262</td>
    <td class="codeline">        if (CurrentFragment) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">          // Rewrite NewFragment to be relative to the existing one (this is</td>
    <td class="lineNumber">263</td>
    <td class="codeline">          // Rewrite NewFragment to be relative to the existing one (this is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">          // what createFragmentExpression wants).  CalculateFragment has</td>
    <td class="lineNumber">264</td>
    <td class="codeline">          // what createFragmentExpression wants).  CalculateFragment has</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">          // already resolved the size for us. FIXME: Should it return the</td>
    <td class="lineNumber">265</td>
    <td class="codeline">          // already resolved the size for us. FIXME: Should it return the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">          // relative fragment too?</td>
    <td class="lineNumber">266</td>
    <td class="codeline">          // relative fragment too?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">          NewFragment.OffsetInBits -= CurrentFragment->OffsetInBits;</td>
    <td class="lineNumber">267</td>
    <td class="codeline">          NewFragment.OffsetInBits -= CurrentFragment->OffsetInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">268</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">        // Add the new fragment info to the existing expression if possible.</td>
    <td class="lineNumber">269</td>
    <td class="codeline">        // Add the new fragment info to the existing expression if possible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">        if (auto E = DIExpression::createFragmentExpression(</td>
    <td class="lineNumber">270</td>
    <td class="codeline">        if (auto E = DIExpression::createFragmentExpression(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">                Expr, NewFragment.OffsetInBits, NewFragment.SizeInBits)) {</td>
    <td class="lineNumber">271</td>
    <td class="codeline">                Expr, NewFragment.OffsetInBits, NewFragment.SizeInBits)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">          Expr = *E;</td>
    <td class="lineNumber">272</td>
    <td class="codeline">          Expr = *E;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">273</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">          // Otherwise, add the new fragment info to an empty expression and</td>
    <td class="lineNumber">274</td>
    <td class="codeline">          // Otherwise, add the new fragment info to an empty expression and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">          // discard the value component of this dbg.assign as the value cannot</td>
    <td class="lineNumber">275</td>
    <td class="codeline">          // discard the value component of this dbg.assign as the value cannot</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">          // be computed with the new fragment.</td>
    <td class="lineNumber">276</td>
    <td class="codeline">          // be computed with the new fragment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">          Expr = *DIExpression::createFragmentExpression(</td>
    <td class="lineNumber">277</td>
    <td class="codeline">          Expr = *DIExpression::createFragmentExpression(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">              DIExpression::get(Expr->getContext(), std::nullopt),</td>
    <td class="lineNumber">278</td>
    <td class="codeline">              DIExpression::get(Expr->getContext(), std::nullopt),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">              NewFragment.OffsetInBits, NewFragment.SizeInBits);</td>
    <td class="lineNumber">279</td>
    <td class="codeline">              NewFragment.OffsetInBits, NewFragment.SizeInBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">          SetKillLocation = true;</td>
    <td class="lineNumber">280</td>
    <td class="codeline">          SetKillLocation = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">281</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">282</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">283</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline"></td>
    <td class="lineNumber">284</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">    // If we haven't created a DIAssignID ID do that now and attach it to Inst.</td>
    <td class="lineNumber">285</td>
    <td class="codeline">    // If we haven't created a DIAssignID ID do that now and attach it to Inst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">    if (!NewID) {</td>
    <td class="lineNumber">286</td>
    <td class="codeline">    if (!NewID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">      NewID = DIAssignID::getDistinct(Ctx);</td>
    <td class="lineNumber">287</td>
    <td class="codeline">      NewID = DIAssignID::getDistinct(Ctx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">      Inst->setMetadata(LLVMContext::MD_DIAssignID, NewID);</td>
    <td class="lineNumber">288</td>
    <td class="codeline">      Inst->setMetadata(LLVMContext::MD_DIAssignID, NewID);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">289</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline"></td>
    <td class="lineNumber">290</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">    ::Value *NewValue = Value ? Value : DbgAssign->getValue();</td>
    <td class="lineNumber">291</td>
    <td class="codeline">    ::Value *NewValue = Value ? Value : DbgAssign->getValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">    auto *NewAssign = DIB.insertDbgAssign(</td>
    <td class="lineNumber">292</td>
    <td class="codeline">    auto *NewAssign = DIB.insertDbgAssign(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">        Inst, NewValue, DbgAssign->getVariable(), Expr, Dest,</td>
    <td class="lineNumber">293</td>
    <td class="codeline">        Inst, NewValue, DbgAssign->getVariable(), Expr, Dest,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">        DIExpression::get(Ctx, std::nullopt), DbgAssign->getDebugLoc());</td>
    <td class="lineNumber">294</td>
    <td class="codeline">        DIExpression::get(Ctx, std::nullopt), DbgAssign->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline"></td>
    <td class="lineNumber">295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">    // If we've updated the value but the original dbg.assign has an arglist</td>
    <td class="lineNumber">296</td>
    <td class="codeline">    // If we've updated the value but the original dbg.assign has an arglist</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">    // then kill it now - we can't use the requested new value.</td>
    <td class="lineNumber">297</td>
    <td class="codeline">    // then kill it now - we can't use the requested new value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">    // We can't replace the DIArgList with the new value as it'd leave</td>
    <td class="lineNumber">298</td>
    <td class="codeline">    // We can't replace the DIArgList with the new value as it'd leave</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">    // the DIExpression in an invalid state (DW_OP_LLVM_arg operands without</td>
    <td class="lineNumber">299</td>
    <td class="codeline">    // the DIExpression in an invalid state (DW_OP_LLVM_arg operands without</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">    // an arglist). And we can't keep the DIArgList in case the linked store</td>
    <td class="lineNumber">300</td>
    <td class="codeline">    // an arglist). And we can't keep the DIArgList in case the linked store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">    // is being split - in which case the DIArgList + expression may no longer</td>
    <td class="lineNumber">301</td>
    <td class="codeline">    // is being split - in which case the DIArgList + expression may no longer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">    // be computing the correct value.</td>
    <td class="lineNumber">302</td>
    <td class="codeline">    // be computing the correct value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">    // This should be a very rare situation as it requires the value being</td>
    <td class="lineNumber">303</td>
    <td class="codeline">    // This should be a very rare situation as it requires the value being</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">    // stored to differ from the dbg.assign (i.e., the value has been</td>
    <td class="lineNumber">304</td>
    <td class="codeline">    // stored to differ from the dbg.assign (i.e., the value has been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">    // represented differently in the debug intrinsic for some reason).</td>
    <td class="lineNumber">305</td>
    <td class="codeline">    // represented differently in the debug intrinsic for some reason).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">    SetKillLocation |=</td>
    <td class="lineNumber">306</td>
    <td class="codeline">    SetKillLocation |=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">        Value && (DbgAssign->hasArgList() ||</td>
    <td class="lineNumber">307</td>
    <td class="codeline">        Value && (DbgAssign->hasArgList() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">                  !DbgAssign->getExpression()->isSingleLocationExpression());</td>
    <td class="lineNumber">308</td>
    <td class="codeline">                  !DbgAssign->getExpression()->isSingleLocationExpression());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">    if (SetKillLocation)</td>
    <td class="lineNumber">309</td>
    <td class="codeline">    if (SetKillLocation)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">      NewAssign->setKillLocation();</td>
    <td class="lineNumber">310</td>
    <td class="codeline">      NewAssign->setKillLocation();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
    <td class="lineNumber">311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">    // We could use more precision here at the cost of some additional (code)</td>
    <td class="lineNumber">312</td>
    <td class="codeline">    // We could use more precision here at the cost of some additional (code)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">    // complexity - if the original dbg.assign was adjacent to its store, we</td>
    <td class="lineNumber">313</td>
    <td class="codeline">    // complexity - if the original dbg.assign was adjacent to its store, we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">    // could position this new dbg.assign adjacent to its store rather than the</td>
    <td class="lineNumber">314</td>
    <td class="codeline">    // could position this new dbg.assign adjacent to its store rather than the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">    // old dbg.assgn. That would result in interleaved dbg.assigns rather than</td>
    <td class="lineNumber">315</td>
    <td class="codeline">    // old dbg.assgn. That would result in interleaved dbg.assigns rather than</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">    // what we get now:</td>
    <td class="lineNumber">316</td>
    <td class="codeline">    // what we get now:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">    //    split store !1</td>
    <td class="lineNumber">317</td>
    <td class="codeline">    //    split store !1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">    //    split store !2</td>
    <td class="lineNumber">318</td>
    <td class="codeline">    //    split store !2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">    //    dbg.assign !1</td>
    <td class="lineNumber">319</td>
    <td class="codeline">    //    dbg.assign !1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">    //    dbg.assign !2</td>
    <td class="lineNumber">320</td>
    <td class="codeline">    //    dbg.assign !2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">    // This (current behaviour) results results in debug assignments being</td>
    <td class="lineNumber">321</td>
    <td class="codeline">    // This (current behaviour) results results in debug assignments being</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">    // noted as slightly offset (in code) from the store. In practice this</td>
    <td class="lineNumber">322</td>
    <td class="codeline">    // noted as slightly offset (in code) from the store. In practice this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">    // should have little effect on the debugging experience due to the fact</td>
    <td class="lineNumber">323</td>
    <td class="codeline">    // should have little effect on the debugging experience due to the fact</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">    // that all the split stores should get the same line number.</td>
    <td class="lineNumber">324</td>
    <td class="codeline">    // that all the split stores should get the same line number.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">    NewAssign->moveBefore(DbgAssign);</td>
    <td class="lineNumber">325</td>
    <td class="codeline">    NewAssign->moveBefore(DbgAssign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline"></td>
    <td class="lineNumber">326</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">    NewAssign->setDebugLoc(DbgAssign->getDebugLoc());</td>
    <td class="lineNumber">327</td>
    <td class="codeline">    NewAssign->setDebugLoc(DbgAssign->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Created new assign intrinsic: " << *NewAssign</td>
    <td class="lineNumber">328</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Created new assign intrinsic: " << *NewAssign</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">                      << "\n");</td>
    <td class="lineNumber">329</td>
    <td class="codeline">                      << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">}</td>
    <td class="lineNumber">331</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline"></td>
    <td class="lineNumber">332</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">/// A custom IRBuilder inserter which prefixes all names, but only in</td>
    <td class="lineNumber">333</td>
    <td class="codeline">/// A custom IRBuilder inserter which prefixes all names, but only in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">/// Assert builds.</td>
    <td class="lineNumber">334</td>
    <td class="codeline">/// Assert builds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">class IRBuilderPrefixedInserter final : public IRBuilderDefaultInserter {</td>
    <td class="lineNumber">335</td>
    <td class="codeline">class IRBuilderPrefixedInserter final : public IRBuilderDefaultInserter {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">  std::string Prefix;</td>
    <td class="lineNumber">336</td>
    <td class="codeline">  std::string Prefix;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline"></td>
    <td class="lineNumber">337</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">  Twine getNameWithPrefix(const Twine &Name) const {</td>
    <td class="lineNumber">338</td>
    <td class="codeline">  Twine getNameWithPrefix(const Twine &Name) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">    return Name.isTriviallyEmpty() ? Name : Prefix + Name;</td>
    <td class="lineNumber">339</td>
    <td class="codeline">    return Name.isTriviallyEmpty() ? Name : Prefix + Name;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">340</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline"></td>
    <td class="lineNumber">341</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">342</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">  void SetNamePrefix(const Twine &P) { Prefix = P.str(); }</td>
    <td class="lineNumber">343</td>
    <td class="codeline">  void SetNamePrefix(const Twine &P) { Prefix = P.str(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
    <td class="lineNumber">344</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  void InsertHelper(Instruction *I, const Twine &Name, BasicBlock *BB,</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  void InsertHelper(Instruction *I, const Twine &Name, BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">                    BasicBlock::iterator InsertPt) const override {</td>
    <td class="lineNumber">346</td>
    <td class="codeline">                    BasicBlock::iterator InsertPt) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">    IRBuilderDefaultInserter::InsertHelper(I, getNameWithPrefix(Name), BB,</td>
    <td class="lineNumber">347</td>
    <td class="codeline">    IRBuilderDefaultInserter::InsertHelper(I, getNameWithPrefix(Name), BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">                                           InsertPt);</td>
    <td class="lineNumber">348</td>
    <td class="codeline">                                           InsertPt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">349</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">};</td>
    <td class="lineNumber">350</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline"></td>
    <td class="lineNumber">351</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">/// Provide a type for IRBuilder that drops names in release builds.</td>
    <td class="lineNumber">352</td>
    <td class="codeline">/// Provide a type for IRBuilder that drops names in release builds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">using IRBuilderTy = IRBuilder<ConstantFolder, IRBuilderPrefixedInserter>;</td>
    <td class="lineNumber">353</td>
    <td class="codeline">using IRBuilderTy = IRBuilder<ConstantFolder, IRBuilderPrefixedInserter>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline"></td>
    <td class="lineNumber">354</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">/// A used slice of an alloca.</td>
    <td class="lineNumber">355</td>
    <td class="codeline">/// A used slice of an alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">///</td>
    <td class="lineNumber">356</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">/// This structure represents a slice of an alloca used by some instruction. It</td>
    <td class="lineNumber">357</td>
    <td class="codeline">/// This structure represents a slice of an alloca used by some instruction. It</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">/// stores both the begin and end offsets of this use, a pointer to the use</td>
    <td class="lineNumber">358</td>
    <td class="codeline">/// stores both the begin and end offsets of this use, a pointer to the use</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">/// itself, and a flag indicating whether we can classify the use as splittable</td>
    <td class="lineNumber">359</td>
    <td class="codeline">/// itself, and a flag indicating whether we can classify the use as splittable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">/// or not when forming partitions of the alloca.</td>
    <td class="lineNumber">360</td>
    <td class="codeline">/// or not when forming partitions of the alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">class Slice {</td>
    <td class="lineNumber">361</td>
    <td class="codeline">class Slice {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">  /// The beginning offset of the range.</td>
    <td class="lineNumber">362</td>
    <td class="codeline">  /// The beginning offset of the range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">  uint64_t BeginOffset = 0;</td>
    <td class="lineNumber">363</td>
    <td class="codeline">  uint64_t BeginOffset = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline"></td>
    <td class="lineNumber">364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">  /// The ending offset, not included in the range.</td>
    <td class="lineNumber">365</td>
    <td class="codeline">  /// The ending offset, not included in the range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">  uint64_t EndOffset = 0;</td>
    <td class="lineNumber">366</td>
    <td class="codeline">  uint64_t EndOffset = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">  /// Storage for both the use of this slice and whether it can be</td>
    <td class="lineNumber">368</td>
    <td class="codeline">  /// Storage for both the use of this slice and whether it can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">  /// split.</td>
    <td class="lineNumber">369</td>
    <td class="codeline">  /// split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">  PointerIntPair<Use *, 1, bool> UseAndIsSplittable;</td>
    <td class="lineNumber">370</td>
    <td class="codeline">  PointerIntPair<Use *, 1, bool> UseAndIsSplittable;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline"></td>
    <td class="lineNumber">371</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">372</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">  Slice() = default;</td>
    <td class="lineNumber">373</td>
    <td class="codeline">  Slice() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline"></td>
    <td class="lineNumber">374</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">  Slice(uint64_t BeginOffset, uint64_t EndOffset, Use *U, bool IsSplittable)</td>
    <td class="lineNumber">375</td>
    <td class="codeline">  Slice(uint64_t BeginOffset, uint64_t EndOffset, Use *U, bool IsSplittable)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">      : BeginOffset(BeginOffset), EndOffset(EndOffset),</td>
    <td class="lineNumber">376</td>
    <td class="codeline">      : BeginOffset(BeginOffset), EndOffset(EndOffset),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">        UseAndIsSplittable(U, IsSplittable) {}</td>
    <td class="lineNumber">377</td>
    <td class="codeline">        UseAndIsSplittable(U, IsSplittable) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline"></td>
    <td class="lineNumber">378</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">  uint64_t beginOffset() const { return BeginOffset; }</td>
    <td class="lineNumber">379</td>
    <td class="codeline">  uint64_t beginOffset() const { return BeginOffset; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">  uint64_t endOffset() const { return EndOffset; }</td>
    <td class="lineNumber">380</td>
    <td class="codeline">  uint64_t endOffset() const { return EndOffset; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline"></td>
    <td class="lineNumber">381</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">  bool isSplittable() const { return UseAndIsSplittable.getInt(); }</td>
    <td class="lineNumber">382</td>
    <td class="codeline">  bool isSplittable() const { return UseAndIsSplittable.getInt(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  void makeUnsplittable() { UseAndIsSplittable.setInt(false); }</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  void makeUnsplittable() { UseAndIsSplittable.setInt(false); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline"></td>
    <td class="lineNumber">384</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">  Use *getUse() const { return UseAndIsSplittable.getPointer(); }</td>
    <td class="lineNumber">385</td>
    <td class="codeline">  Use *getUse() const { return UseAndIsSplittable.getPointer(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline"></td>
    <td class="lineNumber">386</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">  bool isDead() const { return getUse() == nullptr; }</td>
    <td class="lineNumber">387</td>
    <td class="codeline">  bool isDead() const { return getUse() == nullptr; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">  void kill() { UseAndIsSplittable.setPointer(nullptr); }</td>
    <td class="lineNumber">388</td>
    <td class="codeline">  void kill() { UseAndIsSplittable.setPointer(nullptr); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">  /// Support for ordering ranges.</td>
    <td class="lineNumber">390</td>
    <td class="codeline">  /// Support for ordering ranges.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">391</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">  /// This provides an ordering over ranges such that start offsets are</td>
    <td class="lineNumber">392</td>
    <td class="codeline">  /// This provides an ordering over ranges such that start offsets are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">  /// always increasing, and within equal start offsets, the end offsets are</td>
    <td class="lineNumber">393</td>
    <td class="codeline">  /// always increasing, and within equal start offsets, the end offsets are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">  /// decreasing. Thus the spanning range comes first in a cluster with the</td>
    <td class="lineNumber">394</td>
    <td class="codeline">  /// decreasing. Thus the spanning range comes first in a cluster with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">  /// same start position.</td>
    <td class="lineNumber">395</td>
    <td class="codeline">  /// same start position.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  bool operator<(const Slice &RHS) const {</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  bool operator<(const Slice &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">    if (beginOffset() < RHS.beginOffset())</td>
    <td class="lineNumber">397</td>
    <td class="codeline">    if (beginOffset() < RHS.beginOffset())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">398</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">    if (beginOffset() > RHS.beginOffset())</td>
    <td class="lineNumber">399</td>
    <td class="codeline">    if (beginOffset() > RHS.beginOffset())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">400</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">    if (isSplittable() != RHS.isSplittable())</td>
    <td class="lineNumber">401</td>
    <td class="codeline">    if (isSplittable() != RHS.isSplittable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">      return !isSplittable();</td>
    <td class="lineNumber">402</td>
    <td class="codeline">      return !isSplittable();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">    if (endOffset() > RHS.endOffset())</td>
    <td class="lineNumber">403</td>
    <td class="codeline">    if (endOffset() > RHS.endOffset())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">404</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">405</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">406</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline"></td>
    <td class="lineNumber">407</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">  /// Support comparison with a single offset to allow binary searches.</td>
    <td class="lineNumber">408</td>
    <td class="codeline">  /// Support comparison with a single offset to allow binary searches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">  friend LLVM_ATTRIBUTE_UNUSED bool operator<(const Slice &LHS,</td>
    <td class="lineNumber">409</td>
    <td class="codeline">  friend LLVM_ATTRIBUTE_UNUSED bool operator<(const Slice &LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">                                              uint64_t RHSOffset) {</td>
    <td class="lineNumber">410</td>
    <td class="codeline">                                              uint64_t RHSOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">    return LHS.beginOffset() < RHSOffset;</td>
    <td class="lineNumber">411</td>
    <td class="codeline">    return LHS.beginOffset() < RHSOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">412</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">  friend LLVM_ATTRIBUTE_UNUSED bool operator<(uint64_t LHSOffset,</td>
    <td class="lineNumber">413</td>
    <td class="codeline">  friend LLVM_ATTRIBUTE_UNUSED bool operator<(uint64_t LHSOffset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">                                              const Slice &RHS) {</td>
    <td class="lineNumber">414</td>
    <td class="codeline">                                              const Slice &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">    return LHSOffset < RHS.beginOffset();</td>
    <td class="lineNumber">415</td>
    <td class="codeline">    return LHSOffset < RHS.beginOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">416</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline"></td>
    <td class="lineNumber">417</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">  bool operator==(const Slice &RHS) const {</td>
    <td class="lineNumber">418</td>
    <td class="codeline">  bool operator==(const Slice &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">    return isSplittable() == RHS.isSplittable() &&</td>
    <td class="lineNumber">419</td>
    <td class="codeline">    return isSplittable() == RHS.isSplittable() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">           beginOffset() == RHS.beginOffset() && endOffset() == RHS.endOffset();</td>
    <td class="lineNumber">420</td>
    <td class="codeline">           beginOffset() == RHS.beginOffset() && endOffset() == RHS.endOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">421</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">  bool operator!=(const Slice &RHS) const { return !operator==(RHS); }</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  bool operator!=(const Slice &RHS) const { return !operator==(RHS); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">};</td>
    <td class="lineNumber">423</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline"></td>
    <td class="lineNumber">424</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">425</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline"></td>
    <td class="lineNumber">426</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">/// Representation of the alloca slices.</td>
    <td class="lineNumber">427</td>
    <td class="codeline">/// Representation of the alloca slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">///</td>
    <td class="lineNumber">428</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline">/// This class represents the slices of an alloca which are formed by its</td>
    <td class="lineNumber">429</td>
    <td class="codeline">/// This class represents the slices of an alloca which are formed by its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">/// various uses. If a pointer escapes, we can't fully build a representation</td>
    <td class="lineNumber">430</td>
    <td class="codeline">/// various uses. If a pointer escapes, we can't fully build a representation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">/// for the slices used and we reflect that in this structure. The uses are</td>
    <td class="lineNumber">431</td>
    <td class="codeline">/// for the slices used and we reflect that in this structure. The uses are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">/// stored, sorted by increasing beginning offset and with unsplittable slices</td>
    <td class="lineNumber">432</td>
    <td class="codeline">/// stored, sorted by increasing beginning offset and with unsplittable slices</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">/// starting at a particular offset before splittable slices.</td>
    <td class="lineNumber">433</td>
    <td class="codeline">/// starting at a particular offset before splittable slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">class llvm::sroa::AllocaSlices {</td>
    <td class="lineNumber">434</td>
    <td class="codeline">class llvm::sroa::AllocaSlices {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">435</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">  /// Construct the slices of a particular alloca.</td>
    <td class="lineNumber">436</td>
    <td class="codeline">  /// Construct the slices of a particular alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">  AllocaSlices(const DataLayout &DL, AllocaInst &AI);</td>
    <td class="lineNumber">437</td>
    <td class="codeline">  AllocaSlices(const DataLayout &DL, AllocaInst &AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">  /// Test whether a pointer to the allocation escapes our analysis.</td>
    <td class="lineNumber">439</td>
    <td class="codeline">  /// Test whether a pointer to the allocation escapes our analysis.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">440</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">  /// If this is true, the slices are never fully built and should be</td>
    <td class="lineNumber">441</td>
    <td class="codeline">  /// If this is true, the slices are never fully built and should be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">  /// ignored.</td>
    <td class="lineNumber">442</td>
    <td class="codeline">  /// ignored.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">  bool isEscaped() const { return PointerEscapingInstr; }</td>
    <td class="lineNumber">443</td>
    <td class="codeline">  bool isEscaped() const { return PointerEscapingInstr; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline"></td>
    <td class="lineNumber">444</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">  /// Support for iterating over the slices.</td>
    <td class="lineNumber">445</td>
    <td class="codeline">  /// Support for iterating over the slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">  /// @{</td>
    <td class="lineNumber">446</td>
    <td class="codeline">  /// @{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">  using iterator = SmallVectorImpl<Slice>::iterator;</td>
    <td class="lineNumber">447</td>
    <td class="codeline">  using iterator = SmallVectorImpl<Slice>::iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">  using range = iterator_range<iterator>;</td>
    <td class="lineNumber">448</td>
    <td class="codeline">  using range = iterator_range<iterator>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline"></td>
    <td class="lineNumber">449</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">  iterator begin() { return Slices.begin(); }</td>
    <td class="lineNumber">450</td>
    <td class="codeline">  iterator begin() { return Slices.begin(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">  iterator end() { return Slices.end(); }</td>
    <td class="lineNumber">451</td>
    <td class="codeline">  iterator end() { return Slices.end(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
    <td class="lineNumber">452</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  using const_iterator = SmallVectorImpl<Slice>::const_iterator;</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  using const_iterator = SmallVectorImpl<Slice>::const_iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline">  using const_range = iterator_range<const_iterator>;</td>
    <td class="lineNumber">454</td>
    <td class="codeline">  using const_range = iterator_range<const_iterator>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
    <td class="lineNumber">455</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">  const_iterator begin() const { return Slices.begin(); }</td>
    <td class="lineNumber">456</td>
    <td class="codeline">  const_iterator begin() const { return Slices.begin(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">  const_iterator end() const { return Slices.end(); }</td>
    <td class="lineNumber">457</td>
    <td class="codeline">  const_iterator end() const { return Slices.end(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">  /// @}</td>
    <td class="lineNumber">458</td>
    <td class="codeline">  /// @}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline"></td>
    <td class="lineNumber">459</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">  /// Erase a range of slices.</td>
    <td class="lineNumber">460</td>
    <td class="codeline">  /// Erase a range of slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">  void erase(iterator Start, iterator Stop) { Slices.erase(Start, Stop); }</td>
    <td class="lineNumber">461</td>
    <td class="codeline">  void erase(iterator Start, iterator Stop) { Slices.erase(Start, Stop); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline"></td>
    <td class="lineNumber">462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">  /// Insert new slices for this alloca.</td>
    <td class="lineNumber">463</td>
    <td class="codeline">  /// Insert new slices for this alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">  /// This moves the slices into the alloca's slices collection, and re-sorts</td>
    <td class="lineNumber">465</td>
    <td class="codeline">  /// This moves the slices into the alloca's slices collection, and re-sorts</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">  /// everything so that the usual ordering properties of the alloca's slices</td>
    <td class="lineNumber">466</td>
    <td class="codeline">  /// everything so that the usual ordering properties of the alloca's slices</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">  /// hold.</td>
    <td class="lineNumber">467</td>
    <td class="codeline">  /// hold.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">  void insert(ArrayRef<Slice> NewSlices) {</td>
    <td class="lineNumber">468</td>
    <td class="codeline">  void insert(ArrayRef<Slice> NewSlices) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">    int OldSize = Slices.size();</td>
    <td class="lineNumber">469</td>
    <td class="codeline">    int OldSize = Slices.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">    Slices.append(NewSlices.begin(), NewSlices.end());</td>
    <td class="lineNumber">470</td>
    <td class="codeline">    Slices.append(NewSlices.begin(), NewSlices.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">    auto SliceI = Slices.begin() + OldSize;</td>
    <td class="lineNumber">471</td>
    <td class="codeline">    auto SliceI = Slices.begin() + OldSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">    llvm::sort(SliceI, Slices.end());</td>
    <td class="lineNumber">472</td>
    <td class="codeline">    llvm::sort(SliceI, Slices.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">    std::inplace_merge(Slices.begin(), SliceI, Slices.end());</td>
    <td class="lineNumber">473</td>
    <td class="codeline">    std::inplace_merge(Slices.begin(), SliceI, Slices.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">474</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline"></td>
    <td class="lineNumber">475</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">  // Forward declare the iterator and range accessor for walking the</td>
    <td class="lineNumber">476</td>
    <td class="codeline">  // Forward declare the iterator and range accessor for walking the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">  // partitions.</td>
    <td class="lineNumber">477</td>
    <td class="codeline">  // partitions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">  class partition_iterator;</td>
    <td class="lineNumber">478</td>
    <td class="codeline">  class partition_iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  iterator_range<partition_iterator> partitions();</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  iterator_range<partition_iterator> partitions();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline"></td>
    <td class="lineNumber">480</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">  /// Access the dead users for this alloca.</td>
    <td class="lineNumber">481</td>
    <td class="codeline">  /// Access the dead users for this alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">  ArrayRef<Instruction *> getDeadUsers() const { return DeadUsers; }</td>
    <td class="lineNumber">482</td>
    <td class="codeline">  ArrayRef<Instruction *> getDeadUsers() const { return DeadUsers; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline"></td>
    <td class="lineNumber">483</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">  /// Access Uses that should be dropped if the alloca is promotable.</td>
    <td class="lineNumber">484</td>
    <td class="codeline">  /// Access Uses that should be dropped if the alloca is promotable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">  ArrayRef<Use *> getDeadUsesIfPromotable() const {</td>
    <td class="lineNumber">485</td>
    <td class="codeline">  ArrayRef<Use *> getDeadUsesIfPromotable() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">    return DeadUseIfPromotable;</td>
    <td class="lineNumber">486</td>
    <td class="codeline">    return DeadUseIfPromotable;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">487</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">  /// Access the dead operands referring to this alloca.</td>
    <td class="lineNumber">489</td>
    <td class="codeline">  /// Access the dead operands referring to this alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">490</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  /// These are operands which have cannot actually be used to refer to the</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  /// These are operands which have cannot actually be used to refer to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">  /// alloca as they are outside its range and the user doesn't correct for</td>
    <td class="lineNumber">492</td>
    <td class="codeline">  /// alloca as they are outside its range and the user doesn't correct for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  /// that. These mostly consist of PHI node inputs and the like which we just</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  /// that. These mostly consist of PHI node inputs and the like which we just</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">  /// need to replace with undef.</td>
    <td class="lineNumber">494</td>
    <td class="codeline">  /// need to replace with undef.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">  ArrayRef<Use *> getDeadOperands() const { return DeadOperands; }</td>
    <td class="lineNumber">495</td>
    <td class="codeline">  ArrayRef<Use *> getDeadOperands() const { return DeadOperands; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline"></td>
    <td class="lineNumber">496</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">497</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">  void print(raw_ostream &OS, const_iterator I, StringRef Indent = "  ") const;</td>
    <td class="lineNumber">498</td>
    <td class="codeline">  void print(raw_ostream &OS, const_iterator I, StringRef Indent = "  ") const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">  void printSlice(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">499</td>
    <td class="codeline">  void printSlice(raw_ostream &OS, const_iterator I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">                  StringRef Indent = "  ") const;</td>
    <td class="lineNumber">500</td>
    <td class="codeline">                  StringRef Indent = "  ") const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">  void printUse(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">501</td>
    <td class="codeline">  void printUse(raw_ostream &OS, const_iterator I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">                StringRef Indent = "  ") const;</td>
    <td class="lineNumber">502</td>
    <td class="codeline">                StringRef Indent = "  ") const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">  void print(raw_ostream &OS) const;</td>
    <td class="lineNumber">503</td>
    <td class="codeline">  void print(raw_ostream &OS) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">  void dump(const_iterator I) const;</td>
    <td class="lineNumber">504</td>
    <td class="codeline">  void dump(const_iterator I) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline">  void dump() const;</td>
    <td class="lineNumber">505</td>
    <td class="codeline">  void dump() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">506</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline"></td>
    <td class="lineNumber">507</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">508</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  template <typename DerivedT, typename RetT = void> class BuilderBase;</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  template <typename DerivedT, typename RetT = void> class BuilderBase;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">  class SliceBuilder;</td>
    <td class="lineNumber">510</td>
    <td class="codeline">  class SliceBuilder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline"></td>
    <td class="lineNumber">511</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  friend class AllocaSlices::SliceBuilder;</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  friend class AllocaSlices::SliceBuilder;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">514</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">  /// Handle to alloca instruction to simplify method interfaces.</td>
    <td class="lineNumber">515</td>
    <td class="codeline">  /// Handle to alloca instruction to simplify method interfaces.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">  AllocaInst &AI;</td>
    <td class="lineNumber">516</td>
    <td class="codeline">  AllocaInst &AI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">517</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline"></td>
    <td class="lineNumber">518</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  /// The instruction responsible for this alloca not having a known set</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  /// The instruction responsible for this alloca not having a known set</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">  /// of slices.</td>
    <td class="lineNumber">520</td>
    <td class="codeline">  /// of slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">521</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">  /// When an instruction (potentially) escapes the pointer to the alloca, we</td>
    <td class="lineNumber">522</td>
    <td class="codeline">  /// When an instruction (potentially) escapes the pointer to the alloca, we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">  /// store a pointer to that here and abort trying to form slices of the</td>
    <td class="lineNumber">523</td>
    <td class="codeline">  /// store a pointer to that here and abort trying to form slices of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">  /// alloca. This will be null if the alloca slices are analyzed successfully.</td>
    <td class="lineNumber">524</td>
    <td class="codeline">  /// alloca. This will be null if the alloca slices are analyzed successfully.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  Instruction *PointerEscapingInstr;</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  Instruction *PointerEscapingInstr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
    <td class="lineNumber">526</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  /// The slices of the alloca.</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  /// The slices of the alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">528</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">  /// We store a vector of the slices formed by uses of the alloca here. This</td>
    <td class="lineNumber">529</td>
    <td class="codeline">  /// We store a vector of the slices formed by uses of the alloca here. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">  /// vector is sorted by increasing begin offset, and then the unsplittable</td>
    <td class="lineNumber">530</td>
    <td class="codeline">  /// vector is sorted by increasing begin offset, and then the unsplittable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">  /// slices before the splittable ones. See the Slice inner class for more</td>
    <td class="lineNumber">531</td>
    <td class="codeline">  /// slices before the splittable ones. See the Slice inner class for more</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">  /// details.</td>
    <td class="lineNumber">532</td>
    <td class="codeline">  /// details.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">  SmallVector<Slice, 8> Slices;</td>
    <td class="lineNumber">533</td>
    <td class="codeline">  SmallVector<Slice, 8> Slices;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline"></td>
    <td class="lineNumber">534</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">  /// Instructions which will become dead if we rewrite the alloca.</td>
    <td class="lineNumber">535</td>
    <td class="codeline">  /// Instructions which will become dead if we rewrite the alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  /// Note that these are not separated by slice. This is because we expect an</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  /// Note that these are not separated by slice. This is because we expect an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">  /// alloca to be completely rewritten or not rewritten at all. If rewritten,</td>
    <td class="lineNumber">538</td>
    <td class="codeline">  /// alloca to be completely rewritten or not rewritten at all. If rewritten,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">  /// all these instructions can simply be removed and replaced with poison as</td>
    <td class="lineNumber">539</td>
    <td class="codeline">  /// all these instructions can simply be removed and replaced with poison as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline">  /// they come from outside of the allocated space.</td>
    <td class="lineNumber">540</td>
    <td class="codeline">  /// they come from outside of the allocated space.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  SmallVector<Instruction *, 8> DeadUsers;</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  SmallVector<Instruction *, 8> DeadUsers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline"></td>
    <td class="lineNumber">542</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">  /// Uses which will become dead if can promote the alloca.</td>
    <td class="lineNumber">543</td>
    <td class="codeline">  /// Uses which will become dead if can promote the alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">  SmallVector<Use *, 8> DeadUseIfPromotable;</td>
    <td class="lineNumber">544</td>
    <td class="codeline">  SmallVector<Use *, 8> DeadUseIfPromotable;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline"></td>
    <td class="lineNumber">545</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">  /// Operands which will become dead if we rewrite the alloca.</td>
    <td class="lineNumber">546</td>
    <td class="codeline">  /// Operands which will become dead if we rewrite the alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">547</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline">  /// These are operands that in their particular use can be replaced with</td>
    <td class="lineNumber">548</td>
    <td class="codeline">  /// These are operands that in their particular use can be replaced with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">  /// poison when we rewrite the alloca. These show up in out-of-bounds inputs</td>
    <td class="lineNumber">549</td>
    <td class="codeline">  /// poison when we rewrite the alloca. These show up in out-of-bounds inputs</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">  /// to PHI nodes and the like. They aren't entirely dead (there might be</td>
    <td class="lineNumber">550</td>
    <td class="codeline">  /// to PHI nodes and the like. They aren't entirely dead (there might be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline">  /// a GEP back into the bounds using it elsewhere) and nor is the PHI, but we</td>
    <td class="lineNumber">551</td>
    <td class="codeline">  /// a GEP back into the bounds using it elsewhere) and nor is the PHI, but we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">  /// want to swap this particular input for poison to simplify the use lists of</td>
    <td class="lineNumber">552</td>
    <td class="codeline">  /// want to swap this particular input for poison to simplify the use lists of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">  /// the alloca.</td>
    <td class="lineNumber">553</td>
    <td class="codeline">  /// the alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">  SmallVector<Use *, 8> DeadOperands;</td>
    <td class="lineNumber">554</td>
    <td class="codeline">  SmallVector<Use *, 8> DeadOperands;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">};</td>
    <td class="lineNumber">555</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline"></td>
    <td class="lineNumber">556</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">/// A partition of the slices.</td>
    <td class="lineNumber">557</td>
    <td class="codeline">/// A partition of the slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">///</td>
    <td class="lineNumber">558</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">/// An ephemeral representation for a range of slices which can be viewed as</td>
    <td class="lineNumber">559</td>
    <td class="codeline">/// An ephemeral representation for a range of slices which can be viewed as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">/// a partition of the alloca. This range represents a span of the alloca's</td>
    <td class="lineNumber">560</td>
    <td class="codeline">/// a partition of the alloca. This range represents a span of the alloca's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">/// memory which cannot be split, and provides access to all of the slices</td>
    <td class="lineNumber">561</td>
    <td class="codeline">/// memory which cannot be split, and provides access to all of the slices</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">/// overlapping some part of the partition.</td>
    <td class="lineNumber">562</td>
    <td class="codeline">/// overlapping some part of the partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">///</td>
    <td class="lineNumber">563</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">/// Objects of this type are produced by traversing the alloca's slices, but</td>
    <td class="lineNumber">564</td>
    <td class="codeline">/// Objects of this type are produced by traversing the alloca's slices, but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">/// are only ephemeral and not persistent.</td>
    <td class="lineNumber">565</td>
    <td class="codeline">/// are only ephemeral and not persistent.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">class llvm::sroa::Partition {</td>
    <td class="lineNumber">566</td>
    <td class="codeline">class llvm::sroa::Partition {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">567</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">  friend class AllocaSlices;</td>
    <td class="lineNumber">568</td>
    <td class="codeline">  friend class AllocaSlices;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">  friend class AllocaSlices::partition_iterator;</td>
    <td class="lineNumber">569</td>
    <td class="codeline">  friend class AllocaSlices::partition_iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline"></td>
    <td class="lineNumber">570</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">  using iterator = AllocaSlices::iterator;</td>
    <td class="lineNumber">571</td>
    <td class="codeline">  using iterator = AllocaSlices::iterator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline"></td>
    <td class="lineNumber">572</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">  /// The beginning and ending offsets of the alloca for this</td>
    <td class="lineNumber">573</td>
    <td class="codeline">  /// The beginning and ending offsets of the alloca for this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">  /// partition.</td>
    <td class="lineNumber">574</td>
    <td class="codeline">  /// partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">  uint64_t BeginOffset = 0, EndOffset = 0;</td>
    <td class="lineNumber">575</td>
    <td class="codeline">  uint64_t BeginOffset = 0, EndOffset = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline"></td>
    <td class="lineNumber">576</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  /// The start and end iterators of this partition.</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  /// The start and end iterators of this partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">  iterator SI, SJ;</td>
    <td class="lineNumber">578</td>
    <td class="codeline">  iterator SI, SJ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
    <td class="lineNumber">579</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">  /// A collection of split slice tails overlapping the partition.</td>
    <td class="lineNumber">580</td>
    <td class="codeline">  /// A collection of split slice tails overlapping the partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">  SmallVector<Slice *, 4> SplitTails;</td>
    <td class="lineNumber">581</td>
    <td class="codeline">  SmallVector<Slice *, 4> SplitTails;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
    <td class="lineNumber">582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">  /// Raw constructor builds an empty partition starting and ending at</td>
    <td class="lineNumber">583</td>
    <td class="codeline">  /// Raw constructor builds an empty partition starting and ending at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">  /// the given iterator.</td>
    <td class="lineNumber">584</td>
    <td class="codeline">  /// the given iterator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">  Partition(iterator SI) : SI(SI), SJ(SI) {}</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  Partition(iterator SI) : SI(SI), SJ(SI) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline"></td>
    <td class="lineNumber">586</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">587</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">  /// The start offset of this partition.</td>
    <td class="lineNumber">588</td>
    <td class="codeline">  /// The start offset of this partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">589</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">  /// All of the contained slices start at or after this offset.</td>
    <td class="lineNumber">590</td>
    <td class="codeline">  /// All of the contained slices start at or after this offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">  uint64_t beginOffset() const { return BeginOffset; }</td>
    <td class="lineNumber">591</td>
    <td class="codeline">  uint64_t beginOffset() const { return BeginOffset; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline"></td>
    <td class="lineNumber">592</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">  /// The end offset of this partition.</td>
    <td class="lineNumber">593</td>
    <td class="codeline">  /// The end offset of this partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">594</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">  /// All of the contained slices end at or before this offset.</td>
    <td class="lineNumber">595</td>
    <td class="codeline">  /// All of the contained slices end at or before this offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  uint64_t endOffset() const { return EndOffset; }</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  uint64_t endOffset() const { return EndOffset; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
    <td class="lineNumber">597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">  /// The size of the partition.</td>
    <td class="lineNumber">598</td>
    <td class="codeline">  /// The size of the partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">  /// Note that this can never be zero.</td>
    <td class="lineNumber">600</td>
    <td class="codeline">  /// Note that this can never be zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">  uint64_t size() const {</td>
    <td class="lineNumber">601</td>
    <td class="codeline">  uint64_t size() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">    assert(BeginOffset < EndOffset && "Partitions must span some bytes!");</td>
    <td class="lineNumber">602</td>
    <td class="codeline">    assert(BeginOffset < EndOffset && "Partitions must span some bytes!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">    return EndOffset - BeginOffset;</td>
    <td class="lineNumber">603</td>
    <td class="codeline">    return EndOffset - BeginOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline"></td>
    <td class="lineNumber">605</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">  /// Test whether this partition contains no slices, and merely spans</td>
    <td class="lineNumber">606</td>
    <td class="codeline">  /// Test whether this partition contains no slices, and merely spans</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">  /// a region occupied by split slices.</td>
    <td class="lineNumber">607</td>
    <td class="codeline">  /// a region occupied by split slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">  bool empty() const { return SI == SJ; }</td>
    <td class="lineNumber">608</td>
    <td class="codeline">  bool empty() const { return SI == SJ; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline"></td>
    <td class="lineNumber">609</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">  /// \name Iterate slices that start within the partition.</td>
    <td class="lineNumber">610</td>
    <td class="codeline">  /// \name Iterate slices that start within the partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">  /// These may be splittable or unsplittable. They have a begin offset >= the</td>
    <td class="lineNumber">611</td>
    <td class="codeline">  /// These may be splittable or unsplittable. They have a begin offset >= the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">  /// partition begin offset.</td>
    <td class="lineNumber">612</td>
    <td class="codeline">  /// partition begin offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">  /// @{</td>
    <td class="lineNumber">613</td>
    <td class="codeline">  /// @{</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">  // FIXME: We should probably define a "concat_iterator" helper and use that</td>
    <td class="lineNumber">614</td>
    <td class="codeline">  // FIXME: We should probably define a "concat_iterator" helper and use that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  // to stitch together pointee_iterators over the split tails and the</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  // to stitch together pointee_iterators over the split tails and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  // contiguous iterators of the partition. That would give a much nicer</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  // contiguous iterators of the partition. That would give a much nicer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">  // interface here. We could then additionally expose filtered iterators for</td>
    <td class="lineNumber">617</td>
    <td class="codeline">  // interface here. We could then additionally expose filtered iterators for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">  // split, unsplit, and unsplittable splices based on the usage patterns.</td>
    <td class="lineNumber">618</td>
    <td class="codeline">  // split, unsplit, and unsplittable splices based on the usage patterns.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">  iterator begin() const { return SI; }</td>
    <td class="lineNumber">619</td>
    <td class="codeline">  iterator begin() const { return SI; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">  iterator end() const { return SJ; }</td>
    <td class="lineNumber">620</td>
    <td class="codeline">  iterator end() const { return SJ; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">  /// @}</td>
    <td class="lineNumber">621</td>
    <td class="codeline">  /// @}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline"></td>
    <td class="lineNumber">622</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">  /// Get the sequence of split slice tails.</td>
    <td class="lineNumber">623</td>
    <td class="codeline">  /// Get the sequence of split slice tails.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">624</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">  /// These tails are of slices which start before this partition but are</td>
    <td class="lineNumber">625</td>
    <td class="codeline">  /// These tails are of slices which start before this partition but are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  /// split and overlap into the partition. We accumulate these while forming</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  /// split and overlap into the partition. We accumulate these while forming</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">  /// partitions.</td>
    <td class="lineNumber">627</td>
    <td class="codeline">  /// partitions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">  ArrayRef<Slice *> splitSliceTails() const { return SplitTails; }</td>
    <td class="lineNumber">628</td>
    <td class="codeline">  ArrayRef<Slice *> splitSliceTails() const { return SplitTails; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">};</td>
    <td class="lineNumber">629</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">/// An iterator over partitions of the alloca's slices.</td>
    <td class="lineNumber">631</td>
    <td class="codeline">/// An iterator over partitions of the alloca's slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">///</td>
    <td class="lineNumber">632</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">/// This iterator implements the core algorithm for partitioning the alloca's</td>
    <td class="lineNumber">633</td>
    <td class="codeline">/// This iterator implements the core algorithm for partitioning the alloca's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">/// slices. It is a forward iterator as we don't support backtracking for</td>
    <td class="lineNumber">634</td>
    <td class="codeline">/// slices. It is a forward iterator as we don't support backtracking for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">/// efficiency reasons, and re-use a single storage area to maintain the</td>
    <td class="lineNumber">635</td>
    <td class="codeline">/// efficiency reasons, and re-use a single storage area to maintain the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">/// current set of split slices.</td>
    <td class="lineNumber">636</td>
    <td class="codeline">/// current set of split slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">///</td>
    <td class="lineNumber">637</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">/// It is templated on the slice iterator type to use so that it can operate</td>
    <td class="lineNumber">638</td>
    <td class="codeline">/// It is templated on the slice iterator type to use so that it can operate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">/// with either const or non-const slice iterators.</td>
    <td class="lineNumber">639</td>
    <td class="codeline">/// with either const or non-const slice iterators.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">class AllocaSlices::partition_iterator</td>
    <td class="lineNumber">640</td>
    <td class="codeline">class AllocaSlices::partition_iterator</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">    : public iterator_facade_base<partition_iterator, std::forward_iterator_tag,</td>
    <td class="lineNumber">641</td>
    <td class="codeline">    : public iterator_facade_base<partition_iterator, std::forward_iterator_tag,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">                                  Partition> {</td>
    <td class="lineNumber">642</td>
    <td class="codeline">                                  Partition> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  friend class AllocaSlices;</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  friend class AllocaSlices;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
    <td class="lineNumber">644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">  /// Most of the state for walking the partitions is held in a class</td>
    <td class="lineNumber">645</td>
    <td class="codeline">  /// Most of the state for walking the partitions is held in a class</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">  /// with a nice interface for examining them.</td>
    <td class="lineNumber">646</td>
    <td class="codeline">  /// with a nice interface for examining them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">  Partition P;</td>
    <td class="lineNumber">647</td>
    <td class="codeline">  Partition P;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline"></td>
    <td class="lineNumber">648</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  /// We need to keep the end of the slices to know when to stop.</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  /// We need to keep the end of the slices to know when to stop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">  AllocaSlices::iterator SE;</td>
    <td class="lineNumber">650</td>
    <td class="codeline">  AllocaSlices::iterator SE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline"></td>
    <td class="lineNumber">651</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">  /// We also need to keep track of the maximum split end offset seen.</td>
    <td class="lineNumber">652</td>
    <td class="codeline">  /// We also need to keep track of the maximum split end offset seen.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">  /// FIXME: Do we really?</td>
    <td class="lineNumber">653</td>
    <td class="codeline">  /// FIXME: Do we really?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">  uint64_t MaxSplitSliceEndOffset = 0;</td>
    <td class="lineNumber">654</td>
    <td class="codeline">  uint64_t MaxSplitSliceEndOffset = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline"></td>
    <td class="lineNumber">655</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  /// Sets the partition to be empty at given iterator, and sets the</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  /// Sets the partition to be empty at given iterator, and sets the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">  /// end iterator.</td>
    <td class="lineNumber">657</td>
    <td class="codeline">  /// end iterator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">  partition_iterator(AllocaSlices::iterator SI, AllocaSlices::iterator SE)</td>
    <td class="lineNumber">658</td>
    <td class="codeline">  partition_iterator(AllocaSlices::iterator SI, AllocaSlices::iterator SE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">      : P(SI), SE(SE) {</td>
    <td class="lineNumber">659</td>
    <td class="codeline">      : P(SI), SE(SE) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">    // If not already at the end, advance our state to form the initial</td>
    <td class="lineNumber">660</td>
    <td class="codeline">    // If not already at the end, advance our state to form the initial</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">    // partition.</td>
    <td class="lineNumber">661</td>
    <td class="codeline">    // partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">    if (SI != SE)</td>
    <td class="lineNumber">662</td>
    <td class="codeline">    if (SI != SE)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">      advance();</td>
    <td class="lineNumber">663</td>
    <td class="codeline">      advance();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">664</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline"></td>
    <td class="lineNumber">665</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">  /// Advance the iterator to the next partition.</td>
    <td class="lineNumber">666</td>
    <td class="codeline">  /// Advance the iterator to the next partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">667</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">  /// Requires that the iterator not be at the end of the slices.</td>
    <td class="lineNumber">668</td>
    <td class="codeline">  /// Requires that the iterator not be at the end of the slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">  void advance() {</td>
    <td class="lineNumber">669</td>
    <td class="codeline">  void advance() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">    assert((P.SI != SE || !P.SplitTails.empty()) &&</td>
    <td class="lineNumber">670</td>
    <td class="codeline">    assert((P.SI != SE || !P.SplitTails.empty()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">           "Cannot advance past the end of the slices!");</td>
    <td class="lineNumber">671</td>
    <td class="codeline">           "Cannot advance past the end of the slices!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">    // Clear out any split uses which have ended.</td>
    <td class="lineNumber">673</td>
    <td class="codeline">    // Clear out any split uses which have ended.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">    if (!P.SplitTails.empty()) {</td>
    <td class="lineNumber">674</td>
    <td class="codeline">    if (!P.SplitTails.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">      if (P.EndOffset >= MaxSplitSliceEndOffset) {</td>
    <td class="lineNumber">675</td>
    <td class="codeline">      if (P.EndOffset >= MaxSplitSliceEndOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">        // If we've finished all splits, this is easy.</td>
    <td class="lineNumber">676</td>
    <td class="codeline">        // If we've finished all splits, this is easy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">        P.SplitTails.clear();</td>
    <td class="lineNumber">677</td>
    <td class="codeline">        P.SplitTails.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline">        MaxSplitSliceEndOffset = 0;</td>
    <td class="lineNumber">678</td>
    <td class="codeline">        MaxSplitSliceEndOffset = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">679</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">        // Remove the uses which have ended in the prior partition. This</td>
    <td class="lineNumber">680</td>
    <td class="codeline">        // Remove the uses which have ended in the prior partition. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">        // cannot change the max split slice end because we just checked that</td>
    <td class="lineNumber">681</td>
    <td class="codeline">        // cannot change the max split slice end because we just checked that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">        // the prior partition ended prior to that max.</td>
    <td class="lineNumber">682</td>
    <td class="codeline">        // the prior partition ended prior to that max.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">        llvm::erase_if(P.SplitTails,</td>
    <td class="lineNumber">683</td>
    <td class="codeline">        llvm::erase_if(P.SplitTails,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">                       [&](Slice *S) { return S->endOffset() <= P.EndOffset; });</td>
    <td class="lineNumber">684</td>
    <td class="codeline">                       [&](Slice *S) { return S->endOffset() <= P.EndOffset; });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">        assert(llvm::any_of(P.SplitTails,</td>
    <td class="lineNumber">685</td>
    <td class="codeline">        assert(llvm::any_of(P.SplitTails,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">                            [&](Slice *S) {</td>
    <td class="lineNumber">686</td>
    <td class="codeline">                            [&](Slice *S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">                              return S->endOffset() == MaxSplitSliceEndOffset;</td>
    <td class="lineNumber">687</td>
    <td class="codeline">                              return S->endOffset() == MaxSplitSliceEndOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline">                            }) &&</td>
    <td class="lineNumber">688</td>
    <td class="codeline">                            }) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">               "Could not find the current max split slice offset!");</td>
    <td class="lineNumber">689</td>
    <td class="codeline">               "Could not find the current max split slice offset!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">        assert(llvm::all_of(P.SplitTails,</td>
    <td class="lineNumber">690</td>
    <td class="codeline">        assert(llvm::all_of(P.SplitTails,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline">                            [&](Slice *S) {</td>
    <td class="lineNumber">691</td>
    <td class="codeline">                            [&](Slice *S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">                              return S->endOffset() <= MaxSplitSliceEndOffset;</td>
    <td class="lineNumber">692</td>
    <td class="codeline">                              return S->endOffset() <= MaxSplitSliceEndOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">                            }) &&</td>
    <td class="lineNumber">693</td>
    <td class="codeline">                            }) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">               "Max split slice end offset is not actually the max!");</td>
    <td class="lineNumber">694</td>
    <td class="codeline">               "Max split slice end offset is not actually the max!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">695</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">696</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
    <td class="lineNumber">697</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">    // If P.SI is already at the end, then we've cleared the split tail and</td>
    <td class="lineNumber">698</td>
    <td class="codeline">    // If P.SI is already at the end, then we've cleared the split tail and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">    // now have an end iterator.</td>
    <td class="lineNumber">699</td>
    <td class="codeline">    // now have an end iterator.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">    if (P.SI == SE) {</td>
    <td class="lineNumber">700</td>
    <td class="codeline">    if (P.SI == SE) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">      assert(P.SplitTails.empty() && "Failed to clear the split slices!");</td>
    <td class="lineNumber">701</td>
    <td class="codeline">      assert(P.SplitTails.empty() && "Failed to clear the split slices!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">702</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">703</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline"></td>
    <td class="lineNumber">704</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">    // If we had a non-empty partition previously, set up the state for</td>
    <td class="lineNumber">705</td>
    <td class="codeline">    // If we had a non-empty partition previously, set up the state for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">    // subsequent partitions.</td>
    <td class="lineNumber">706</td>
    <td class="codeline">    // subsequent partitions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">    if (P.SI != P.SJ) {</td>
    <td class="lineNumber">707</td>
    <td class="codeline">    if (P.SI != P.SJ) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">      // Accumulate all the splittable slices which started in the old</td>
    <td class="lineNumber">708</td>
    <td class="codeline">      // Accumulate all the splittable slices which started in the old</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">      // partition into the split list.</td>
    <td class="lineNumber">709</td>
    <td class="codeline">      // partition into the split list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">      for (Slice &S : P)</td>
    <td class="lineNumber">710</td>
    <td class="codeline">      for (Slice &S : P)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">        if (S.isSplittable() && S.endOffset() > P.EndOffset) {</td>
    <td class="lineNumber">711</td>
    <td class="codeline">        if (S.isSplittable() && S.endOffset() > P.EndOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">          P.SplitTails.push_back(&S);</td>
    <td class="lineNumber">712</td>
    <td class="codeline">          P.SplitTails.push_back(&S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">          MaxSplitSliceEndOffset =</td>
    <td class="lineNumber">713</td>
    <td class="codeline">          MaxSplitSliceEndOffset =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">              std::max(S.endOffset(), MaxSplitSliceEndOffset);</td>
    <td class="lineNumber">714</td>
    <td class="codeline">              std::max(S.endOffset(), MaxSplitSliceEndOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">715</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline"></td>
    <td class="lineNumber">716</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">      // Start from the end of the previous partition.</td>
    <td class="lineNumber">717</td>
    <td class="codeline">      // Start from the end of the previous partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">      P.SI = P.SJ;</td>
    <td class="lineNumber">718</td>
    <td class="codeline">      P.SI = P.SJ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline"></td>
    <td class="lineNumber">719</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">      // If P.SI is now at the end, we at most have a tail of split slices.</td>
    <td class="lineNumber">720</td>
    <td class="codeline">      // If P.SI is now at the end, we at most have a tail of split slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">      if (P.SI == SE) {</td>
    <td class="lineNumber">721</td>
    <td class="codeline">      if (P.SI == SE) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">        P.BeginOffset = P.EndOffset;</td>
    <td class="lineNumber">722</td>
    <td class="codeline">        P.BeginOffset = P.EndOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">        P.EndOffset = MaxSplitSliceEndOffset;</td>
    <td class="lineNumber">723</td>
    <td class="codeline">        P.EndOffset = MaxSplitSliceEndOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">        return;</td>
    <td class="lineNumber">724</td>
    <td class="codeline">        return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">725</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
    <td class="lineNumber">726</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">      // If the we have split slices and the next slice is after a gap and is</td>
    <td class="lineNumber">727</td>
    <td class="codeline">      // If the we have split slices and the next slice is after a gap and is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">      // not splittable immediately form an empty partition for the split</td>
    <td class="lineNumber">728</td>
    <td class="codeline">      // not splittable immediately form an empty partition for the split</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">      // slices up until the next slice begins.</td>
    <td class="lineNumber">729</td>
    <td class="codeline">      // slices up until the next slice begins.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">      if (!P.SplitTails.empty() && P.SI->beginOffset() != P.EndOffset &&</td>
    <td class="lineNumber">730</td>
    <td class="codeline">      if (!P.SplitTails.empty() && P.SI->beginOffset() != P.EndOffset &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">          !P.SI->isSplittable()) {</td>
    <td class="lineNumber">731</td>
    <td class="codeline">          !P.SI->isSplittable()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">        P.BeginOffset = P.EndOffset;</td>
    <td class="lineNumber">732</td>
    <td class="codeline">        P.BeginOffset = P.EndOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">        P.EndOffset = P.SI->beginOffset();</td>
    <td class="lineNumber">733</td>
    <td class="codeline">        P.EndOffset = P.SI->beginOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">        return;</td>
    <td class="lineNumber">734</td>
    <td class="codeline">        return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">735</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">736</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">    // OK, we need to consume new slices. Set the end offset based on the</td>
    <td class="lineNumber">738</td>
    <td class="codeline">    // OK, we need to consume new slices. Set the end offset based on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">    // current slice, and step SJ past it. The beginning offset of the</td>
    <td class="lineNumber">739</td>
    <td class="codeline">    // current slice, and step SJ past it. The beginning offset of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">    // partition is the beginning offset of the next slice unless we have</td>
    <td class="lineNumber">740</td>
    <td class="codeline">    // partition is the beginning offset of the next slice unless we have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">    // pre-existing split slices that are continuing, in which case we begin</td>
    <td class="lineNumber">741</td>
    <td class="codeline">    // pre-existing split slices that are continuing, in which case we begin</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">    // at the prior end offset.</td>
    <td class="lineNumber">742</td>
    <td class="codeline">    // at the prior end offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">    P.BeginOffset = P.SplitTails.empty() ? P.SI->beginOffset() : P.EndOffset;</td>
    <td class="lineNumber">743</td>
    <td class="codeline">    P.BeginOffset = P.SplitTails.empty() ? P.SI->beginOffset() : P.EndOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">    P.EndOffset = P.SI->endOffset();</td>
    <td class="lineNumber">744</td>
    <td class="codeline">    P.EndOffset = P.SI->endOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">    ++P.SJ;</td>
    <td class="lineNumber">745</td>
    <td class="codeline">    ++P.SJ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
    <td class="lineNumber">746</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">    // There are two strategies to form a partition based on whether the</td>
    <td class="lineNumber">747</td>
    <td class="codeline">    // There are two strategies to form a partition based on whether the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">    // partition starts with an unsplittable slice or a splittable slice.</td>
    <td class="lineNumber">748</td>
    <td class="codeline">    // partition starts with an unsplittable slice or a splittable slice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">    if (!P.SI->isSplittable()) {</td>
    <td class="lineNumber">749</td>
    <td class="codeline">    if (!P.SI->isSplittable()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">      // When we're forming an unsplittable region, it must always start at</td>
    <td class="lineNumber">750</td>
    <td class="codeline">      // When we're forming an unsplittable region, it must always start at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">      // the first slice and will extend through its end.</td>
    <td class="lineNumber">751</td>
    <td class="codeline">      // the first slice and will extend through its end.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">      assert(P.BeginOffset == P.SI->beginOffset());</td>
    <td class="lineNumber">752</td>
    <td class="codeline">      assert(P.BeginOffset == P.SI->beginOffset());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline"></td>
    <td class="lineNumber">753</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">      // Form a partition including all of the overlapping slices with this</td>
    <td class="lineNumber">754</td>
    <td class="codeline">      // Form a partition including all of the overlapping slices with this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">      // unsplittable slice.</td>
    <td class="lineNumber">755</td>
    <td class="codeline">      // unsplittable slice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">      while (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset) {</td>
    <td class="lineNumber">756</td>
    <td class="codeline">      while (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">        if (!P.SJ->isSplittable())</td>
    <td class="lineNumber">757</td>
    <td class="codeline">        if (!P.SJ->isSplittable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">          P.EndOffset = std::max(P.EndOffset, P.SJ->endOffset());</td>
    <td class="lineNumber">758</td>
    <td class="codeline">          P.EndOffset = std::max(P.EndOffset, P.SJ->endOffset());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">        ++P.SJ;</td>
    <td class="lineNumber">759</td>
    <td class="codeline">        ++P.SJ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">760</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline"></td>
    <td class="lineNumber">761</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">      // We have a partition across a set of overlapping unsplittable</td>
    <td class="lineNumber">762</td>
    <td class="codeline">      // We have a partition across a set of overlapping unsplittable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">      // partitions.</td>
    <td class="lineNumber">763</td>
    <td class="codeline">      // partitions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">764</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">765</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">    // If we're starting with a splittable slice, then we need to form</td>
    <td class="lineNumber">767</td>
    <td class="codeline">    // If we're starting with a splittable slice, then we need to form</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">    // a synthetic partition spanning it and any other overlapping splittable</td>
    <td class="lineNumber">768</td>
    <td class="codeline">    // a synthetic partition spanning it and any other overlapping splittable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">    // splices.</td>
    <td class="lineNumber">769</td>
    <td class="codeline">    // splices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">    assert(P.SI->isSplittable() && "Forming a splittable partition!");</td>
    <td class="lineNumber">770</td>
    <td class="codeline">    assert(P.SI->isSplittable() && "Forming a splittable partition!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
    <td class="lineNumber">771</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">    // Collect all of the overlapping splittable slices.</td>
    <td class="lineNumber">772</td>
    <td class="codeline">    // Collect all of the overlapping splittable slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">    while (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset &&</td>
    <td class="lineNumber">773</td>
    <td class="codeline">    while (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">           P.SJ->isSplittable()) {</td>
    <td class="lineNumber">774</td>
    <td class="codeline">           P.SJ->isSplittable()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">      P.EndOffset = std::max(P.EndOffset, P.SJ->endOffset());</td>
    <td class="lineNumber">775</td>
    <td class="codeline">      P.EndOffset = std::max(P.EndOffset, P.SJ->endOffset());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline">      ++P.SJ;</td>
    <td class="lineNumber">776</td>
    <td class="codeline">      ++P.SJ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">777</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
    <td class="lineNumber">778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline">    // Back upiP.EndOffset if we ended the span early when encountering an</td>
    <td class="lineNumber">779</td>
    <td class="codeline">    // Back upiP.EndOffset if we ended the span early when encountering an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">    // unsplittable slice. This synthesizes the early end offset of</td>
    <td class="lineNumber">780</td>
    <td class="codeline">    // unsplittable slice. This synthesizes the early end offset of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">    // a partition spanning only splittable slices.</td>
    <td class="lineNumber">781</td>
    <td class="codeline">    // a partition spanning only splittable slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">    if (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset) {</td>
    <td class="lineNumber">782</td>
    <td class="codeline">    if (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">      assert(!P.SJ->isSplittable());</td>
    <td class="lineNumber">783</td>
    <td class="codeline">      assert(!P.SJ->isSplittable());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">      P.EndOffset = P.SJ->beginOffset();</td>
    <td class="lineNumber">784</td>
    <td class="codeline">      P.EndOffset = P.SJ->beginOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">785</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">786</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline"></td>
    <td class="lineNumber">787</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">788</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">  bool operator==(const partition_iterator &RHS) const {</td>
    <td class="lineNumber">789</td>
    <td class="codeline">  bool operator==(const partition_iterator &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">    assert(SE == RHS.SE &&</td>
    <td class="lineNumber">790</td>
    <td class="codeline">    assert(SE == RHS.SE &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">           "End iterators don't match between compared partition iterators!");</td>
    <td class="lineNumber">791</td>
    <td class="codeline">           "End iterators don't match between compared partition iterators!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline"></td>
    <td class="lineNumber">792</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">    // The observed positions of partitions is marked by the P.SI iterator and</td>
    <td class="lineNumber">793</td>
    <td class="codeline">    // The observed positions of partitions is marked by the P.SI iterator and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">    // the emptiness of the split slices. The latter is only relevant when</td>
    <td class="lineNumber">794</td>
    <td class="codeline">    // the emptiness of the split slices. The latter is only relevant when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">    // P.SI == SE, as the end iterator will additionally have an empty split</td>
    <td class="lineNumber">795</td>
    <td class="codeline">    // P.SI == SE, as the end iterator will additionally have an empty split</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">    // slices list, but the prior may have the same P.SI and a tail of split</td>
    <td class="lineNumber">796</td>
    <td class="codeline">    // slices list, but the prior may have the same P.SI and a tail of split</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">    // slices.</td>
    <td class="lineNumber">797</td>
    <td class="codeline">    // slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">    if (P.SI == RHS.P.SI && P.SplitTails.empty() == RHS.P.SplitTails.empty()) {</td>
    <td class="lineNumber">798</td>
    <td class="codeline">    if (P.SI == RHS.P.SI && P.SplitTails.empty() == RHS.P.SplitTails.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">      assert(P.SJ == RHS.P.SJ &&</td>
    <td class="lineNumber">799</td>
    <td class="codeline">      assert(P.SJ == RHS.P.SJ &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">             "Same set of slices formed two different sized partitions!");</td>
    <td class="lineNumber">800</td>
    <td class="codeline">             "Same set of slices formed two different sized partitions!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">      assert(P.SplitTails.size() == RHS.P.SplitTails.size() &&</td>
    <td class="lineNumber">801</td>
    <td class="codeline">      assert(P.SplitTails.size() == RHS.P.SplitTails.size() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">             "Same slice position with differently sized non-empty split "</td>
    <td class="lineNumber">802</td>
    <td class="codeline">             "Same slice position with differently sized non-empty split "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">             "slice tails!");</td>
    <td class="lineNumber">803</td>
    <td class="codeline">             "slice tails!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">804</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">805</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">806</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">807</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline"></td>
    <td class="lineNumber">808</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">  partition_iterator &operator++() {</td>
    <td class="lineNumber">809</td>
    <td class="codeline">  partition_iterator &operator++() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">    advance();</td>
    <td class="lineNumber">810</td>
    <td class="codeline">    advance();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">    return *this;</td>
    <td class="lineNumber">811</td>
    <td class="codeline">    return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">812</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline"></td>
    <td class="lineNumber">813</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">  Partition &operator*() { return P; }</td>
    <td class="lineNumber">814</td>
    <td class="codeline">  Partition &operator*() { return P; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">};</td>
    <td class="lineNumber">815</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline"></td>
    <td class="lineNumber">816</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">/// A forward range over the partitions of the alloca's slices.</td>
    <td class="lineNumber">817</td>
    <td class="codeline">/// A forward range over the partitions of the alloca's slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">///</td>
    <td class="lineNumber">818</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">/// This accesses an iterator range over the partitions of the alloca's</td>
    <td class="lineNumber">819</td>
    <td class="codeline">/// This accesses an iterator range over the partitions of the alloca's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">/// slices. It computes these partitions on the fly based on the overlapping</td>
    <td class="lineNumber">820</td>
    <td class="codeline">/// slices. It computes these partitions on the fly based on the overlapping</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">/// offsets of the slices and the ability to split them. It will visit "empty"</td>
    <td class="lineNumber">821</td>
    <td class="codeline">/// offsets of the slices and the ability to split them. It will visit "empty"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">/// partitions to cover regions of the alloca only accessed via split</td>
    <td class="lineNumber">822</td>
    <td class="codeline">/// partitions to cover regions of the alloca only accessed via split</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">/// slices.</td>
    <td class="lineNumber">823</td>
    <td class="codeline">/// slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">iterator_range<AllocaSlices::partition_iterator> AllocaSlices::partitions() {</td>
    <td class="lineNumber">824</td>
    <td class="codeline">iterator_range<AllocaSlices::partition_iterator> AllocaSlices::partitions() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">  return make_range(partition_iterator(begin(), end()),</td>
    <td class="lineNumber">825</td>
    <td class="codeline">  return make_range(partition_iterator(begin(), end()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">                    partition_iterator(end(), end()));</td>
    <td class="lineNumber">826</td>
    <td class="codeline">                    partition_iterator(end(), end()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">}</td>
    <td class="lineNumber">827</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline"></td>
    <td class="lineNumber">828</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">static Value *foldSelectInst(SelectInst &SI) {</td>
    <td class="lineNumber">829</td>
    <td class="codeline">static Value *foldSelectInst(SelectInst &SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">  // If the condition being selected on is a constant or the same value is</td>
    <td class="lineNumber">830</td>
    <td class="codeline">  // If the condition being selected on is a constant or the same value is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">  // being selected between, fold the select. Yes this does (rarely) happen</td>
    <td class="lineNumber">831</td>
    <td class="codeline">  // being selected between, fold the select. Yes this does (rarely) happen</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">  // early on.</td>
    <td class="lineNumber">832</td>
    <td class="codeline">  // early on.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline">  if (ConstantInt *CI = dyn_cast<ConstantInt>(SI.getCondition()))</td>
    <td class="lineNumber">833</td>
    <td class="codeline">  if (ConstantInt *CI = dyn_cast<ConstantInt>(SI.getCondition()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">    return SI.getOperand(1 + CI->isZero());</td>
    <td class="lineNumber">834</td>
    <td class="codeline">    return SI.getOperand(1 + CI->isZero());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">  if (SI.getOperand(1) == SI.getOperand(2))</td>
    <td class="lineNumber">835</td>
    <td class="codeline">  if (SI.getOperand(1) == SI.getOperand(2))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">    return SI.getOperand(1);</td>
    <td class="lineNumber">836</td>
    <td class="codeline">    return SI.getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline"></td>
    <td class="lineNumber">837</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">838</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">}</td>
    <td class="lineNumber">839</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline"></td>
    <td class="lineNumber">840</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">/// A helper that folds a PHI node or a select.</td>
    <td class="lineNumber">841</td>
    <td class="codeline">/// A helper that folds a PHI node or a select.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">static Value *foldPHINodeOrSelectInst(Instruction &I) {</td>
    <td class="lineNumber">842</td>
    <td class="codeline">static Value *foldPHINodeOrSelectInst(Instruction &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">  if (PHINode *PN = dyn_cast<PHINode>(&I)) {</td>
    <td class="lineNumber">843</td>
    <td class="codeline">  if (PHINode *PN = dyn_cast<PHINode>(&I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">    // If PN merges together the same value, return that value.</td>
    <td class="lineNumber">844</td>
    <td class="codeline">    // If PN merges together the same value, return that value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">    return PN->hasConstantValue();</td>
    <td class="lineNumber">845</td>
    <td class="codeline">    return PN->hasConstantValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">846</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  return foldSelectInst(cast<SelectInst>(I));</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  return foldSelectInst(cast<SelectInst>(I));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">}</td>
    <td class="lineNumber">848</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline"></td>
    <td class="lineNumber">849</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">/// Builder for the alloca slices.</td>
    <td class="lineNumber">850</td>
    <td class="codeline">/// Builder for the alloca slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">///</td>
    <td class="lineNumber">851</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">/// This class builds a set of alloca slices by recursively visiting the uses</td>
    <td class="lineNumber">852</td>
    <td class="codeline">/// This class builds a set of alloca slices by recursively visiting the uses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">/// of an alloca and making a slice for each load and store at each offset.</td>
    <td class="lineNumber">853</td>
    <td class="codeline">/// of an alloca and making a slice for each load and store at each offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">class AllocaSlices::SliceBuilder : public PtrUseVisitor<SliceBuilder> {</td>
    <td class="lineNumber">854</td>
    <td class="codeline">class AllocaSlices::SliceBuilder : public PtrUseVisitor<SliceBuilder> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">  friend class PtrUseVisitor<SliceBuilder>;</td>
    <td class="lineNumber">855</td>
    <td class="codeline">  friend class PtrUseVisitor<SliceBuilder>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">  friend class InstVisitor<SliceBuilder>;</td>
    <td class="lineNumber">856</td>
    <td class="codeline">  friend class InstVisitor<SliceBuilder>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline"></td>
    <td class="lineNumber">857</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">  using Base = PtrUseVisitor<SliceBuilder>;</td>
    <td class="lineNumber">858</td>
    <td class="codeline">  using Base = PtrUseVisitor<SliceBuilder>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline"></td>
    <td class="lineNumber">859</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">  const uint64_t AllocSize;</td>
    <td class="lineNumber">860</td>
    <td class="codeline">  const uint64_t AllocSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">  AllocaSlices &AS;</td>
    <td class="lineNumber">861</td>
    <td class="codeline">  AllocaSlices &AS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline"></td>
    <td class="lineNumber">862</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">  SmallDenseMap<Instruction *, unsigned> MemTransferSliceMap;</td>
    <td class="lineNumber">863</td>
    <td class="codeline">  SmallDenseMap<Instruction *, unsigned> MemTransferSliceMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">  SmallDenseMap<Instruction *, uint64_t> PHIOrSelectSizes;</td>
    <td class="lineNumber">864</td>
    <td class="codeline">  SmallDenseMap<Instruction *, uint64_t> PHIOrSelectSizes;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline"></td>
    <td class="lineNumber">865</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">  /// Set to de-duplicate dead instructions found in the use walk.</td>
    <td class="lineNumber">866</td>
    <td class="codeline">  /// Set to de-duplicate dead instructions found in the use walk.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">  SmallPtrSet<Instruction *, 4> VisitedDeadInsts;</td>
    <td class="lineNumber">867</td>
    <td class="codeline">  SmallPtrSet<Instruction *, 4> VisitedDeadInsts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline"></td>
    <td class="lineNumber">868</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">869</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  SliceBuilder(const DataLayout &DL, AllocaInst &AI, AllocaSlices &AS)</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  SliceBuilder(const DataLayout &DL, AllocaInst &AI, AllocaSlices &AS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">      : PtrUseVisitor<SliceBuilder>(DL),</td>
    <td class="lineNumber">871</td>
    <td class="codeline">      : PtrUseVisitor<SliceBuilder>(DL),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">        AllocSize(DL.getTypeAllocSize(AI.getAllocatedType()).getFixedValue()),</td>
    <td class="lineNumber">872</td>
    <td class="codeline">        AllocSize(DL.getTypeAllocSize(AI.getAllocatedType()).getFixedValue()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">        AS(AS) {}</td>
    <td class="lineNumber">873</td>
    <td class="codeline">        AS(AS) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
    <td class="lineNumber">874</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">875</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  void markAsDead(Instruction &I) {</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  void markAsDead(Instruction &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">    if (VisitedDeadInsts.insert(&I).second)</td>
    <td class="lineNumber">877</td>
    <td class="codeline">    if (VisitedDeadInsts.insert(&I).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline">      AS.DeadUsers.push_back(&I);</td>
    <td class="lineNumber">878</td>
    <td class="codeline">      AS.DeadUsers.push_back(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">879</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline"></td>
    <td class="lineNumber">880</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">  void insertUse(Instruction &I, const APInt &Offset, uint64_t Size,</td>
    <td class="lineNumber">881</td>
    <td class="codeline">  void insertUse(Instruction &I, const APInt &Offset, uint64_t Size,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">                 bool IsSplittable = false) {</td>
    <td class="lineNumber">882</td>
    <td class="codeline">                 bool IsSplittable = false) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">    // Completely skip uses which have a zero size or start either before or</td>
    <td class="lineNumber">883</td>
    <td class="codeline">    // Completely skip uses which have a zero size or start either before or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">    // past the end of the allocation.</td>
    <td class="lineNumber">884</td>
    <td class="codeline">    // past the end of the allocation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">    if (Size == 0 || Offset.uge(AllocSize)) {</td>
    <td class="lineNumber">885</td>
    <td class="codeline">    if (Size == 0 || Offset.uge(AllocSize)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "WARNING: Ignoring " << Size << " byte use @"</td>
    <td class="lineNumber">886</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "WARNING: Ignoring " << Size << " byte use @"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">                        << Offset</td>
    <td class="lineNumber">887</td>
    <td class="codeline">                        << Offset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">                        << " which has zero size or starts outside of the "</td>
    <td class="lineNumber">888</td>
    <td class="codeline">                        << " which has zero size or starts outside of the "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">                        << AllocSize << " byte alloca:\n"</td>
    <td class="lineNumber">889</td>
    <td class="codeline">                        << AllocSize << " byte alloca:\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline">                        << "    alloca: " << AS.AI << "\n"</td>
    <td class="lineNumber">890</td>
    <td class="codeline">                        << "    alloca: " << AS.AI << "\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">                        << "       use: " << I << "\n");</td>
    <td class="lineNumber">891</td>
    <td class="codeline">                        << "       use: " << I << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">      return markAsDead(I);</td>
    <td class="lineNumber">892</td>
    <td class="codeline">      return markAsDead(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">893</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline"></td>
    <td class="lineNumber">894</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">    uint64_t BeginOffset = Offset.getZExtValue();</td>
    <td class="lineNumber">895</td>
    <td class="codeline">    uint64_t BeginOffset = Offset.getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">    uint64_t EndOffset = BeginOffset + Size;</td>
    <td class="lineNumber">896</td>
    <td class="codeline">    uint64_t EndOffset = BeginOffset + Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline"></td>
    <td class="lineNumber">897</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">    // Clamp the end offset to the end of the allocation. Note that this is</td>
    <td class="lineNumber">898</td>
    <td class="codeline">    // Clamp the end offset to the end of the allocation. Note that this is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">    // formulated to handle even the case where "BeginOffset + Size" overflows.</td>
    <td class="lineNumber">899</td>
    <td class="codeline">    // formulated to handle even the case where "BeginOffset + Size" overflows.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">    // This may appear superficially to be something we could ignore entirely,</td>
    <td class="lineNumber">900</td>
    <td class="codeline">    // This may appear superficially to be something we could ignore entirely,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">    // but that is not so! There may be widened loads or PHI-node uses where</td>
    <td class="lineNumber">901</td>
    <td class="codeline">    // but that is not so! There may be widened loads or PHI-node uses where</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">    // some instructions are dead but not others. We can't completely ignore</td>
    <td class="lineNumber">902</td>
    <td class="codeline">    // some instructions are dead but not others. We can't completely ignore</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">    // them, and so have to record at least the information here.</td>
    <td class="lineNumber">903</td>
    <td class="codeline">    // them, and so have to record at least the information here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">    assert(AllocSize >= BeginOffset); // Established above.</td>
    <td class="lineNumber">904</td>
    <td class="codeline">    assert(AllocSize >= BeginOffset); // Established above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline">    if (Size > AllocSize - BeginOffset) {</td>
    <td class="lineNumber">905</td>
    <td class="codeline">    if (Size > AllocSize - BeginOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "WARNING: Clamping a " << Size << " byte use @"</td>
    <td class="lineNumber">906</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "WARNING: Clamping a " << Size << " byte use @"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">                        << Offset << " to remain within the " << AllocSize</td>
    <td class="lineNumber">907</td>
    <td class="codeline">                        << Offset << " to remain within the " << AllocSize</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">                        << " byte alloca:\n"</td>
    <td class="lineNumber">908</td>
    <td class="codeline">                        << " byte alloca:\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">                        << "    alloca: " << AS.AI << "\n"</td>
    <td class="lineNumber">909</td>
    <td class="codeline">                        << "    alloca: " << AS.AI << "\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">                        << "       use: " << I << "\n");</td>
    <td class="lineNumber">910</td>
    <td class="codeline">                        << "       use: " << I << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">      EndOffset = AllocSize;</td>
    <td class="lineNumber">911</td>
    <td class="codeline">      EndOffset = AllocSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">912</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline"></td>
    <td class="lineNumber">913</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">    AS.Slices.push_back(Slice(BeginOffset, EndOffset, U, IsSplittable));</td>
    <td class="lineNumber">914</td>
    <td class="codeline">    AS.Slices.push_back(Slice(BeginOffset, EndOffset, U, IsSplittable));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">915</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
    <td class="lineNumber">916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline">  void visitBitCastInst(BitCastInst &BC) {</td>
    <td class="lineNumber">917</td>
    <td class="codeline">  void visitBitCastInst(BitCastInst &BC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">    if (BC.use_empty())</td>
    <td class="lineNumber">918</td>
    <td class="codeline">    if (BC.use_empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">      return markAsDead(BC);</td>
    <td class="lineNumber">919</td>
    <td class="codeline">      return markAsDead(BC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline"></td>
    <td class="lineNumber">920</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline">    return Base::visitBitCastInst(BC);</td>
    <td class="lineNumber">921</td>
    <td class="codeline">    return Base::visitBitCastInst(BC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">922</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline"></td>
    <td class="lineNumber">923</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">  void visitAddrSpaceCastInst(AddrSpaceCastInst &ASC) {</td>
    <td class="lineNumber">924</td>
    <td class="codeline">  void visitAddrSpaceCastInst(AddrSpaceCastInst &ASC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">    if (ASC.use_empty())</td>
    <td class="lineNumber">925</td>
    <td class="codeline">    if (ASC.use_empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">      return markAsDead(ASC);</td>
    <td class="lineNumber">926</td>
    <td class="codeline">      return markAsDead(ASC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline"></td>
    <td class="lineNumber">927</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline">    return Base::visitAddrSpaceCastInst(ASC);</td>
    <td class="lineNumber">928</td>
    <td class="codeline">    return Base::visitAddrSpaceCastInst(ASC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">929</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline"></td>
    <td class="lineNumber">930</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">  void visitGetElementPtrInst(GetElementPtrInst &GEPI) {</td>
    <td class="lineNumber">931</td>
    <td class="codeline">  void visitGetElementPtrInst(GetElementPtrInst &GEPI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">    if (GEPI.use_empty())</td>
    <td class="lineNumber">932</td>
    <td class="codeline">    if (GEPI.use_empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">      return markAsDead(GEPI);</td>
    <td class="lineNumber">933</td>
    <td class="codeline">      return markAsDead(GEPI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline"></td>
    <td class="lineNumber">934</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">    if (SROAStrictInbounds && GEPI.isInBounds()) {</td>
    <td class="lineNumber">935</td>
    <td class="codeline">    if (SROAStrictInbounds && GEPI.isInBounds()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">      // FIXME: This is a manually un-factored variant of the basic code inside</td>
    <td class="lineNumber">936</td>
    <td class="codeline">      // FIXME: This is a manually un-factored variant of the basic code inside</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">      // of GEPs with checking of the inbounds invariant specified in the</td>
    <td class="lineNumber">937</td>
    <td class="codeline">      // of GEPs with checking of the inbounds invariant specified in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">      // langref in a very strict sense. If we ever want to enable</td>
    <td class="lineNumber">938</td>
    <td class="codeline">      // langref in a very strict sense. If we ever want to enable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">      // SROAStrictInbounds, this code should be factored cleanly into</td>
    <td class="lineNumber">939</td>
    <td class="codeline">      // SROAStrictInbounds, this code should be factored cleanly into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline">      // PtrUseVisitor, but it is easier to experiment with SROAStrictInbounds</td>
    <td class="lineNumber">940</td>
    <td class="codeline">      // PtrUseVisitor, but it is easier to experiment with SROAStrictInbounds</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">      // by writing out the code here where we have the underlying allocation</td>
    <td class="lineNumber">941</td>
    <td class="codeline">      // by writing out the code here where we have the underlying allocation</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">      // size readily available.</td>
    <td class="lineNumber">942</td>
    <td class="codeline">      // size readily available.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">      APInt GEPOffset = Offset;</td>
    <td class="lineNumber">943</td>
    <td class="codeline">      APInt GEPOffset = Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">      const DataLayout &DL = GEPI.getModule()->getDataLayout();</td>
    <td class="lineNumber">944</td>
    <td class="codeline">      const DataLayout &DL = GEPI.getModule()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline">      for (gep_type_iterator GTI = gep_type_begin(GEPI),</td>
    <td class="lineNumber">945</td>
    <td class="codeline">      for (gep_type_iterator GTI = gep_type_begin(GEPI),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">                             GTE = gep_type_end(GEPI);</td>
    <td class="lineNumber">946</td>
    <td class="codeline">                             GTE = gep_type_end(GEPI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">           GTI != GTE; ++GTI) {</td>
    <td class="lineNumber">947</td>
    <td class="codeline">           GTI != GTE; ++GTI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">        ConstantInt *OpC = dyn_cast<ConstantInt>(GTI.getOperand());</td>
    <td class="lineNumber">948</td>
    <td class="codeline">        ConstantInt *OpC = dyn_cast<ConstantInt>(GTI.getOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">        if (!OpC)</td>
    <td class="lineNumber">949</td>
    <td class="codeline">        if (!OpC)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">          break;</td>
    <td class="lineNumber">950</td>
    <td class="codeline">          break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline"></td>
    <td class="lineNumber">951</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline">        // Handle a struct index, which adds its field offset to the pointer.</td>
    <td class="lineNumber">952</td>
    <td class="codeline">        // Handle a struct index, which adds its field offset to the pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">        if (StructType *STy = GTI.getStructTypeOrNull()) {</td>
    <td class="lineNumber">953</td>
    <td class="codeline">        if (StructType *STy = GTI.getStructTypeOrNull()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">          unsigned ElementIdx = OpC->getZExtValue();</td>
    <td class="lineNumber">954</td>
    <td class="codeline">          unsigned ElementIdx = OpC->getZExtValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">          const StructLayout *SL = DL.getStructLayout(STy);</td>
    <td class="lineNumber">955</td>
    <td class="codeline">          const StructLayout *SL = DL.getStructLayout(STy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">          GEPOffset +=</td>
    <td class="lineNumber">956</td>
    <td class="codeline">          GEPOffset +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">              APInt(Offset.getBitWidth(), SL->getElementOffset(ElementIdx));</td>
    <td class="lineNumber">957</td>
    <td class="codeline">              APInt(Offset.getBitWidth(), SL->getElementOffset(ElementIdx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">        } else {</td>
    <td class="lineNumber">958</td>
    <td class="codeline">        } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline">          // For array or vector indices, scale the index by the size of the</td>
    <td class="lineNumber">959</td>
    <td class="codeline">          // For array or vector indices, scale the index by the size of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">          // type.</td>
    <td class="lineNumber">960</td>
    <td class="codeline">          // type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">          APInt Index = OpC->getValue().sextOrTrunc(Offset.getBitWidth());</td>
    <td class="lineNumber">961</td>
    <td class="codeline">          APInt Index = OpC->getValue().sextOrTrunc(Offset.getBitWidth());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">          GEPOffset +=</td>
    <td class="lineNumber">962</td>
    <td class="codeline">          GEPOffset +=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">              Index *</td>
    <td class="lineNumber">963</td>
    <td class="codeline">              Index *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">              APInt(Offset.getBitWidth(),</td>
    <td class="lineNumber">964</td>
    <td class="codeline">              APInt(Offset.getBitWidth(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline">                    DL.getTypeAllocSize(GTI.getIndexedType()).getFixedValue());</td>
    <td class="lineNumber">965</td>
    <td class="codeline">                    DL.getTypeAllocSize(GTI.getIndexedType()).getFixedValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">966</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline"></td>
    <td class="lineNumber">967</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline">        // If this index has computed an intermediate pointer which is not</td>
    <td class="lineNumber">968</td>
    <td class="codeline">        // If this index has computed an intermediate pointer which is not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">        // inbounds, then the result of the GEP is a poison value and we can</td>
    <td class="lineNumber">969</td>
    <td class="codeline">        // inbounds, then the result of the GEP is a poison value and we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">        // delete it and all uses.</td>
    <td class="lineNumber">970</td>
    <td class="codeline">        // delete it and all uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline">        if (GEPOffset.ugt(AllocSize))</td>
    <td class="lineNumber">971</td>
    <td class="codeline">        if (GEPOffset.ugt(AllocSize))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">          return markAsDead(GEPI);</td>
    <td class="lineNumber">972</td>
    <td class="codeline">          return markAsDead(GEPI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">973</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">974</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline"></td>
    <td class="lineNumber">975</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">    return Base::visitGetElementPtrInst(GEPI);</td>
    <td class="lineNumber">976</td>
    <td class="codeline">    return Base::visitGetElementPtrInst(GEPI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">977</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline"></td>
    <td class="lineNumber">978</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">  void handleLoadOrStore(Type *Ty, Instruction &I, const APInt &Offset,</td>
    <td class="lineNumber">979</td>
    <td class="codeline">  void handleLoadOrStore(Type *Ty, Instruction &I, const APInt &Offset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">                         uint64_t Size, bool IsVolatile) {</td>
    <td class="lineNumber">980</td>
    <td class="codeline">                         uint64_t Size, bool IsVolatile) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">    // We allow splitting of non-volatile loads and stores where the type is an</td>
    <td class="lineNumber">981</td>
    <td class="codeline">    // We allow splitting of non-volatile loads and stores where the type is an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline">    // integer type. These may be used to implement 'memcpy' or other "transfer</td>
    <td class="lineNumber">982</td>
    <td class="codeline">    // integer type. These may be used to implement 'memcpy' or other "transfer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">    // of bits" patterns.</td>
    <td class="lineNumber">983</td>
    <td class="codeline">    // of bits" patterns.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">    bool IsSplittable =</td>
    <td class="lineNumber">984</td>
    <td class="codeline">    bool IsSplittable =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">        Ty->isIntegerTy() && !IsVolatile && DL.typeSizeEqualsStoreSize(Ty);</td>
    <td class="lineNumber">985</td>
    <td class="codeline">        Ty->isIntegerTy() && !IsVolatile && DL.typeSizeEqualsStoreSize(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline"></td>
    <td class="lineNumber">986</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline">    insertUse(I, Offset, Size, IsSplittable);</td>
    <td class="lineNumber">987</td>
    <td class="codeline">    insertUse(I, Offset, Size, IsSplittable);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">988</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline"></td>
    <td class="lineNumber">989</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">  void visitLoadInst(LoadInst &LI) {</td>
    <td class="lineNumber">990</td>
    <td class="codeline">  void visitLoadInst(LoadInst &LI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">    assert((!LI.isSimple() || LI.getType()->isSingleValueType()) &&</td>
    <td class="lineNumber">991</td>
    <td class="codeline">    assert((!LI.isSimple() || LI.getType()->isSingleValueType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">           "All simple FCA loads should have been pre-split");</td>
    <td class="lineNumber">992</td>
    <td class="codeline">           "All simple FCA loads should have been pre-split");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline"></td>
    <td class="lineNumber">993</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">994</td>
    <td class="codeline">    if (!IsOffsetKnown)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">      return PI.setAborted(&LI);</td>
    <td class="lineNumber">995</td>
    <td class="codeline">      return PI.setAborted(&LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline"></td>
    <td class="lineNumber">996</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">    TypeSize Size = DL.getTypeStoreSize(LI.getType());</td>
    <td class="lineNumber">997</td>
    <td class="codeline">    TypeSize Size = DL.getTypeStoreSize(LI.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline">    if (Size.isScalable())</td>
    <td class="lineNumber">998</td>
    <td class="codeline">    if (Size.isScalable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">      return PI.setAborted(&LI);</td>
    <td class="lineNumber">999</td>
    <td class="codeline">      return PI.setAborted(&LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline"></td>
    <td class="lineNumber">1000</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">    return handleLoadOrStore(LI.getType(), LI, Offset, Size.getFixedValue(),</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">    return handleLoadOrStore(LI.getType(), LI, Offset, Size.getFixedValue(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">                             LI.isVolatile());</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">                             LI.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1003</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline"></td>
    <td class="lineNumber">1004</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">  void visitStoreInst(StoreInst &SI) {</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">  void visitStoreInst(StoreInst &SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline">    Value *ValOp = SI.getValueOperand();</td>
    <td class="lineNumber">1006</td>
    <td class="codeline">    Value *ValOp = SI.getValueOperand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">    if (ValOp == *U)</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">    if (ValOp == *U)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">      return PI.setEscapedAndAborted(&SI);</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">      return PI.setEscapedAndAborted(&SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">1009</td>
    <td class="codeline">    if (!IsOffsetKnown)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">      return PI.setAborted(&SI);</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">      return PI.setAborted(&SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline"></td>
    <td class="lineNumber">1011</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline">    TypeSize StoreSize = DL.getTypeStoreSize(ValOp->getType());</td>
    <td class="lineNumber">1012</td>
    <td class="codeline">    TypeSize StoreSize = DL.getTypeStoreSize(ValOp->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">    if (StoreSize.isScalable())</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">    if (StoreSize.isScalable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">      return PI.setAborted(&SI);</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">      return PI.setAborted(&SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline"></td>
    <td class="lineNumber">1015</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">    uint64_t Size = StoreSize.getFixedValue();</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">    uint64_t Size = StoreSize.getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline"></td>
    <td class="lineNumber">1017</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline">    // If this memory access can be shown to *statically* extend outside the</td>
    <td class="lineNumber">1018</td>
    <td class="codeline">    // If this memory access can be shown to *statically* extend outside the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">    // bounds of the allocation, it's behavior is undefined, so simply</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">    // bounds of the allocation, it's behavior is undefined, so simply</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">    // ignore it. Note that this is more strict than the generic clamping</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">    // ignore it. Note that this is more strict than the generic clamping</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">    // behavior of insertUse. We also try to handle cases which might run the</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">    // behavior of insertUse. We also try to handle cases which might run the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">    // risk of overflow.</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">    // risk of overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">    // FIXME: We should instead consider the pointer to have escaped if this</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">    // FIXME: We should instead consider the pointer to have escaped if this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">    // function is being instrumented for addressing bugs or race conditions.</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">    // function is being instrumented for addressing bugs or race conditions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">    if (Size > AllocSize || Offset.ugt(AllocSize - Size)) {</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">    if (Size > AllocSize || Offset.ugt(AllocSize - Size)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "WARNING: Ignoring " << Size << " byte store @"</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "WARNING: Ignoring " << Size << " byte store @"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">                        << Offset << " which extends past the end of the "</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">                        << Offset << " which extends past the end of the "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">                        << AllocSize << " byte alloca:\n"</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">                        << AllocSize << " byte alloca:\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">                        << "    alloca: " << AS.AI << "\n"</td>
    <td class="lineNumber">1029</td>
    <td class="codeline">                        << "    alloca: " << AS.AI << "\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">                        << "       use: " << SI << "\n");</td>
    <td class="lineNumber">1030</td>
    <td class="codeline">                        << "       use: " << SI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">      return markAsDead(SI);</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">      return markAsDead(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline"></td>
    <td class="lineNumber">1033</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">    assert((!SI.isSimple() || ValOp->getType()->isSingleValueType()) &&</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">    assert((!SI.isSimple() || ValOp->getType()->isSingleValueType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">           "All simple FCA stores should have been pre-split");</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">           "All simple FCA stores should have been pre-split");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">    handleLoadOrStore(ValOp->getType(), SI, Offset, Size, SI.isVolatile());</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">    handleLoadOrStore(ValOp->getType(), SI, Offset, Size, SI.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1037</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline"></td>
    <td class="lineNumber">1038</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">  void visitMemSetInst(MemSetInst &II) {</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">  void visitMemSetInst(MemSetInst &II) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">    assert(II.getRawDest() == *U && "Pointer use is not the destination?");</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">    assert(II.getRawDest() == *U && "Pointer use is not the destination?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">    ConstantInt *Length = dyn_cast<ConstantInt>(II.getLength());</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">    ConstantInt *Length = dyn_cast<ConstantInt>(II.getLength());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">    if ((Length && Length->getValue() == 0) ||</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">    if ((Length && Length->getValue() == 0) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">        (IsOffsetKnown && Offset.uge(AllocSize)))</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">        (IsOffsetKnown && Offset.uge(AllocSize)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">      // Zero-length mem transfer intrinsics can be ignored entirely.</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">      // Zero-length mem transfer intrinsics can be ignored entirely.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">      return markAsDead(II);</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">      return markAsDead(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline"></td>
    <td class="lineNumber">1046</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">    if (!IsOffsetKnown)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">      return PI.setAborted(&II);</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">      return PI.setAborted(&II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline"></td>
    <td class="lineNumber">1049</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">    insertUse(II, Offset, Length ? Length->getLimitedValue()</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">    insertUse(II, Offset, Length ? Length->getLimitedValue()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">                                 : AllocSize - Offset.getLimitedValue(),</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">                                 : AllocSize - Offset.getLimitedValue(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">              (bool)Length);</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">              (bool)Length);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline"></td>
    <td class="lineNumber">1054</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">  void visitMemTransferInst(MemTransferInst &II) {</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">  void visitMemTransferInst(MemTransferInst &II) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">    ConstantInt *Length = dyn_cast<ConstantInt>(II.getLength());</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">    ConstantInt *Length = dyn_cast<ConstantInt>(II.getLength());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">    if (Length && Length->getValue() == 0)</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">    if (Length && Length->getValue() == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline">      // Zero-length mem transfer intrinsics can be ignored entirely.</td>
    <td class="lineNumber">1058</td>
    <td class="codeline">      // Zero-length mem transfer intrinsics can be ignored entirely.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">      return markAsDead(II);</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">      return markAsDead(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline"></td>
    <td class="lineNumber">1060</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">    // Because we can visit these intrinsics twice, also check to see if the</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">    // Because we can visit these intrinsics twice, also check to see if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">    // first time marked this instruction as dead. If so, skip it.</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">    // first time marked this instruction as dead. If so, skip it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline">    if (VisitedDeadInsts.count(&II))</td>
    <td class="lineNumber">1063</td>
    <td class="codeline">    if (VisitedDeadInsts.count(&II))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline"></td>
    <td class="lineNumber">1065</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">    if (!IsOffsetKnown)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">      return PI.setAborted(&II);</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">      return PI.setAborted(&II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline"></td>
    <td class="lineNumber">1068</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline">    // This side of the transfer is completely out-of-bounds, and so we can</td>
    <td class="lineNumber">1069</td>
    <td class="codeline">    // This side of the transfer is completely out-of-bounds, and so we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">    // nuke the entire transfer. However, we also need to nuke the other side</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">    // nuke the entire transfer. However, we also need to nuke the other side</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">    // if already added to our partitions.</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">    // if already added to our partitions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">    // FIXME: Yet another place we really should bypass this when</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">    // FIXME: Yet another place we really should bypass this when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">    // instrumenting for ASan.</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">    // instrumenting for ASan.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline">    if (Offset.uge(AllocSize)) {</td>
    <td class="lineNumber">1074</td>
    <td class="codeline">    if (Offset.uge(AllocSize)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">      SmallDenseMap<Instruction *, unsigned>::iterator MTPI =</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">      SmallDenseMap<Instruction *, unsigned>::iterator MTPI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">          MemTransferSliceMap.find(&II);</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">          MemTransferSliceMap.find(&II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">      if (MTPI != MemTransferSliceMap.end())</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">      if (MTPI != MemTransferSliceMap.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">        AS.Slices[MTPI->second].kill();</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">        AS.Slices[MTPI->second].kill();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">      return markAsDead(II);</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">      return markAsDead(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline"></td>
    <td class="lineNumber">1081</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">    uint64_t RawOffset = Offset.getLimitedValue();</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">    uint64_t RawOffset = Offset.getLimitedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">    uint64_t Size = Length ? Length->getLimitedValue() : AllocSize - RawOffset;</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">    uint64_t Size = Length ? Length->getLimitedValue() : AllocSize - RawOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline"></td>
    <td class="lineNumber">1084</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">    // Check for the special case where the same exact value is used for both</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">    // Check for the special case where the same exact value is used for both</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline">    // source and dest.</td>
    <td class="lineNumber">1086</td>
    <td class="codeline">    // source and dest.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">    if (*U == II.getRawDest() && *U == II.getRawSource()) {</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">    if (*U == II.getRawDest() && *U == II.getRawSource()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">      // For non-volatile transfers this is a no-op.</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">      // For non-volatile transfers this is a no-op.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">      if (!II.isVolatile())</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">      if (!II.isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">        return markAsDead(II);</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">        return markAsDead(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline"></td>
    <td class="lineNumber">1091</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">      return insertUse(II, Offset, Size, /*IsSplittable=*/false);</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">      return insertUse(II, Offset, Size, /*IsSplittable=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline"></td>
    <td class="lineNumber">1094</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">    // If we have seen both source and destination for a mem transfer, then</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">    // If we have seen both source and destination for a mem transfer, then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline">    // they both point to the same alloca.</td>
    <td class="lineNumber">1096</td>
    <td class="codeline">    // they both point to the same alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">    bool Inserted;</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">    bool Inserted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">    SmallDenseMap<Instruction *, unsigned>::iterator MTPI;</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">    SmallDenseMap<Instruction *, unsigned>::iterator MTPI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline">    std::tie(MTPI, Inserted) =</td>
    <td class="lineNumber">1099</td>
    <td class="codeline">    std::tie(MTPI, Inserted) =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">        MemTransferSliceMap.insert(std::make_pair(&II, AS.Slices.size()));</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">        MemTransferSliceMap.insert(std::make_pair(&II, AS.Slices.size()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">    unsigned PrevIdx = MTPI->second;</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">    unsigned PrevIdx = MTPI->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">    if (!Inserted) {</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">    if (!Inserted) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">      Slice &PrevP = AS.Slices[PrevIdx];</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">      Slice &PrevP = AS.Slices[PrevIdx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline"></td>
    <td class="lineNumber">1104</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">      // Check if the begin offsets match and this is a non-volatile transfer.</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">      // Check if the begin offsets match and this is a non-volatile transfer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">      // In that case, we can completely elide the transfer.</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">      // In that case, we can completely elide the transfer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">      if (!II.isVolatile() && PrevP.beginOffset() == RawOffset) {</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">      if (!II.isVolatile() && PrevP.beginOffset() == RawOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">        PrevP.kill();</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">        PrevP.kill();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline">        return markAsDead(II);</td>
    <td class="lineNumber">1109</td>
    <td class="codeline">        return markAsDead(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline"></td>
    <td class="lineNumber">1111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">      // Otherwise we have an offset transfer within the same alloca. We can't</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">      // Otherwise we have an offset transfer within the same alloca. We can't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">      // split those.</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">      // split those.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline">      PrevP.makeUnsplittable();</td>
    <td class="lineNumber">1114</td>
    <td class="codeline">      PrevP.makeUnsplittable();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline"></td>
    <td class="lineNumber">1116</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">    // Insert the use now that we've fixed up the splittable nature.</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">    // Insert the use now that we've fixed up the splittable nature.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">    insertUse(II, Offset, Size, /*IsSplittable=*/Inserted && Length);</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">    insertUse(II, Offset, Size, /*IsSplittable=*/Inserted && Length);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline"></td>
    <td class="lineNumber">1119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline">    // Check that we ended up with a valid index in the map.</td>
    <td class="lineNumber">1120</td>
    <td class="codeline">    // Check that we ended up with a valid index in the map.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">    assert(AS.Slices[PrevIdx].getUse()->getUser() == &II &&</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">    assert(AS.Slices[PrevIdx].getUse()->getUser() == &II &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">           "Map index doesn't point back to a slice with this user.");</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">           "Map index doesn't point back to a slice with this user.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline"></td>
    <td class="lineNumber">1124</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">  // Disable SRoA for any intrinsics except for lifetime invariants and</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">  // Disable SRoA for any intrinsics except for lifetime invariants and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">  // invariant group.</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">  // invariant group.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">  // FIXME: What about debug intrinsics? This matches old behavior, but</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">  // FIXME: What about debug intrinsics? This matches old behavior, but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">  // doesn't make sense.</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">  // doesn't make sense.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">  void visitIntrinsicInst(IntrinsicInst &II) {</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">  void visitIntrinsicInst(IntrinsicInst &II) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">    if (II.isDroppable()) {</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">    if (II.isDroppable()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline">      AS.DeadUseIfPromotable.push_back(U);</td>
    <td class="lineNumber">1131</td>
    <td class="codeline">      AS.DeadUseIfPromotable.push_back(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline"></td>
    <td class="lineNumber">1134</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">    if (!IsOffsetKnown)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">      return PI.setAborted(&II);</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">      return PI.setAborted(&II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline"></td>
    <td class="lineNumber">1137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">    if (II.isLifetimeStartOrEnd()) {</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">    if (II.isLifetimeStartOrEnd()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">      ConstantInt *Length = cast<ConstantInt>(II.getArgOperand(0));</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">      ConstantInt *Length = cast<ConstantInt>(II.getArgOperand(0));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">      uint64_t Size = std::min(AllocSize - Offset.getLimitedValue(),</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">      uint64_t Size = std::min(AllocSize - Offset.getLimitedValue(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">                               Length->getLimitedValue());</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">                               Length->getLimitedValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">      insertUse(II, Offset, Size, true);</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">      insertUse(II, Offset, Size, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline"></td>
    <td class="lineNumber">1145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">    if (II.isLaunderOrStripInvariantGroup()) {</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">    if (II.isLaunderOrStripInvariantGroup()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">      enqueueUsers(II);</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">      enqueueUsers(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline"></td>
    <td class="lineNumber">1150</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline">    Base::visitIntrinsicInst(II);</td>
    <td class="lineNumber">1151</td>
    <td class="codeline">    Base::visitIntrinsicInst(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline"></td>
    <td class="lineNumber">1153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">  Instruction *hasUnsafePHIOrSelectUse(Instruction *Root, uint64_t &Size) {</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">  Instruction *hasUnsafePHIOrSelectUse(Instruction *Root, uint64_t &Size) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">    // We consider any PHI or select that results in a direct load or store of</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">    // We consider any PHI or select that results in a direct load or store of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">    // the same offset to be a viable use for slicing purposes. These uses</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">    // the same offset to be a viable use for slicing purposes. These uses</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">    // are considered unsplittable and the size is the maximum loaded or stored</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">    // are considered unsplittable and the size is the maximum loaded or stored</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">    // size.</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">    // size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">    SmallPtrSet<Instruction *, 4> Visited;</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">    SmallPtrSet<Instruction *, 4> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">    SmallVector<std::pair<Instruction *, Instruction *>, 4> Uses;</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">    SmallVector<std::pair<Instruction *, Instruction *>, 4> Uses;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline">    Visited.insert(Root);</td>
    <td class="lineNumber">1161</td>
    <td class="codeline">    Visited.insert(Root);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">    Uses.push_back(std::make_pair(cast<Instruction>(*U), Root));</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">    Uses.push_back(std::make_pair(cast<Instruction>(*U), Root));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">    const DataLayout &DL = Root->getModule()->getDataLayout();</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">    const DataLayout &DL = Root->getModule()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">    // If there are no loads or stores, the access is dead. We mark that as</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">    // If there are no loads or stores, the access is dead. We mark that as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">    // a size zero access.</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">    // a size zero access.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">    Size = 0;</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">    Size = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">    do {</td>
    <td class="lineNumber">1167</td>
    <td class="codeline">    do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">      Instruction *I, *UsedI;</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">      Instruction *I, *UsedI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">      std::tie(UsedI, I) = Uses.pop_back_val();</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">      std::tie(UsedI, I) = Uses.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline"></td>
    <td class="lineNumber">1170</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">      if (LoadInst *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">      if (LoadInst *LI = dyn_cast<LoadInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">        Size =</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">        Size =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">            std::max(Size, DL.getTypeStoreSize(LI->getType()).getFixedValue());</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">            std::max(Size, DL.getTypeStoreSize(LI->getType()).getFixedValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1175</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">      if (StoreInst *SI = dyn_cast<StoreInst>(I)) {</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">      if (StoreInst *SI = dyn_cast<StoreInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">        Value *Op = SI->getOperand(0);</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">        Value *Op = SI->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">        if (Op == UsedI)</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">        if (Op == UsedI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">          return SI;</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">          return SI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">        Size =</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">        Size =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">            std::max(Size, DL.getTypeStoreSize(Op->getType()).getFixedValue());</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">            std::max(Size, DL.getTypeStoreSize(Op->getType()).getFixedValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1183</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline"></td>
    <td class="lineNumber">1184</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">      if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(I)) {</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">      if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">        if (!GEP->hasAllZeroIndices())</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">        if (!GEP->hasAllZeroIndices())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline">          return GEP;</td>
    <td class="lineNumber">1187</td>
    <td class="codeline">          return GEP;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">      } else if (!isa<BitCastInst>(I) && !isa<PHINode>(I) &&</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">      } else if (!isa<BitCastInst>(I) && !isa<PHINode>(I) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">                 !isa<SelectInst>(I) && !isa<AddrSpaceCastInst>(I)) {</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">                 !isa<SelectInst>(I) && !isa<AddrSpaceCastInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">        return I;</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">        return I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline"></td>
    <td class="lineNumber">1192</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">      for (User *U : I->users())</td>
    <td class="lineNumber">1193</td>
    <td class="codeline">      for (User *U : I->users())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">        if (Visited.insert(cast<Instruction>(U)).second)</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">        if (Visited.insert(cast<Instruction>(U)).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">          Uses.push_back(std::make_pair(I, cast<Instruction>(U)));</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">          Uses.push_back(std::make_pair(I, cast<Instruction>(U)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">    } while (!Uses.empty());</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">    } while (!Uses.empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline"></td>
    <td class="lineNumber">1197</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1199</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline"></td>
    <td class="lineNumber">1200</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">  void visitPHINodeOrSelectInst(Instruction &I) {</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">  void visitPHINodeOrSelectInst(Instruction &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">    assert(isa<PHINode>(I) || isa<SelectInst>(I));</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">    assert(isa<PHINode>(I) || isa<SelectInst>(I));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">    if (I.use_empty())</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">    if (I.use_empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline">      return markAsDead(I);</td>
    <td class="lineNumber">1204</td>
    <td class="codeline">      return markAsDead(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline"></td>
    <td class="lineNumber">1205</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">    // If this is a PHI node before a catchswitch, we cannot insert any non-PHI</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">    // If this is a PHI node before a catchswitch, we cannot insert any non-PHI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">    // instructions in this BB, which may be required during rewriting. Bail out</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">    // instructions in this BB, which may be required during rewriting. Bail out</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">    // on these cases.</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">    // on these cases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">    if (isa<PHINode>(I) &&</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">    if (isa<PHINode>(I) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">        I.getParent()->getFirstInsertionPt() == I.getParent()->end())</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">        I.getParent()->getFirstInsertionPt() == I.getParent()->end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline">      return PI.setAborted(&I);</td>
    <td class="lineNumber">1211</td>
    <td class="codeline">      return PI.setAborted(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline"></td>
    <td class="lineNumber">1212</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">    // TODO: We could use simplifyInstruction here to fold PHINodes and</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">    // TODO: We could use simplifyInstruction here to fold PHINodes and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">    // SelectInsts. However, doing so requires to change the current</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">    // SelectInsts. However, doing so requires to change the current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline">    // dead-operand-tracking mechanism. For instance, suppose neither loading</td>
    <td class="lineNumber">1215</td>
    <td class="codeline">    // dead-operand-tracking mechanism. For instance, suppose neither loading</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">    // from %U nor %other traps. Then "load (select undef, %U, %other)" does not</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">    // from %U nor %other traps. Then "load (select undef, %U, %other)" does not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">    // trap either.  However, if we simply replace %U with undef using the</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">    // trap either.  However, if we simply replace %U with undef using the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">    // current dead-operand-tracking mechanism, "load (select undef, undef,</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">    // current dead-operand-tracking mechanism, "load (select undef, undef,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline">    // %other)" may trap because the select may return the first operand</td>
    <td class="lineNumber">1219</td>
    <td class="codeline">    // %other)" may trap because the select may return the first operand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">    // "undef".</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">    // "undef".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">    if (Value *Result = foldPHINodeOrSelectInst(I)) {</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">    if (Value *Result = foldPHINodeOrSelectInst(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">      if (Result == *U)</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">      if (Result == *U)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">        // If the result of the constant fold will be the pointer, recurse</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">        // If the result of the constant fold will be the pointer, recurse</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline">        // through the PHI/select as if we had RAUW'ed it.</td>
    <td class="lineNumber">1224</td>
    <td class="codeline">        // through the PHI/select as if we had RAUW'ed it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">        enqueueUsers(I);</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">        enqueueUsers(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">        // Otherwise the operand to the PHI/select is dead, and we can replace</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">        // Otherwise the operand to the PHI/select is dead, and we can replace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">        // it with poison.</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">        // it with poison.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">        AS.DeadOperands.push_back(U);</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">        AS.DeadOperands.push_back(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline"></td>
    <td class="lineNumber">1230</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline"></td>
    <td class="lineNumber">1233</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">1234</td>
    <td class="codeline">    if (!IsOffsetKnown)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">      return PI.setAborted(&I);</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">      return PI.setAborted(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline"></td>
    <td class="lineNumber">1236</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">    // See if we already have computed info on this node.</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">    // See if we already have computed info on this node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline">    uint64_t &Size = PHIOrSelectSizes[&I];</td>
    <td class="lineNumber">1238</td>
    <td class="codeline">    uint64_t &Size = PHIOrSelectSizes[&I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">    if (!Size) {</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">    if (!Size) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">      // This is a new PHI/Select, check for an unsafe use of it.</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">      // This is a new PHI/Select, check for an unsafe use of it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">      if (Instruction *UnsafeI = hasUnsafePHIOrSelectUse(&I, Size))</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">      if (Instruction *UnsafeI = hasUnsafePHIOrSelectUse(&I, Size))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline">        return PI.setAborted(UnsafeI);</td>
    <td class="lineNumber">1242</td>
    <td class="codeline">        return PI.setAborted(UnsafeI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline"></td>
    <td class="lineNumber">1244</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline">    // For PHI and select operands outside the alloca, we can't nuke the entire</td>
    <td class="lineNumber">1245</td>
    <td class="codeline">    // For PHI and select operands outside the alloca, we can't nuke the entire</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">    // phi or select -- the other side might still be relevant, so we special</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">    // phi or select -- the other side might still be relevant, so we special</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">    // case them here and use a separate structure to track the operands</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">    // case them here and use a separate structure to track the operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline">    // themselves which should be replaced with poison.</td>
    <td class="lineNumber">1248</td>
    <td class="codeline">    // themselves which should be replaced with poison.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">    // FIXME: This should instead be escaped in the event we're instrumenting</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">    // FIXME: This should instead be escaped in the event we're instrumenting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">    // for address sanitization.</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">    // for address sanitization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">    if (Offset.uge(AllocSize)) {</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">    if (Offset.uge(AllocSize)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">      AS.DeadOperands.push_back(U);</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">      AS.DeadOperands.push_back(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline">      return;</td>
    <td class="lineNumber">1253</td>
    <td class="codeline">      return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline"></td>
    <td class="lineNumber">1255</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">    insertUse(I, Offset, Size);</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">    insertUse(I, Offset, Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline"></td>
    <td class="lineNumber">1258</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline">  void visitPHINode(PHINode &PN) { visitPHINodeOrSelectInst(PN); }</td>
    <td class="lineNumber">1259</td>
    <td class="codeline">  void visitPHINode(PHINode &PN) { visitPHINodeOrSelectInst(PN); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline"></td>
    <td class="lineNumber">1260</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">  void visitSelectInst(SelectInst &SI) { visitPHINodeOrSelectInst(SI); }</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">  void visitSelectInst(SelectInst &SI) { visitPHINodeOrSelectInst(SI); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline"></td>
    <td class="lineNumber">1262</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline">  /// Disable SROA entirely if there are unhandled users of the alloca.</td>
    <td class="lineNumber">1263</td>
    <td class="codeline">  /// Disable SROA entirely if there are unhandled users of the alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">  void visitInstruction(Instruction &I) { PI.setAborted(&I); }</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">  void visitInstruction(Instruction &I) { PI.setAborted(&I); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">};</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline"></td>
    <td class="lineNumber">1266</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline">AllocaSlices::AllocaSlices(const DataLayout &DL, AllocaInst &AI)</td>
    <td class="lineNumber">1267</td>
    <td class="codeline">AllocaSlices::AllocaSlices(const DataLayout &DL, AllocaInst &AI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">    :</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">    :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">      AI(AI),</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">      AI(AI),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">      PointerEscapingInstr(nullptr) {</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">      PointerEscapingInstr(nullptr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">  SliceBuilder PB(DL, AI, *this);</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">  SliceBuilder PB(DL, AI, *this);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">  SliceBuilder::PtrInfo PtrI = PB.visitPtr(AI);</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">  SliceBuilder::PtrInfo PtrI = PB.visitPtr(AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">  if (PtrI.isEscaped() || PtrI.isAborted()) {</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">  if (PtrI.isEscaped() || PtrI.isAborted()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline">    // FIXME: We should sink the escape vs. abort info into the caller nicely,</td>
    <td class="lineNumber">1276</td>
    <td class="codeline">    // FIXME: We should sink the escape vs. abort info into the caller nicely,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">    // possibly by just storing the PtrInfo in the AllocaSlices.</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">    // possibly by just storing the PtrInfo in the AllocaSlices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">    PointerEscapingInstr = PtrI.getEscapingInst() ? PtrI.getEscapingInst()</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">    PointerEscapingInstr = PtrI.getEscapingInst() ? PtrI.getEscapingInst()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">                                                  : PtrI.getAbortingInst();</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">                                                  : PtrI.getAbortingInst();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">    assert(PointerEscapingInstr && "Did not track a bad instruction");</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">    assert(PointerEscapingInstr && "Did not track a bad instruction");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline"></td>
    <td class="lineNumber">1283</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">  llvm::erase_if(Slices, [](const Slice &S) { return S.isDead(); });</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">  llvm::erase_if(Slices, [](const Slice &S) { return S.isDead(); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
    <td class="lineNumber">1285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline">  // Sort the uses. This arranges for the offsets to be in ascending order,</td>
    <td class="lineNumber">1286</td>
    <td class="codeline">  // Sort the uses. This arranges for the offsets to be in ascending order,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">  // and the sizes to be in descending order.</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">  // and the sizes to be in descending order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">  llvm::stable_sort(Slices);</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">  llvm::stable_sort(Slices);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline"></td>
    <td class="lineNumber">1290</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">1291</td>
    <td class="codeline">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline"></td>
    <td class="lineNumber">1292</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">void AllocaSlices::print(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">void AllocaSlices::print(raw_ostream &OS, const_iterator I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline">                         StringRef Indent) const {</td>
    <td class="lineNumber">1294</td>
    <td class="codeline">                         StringRef Indent) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">  printSlice(OS, I, Indent);</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">  printSlice(OS, I, Indent);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">  OS << "\n";</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">  OS << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">  printUse(OS, I, Indent);</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">  printUse(OS, I, Indent);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline"></td>
    <td class="lineNumber">1299</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">void AllocaSlices::printSlice(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">void AllocaSlices::printSlice(raw_ostream &OS, const_iterator I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">                              StringRef Indent) const {</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">                              StringRef Indent) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline">  OS << Indent << "[" << I->beginOffset() << "," << I->endOffset() << ")"</td>
    <td class="lineNumber">1302</td>
    <td class="codeline">  OS << Indent << "[" << I->beginOffset() << "," << I->endOffset() << ")"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">     << " slice #" << (I - begin())</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">     << " slice #" << (I - begin())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">     << (I->isSplittable() ? " (splittable)" : "");</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">     << (I->isSplittable() ? " (splittable)" : "");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline"></td>
    <td class="lineNumber">1306</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">void AllocaSlices::printUse(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">void AllocaSlices::printUse(raw_ostream &OS, const_iterator I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">                            StringRef Indent) const {</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">                            StringRef Indent) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">  OS << Indent << "  used by: " << *I->getUse()->getUser() << "\n";</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">  OS << Indent << "  used by: " << *I->getUse()->getUser() << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">void AllocaSlices::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">void AllocaSlices::print(raw_ostream &OS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">  if (PointerEscapingInstr) {</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">  if (PointerEscapingInstr) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">    OS << "Can't analyze slices for alloca: " << AI << "\n"</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">    OS << "Can't analyze slices for alloca: " << AI << "\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">       << "  A pointer to this alloca escaped by:\n"</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">       << "  A pointer to this alloca escaped by:\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">       << "  " << *PointerEscapingInstr << "\n";</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">       << "  " << *PointerEscapingInstr << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">1317</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline"></td>
    <td class="lineNumber">1319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">  OS << "Slices of alloca: " << AI << "\n";</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">  OS << "Slices of alloca: " << AI << "\n";</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">  for (const_iterator I = begin(), E = end(); I != E; ++I)</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">  for (const_iterator I = begin(), E = end(); I != E; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">    print(OS, I);</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">    print(OS, I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline"></td>
    <td class="lineNumber">1324</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline">LLVM_DUMP_METHOD void AllocaSlices::dump(const_iterator I) const {</td>
    <td class="lineNumber">1325</td>
    <td class="codeline">LLVM_DUMP_METHOD void AllocaSlices::dump(const_iterator I) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">  print(dbgs(), I);</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">  print(dbgs(), I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">LLVM_DUMP_METHOD void AllocaSlices::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">LLVM_DUMP_METHOD void AllocaSlices::dump() const { print(dbgs()); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline"></td>
    <td class="lineNumber">1329</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline">#endif // !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">1330</td>
    <td class="codeline">#endif // !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline"></td>
    <td class="lineNumber">1331</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">/// Walk the range of a partitioning looking for a common type to cover this</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">/// Walk the range of a partitioning looking for a common type to cover this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">/// sequence of slices.</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">/// sequence of slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">static std::pair<Type *, IntegerType *></td>
    <td class="lineNumber">1334</td>
    <td class="codeline">static std::pair<Type *, IntegerType *></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">findCommonType(AllocaSlices::const_iterator B, AllocaSlices::const_iterator E,</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">findCommonType(AllocaSlices::const_iterator B, AllocaSlices::const_iterator E,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline">               uint64_t EndOffset) {</td>
    <td class="lineNumber">1336</td>
    <td class="codeline">               uint64_t EndOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">  Type *Ty = nullptr;</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">  Type *Ty = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">  bool TyIsCommon = true;</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">  bool TyIsCommon = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline">  IntegerType *ITy = nullptr;</td>
    <td class="lineNumber">1339</td>
    <td class="codeline">  IntegerType *ITy = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline"></td>
    <td class="lineNumber">1340</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">  // Note that we need to look at *every* alloca slice's Use to ensure we</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">  // Note that we need to look at *every* alloca slice's Use to ensure we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">  // always get consistent results regardless of the order of slices.</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">  // always get consistent results regardless of the order of slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline">  for (AllocaSlices::const_iterator I = B; I != E; ++I) {</td>
    <td class="lineNumber">1343</td>
    <td class="codeline">  for (AllocaSlices::const_iterator I = B; I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">    Use *U = I->getUse();</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">    Use *U = I->getUse();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">    if (isa<IntrinsicInst>(*U->getUser()))</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">    if (isa<IntrinsicInst>(*U->getUser()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline">    if (I->beginOffset() != B->beginOffset() || I->endOffset() != EndOffset)</td>
    <td class="lineNumber">1347</td>
    <td class="codeline">    if (I->beginOffset() != B->beginOffset() || I->endOffset() != EndOffset)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
    <td class="lineNumber">1349</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline">    Type *UserTy = nullptr;</td>
    <td class="lineNumber">1350</td>
    <td class="codeline">    Type *UserTy = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">    if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">    if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">      UserTy = LI->getType();</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">      UserTy = LI->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">    } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">    } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">      UserTy = SI->getValueOperand()->getType();</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">      UserTy = SI->getValueOperand()->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1355</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline"></td>
    <td class="lineNumber">1356</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">    if (IntegerType *UserITy = dyn_cast_or_null<IntegerType>(UserTy)) {</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">    if (IntegerType *UserITy = dyn_cast_or_null<IntegerType>(UserTy)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline">      // If the type is larger than the partition, skip it. We only encounter</td>
    <td class="lineNumber">1358</td>
    <td class="codeline">      // If the type is larger than the partition, skip it. We only encounter</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">      // this for split integer operations where we want to use the type of the</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">      // this for split integer operations where we want to use the type of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">      // entity causing the split. Also skip if the type is not a byte width</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">      // entity causing the split. Also skip if the type is not a byte width</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline">      // multiple.</td>
    <td class="lineNumber">1361</td>
    <td class="codeline">      // multiple.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">      if (UserITy->getBitWidth() % 8 != 0 ||</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">      if (UserITy->getBitWidth() % 8 != 0 ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">          UserITy->getBitWidth() / 8 > (EndOffset - B->beginOffset()))</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">          UserITy->getBitWidth() / 8 > (EndOffset - B->beginOffset()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">1364</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline"></td>
    <td class="lineNumber">1365</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">      // Track the largest bitwidth integer type used in this way in case there</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">      // Track the largest bitwidth integer type used in this way in case there</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline">      // is no common type.</td>
    <td class="lineNumber">1367</td>
    <td class="codeline">      // is no common type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">      if (!ITy || ITy->getBitWidth() < UserITy->getBitWidth())</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">      if (!ITy || ITy->getBitWidth() < UserITy->getBitWidth())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">        ITy = UserITy;</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">        ITy = UserITy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1370</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline"></td>
    <td class="lineNumber">1371</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">    // To avoid depending on the order of slices, Ty and TyIsCommon must not</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">    // To avoid depending on the order of slices, Ty and TyIsCommon must not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline">    // depend on types skipped above.</td>
    <td class="lineNumber">1373</td>
    <td class="codeline">    // depend on types skipped above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">    if (!UserTy || (Ty && Ty != UserTy))</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">    if (!UserTy || (Ty && Ty != UserTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">      TyIsCommon = false; // Give up on anything but an iN type.</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">      TyIsCommon = false; // Give up on anything but an iN type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">1376</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">      Ty = UserTy;</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">      Ty = UserTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline"></td>
    <td class="lineNumber">1379</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline">  return {TyIsCommon ? Ty : nullptr, ITy};</td>
    <td class="lineNumber">1380</td>
    <td class="codeline">  return {TyIsCommon ? Ty : nullptr, ITy};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
    <td class="lineNumber">1382</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">/// PHI instructions that use an alloca and are subsequently loaded can be</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">/// PHI instructions that use an alloca and are subsequently loaded can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline">/// rewritten to load both input pointers in the pred blocks and then PHI the</td>
    <td class="lineNumber">1384</td>
    <td class="codeline">/// rewritten to load both input pointers in the pred blocks and then PHI the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">/// results, allowing the load of the alloca to be promoted.</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">/// results, allowing the load of the alloca to be promoted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">/// From this:</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">/// From this:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">///   %P2 = phi [i32* %Alloca, i32* %Other]</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">///   %P2 = phi [i32* %Alloca, i32* %Other]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline">///   %V = load i32* %P2</td>
    <td class="lineNumber">1388</td>
    <td class="codeline">///   %V = load i32* %P2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">/// to:</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">/// to:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">///   %V1 = load i32* %Alloca      -> will be mem2reg'd</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">///   %V1 = load i32* %Alloca      -> will be mem2reg'd</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline">///   ...</td>
    <td class="lineNumber">1391</td>
    <td class="codeline">///   ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">///   %V2 = load i32* %Other</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">///   %V2 = load i32* %Other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">///   ...</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">///   ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">///   %V = phi [i32 %V1, i32 %V2]</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">///   %V = phi [i32 %V1, i32 %V2]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline">/// We can do this to a select if its only uses are loads and if the operands</td>
    <td class="lineNumber">1396</td>
    <td class="codeline">/// We can do this to a select if its only uses are loads and if the operands</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">/// to the select can be loaded unconditionally.</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">/// to the select can be loaded unconditionally.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline">/// FIXME: This should be hoisted into a generic utility, likely in</td>
    <td class="lineNumber">1399</td>
    <td class="codeline">/// FIXME: This should be hoisted into a generic utility, likely in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">/// Transforms/Util/Local.h</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">/// Transforms/Util/Local.h</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">static bool isSafePHIToSpeculate(PHINode &PN) {</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">static bool isSafePHIToSpeculate(PHINode &PN) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline">  const DataLayout &DL = PN.getModule()->getDataLayout();</td>
    <td class="lineNumber">1402</td>
    <td class="codeline">  const DataLayout &DL = PN.getModule()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline"></td>
    <td class="lineNumber">1403</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">  // For now, we can only do this promotion if the load is in the same block</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">  // For now, we can only do this promotion if the load is in the same block</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline">  // as the PHI, and if there are no stores between the phi and load.</td>
    <td class="lineNumber">1405</td>
    <td class="codeline">  // as the PHI, and if there are no stores between the phi and load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">  // TODO: Allow recursive phi users.</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">  // TODO: Allow recursive phi users.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">  // TODO: Allow stores.</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">  // TODO: Allow stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline">  BasicBlock *BB = PN.getParent();</td>
    <td class="lineNumber">1408</td>
    <td class="codeline">  BasicBlock *BB = PN.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">  Align MaxAlign;</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">  Align MaxAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">  uint64_t APWidth = DL.getIndexTypeSizeInBits(PN.getType());</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">  uint64_t APWidth = DL.getIndexTypeSizeInBits(PN.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">  Type *LoadType = nullptr;</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">  Type *LoadType = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline">  for (User *U : PN.users()) {</td>
    <td class="lineNumber">1412</td>
    <td class="codeline">  for (User *U : PN.users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">    LoadInst *LI = dyn_cast<LoadInst>(U);</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">    LoadInst *LI = dyn_cast<LoadInst>(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">    if (!LI || !LI->isSimple())</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">    if (!LI || !LI->isSimple())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline"></td>
    <td class="lineNumber">1416</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">    // For now we only allow loads in the same block as the PHI.  This is</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">    // For now we only allow loads in the same block as the PHI.  This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">    // a common case that happens when instcombine merges two loads through</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">    // a common case that happens when instcombine merges two loads through</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline">    // a PHI.</td>
    <td class="lineNumber">1419</td>
    <td class="codeline">    // a PHI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">    if (LI->getParent() != BB)</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">    if (LI->getParent() != BB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline"></td>
    <td class="lineNumber">1422</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">    if (LoadType) {</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">    if (LoadType) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">      if (LoadType != LI->getType())</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">      if (LoadType != LI->getType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1425</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">      LoadType = LI->getType();</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">      LoadType = LI->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline"></td>
    <td class="lineNumber">1429</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">    // Ensure that there are no instructions between the PHI and the load that</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">    // Ensure that there are no instructions between the PHI and the load that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">    // could store.</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">    // could store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">    for (BasicBlock::iterator BBI(PN); &*BBI != LI; ++BBI)</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">    for (BasicBlock::iterator BBI(PN); &*BBI != LI; ++BBI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">      if (BBI->mayWriteToMemory())</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">      if (BBI->mayWriteToMemory())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">1434</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline"></td>
    <td class="lineNumber">1435</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">    MaxAlign = std::max(MaxAlign, LI->getAlign());</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">    MaxAlign = std::max(MaxAlign, LI->getAlign());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline"></td>
    <td class="lineNumber">1438</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">  if (!LoadType)</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">  if (!LoadType)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline"></td>
    <td class="lineNumber">1441</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline">  APInt LoadSize =</td>
    <td class="lineNumber">1442</td>
    <td class="codeline">  APInt LoadSize =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">      APInt(APWidth, DL.getTypeStoreSize(LoadType).getFixedValue());</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">      APInt(APWidth, DL.getTypeStoreSize(LoadType).getFixedValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline"></td>
    <td class="lineNumber">1444</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">  // We can only transform this if it is safe to push the loads into the</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">  // We can only transform this if it is safe to push the loads into the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">  // predecessor blocks. The only thing to watch out for is that we can't put</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">  // predecessor blocks. The only thing to watch out for is that we can't put</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline">  // a possibly trapping load in the predecessor if it is a critical edge.</td>
    <td class="lineNumber">1447</td>
    <td class="codeline">  // a possibly trapping load in the predecessor if it is a critical edge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">  for (unsigned Idx = 0, Num = PN.getNumIncomingValues(); Idx != Num; ++Idx) {</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">  for (unsigned Idx = 0, Num = PN.getNumIncomingValues(); Idx != Num; ++Idx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">    Instruction *TI = PN.getIncomingBlock(Idx)->getTerminator();</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">    Instruction *TI = PN.getIncomingBlock(Idx)->getTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">    Value *InVal = PN.getIncomingValue(Idx);</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">    Value *InVal = PN.getIncomingValue(Idx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline"></td>
    <td class="lineNumber">1451</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">    // If the value is produced by the terminator of the predecessor (an</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">    // If the value is produced by the terminator of the predecessor (an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline">    // invoke) or it has side-effects, there is no valid place to put a load</td>
    <td class="lineNumber">1453</td>
    <td class="codeline">    // invoke) or it has side-effects, there is no valid place to put a load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">    // in the predecessor.</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">    // in the predecessor.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">    if (TI == InVal || TI->mayHaveSideEffects())</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">    if (TI == InVal || TI->mayHaveSideEffects())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline"></td>
    <td class="lineNumber">1457</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">    // If the predecessor has a single successor, then the edge isn't</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">    // If the predecessor has a single successor, then the edge isn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">    // critical.</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">    // critical.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">    if (TI->getNumSuccessors() == 1)</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">    if (TI->getNumSuccessors() == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline"></td>
    <td class="lineNumber">1462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">    // If this pointer is always safe to load, or if we can prove that there</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">    // If this pointer is always safe to load, or if we can prove that there</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">    // is already a load in the block, then we can move the load to the pred</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">    // is already a load in the block, then we can move the load to the pred</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">    // block.</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">    // block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline">    if (isSafeToLoadUnconditionally(InVal, MaxAlign, LoadSize, DL, TI))</td>
    <td class="lineNumber">1466</td>
    <td class="codeline">    if (isSafeToLoadUnconditionally(InVal, MaxAlign, LoadSize, DL, TI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline"></td>
    <td class="lineNumber">1468</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1470</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline"></td>
    <td class="lineNumber">1471</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1473</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline"></td>
    <td class="lineNumber">1474</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">static void speculatePHINodeLoads(IRBuilderTy &IRB, PHINode &PN) {</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">static void speculatePHINodeLoads(IRBuilderTy &IRB, PHINode &PN) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    original: " << PN << "\n");</td>
    <td class="lineNumber">1476</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    original: " << PN << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline"></td>
    <td class="lineNumber">1477</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">  LoadInst *SomeLoad = cast<LoadInst>(PN.user_back());</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">  LoadInst *SomeLoad = cast<LoadInst>(PN.user_back());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">  Type *LoadTy = SomeLoad->getType();</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">  Type *LoadTy = SomeLoad->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">  IRB.SetInsertPoint(&PN);</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">  IRB.SetInsertPoint(&PN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline">  PHINode *NewPN = IRB.CreatePHI(LoadTy, PN.getNumIncomingValues(),</td>
    <td class="lineNumber">1481</td>
    <td class="codeline">  PHINode *NewPN = IRB.CreatePHI(LoadTy, PN.getNumIncomingValues(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">                                 PN.getName() + ".sroa.speculated");</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">                                 PN.getName() + ".sroa.speculated");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline"></td>
    <td class="lineNumber">1483</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">  // Get the AA tags and alignment to use from one of the loads. It does not</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">  // Get the AA tags and alignment to use from one of the loads. It does not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">  // matter which one we get and if any differ.</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">  // matter which one we get and if any differ.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">  AAMDNodes AATags = SomeLoad->getAAMetadata();</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">  AAMDNodes AATags = SomeLoad->getAAMetadata();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline">  Align Alignment = SomeLoad->getAlign();</td>
    <td class="lineNumber">1487</td>
    <td class="codeline">  Align Alignment = SomeLoad->getAlign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline"></td>
    <td class="lineNumber">1488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">  // Rewrite all loads of the PN to use the new PHI.</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">  // Rewrite all loads of the PN to use the new PHI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">  while (!PN.use_empty()) {</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">  while (!PN.use_empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">    LoadInst *LI = cast<LoadInst>(PN.user_back());</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">    LoadInst *LI = cast<LoadInst>(PN.user_back());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">    LI->replaceAllUsesWith(NewPN);</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">    LI->replaceAllUsesWith(NewPN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">    LI->eraseFromParent();</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">    LI->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1494</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline"></td>
    <td class="lineNumber">1495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">  // Inject loads into all of the pred blocks.</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">  // Inject loads into all of the pred blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline">  DenseMap<BasicBlock*, Value*> InjectedLoads;</td>
    <td class="lineNumber">1497</td>
    <td class="codeline">  DenseMap<BasicBlock*, Value*> InjectedLoads;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">  for (unsigned Idx = 0, Num = PN.getNumIncomingValues(); Idx != Num; ++Idx) {</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">  for (unsigned Idx = 0, Num = PN.getNumIncomingValues(); Idx != Num; ++Idx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">    BasicBlock *Pred = PN.getIncomingBlock(Idx);</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">    BasicBlock *Pred = PN.getIncomingBlock(Idx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">    Value *InVal = PN.getIncomingValue(Idx);</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">    Value *InVal = PN.getIncomingValue(Idx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline"></td>
    <td class="lineNumber">1501</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">    // A PHI node is allowed to have multiple (duplicated) entries for the same</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">    // A PHI node is allowed to have multiple (duplicated) entries for the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">    // basic block, as long as the value is the same. So if we already injected</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">    // basic block, as long as the value is the same. So if we already injected</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">    // a load in the predecessor, then we should reuse the same load for all</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">    // a load in the predecessor, then we should reuse the same load for all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">    // duplicated entries.</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">    // duplicated entries.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">    if (Value* V = InjectedLoads.lookup(Pred)) {</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">    if (Value* V = InjectedLoads.lookup(Pred)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">      NewPN->addIncoming(V, Pred);</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">      NewPN->addIncoming(V, Pred);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline"></td>
    <td class="lineNumber">1510</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">    Instruction *TI = Pred->getTerminator();</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">    Instruction *TI = Pred->getTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">    IRB.SetInsertPoint(TI);</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">    IRB.SetInsertPoint(TI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline"></td>
    <td class="lineNumber">1513</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">    LoadInst *Load = IRB.CreateAlignedLoad(</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">    LoadInst *Load = IRB.CreateAlignedLoad(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">        LoadTy, InVal, Alignment,</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">        LoadTy, InVal, Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">        (PN.getName() + ".sroa.speculate.load." + Pred->getName()));</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">        (PN.getName() + ".sroa.speculate.load." + Pred->getName()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">    ++NumLoadsSpeculated;</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">    ++NumLoadsSpeculated;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline">    if (AATags)</td>
    <td class="lineNumber">1518</td>
    <td class="codeline">    if (AATags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">      Load->setAAMetadata(AATags);</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">      Load->setAAMetadata(AATags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">    NewPN->addIncoming(Load, Pred);</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">    NewPN->addIncoming(Load, Pred);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">    InjectedLoads[Pred] = Load;</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">    InjectedLoads[Pred] = Load;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline"></td>
    <td class="lineNumber">1523</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "          speculated to: " << *NewPN << "\n");</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "          speculated to: " << *NewPN << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline">  PN.eraseFromParent();</td>
    <td class="lineNumber">1525</td>
    <td class="codeline">  PN.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline"></td>
    <td class="lineNumber">1527</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline">sroa::SelectHandSpeculativity &</td>
    <td class="lineNumber">1528</td>
    <td class="codeline">sroa::SelectHandSpeculativity &</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">sroa::SelectHandSpeculativity::setAsSpeculatable(bool isTrueVal) {</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">sroa::SelectHandSpeculativity::setAsSpeculatable(bool isTrueVal) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">  if (isTrueVal)</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">  if (isTrueVal)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">    Bitfield::set<sroa::SelectHandSpeculativity::TrueVal>(Storage, true);</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">    Bitfield::set<sroa::SelectHandSpeculativity::TrueVal>(Storage, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1532</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">    Bitfield::set<sroa::SelectHandSpeculativity::FalseVal>(Storage, true);</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">    Bitfield::set<sroa::SelectHandSpeculativity::FalseVal>(Storage, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">  return *this;</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">  return *this;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1535</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline"></td>
    <td class="lineNumber">1536</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">bool sroa::SelectHandSpeculativity::isSpeculatable(bool isTrueVal) const {</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">bool sroa::SelectHandSpeculativity::isSpeculatable(bool isTrueVal) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">  return isTrueVal</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">  return isTrueVal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline">             ? Bitfield::get<sroa::SelectHandSpeculativity::TrueVal>(Storage)</td>
    <td class="lineNumber">1539</td>
    <td class="codeline">             ? Bitfield::get<sroa::SelectHandSpeculativity::TrueVal>(Storage)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">             : Bitfield::get<sroa::SelectHandSpeculativity::FalseVal>(Storage);</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">             : Bitfield::get<sroa::SelectHandSpeculativity::FalseVal>(Storage);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline"></td>
    <td class="lineNumber">1542</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">bool sroa::SelectHandSpeculativity::areAllSpeculatable() const {</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">bool sroa::SelectHandSpeculativity::areAllSpeculatable() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline">  return isSpeculatable(/*isTrueVal=*/true) &&</td>
    <td class="lineNumber">1544</td>
    <td class="codeline">  return isSpeculatable(/*isTrueVal=*/true) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">         isSpeculatable(/*isTrueVal=*/false);</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">         isSpeculatable(/*isTrueVal=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline"></td>
    <td class="lineNumber">1547</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline">bool sroa::SelectHandSpeculativity::areAnySpeculatable() const {</td>
    <td class="lineNumber">1548</td>
    <td class="codeline">bool sroa::SelectHandSpeculativity::areAnySpeculatable() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">  return isSpeculatable(/*isTrueVal=*/true) ||</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">  return isSpeculatable(/*isTrueVal=*/true) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">         isSpeculatable(/*isTrueVal=*/false);</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">         isSpeculatable(/*isTrueVal=*/false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline">bool sroa::SelectHandSpeculativity::areNoneSpeculatable() const {</td>
    <td class="lineNumber">1552</td>
    <td class="codeline">bool sroa::SelectHandSpeculativity::areNoneSpeculatable() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">  return !areAnySpeculatable();</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">  return !areAnySpeculatable();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1554</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline"></td>
    <td class="lineNumber">1555</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline">static sroa::SelectHandSpeculativity</td>
    <td class="lineNumber">1556</td>
    <td class="codeline">static sroa::SelectHandSpeculativity</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">isSafeLoadOfSelectToSpeculate(LoadInst &LI, SelectInst &SI, bool PreserveCFG) {</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">isSafeLoadOfSelectToSpeculate(LoadInst &LI, SelectInst &SI, bool PreserveCFG) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">  assert(LI.isSimple() && "Only for simple loads");</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">  assert(LI.isSimple() && "Only for simple loads");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">  sroa::SelectHandSpeculativity Spec;</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">  sroa::SelectHandSpeculativity Spec;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline"></td>
    <td class="lineNumber">1560</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">  const DataLayout &DL = SI.getModule()->getDataLayout();</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">  const DataLayout &DL = SI.getModule()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline">  for (Value *Value : {SI.getTrueValue(), SI.getFalseValue()})</td>
    <td class="lineNumber">1562</td>
    <td class="codeline">  for (Value *Value : {SI.getTrueValue(), SI.getFalseValue()})</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">    if (isSafeToLoadUnconditionally(Value, LI.getType(), LI.getAlign(), DL,</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">    if (isSafeToLoadUnconditionally(Value, LI.getType(), LI.getAlign(), DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">                                    &LI))</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">                                    &LI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">      Spec.setAsSpeculatable(/*isTrueVal=*/Value == SI.getTrueValue());</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">      Spec.setAsSpeculatable(/*isTrueVal=*/Value == SI.getTrueValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">    else if (PreserveCFG)</td>
    <td class="lineNumber">1566</td>
    <td class="codeline">    else if (PreserveCFG)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">      return Spec;</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">      return Spec;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline"></td>
    <td class="lineNumber">1568</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">  return Spec;</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">  return Spec;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline"></td>
    <td class="lineNumber">1571</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">std::optional<sroa::RewriteableMemOps></td>
    <td class="lineNumber">1572</td>
    <td class="codeline">std::optional<sroa::RewriteableMemOps></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline">SROAPass::isSafeSelectToSpeculate(SelectInst &SI, bool PreserveCFG) {</td>
    <td class="lineNumber">1573</td>
    <td class="codeline">SROAPass::isSafeSelectToSpeculate(SelectInst &SI, bool PreserveCFG) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">  RewriteableMemOps Ops;</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">  RewriteableMemOps Ops;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline"></td>
    <td class="lineNumber">1575</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">  for (User *U : SI.users()) {</td>
    <td class="lineNumber">1576</td>
    <td class="codeline">  for (User *U : SI.users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">    if (auto *BC = dyn_cast<BitCastInst>(U); BC && BC->hasOneUse())</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">    if (auto *BC = dyn_cast<BitCastInst>(U); BC && BC->hasOneUse())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline">      U = *BC->user_begin();</td>
    <td class="lineNumber">1578</td>
    <td class="codeline">      U = *BC->user_begin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline"></td>
    <td class="lineNumber">1579</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">    if (auto *Store = dyn_cast<StoreInst>(U)) {</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">    if (auto *Store = dyn_cast<StoreInst>(U)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">      // Note that atomic stores can be transformed; atomic semantics do not</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">      // Note that atomic stores can be transformed; atomic semantics do not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">      // have any meaning for a local alloca. Stores are not speculatable,</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">      // have any meaning for a local alloca. Stores are not speculatable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">      // however, so if we can't turn it into a predicated store, we are done.</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">      // however, so if we can't turn it into a predicated store, we are done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">      if (Store->isVolatile() || PreserveCFG)</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">      if (Store->isVolatile() || PreserveCFG)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">        return {}; // Give up on this `select`.</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">        return {}; // Give up on this `select`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline">      Ops.emplace_back(Store);</td>
    <td class="lineNumber">1586</td>
    <td class="codeline">      Ops.emplace_back(Store);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline"></td>
    <td class="lineNumber">1589</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">    auto *LI = dyn_cast<LoadInst>(U);</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">    auto *LI = dyn_cast<LoadInst>(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline"></td>
    <td class="lineNumber">1591</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">    // Note that atomic loads can be transformed;</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">    // Note that atomic loads can be transformed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">    // atomic semantics do not have any meaning for a local alloca.</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">    // atomic semantics do not have any meaning for a local alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline">    if (!LI || LI->isVolatile())</td>
    <td class="lineNumber">1594</td>
    <td class="codeline">    if (!LI || LI->isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">      return {}; // Give up on this `select`.</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">      return {}; // Give up on this `select`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline"></td>
    <td class="lineNumber">1596</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline">    PossiblySpeculatableLoad Load(LI);</td>
    <td class="lineNumber">1597</td>
    <td class="codeline">    PossiblySpeculatableLoad Load(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">    if (!LI->isSimple()) {</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">    if (!LI->isSimple()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">      // If the `load` is not simple, we can't speculatively execute it,</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">      // If the `load` is not simple, we can't speculatively execute it,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">      // but we could handle this via a CFG modification. But can we?</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">      // but we could handle this via a CFG modification. But can we?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline">      if (PreserveCFG)</td>
    <td class="lineNumber">1601</td>
    <td class="codeline">      if (PreserveCFG)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">        return {}; // Give up on this `select`.</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">        return {}; // Give up on this `select`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">      Ops.emplace_back(Load);</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">      Ops.emplace_back(Load);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">1604</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline"></td>
    <td class="lineNumber">1606</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">    sroa::SelectHandSpeculativity Spec =</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">    sroa::SelectHandSpeculativity Spec =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">        isSafeLoadOfSelectToSpeculate(*LI, SI, PreserveCFG);</td>
    <td class="lineNumber">1608</td>
    <td class="codeline">        isSafeLoadOfSelectToSpeculate(*LI, SI, PreserveCFG);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">    if (PreserveCFG && !Spec.areAllSpeculatable())</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">    if (PreserveCFG && !Spec.areAllSpeculatable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline">      return {}; // Give up on this `select`.</td>
    <td class="lineNumber">1610</td>
    <td class="codeline">      return {}; // Give up on this `select`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline"></td>
    <td class="lineNumber">1611</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">    Load.setInt(Spec);</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">    Load.setInt(Spec);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline">    Ops.emplace_back(Load);</td>
    <td class="lineNumber">1613</td>
    <td class="codeline">    Ops.emplace_back(Load);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline"></td>
    <td class="lineNumber">1615</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline">  return Ops;</td>
    <td class="lineNumber">1616</td>
    <td class="codeline">  return Ops;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline"></td>
    <td class="lineNumber">1618</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline">static void speculateSelectInstLoads(SelectInst &SI, LoadInst &LI,</td>
    <td class="lineNumber">1619</td>
    <td class="codeline">static void speculateSelectInstLoads(SelectInst &SI, LoadInst &LI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">                                     IRBuilderTy &IRB) {</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">                                     IRBuilderTy &IRB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    original load: " << SI << "\n");</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    original load: " << SI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline"></td>
    <td class="lineNumber">1622</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">  Value *TV = SI.getTrueValue();</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">  Value *TV = SI.getTrueValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">  Value *FV = SI.getFalseValue();</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">  Value *FV = SI.getFalseValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline">  // Replace the given load of the select with a select of two loads.</td>
    <td class="lineNumber">1625</td>
    <td class="codeline">  // Replace the given load of the select with a select of two loads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline"></td>
    <td class="lineNumber">1626</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">  assert(LI.isSimple() && "We only speculate simple loads");</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">  assert(LI.isSimple() && "We only speculate simple loads");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline"></td>
    <td class="lineNumber">1628</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">  IRB.SetInsertPoint(&LI);</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">  IRB.SetInsertPoint(&LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline"></td>
    <td class="lineNumber">1630</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline">  LoadInst *TL =</td>
    <td class="lineNumber">1631</td>
    <td class="codeline">  LoadInst *TL =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">      IRB.CreateAlignedLoad(LI.getType(), TV, LI.getAlign(),</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">      IRB.CreateAlignedLoad(LI.getType(), TV, LI.getAlign(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">                            LI.getName() + ".sroa.speculate.load.true");</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">                            LI.getName() + ".sroa.speculate.load.true");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">  LoadInst *FL =</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">  LoadInst *FL =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">      IRB.CreateAlignedLoad(LI.getType(), FV, LI.getAlign(),</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">      IRB.CreateAlignedLoad(LI.getType(), FV, LI.getAlign(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">                            LI.getName() + ".sroa.speculate.load.false");</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">                            LI.getName() + ".sroa.speculate.load.false");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline">  NumLoadsSpeculated += 2;</td>
    <td class="lineNumber">1637</td>
    <td class="codeline">  NumLoadsSpeculated += 2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline"></td>
    <td class="lineNumber">1638</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">  // Transfer alignment and AA info if present.</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">  // Transfer alignment and AA info if present.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">  TL->setAlignment(LI.getAlign());</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">  TL->setAlignment(LI.getAlign());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">  FL->setAlignment(LI.getAlign());</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">  FL->setAlignment(LI.getAlign());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline"></td>
    <td class="lineNumber">1642</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline">  AAMDNodes Tags = LI.getAAMetadata();</td>
    <td class="lineNumber">1643</td>
    <td class="codeline">  AAMDNodes Tags = LI.getAAMetadata();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">  if (Tags) {</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">  if (Tags) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">    TL->setAAMetadata(Tags);</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">    TL->setAAMetadata(Tags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">    FL->setAAMetadata(Tags);</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">    FL->setAAMetadata(Tags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1647</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline"></td>
    <td class="lineNumber">1648</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">  Value *V = IRB.CreateSelect(SI.getCondition(), TL, FL,</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">  Value *V = IRB.CreateSelect(SI.getCondition(), TL, FL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">                              LI.getName() + ".sroa.speculated");</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">                              LI.getName() + ".sroa.speculated");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline"></td>
    <td class="lineNumber">1651</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "          speculated to: " << *V << "\n");</td>
    <td class="lineNumber">1652</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "          speculated to: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">  LI.replaceAllUsesWith(V);</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">  LI.replaceAllUsesWith(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline"></td>
    <td class="lineNumber">1655</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">template <typename T></td>
    <td class="lineNumber">1656</td>
    <td class="codeline">template <typename T></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">static void rewriteMemOpOfSelect(SelectInst &SI, T &I,</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">static void rewriteMemOpOfSelect(SelectInst &SI, T &I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">                                 sroa::SelectHandSpeculativity Spec,</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">                                 sroa::SelectHandSpeculativity Spec,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline">                                 DomTreeUpdater &DTU) {</td>
    <td class="lineNumber">1659</td>
    <td class="codeline">                                 DomTreeUpdater &DTU) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">  assert((isa<LoadInst>(I) || isa<StoreInst>(I)) && "Only for load and store!");</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">  assert((isa<LoadInst>(I) || isa<StoreInst>(I)) && "Only for load and store!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    original mem op: " << I << "\n");</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    original mem op: " << I << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">  BasicBlock *Head = I.getParent();</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">  BasicBlock *Head = I.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">  Instruction *ThenTerm = nullptr;</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">  Instruction *ThenTerm = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">  Instruction *ElseTerm = nullptr;</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">  Instruction *ElseTerm = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline">  if (Spec.areNoneSpeculatable())</td>
    <td class="lineNumber">1665</td>
    <td class="codeline">  if (Spec.areNoneSpeculatable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">    SplitBlockAndInsertIfThenElse(SI.getCondition(), &I, &ThenTerm, &ElseTerm,</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">    SplitBlockAndInsertIfThenElse(SI.getCondition(), &I, &ThenTerm, &ElseTerm,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">                                  SI.getMetadata(LLVMContext::MD_prof), &DTU);</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">                                  SI.getMetadata(LLVMContext::MD_prof), &DTU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">  else {</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">  else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">    SplitBlockAndInsertIfThen(SI.getCondition(), &I, /*Unreachable=*/false,</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">    SplitBlockAndInsertIfThen(SI.getCondition(), &I, /*Unreachable=*/false,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">                              SI.getMetadata(LLVMContext::MD_prof), &DTU,</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">                              SI.getMetadata(LLVMContext::MD_prof), &DTU,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline">                              /*LI=*/nullptr, /*ThenBlock=*/nullptr);</td>
    <td class="lineNumber">1671</td>
    <td class="codeline">                              /*LI=*/nullptr, /*ThenBlock=*/nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">    if (Spec.isSpeculatable(/*isTrueVal=*/true))</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">    if (Spec.isSpeculatable(/*isTrueVal=*/true))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">      cast<BranchInst>(Head->getTerminator())->swapSuccessors();</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">      cast<BranchInst>(Head->getTerminator())->swapSuccessors();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline">  auto *HeadBI = cast<BranchInst>(Head->getTerminator());</td>
    <td class="lineNumber">1675</td>
    <td class="codeline">  auto *HeadBI = cast<BranchInst>(Head->getTerminator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">  Spec = {}; // Do not use `Spec` beyond this point.</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">  Spec = {}; // Do not use `Spec` beyond this point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">  BasicBlock *Tail = I.getParent();</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">  BasicBlock *Tail = I.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline">  Tail->setName(Head->getName() + ".cont");</td>
    <td class="lineNumber">1678</td>
    <td class="codeline">  Tail->setName(Head->getName() + ".cont");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">  PHINode *PN;</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">  PHINode *PN;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">  if (isa<LoadInst>(I))</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">  if (isa<LoadInst>(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">    PN = PHINode::Create(I.getType(), 2, "", &I);</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">    PN = PHINode::Create(I.getType(), 2, "", &I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">  for (BasicBlock *SuccBB : successors(Head)) {</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">  for (BasicBlock *SuccBB : successors(Head)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline">    bool IsThen = SuccBB == HeadBI->getSuccessor(0);</td>
    <td class="lineNumber">1683</td>
    <td class="codeline">    bool IsThen = SuccBB == HeadBI->getSuccessor(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">    int SuccIdx = IsThen ? 0 : 1;</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">    int SuccIdx = IsThen ? 0 : 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">    auto *NewMemOpBB = SuccBB == Tail ? Head : SuccBB;</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">    auto *NewMemOpBB = SuccBB == Tail ? Head : SuccBB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline">    auto &CondMemOp = cast<T>(*I.clone());</td>
    <td class="lineNumber">1686</td>
    <td class="codeline">    auto &CondMemOp = cast<T>(*I.clone());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">    if (NewMemOpBB != Head) {</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">    if (NewMemOpBB != Head) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">      NewMemOpBB->setName(Head->getName() + (IsThen ? ".then" : ".else"));</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">      NewMemOpBB->setName(Head->getName() + (IsThen ? ".then" : ".else"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline">      if (isa<LoadInst>(I))</td>
    <td class="lineNumber">1689</td>
    <td class="codeline">      if (isa<LoadInst>(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">        ++NumLoadsPredicated;</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">        ++NumLoadsPredicated;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">        ++NumStoresPredicated;</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">        ++NumStoresPredicated;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1693</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">      CondMemOp.dropUBImplyingAttrsAndMetadata();</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">      CondMemOp.dropUBImplyingAttrsAndMetadata();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">      ++NumLoadsSpeculated;</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">      ++NumLoadsSpeculated;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1696</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">    CondMemOp.insertBefore(NewMemOpBB->getTerminator());</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">    CondMemOp.insertBefore(NewMemOpBB->getTerminator());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">    Value *Ptr = SI.getOperand(1 + SuccIdx);</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">    Value *Ptr = SI.getOperand(1 + SuccIdx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">    CondMemOp.setOperand(I.getPointerOperandIndex(), Ptr);</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">    CondMemOp.setOperand(I.getPointerOperandIndex(), Ptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">    if (isa<LoadInst>(I)) {</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">    if (isa<LoadInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">      CondMemOp.setName(I.getName() + (IsThen ? ".then" : ".else") + ".val");</td>
    <td class="lineNumber">1701</td>
    <td class="codeline">      CondMemOp.setName(I.getName() + (IsThen ? ".then" : ".else") + ".val");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">      PN->addIncoming(&CondMemOp, NewMemOpBB);</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">      PN->addIncoming(&CondMemOp, NewMemOpBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">    } else</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">    } else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "                 to: " << CondMemOp << "\n");</td>
    <td class="lineNumber">1704</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "                 to: " << CondMemOp << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">  if (isa<LoadInst>(I)) {</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">  if (isa<LoadInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">    PN->takeName(&I);</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">    PN->takeName(&I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *PN << "\n");</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *PN << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline">    I.replaceAllUsesWith(PN);</td>
    <td class="lineNumber">1709</td>
    <td class="codeline">    I.replaceAllUsesWith(PN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline"></td>
    <td class="lineNumber">1712</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">static void rewriteMemOpOfSelect(SelectInst &SelInst, Instruction &I,</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">static void rewriteMemOpOfSelect(SelectInst &SelInst, Instruction &I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">                                 sroa::SelectHandSpeculativity Spec,</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">                                 sroa::SelectHandSpeculativity Spec,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">                                 DomTreeUpdater &DTU) {</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">                                 DomTreeUpdater &DTU) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline">  if (auto *LI = dyn_cast<LoadInst>(&I))</td>
    <td class="lineNumber">1716</td>
    <td class="codeline">  if (auto *LI = dyn_cast<LoadInst>(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">    rewriteMemOpOfSelect(SelInst, *LI, Spec, DTU);</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">    rewriteMemOpOfSelect(SelInst, *LI, Spec, DTU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">  else if (auto *SI = dyn_cast<StoreInst>(&I))</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">  else if (auto *SI = dyn_cast<StoreInst>(&I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline">    rewriteMemOpOfSelect(SelInst, *SI, Spec, DTU);</td>
    <td class="lineNumber">1719</td>
    <td class="codeline">    rewriteMemOpOfSelect(SelInst, *SI, Spec, DTU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">    llvm_unreachable_internal("Only for load and store.");</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">    llvm_unreachable_internal("Only for load and store.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline"></td>
    <td class="lineNumber">1723</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">static bool rewriteSelectInstMemOps(SelectInst &SI,</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">static bool rewriteSelectInstMemOps(SelectInst &SI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">                                    const sroa::RewriteableMemOps &Ops,</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">                                    const sroa::RewriteableMemOps &Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">                                    IRBuilderTy &IRB, DomTreeUpdater *DTU) {</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">                                    IRBuilderTy &IRB, DomTreeUpdater *DTU) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">  bool CFGChanged = false;</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">  bool CFGChanged = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    original select: " << SI << "\n");</td>
    <td class="lineNumber">1728</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    original select: " << SI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline"></td>
    <td class="lineNumber">1729</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">  for (const RewriteableMemOp &Op : Ops) {</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">  for (const RewriteableMemOp &Op : Ops) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">    sroa::SelectHandSpeculativity Spec;</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">    sroa::SelectHandSpeculativity Spec;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline">    Instruction *I;</td>
    <td class="lineNumber">1732</td>
    <td class="codeline">    Instruction *I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">    if (auto *const *US = std::get_if<UnspeculatableStore>(&Op)) {</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">    if (auto *const *US = std::get_if<UnspeculatableStore>(&Op)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">      I = *US;</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">      I = *US;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">      auto PSL = std::get<PossiblySpeculatableLoad>(Op);</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">      auto PSL = std::get<PossiblySpeculatableLoad>(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">      I = PSL.getPointer();</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">      I = PSL.getPointer();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline">      Spec = PSL.getInt();</td>
    <td class="lineNumber">1738</td>
    <td class="codeline">      Spec = PSL.getInt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">    if (Spec.areAllSpeculatable()) {</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">    if (Spec.areAllSpeculatable()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">      speculateSelectInstLoads(SI, cast<LoadInst>(*I), IRB);</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">      speculateSelectInstLoads(SI, cast<LoadInst>(*I), IRB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">      assert(DTU && "Should not get here when not allowed to modify the CFG!");</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">      assert(DTU && "Should not get here when not allowed to modify the CFG!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">      rewriteMemOpOfSelect(SI, *I, Spec, *DTU);</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">      rewriteMemOpOfSelect(SI, *I, Spec, *DTU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline">      CFGChanged = true;</td>
    <td class="lineNumber">1745</td>
    <td class="codeline">      CFGChanged = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">    I->eraseFromParent();</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">    I->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline"></td>
    <td class="lineNumber">1749</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline">  for (User *U : make_early_inc_range(SI.users()))</td>
    <td class="lineNumber">1750</td>
    <td class="codeline">  for (User *U : make_early_inc_range(SI.users()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">    cast<BitCastInst>(U)->eraseFromParent();</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">    cast<BitCastInst>(U)->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">  SI.eraseFromParent();</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">  SI.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline">  return CFGChanged;</td>
    <td class="lineNumber">1753</td>
    <td class="codeline">  return CFGChanged;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline"></td>
    <td class="lineNumber">1755</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">/// Compute an adjusted pointer from Ptr by Offset bytes where the</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">/// Compute an adjusted pointer from Ptr by Offset bytes where the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">/// resulting pointer has PointerTy.</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">/// resulting pointer has PointerTy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">static Value *getAdjustedPtr(IRBuilderTy &IRB, const DataLayout &DL, Value *Ptr,</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">static Value *getAdjustedPtr(IRBuilderTy &IRB, const DataLayout &DL, Value *Ptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">                             APInt Offset, Type *PointerTy,</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">                             APInt Offset, Type *PointerTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">                             const Twine &NamePrefix) {</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">                             const Twine &NamePrefix) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline">  if (Offset != 0)</td>
    <td class="lineNumber">1761</td>
    <td class="codeline">  if (Offset != 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">    Ptr = IRB.CreateInBoundsGEP(IRB.getInt8Ty(), Ptr, IRB.getInt(Offset),</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">    Ptr = IRB.CreateInBoundsGEP(IRB.getInt8Ty(), Ptr, IRB.getInt(Offset),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">                                NamePrefix + "sroa_idx");</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">                                NamePrefix + "sroa_idx");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">  return IRB.CreatePointerBitCastOrAddrSpaceCast(Ptr, PointerTy,</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">  return IRB.CreatePointerBitCastOrAddrSpaceCast(Ptr, PointerTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline">                                                 NamePrefix + "sroa_cast");</td>
    <td class="lineNumber">1765</td>
    <td class="codeline">                                                 NamePrefix + "sroa_cast");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
    <td class="lineNumber">1767</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">/// Compute the adjusted alignment for a load or store from an offset.</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">/// Compute the adjusted alignment for a load or store from an offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline">static Align getAdjustedAlignment(Instruction *I, uint64_t Offset) {</td>
    <td class="lineNumber">1769</td>
    <td class="codeline">static Align getAdjustedAlignment(Instruction *I, uint64_t Offset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">  return commonAlignment(getLoadStoreAlignment(I), Offset);</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">  return commonAlignment(getLoadStoreAlignment(I), Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline"></td>
    <td class="lineNumber">1772</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline">/// Test whether we can convert a value from the old to the new type.</td>
    <td class="lineNumber">1773</td>
    <td class="codeline">/// Test whether we can convert a value from the old to the new type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">/// This predicate should be used to guard calls to convertValue in order to</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">/// This predicate should be used to guard calls to convertValue in order to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">/// ensure that we only try to convert viable values. The strategy is that we</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">/// ensure that we only try to convert viable values. The strategy is that we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">/// will peel off single element struct and array wrappings to get to an</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">/// will peel off single element struct and array wrappings to get to an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline">/// underlying value, and convert that value.</td>
    <td class="lineNumber">1778</td>
    <td class="codeline">/// underlying value, and convert that value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">static bool canConvertValue(const DataLayout &DL, Type *OldTy, Type *NewTy) {</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">static bool canConvertValue(const DataLayout &DL, Type *OldTy, Type *NewTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline">  if (OldTy == NewTy)</td>
    <td class="lineNumber">1780</td>
    <td class="codeline">  if (OldTy == NewTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline"></td>
    <td class="lineNumber">1782</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">  // For integer types, we can't handle any bit-width differences. This would</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">  // For integer types, we can't handle any bit-width differences. This would</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">  // break both vector conversions with extension and introduce endianness</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">  // break both vector conversions with extension and introduce endianness</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">  // issues when in conjunction with loads and stores.</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">  // issues when in conjunction with loads and stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">  if (isa<IntegerType>(OldTy) && isa<IntegerType>(NewTy)) {</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">  if (isa<IntegerType>(OldTy) && isa<IntegerType>(NewTy)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">    assert(cast<IntegerType>(OldTy)->getBitWidth() !=</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">    assert(cast<IntegerType>(OldTy)->getBitWidth() !=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">               cast<IntegerType>(NewTy)->getBitWidth() &&</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">               cast<IntegerType>(NewTy)->getBitWidth() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">           "We can't have the same bitwidth for different int types");</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">           "We can't have the same bitwidth for different int types");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline"></td>
    <td class="lineNumber">1792</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline">  if (DL.getTypeSizeInBits(NewTy).getFixedValue() !=</td>
    <td class="lineNumber">1793</td>
    <td class="codeline">  if (DL.getTypeSizeInBits(NewTy).getFixedValue() !=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">      DL.getTypeSizeInBits(OldTy).getFixedValue())</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">      DL.getTypeSizeInBits(OldTy).getFixedValue())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">  if (!NewTy->isSingleValueType() || !OldTy->isSingleValueType())</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">  if (!NewTy->isSingleValueType() || !OldTy->isSingleValueType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline"></td>
    <td class="lineNumber">1798</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">  // We can convert pointers to integers and vice-versa. Same for vectors</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">  // We can convert pointers to integers and vice-versa. Same for vectors</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">  // of pointers and integers.</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">  // of pointers and integers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">  OldTy = OldTy->getScalarType();</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">  OldTy = OldTy->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">  NewTy = NewTy->getScalarType();</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">  NewTy = NewTy->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline">  if (NewTy->isPointerTy() || OldTy->isPointerTy()) {</td>
    <td class="lineNumber">1803</td>
    <td class="codeline">  if (NewTy->isPointerTy() || OldTy->isPointerTy()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">    if (NewTy->isPointerTy() && OldTy->isPointerTy()) {</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">    if (NewTy->isPointerTy() && OldTy->isPointerTy()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">      unsigned OldAS = OldTy->getPointerAddressSpace();</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">      unsigned OldAS = OldTy->getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">      unsigned NewAS = NewTy->getPointerAddressSpace();</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">      unsigned NewAS = NewTy->getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">      // Convert pointers if they are pointers from the same address space or</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">      // Convert pointers if they are pointers from the same address space or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">      // different integral (not non-integral) address spaces with the same</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">      // different integral (not non-integral) address spaces with the same</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">      // pointer size.</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">      // pointer size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">      return OldAS == NewAS ||</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">      return OldAS == NewAS ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">             (!DL.isNonIntegralAddressSpace(OldAS) &&</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">             (!DL.isNonIntegralAddressSpace(OldAS) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline">              !DL.isNonIntegralAddressSpace(NewAS) &&</td>
    <td class="lineNumber">1812</td>
    <td class="codeline">              !DL.isNonIntegralAddressSpace(NewAS) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">              DL.getPointerSize(OldAS) == DL.getPointerSize(NewAS));</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">              DL.getPointerSize(OldAS) == DL.getPointerSize(NewAS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline"></td>
    <td class="lineNumber">1815</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">    // We can convert integers to integral pointers, but not to non-integral</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">    // We can convert integers to integral pointers, but not to non-integral</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">    // pointers.</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">    // pointers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">    if (OldTy->isIntegerTy())</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">    if (OldTy->isIntegerTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">      return !DL.isNonIntegralPointerType(NewTy);</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">      return !DL.isNonIntegralPointerType(NewTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline"></td>
    <td class="lineNumber">1820</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">    // We can convert integral pointers to integers, but non-integral pointers</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">    // We can convert integral pointers to integers, but non-integral pointers</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">    // need to remain pointers.</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">    // need to remain pointers.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">    if (!DL.isNonIntegralPointerType(OldTy))</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">    if (!DL.isNonIntegralPointerType(OldTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">      return NewTy->isIntegerTy();</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">      return NewTy->isIntegerTy();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline"></td>
    <td class="lineNumber">1825</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline"></td>
    <td class="lineNumber">1828</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">  if (OldTy->isTargetExtTy() || NewTy->isTargetExtTy())</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">  if (OldTy->isTargetExtTy() || NewTy->isTargetExtTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1830</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline"></td>
    <td class="lineNumber">1831</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline"></td>
    <td class="lineNumber">1834</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">/// Generic routine to convert an SSA value to a value of a different</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">/// Generic routine to convert an SSA value to a value of a different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">/// type.</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">/// type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline">/// This will try various different casting techniques, such as bitcasts,</td>
    <td class="lineNumber">1838</td>
    <td class="codeline">/// This will try various different casting techniques, such as bitcasts,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">/// inttoptr, and ptrtoint casts. Use the \c canConvertValue predicate to test</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">/// inttoptr, and ptrtoint casts. Use the \c canConvertValue predicate to test</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">/// two types for viability with this routine.</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">/// two types for viability with this routine.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">static Value *convertValue(const DataLayout &DL, IRBuilderTy &IRB, Value *V,</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">static Value *convertValue(const DataLayout &DL, IRBuilderTy &IRB, Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">                           Type *NewTy) {</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">                           Type *NewTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">  Type *OldTy = V->getType();</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">  Type *OldTy = V->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">  assert(canConvertValue(DL, OldTy, NewTy) && "Value not convertable to type");</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">  assert(canConvertValue(DL, OldTy, NewTy) && "Value not convertable to type");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline"></td>
    <td class="lineNumber">1845</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">  if (OldTy == NewTy)</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">  if (OldTy == NewTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline"></td>
    <td class="lineNumber">1848</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">  assert(!(isa<IntegerType>(OldTy) && isa<IntegerType>(NewTy)) &&</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">  assert(!(isa<IntegerType>(OldTy) && isa<IntegerType>(NewTy)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline">         "Integer types must be the exact same to convert.");</td>
    <td class="lineNumber">1850</td>
    <td class="codeline">         "Integer types must be the exact same to convert.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline"></td>
    <td class="lineNumber">1851</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">  // See if we need inttoptr for this type pair. May require additional bitcast.</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">  // See if we need inttoptr for this type pair. May require additional bitcast.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">  if (OldTy->isIntOrIntVectorTy() && NewTy->isPtrOrPtrVectorTy()) {</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">  if (OldTy->isIntOrIntVectorTy() && NewTy->isPtrOrPtrVectorTy()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">    // Expand <2 x i32> to i8* --> <2 x i32> to i64 to i8*</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">    // Expand <2 x i32> to i8* --> <2 x i32> to i64 to i8*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">    // Expand i128 to <2 x i8*> --> i128 to <2 x i64> to <2 x i8*></td>
    <td class="lineNumber">1855</td>
    <td class="codeline">    // Expand i128 to <2 x i8*> --> i128 to <2 x i64> to <2 x i8*></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">    // Expand <4 x i32> to <2 x i8*> --> <4 x i32> to <2 x i64> to <2 x i8*></td>
    <td class="lineNumber">1856</td>
    <td class="codeline">    // Expand <4 x i32> to <2 x i8*> --> <4 x i32> to <2 x i64> to <2 x i8*></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">    // Directly handle i64 to i8*</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">    // Directly handle i64 to i8*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">    return IRB.CreateIntToPtr(IRB.CreateBitCast(V, DL.getIntPtrType(NewTy)),</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">    return IRB.CreateIntToPtr(IRB.CreateBitCast(V, DL.getIntPtrType(NewTy)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">                              NewTy);</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">                              NewTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline"></td>
    <td class="lineNumber">1861</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">  // See if we need ptrtoint for this type pair. May require additional bitcast.</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">  // See if we need ptrtoint for this type pair. May require additional bitcast.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">  if (OldTy->isPtrOrPtrVectorTy() && NewTy->isIntOrIntVectorTy()) {</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">  if (OldTy->isPtrOrPtrVectorTy() && NewTy->isIntOrIntVectorTy()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">    // Expand <2 x i8*> to i128 --> <2 x i8*> to <2 x i64> to i128</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">    // Expand <2 x i8*> to i128 --> <2 x i8*> to <2 x i64> to i128</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">    // Expand i8* to <2 x i32> --> i8* to i64 to <2 x i32></td>
    <td class="lineNumber">1865</td>
    <td class="codeline">    // Expand i8* to <2 x i32> --> i8* to i64 to <2 x i32></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline">    // Expand <2 x i8*> to <4 x i32> --> <2 x i8*> to <2 x i64> to <4 x i32></td>
    <td class="lineNumber">1866</td>
    <td class="codeline">    // Expand <2 x i8*> to <4 x i32> --> <2 x i8*> to <2 x i64> to <4 x i32></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">    // Expand i8* to i64 --> i8* to i64 to i64</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">    // Expand i8* to i64 --> i8* to i64 to i64</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">    return IRB.CreateBitCast(IRB.CreatePtrToInt(V, DL.getIntPtrType(OldTy)),</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">    return IRB.CreateBitCast(IRB.CreatePtrToInt(V, DL.getIntPtrType(OldTy)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">                             NewTy);</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">                             NewTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1870</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline"></td>
    <td class="lineNumber">1871</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">  if (OldTy->isPtrOrPtrVectorTy() && NewTy->isPtrOrPtrVectorTy()) {</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">  if (OldTy->isPtrOrPtrVectorTy() && NewTy->isPtrOrPtrVectorTy()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">    unsigned OldAS = OldTy->getPointerAddressSpace();</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">    unsigned OldAS = OldTy->getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">    unsigned NewAS = NewTy->getPointerAddressSpace();</td>
    <td class="lineNumber">1874</td>
    <td class="codeline">    unsigned NewAS = NewTy->getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">    // To convert pointers with different address spaces (they are already</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">    // To convert pointers with different address spaces (they are already</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline">    // checked convertible, i.e. they have the same pointer size), so far we</td>
    <td class="lineNumber">1876</td>
    <td class="codeline">    // checked convertible, i.e. they have the same pointer size), so far we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">    // cannot use `bitcast` (which has restrict on the same address space) or</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">    // cannot use `bitcast` (which has restrict on the same address space) or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">    // `addrspacecast` (which is not always no-op casting). Instead, use a pair</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">    // `addrspacecast` (which is not always no-op casting). Instead, use a pair</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">    // of no-op `ptrtoint`/`inttoptr` casts through an integer with the same bit</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">    // of no-op `ptrtoint`/`inttoptr` casts through an integer with the same bit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">    // size.</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">    // size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">    if (OldAS != NewAS) {</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">    if (OldAS != NewAS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">      assert(DL.getPointerSize(OldAS) == DL.getPointerSize(NewAS));</td>
    <td class="lineNumber">1882</td>
    <td class="codeline">      assert(DL.getPointerSize(OldAS) == DL.getPointerSize(NewAS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">      return IRB.CreateIntToPtr(IRB.CreatePtrToInt(V, DL.getIntPtrType(OldTy)),</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">      return IRB.CreateIntToPtr(IRB.CreatePtrToInt(V, DL.getIntPtrType(OldTy)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline">                                NewTy);</td>
    <td class="lineNumber">1884</td>
    <td class="codeline">                                NewTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline"></td>
    <td class="lineNumber">1887</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">  return IRB.CreateBitCast(V, NewTy);</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">  return IRB.CreateBitCast(V, NewTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline"></td>
    <td class="lineNumber">1890</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">/// Test whether the given slice use can be promoted to a vector.</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">/// Test whether the given slice use can be promoted to a vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">/// This function is called to test each entry in a partition which is slated</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">/// This function is called to test each entry in a partition which is slated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline">/// for a single slice.</td>
    <td class="lineNumber">1894</td>
    <td class="codeline">/// for a single slice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">static bool isVectorPromotionViableForSlice(Partition &P, const Slice &S,</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">static bool isVectorPromotionViableForSlice(Partition &P, const Slice &S,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">                                            VectorType *Ty,</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">                                            VectorType *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">                                            uint64_t ElementSize,</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">                                            uint64_t ElementSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">                                            const DataLayout &DL) {</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">                                            const DataLayout &DL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">  // First validate the slice offsets.</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">  // First validate the slice offsets.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">  uint64_t BeginOffset =</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">  uint64_t BeginOffset =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">      std::max(S.beginOffset(), P.beginOffset()) - P.beginOffset();</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">      std::max(S.beginOffset(), P.beginOffset()) - P.beginOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">  uint64_t BeginIndex = BeginOffset / ElementSize;</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">  uint64_t BeginIndex = BeginOffset / ElementSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline">  if (BeginIndex * ElementSize != BeginOffset ||</td>
    <td class="lineNumber">1903</td>
    <td class="codeline">  if (BeginIndex * ElementSize != BeginOffset ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">      BeginIndex >= cast<FixedVectorType>(Ty)->getNumElements())</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">      BeginIndex >= cast<FixedVectorType>(Ty)->getNumElements())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">  uint64_t EndOffset =</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">  uint64_t EndOffset =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">      std::min(S.endOffset(), P.endOffset()) - P.beginOffset();</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">      std::min(S.endOffset(), P.endOffset()) - P.beginOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">  uint64_t EndIndex = EndOffset / ElementSize;</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">  uint64_t EndIndex = EndOffset / ElementSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">  if (EndIndex * ElementSize != EndOffset ||</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">  if (EndIndex * ElementSize != EndOffset ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">      EndIndex > cast<FixedVectorType>(Ty)->getNumElements())</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">      EndIndex > cast<FixedVectorType>(Ty)->getNumElements())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline"></td>
    <td class="lineNumber">1912</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">  assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">  assert(EndIndex > BeginIndex && "Empty vector!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">  uint64_t NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">  uint64_t NumElements = EndIndex - BeginIndex;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">  Type *SliceTy = (NumElements == 1)</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">  Type *SliceTy = (NumElements == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">                      ? Ty->getElementType()</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">                      ? Ty->getElementType()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">                      : FixedVectorType::get(Ty->getElementType(), NumElements);</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">                      : FixedVectorType::get(Ty->getElementType(), NumElements);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline"></td>
    <td class="lineNumber">1918</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">  Type *SplitIntTy =</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">  Type *SplitIntTy =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">      Type::getIntNTy(Ty->getContext(), NumElements * ElementSize * 8);</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">      Type::getIntNTy(Ty->getContext(), NumElements * ElementSize * 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline"></td>
    <td class="lineNumber">1921</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">  Use *U = S.getUse();</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">  Use *U = S.getUse();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline"></td>
    <td class="lineNumber">1923</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">  if (MemIntrinsic *MI = dyn_cast<MemIntrinsic>(U->getUser())) {</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">  if (MemIntrinsic *MI = dyn_cast<MemIntrinsic>(U->getUser())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">    if (MI->isVolatile())</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">    if (MI->isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1926</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">    if (!S.isSplittable())</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">    if (!S.isSplittable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">      return false; // Skip any unsplittable intrinsics.</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">      return false; // Skip any unsplittable intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">  } else if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(U->getUser())) {</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">  } else if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(U->getUser())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">    if (!II->isLifetimeStartOrEnd() && !II->isDroppable())</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">    if (!II->isLifetimeStartOrEnd() && !II->isDroppable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline">  } else if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
    <td class="lineNumber">1932</td>
    <td class="codeline">  } else if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline">    if (LI->isVolatile())</td>
    <td class="lineNumber">1933</td>
    <td class="codeline">    if (LI->isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">    Type *LTy = LI->getType();</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">    Type *LTy = LI->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">    // Disable vector promotion when there are loads or stores of an FCA.</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">    // Disable vector promotion when there are loads or stores of an FCA.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">    if (LTy->isStructTy())</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">    if (LTy->isStructTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">    if (P.beginOffset() > S.beginOffset() || P.endOffset() < S.endOffset()) {</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">    if (P.beginOffset() > S.beginOffset() || P.endOffset() < S.endOffset()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">      assert(LTy->isIntegerTy());</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">      assert(LTy->isIntegerTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline">      LTy = SplitIntTy;</td>
    <td class="lineNumber">1941</td>
    <td class="codeline">      LTy = SplitIntTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">    if (!canConvertValue(DL, SliceTy, LTy))</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">    if (!canConvertValue(DL, SliceTy, LTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">  } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">  } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline">    if (SI->isVolatile())</td>
    <td class="lineNumber">1946</td>
    <td class="codeline">    if (SI->isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1947</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">    Type *STy = SI->getValueOperand()->getType();</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">    Type *STy = SI->getValueOperand()->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">    // Disable vector promotion when there are loads or stores of an FCA.</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">    // Disable vector promotion when there are loads or stores of an FCA.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">    if (STy->isStructTy())</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">    if (STy->isStructTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">    if (P.beginOffset() > S.beginOffset() || P.endOffset() < S.endOffset()) {</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">    if (P.beginOffset() > S.beginOffset() || P.endOffset() < S.endOffset()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">      assert(STy->isIntegerTy());</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">      assert(STy->isIntegerTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">      STy = SplitIntTy;</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">      STy = SplitIntTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">    if (!canConvertValue(DL, STy, SliceTy))</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">    if (!canConvertValue(DL, STy, SliceTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1957</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline"></td>
    <td class="lineNumber">1961</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline"></td>
    <td class="lineNumber">1964</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">/// Test whether a vector type is viable for promotion.</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">/// Test whether a vector type is viable for promotion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">/// This implements the necessary checking for \c isVectorPromotionViable over</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">/// This implements the necessary checking for \c isVectorPromotionViable over</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">/// all slices of the alloca for the given VectorType.</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">/// all slices of the alloca for the given VectorType.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline">static bool checkVectorTypeForPromotion(Partition &P, VectorType *VTy,</td>
    <td class="lineNumber">1969</td>
    <td class="codeline">static bool checkVectorTypeForPromotion(Partition &P, VectorType *VTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">                                        const DataLayout &DL) {</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">                                        const DataLayout &DL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">  uint64_t ElementSize =</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">  uint64_t ElementSize =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">      DL.getTypeSizeInBits(VTy->getElementType()).getFixedValue();</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">      DL.getTypeSizeInBits(VTy->getElementType()).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline"></td>
    <td class="lineNumber">1973</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">  // While the definition of LLVM vectors is bitpacked, we don't support sizes</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">  // While the definition of LLVM vectors is bitpacked, we don't support sizes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">  // that aren't byte sized.</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">  // that aren't byte sized.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">  if (ElementSize % 8)</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">  if (ElementSize % 8)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">  assert((DL.getTypeSizeInBits(VTy).getFixedValue() % 8) == 0 &&</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">  assert((DL.getTypeSizeInBits(VTy).getFixedValue() % 8) == 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">         "vector size not a multiple of element size?");</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">         "vector size not a multiple of element size?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">  ElementSize /= 8;</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">  ElementSize /= 8;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline"></td>
    <td class="lineNumber">1981</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">  for (const Slice &S : P)</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">  for (const Slice &S : P)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">    if (!isVectorPromotionViableForSlice(P, S, VTy, ElementSize, DL))</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">    if (!isVectorPromotionViableForSlice(P, S, VTy, ElementSize, DL))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline"></td>
    <td class="lineNumber">1985</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">  for (const Slice *S : P.splitSliceTails())</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">  for (const Slice *S : P.splitSliceTails())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">    if (!isVectorPromotionViableForSlice(P, *S, VTy, ElementSize, DL))</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">    if (!isVectorPromotionViableForSlice(P, *S, VTy, ElementSize, DL))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline"></td>
    <td class="lineNumber">1989</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">1990</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">}</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline"></td>
    <td class="lineNumber">1992</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">/// Test whether the given alloca partitioning and range of slices can be</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">/// Test whether the given alloca partitioning and range of slices can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">/// promoted to a vector.</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">/// promoted to a vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">///</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline">/// This is a quick test to check whether we can rewrite a particular alloca</td>
    <td class="lineNumber">1996</td>
    <td class="codeline">/// This is a quick test to check whether we can rewrite a particular alloca</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">/// partition (and its newly formed alloca) into a vector alloca with only</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">/// partition (and its newly formed alloca) into a vector alloca with only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">/// whole-vector loads and stores such that it could be promoted to a vector</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">/// whole-vector loads and stores such that it could be promoted to a vector</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">/// SSA value. We only can ensure this for a limited set of operations, and we</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">/// SSA value. We only can ensure this for a limited set of operations, and we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">/// don't want to do the rewrites unless we are confident that the result will</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">/// don't want to do the rewrites unless we are confident that the result will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline">/// be promotable, so we have an early test here.</td>
    <td class="lineNumber">2001</td>
    <td class="codeline">/// be promotable, so we have an early test here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">static VectorType *isVectorPromotionViable(Partition &P, const DataLayout &DL) {</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">static VectorType *isVectorPromotionViable(Partition &P, const DataLayout &DL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">  // Collect the candidate types for vector-based promotion. Also track whether</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">  // Collect the candidate types for vector-based promotion. Also track whether</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">  // we have different element types.</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">  // we have different element types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">  SmallVector<VectorType *, 4> CandidateTys;</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">  SmallVector<VectorType *, 4> CandidateTys;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">  SetVector<Type *> LoadStoreTys;</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">  SetVector<Type *> LoadStoreTys;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">  Type *CommonEltTy = nullptr;</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">  Type *CommonEltTy = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">  VectorType *CommonVecPtrTy = nullptr;</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">  VectorType *CommonVecPtrTy = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline">  bool HaveVecPtrTy = false;</td>
    <td class="lineNumber">2009</td>
    <td class="codeline">  bool HaveVecPtrTy = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">  bool HaveCommonEltTy = true;</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">  bool HaveCommonEltTy = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">  bool HaveCommonVecPtrTy = true;</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">  bool HaveCommonVecPtrTy = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">  auto CheckCandidateType = [&](Type *Ty) {</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">  auto CheckCandidateType = [&](Type *Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline">      // Return if bitcast to vectors is different for total size in bits.</td>
    <td class="lineNumber">2014</td>
    <td class="codeline">      // Return if bitcast to vectors is different for total size in bits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">      if (!CandidateTys.empty()) {</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">      if (!CandidateTys.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">        VectorType *V = CandidateTys[0];</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">        VectorType *V = CandidateTys[0];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">        if (DL.getTypeSizeInBits(VTy).getFixedValue() !=</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">        if (DL.getTypeSizeInBits(VTy).getFixedValue() !=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline">            DL.getTypeSizeInBits(V).getFixedValue()) {</td>
    <td class="lineNumber">2018</td>
    <td class="codeline">            DL.getTypeSizeInBits(V).getFixedValue()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">          CandidateTys.clear();</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">          CandidateTys.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">          return;</td>
    <td class="lineNumber">2020</td>
    <td class="codeline">          return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">2021</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">      CandidateTys.push_back(VTy);</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">      CandidateTys.push_back(VTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline">      Type *EltTy = VTy->getElementType();</td>
    <td class="lineNumber">2024</td>
    <td class="codeline">      Type *EltTy = VTy->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline"></td>
    <td class="lineNumber">2025</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline">      if (!CommonEltTy)</td>
    <td class="lineNumber">2026</td>
    <td class="codeline">      if (!CommonEltTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline">        CommonEltTy = EltTy;</td>
    <td class="lineNumber">2027</td>
    <td class="codeline">        CommonEltTy = EltTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">      else if (CommonEltTy != EltTy)</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">      else if (CommonEltTy != EltTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">        HaveCommonEltTy = false;</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">        HaveCommonEltTy = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline"></td>
    <td class="lineNumber">2030</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">      if (EltTy->isPointerTy()) {</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">      if (EltTy->isPointerTy()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">        HaveVecPtrTy = true;</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">        HaveVecPtrTy = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline">        if (!CommonVecPtrTy)</td>
    <td class="lineNumber">2033</td>
    <td class="codeline">        if (!CommonVecPtrTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">          CommonVecPtrTy = VTy;</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">          CommonVecPtrTy = VTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">        else if (CommonVecPtrTy != VTy)</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">        else if (CommonVecPtrTy != VTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline">          HaveCommonVecPtrTy = false;</td>
    <td class="lineNumber">2036</td>
    <td class="codeline">          HaveCommonVecPtrTy = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">2039</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">  // Put load and store types into a set for de-duplication.</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">  // Put load and store types into a set for de-duplication.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">  for (const Slice &S : P) {</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">  for (const Slice &S : P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">    Type *Ty;</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">    Type *Ty;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline">    if (auto *LI = dyn_cast<LoadInst>(S.getUse()->getUser()))</td>
    <td class="lineNumber">2043</td>
    <td class="codeline">    if (auto *LI = dyn_cast<LoadInst>(S.getUse()->getUser()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">      Ty = LI->getType();</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">      Ty = LI->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">    else if (auto *SI = dyn_cast<StoreInst>(S.getUse()->getUser()))</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">    else if (auto *SI = dyn_cast<StoreInst>(S.getUse()->getUser()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">      Ty = SI->getValueOperand()->getType();</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">      Ty = SI->getValueOperand()->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">    LoadStoreTys.insert(Ty);</td>
    <td class="lineNumber">2049</td>
    <td class="codeline">    LoadStoreTys.insert(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">    // Consider any loads or stores that are the exact size of the slice.</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">    // Consider any loads or stores that are the exact size of the slice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">    if (S.beginOffset() == P.beginOffset() && S.endOffset() == P.endOffset())</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">    if (S.beginOffset() == P.beginOffset() && S.endOffset() == P.endOffset())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline">      CheckCandidateType(Ty);</td>
    <td class="lineNumber">2052</td>
    <td class="codeline">      CheckCandidateType(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">  // Consider additional vector types where the element type size is a</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">  // Consider additional vector types where the element type size is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline">  // multiple of load/store element size.</td>
    <td class="lineNumber">2055</td>
    <td class="codeline">  // multiple of load/store element size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">  for (Type *Ty : LoadStoreTys) {</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">  for (Type *Ty : LoadStoreTys) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">    if (!VectorType::isValidElementType(Ty))</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">    if (!VectorType::isValidElementType(Ty))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline">    unsigned TypeSize = DL.getTypeSizeInBits(Ty).getFixedValue();</td>
    <td class="lineNumber">2059</td>
    <td class="codeline">    unsigned TypeSize = DL.getTypeSizeInBits(Ty).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">    // Make a copy of CandidateTys and iterate through it, because we might</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">    // Make a copy of CandidateTys and iterate through it, because we might</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">    // append to CandidateTys in the loop.</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">    // append to CandidateTys in the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">    SmallVector<VectorType *, 4> CandidateTysCopy = CandidateTys;</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">    SmallVector<VectorType *, 4> CandidateTysCopy = CandidateTys;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline">    for (VectorType *&VTy : CandidateTysCopy) {</td>
    <td class="lineNumber">2063</td>
    <td class="codeline">    for (VectorType *&VTy : CandidateTysCopy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">      unsigned VectorSize = DL.getTypeSizeInBits(VTy).getFixedValue();</td>
    <td class="lineNumber">2064</td>
    <td class="codeline">      unsigned VectorSize = DL.getTypeSizeInBits(VTy).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">      unsigned ElementSize =</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">      unsigned ElementSize =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">          DL.getTypeSizeInBits(VTy->getElementType()).getFixedValue();</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">          DL.getTypeSizeInBits(VTy->getElementType()).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline">      if (TypeSize != VectorSize && TypeSize != ElementSize &&</td>
    <td class="lineNumber">2067</td>
    <td class="codeline">      if (TypeSize != VectorSize && TypeSize != ElementSize &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">          VectorSize % TypeSize == 0) {</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">          VectorSize % TypeSize == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">        VectorType *NewVTy = VectorType::get(Ty, VectorSize / TypeSize, false);</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">        VectorType *NewVTy = VectorType::get(Ty, VectorSize / TypeSize, false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">        CheckCandidateType(NewVTy);</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">        CheckCandidateType(NewVTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2072</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline"></td>
    <td class="lineNumber">2074</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline">  // If we didn't find a vector type, nothing to do here.</td>
    <td class="lineNumber">2075</td>
    <td class="codeline">  // If we didn't find a vector type, nothing to do here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">  if (CandidateTys.empty())</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">  if (CandidateTys.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline"></td>
    <td class="lineNumber">2078</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">  // Pointer-ness is sticky, if we had a vector-of-pointers candidate type,</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">  // Pointer-ness is sticky, if we had a vector-of-pointers candidate type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">  // then we should choose it, not some other alternative.</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">  // then we should choose it, not some other alternative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">  // But, we can't perform a no-op pointer address space change via bitcast,</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">  // But, we can't perform a no-op pointer address space change via bitcast,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">  // so if we didn't have a common pointer element type, bail.</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">  // so if we didn't have a common pointer element type, bail.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">  if (HaveVecPtrTy && !HaveCommonVecPtrTy)</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">  if (HaveVecPtrTy && !HaveCommonVecPtrTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">2084</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline"></td>
    <td class="lineNumber">2085</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">  // Try to pick the "best" element type out of the choices.</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">  // Try to pick the "best" element type out of the choices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">  if (!HaveCommonEltTy && HaveVecPtrTy) {</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">  if (!HaveCommonEltTy && HaveVecPtrTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline">    // If there was a pointer element type, there's really only one choice.</td>
    <td class="lineNumber">2088</td>
    <td class="codeline">    // If there was a pointer element type, there's really only one choice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">    CandidateTys.clear();</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">    CandidateTys.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">    CandidateTys.push_back(CommonVecPtrTy);</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">    CandidateTys.push_back(CommonVecPtrTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">  } else if (!HaveCommonEltTy && !HaveVecPtrTy) {</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">  } else if (!HaveCommonEltTy && !HaveVecPtrTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">    // Integer-ify vector types.</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">    // Integer-ify vector types.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline">    for (VectorType *&VTy : CandidateTys) {</td>
    <td class="lineNumber">2093</td>
    <td class="codeline">    for (VectorType *&VTy : CandidateTys) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">      if (!VTy->getElementType()->isIntegerTy())</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">      if (!VTy->getElementType()->isIntegerTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">        VTy = cast<VectorType>(VTy->getWithNewType(IntegerType::getIntNTy(</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">        VTy = cast<VectorType>(VTy->getWithNewType(IntegerType::getIntNTy(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">            VTy->getContext(), VTy->getScalarSizeInBits())));</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">            VTy->getContext(), VTy->getScalarSizeInBits())));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline"></td>
    <td class="lineNumber">2098</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">    // Rank the remaining candidate vector types. This is easy because we know</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">    // Rank the remaining candidate vector types. This is easy because we know</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">    // they're all integer vectors. We sort by ascending number of elements.</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">    // they're all integer vectors. We sort by ascending number of elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">    auto RankVectorTypesComp = [&DL](VectorType *RHSTy, VectorType *LHSTy) {</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">    auto RankVectorTypesComp = [&DL](VectorType *RHSTy, VectorType *LHSTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">      (void)DL;</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">      (void)DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">      assert(DL.getTypeSizeInBits(RHSTy).getFixedValue() ==</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">      assert(DL.getTypeSizeInBits(RHSTy).getFixedValue() ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">                 DL.getTypeSizeInBits(LHSTy).getFixedValue() &&</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">                 DL.getTypeSizeInBits(LHSTy).getFixedValue() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">             "Cannot have vector types of different sizes!");</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">             "Cannot have vector types of different sizes!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">      assert(RHSTy->getElementType()->isIntegerTy() &&</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">      assert(RHSTy->getElementType()->isIntegerTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">             "All non-integer types eliminated!");</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">             "All non-integer types eliminated!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">      assert(LHSTy->getElementType()->isIntegerTy() &&</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">      assert(LHSTy->getElementType()->isIntegerTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">             "All non-integer types eliminated!");</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">             "All non-integer types eliminated!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">      return cast<FixedVectorType>(RHSTy)->getNumElements() <</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">      return cast<FixedVectorType>(RHSTy)->getNumElements() <</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline">             cast<FixedVectorType>(LHSTy)->getNumElements();</td>
    <td class="lineNumber">2111</td>
    <td class="codeline">             cast<FixedVectorType>(LHSTy)->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">    auto RankVectorTypesEq = [&DL](VectorType *RHSTy, VectorType *LHSTy) {</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">    auto RankVectorTypesEq = [&DL](VectorType *RHSTy, VectorType *LHSTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">      (void)DL;</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">      (void)DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">      assert(DL.getTypeSizeInBits(RHSTy).getFixedValue() ==</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">      assert(DL.getTypeSizeInBits(RHSTy).getFixedValue() ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">                 DL.getTypeSizeInBits(LHSTy).getFixedValue() &&</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">                 DL.getTypeSizeInBits(LHSTy).getFixedValue() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline">             "Cannot have vector types of different sizes!");</td>
    <td class="lineNumber">2117</td>
    <td class="codeline">             "Cannot have vector types of different sizes!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">      assert(RHSTy->getElementType()->isIntegerTy() &&</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">      assert(RHSTy->getElementType()->isIntegerTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">             "All non-integer types eliminated!");</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">             "All non-integer types eliminated!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">      assert(LHSTy->getElementType()->isIntegerTy() &&</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">      assert(LHSTy->getElementType()->isIntegerTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">             "All non-integer types eliminated!");</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">             "All non-integer types eliminated!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">      return cast<FixedVectorType>(RHSTy)->getNumElements() ==</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">      return cast<FixedVectorType>(RHSTy)->getNumElements() ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">             cast<FixedVectorType>(LHSTy)->getNumElements();</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">             cast<FixedVectorType>(LHSTy)->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">    };</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">    };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">    llvm::sort(CandidateTys, RankVectorTypesComp);</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">    llvm::sort(CandidateTys, RankVectorTypesComp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">    CandidateTys.erase(std::unique(CandidateTys.begin(), CandidateTys.end(),</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">    CandidateTys.erase(std::unique(CandidateTys.begin(), CandidateTys.end(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">                                   RankVectorTypesEq),</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">                                   RankVectorTypesEq),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">                       CandidateTys.end());</td>
    <td class="lineNumber">2128</td>
    <td class="codeline">                       CandidateTys.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline">// The only way to have the same element type in every vector type is to</td>
    <td class="lineNumber">2130</td>
    <td class="codeline">// The only way to have the same element type in every vector type is to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">// have the same vector type. Check that and remove all but one.</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">// have the same vector type. Check that and remove all but one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">    for (VectorType *VTy : CandidateTys) {</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">    for (VectorType *VTy : CandidateTys) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">      assert(VTy->getElementType() == CommonEltTy &&</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">      assert(VTy->getElementType() == CommonEltTy &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">             "Unaccounted for element type!");</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">             "Unaccounted for element type!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">      assert(VTy == CandidateTys[0] &&</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">      assert(VTy == CandidateTys[0] &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">             "Different vector types with the same element type!");</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">             "Different vector types with the same element type!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">    CandidateTys.resize(1);</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">    CandidateTys.resize(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline"></td>
    <td class="lineNumber">2142</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline">  // FIXME: hack. Do we have a named constant for this?</td>
    <td class="lineNumber">2143</td>
    <td class="codeline">  // FIXME: hack. Do we have a named constant for this?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">  // SDAG SDNode can't have more than 65535 operands.</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">  // SDAG SDNode can't have more than 65535 operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">  llvm::erase_if(CandidateTys, [](VectorType *VTy) {</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">  llvm::erase_if(CandidateTys, [](VectorType *VTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">    return cast<FixedVectorType>(VTy)->getNumElements() ></td>
    <td class="lineNumber">2146</td>
    <td class="codeline">    return cast<FixedVectorType>(VTy)->getNumElements() ></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">           std::numeric_limits<unsigned short>::max();</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">           std::numeric_limits<unsigned short>::max();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">2148</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline"></td>
    <td class="lineNumber">2149</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">  for (VectorType *VTy : CandidateTys)</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">  for (VectorType *VTy : CandidateTys)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">    if (checkVectorTypeForPromotion(P, VTy, DL))</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">    if (checkVectorTypeForPromotion(P, VTy, DL))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">      return VTy;</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">      return VTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline"></td>
    <td class="lineNumber">2153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">  return nullptr;</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">  return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline"></td>
    <td class="lineNumber">2156</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline">/// Test whether a slice of an alloca is valid for integer widening.</td>
    <td class="lineNumber">2157</td>
    <td class="codeline">/// Test whether a slice of an alloca is valid for integer widening.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">/// This implements the necessary checking for the \c isIntegerWideningViable</td>
    <td class="lineNumber">2159</td>
    <td class="codeline">/// This implements the necessary checking for the \c isIntegerWideningViable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">/// test below on a single slice of the alloca.</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">/// test below on a single slice of the alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline">static bool isIntegerWideningViableForSlice(const Slice &S,</td>
    <td class="lineNumber">2161</td>
    <td class="codeline">static bool isIntegerWideningViableForSlice(const Slice &S,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">                                            uint64_t AllocBeginOffset,</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">                                            uint64_t AllocBeginOffset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">                                            Type *AllocaTy,</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">                                            Type *AllocaTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">                                            const DataLayout &DL,</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">                                            const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline">                                            bool &WholeAllocaOp) {</td>
    <td class="lineNumber">2165</td>
    <td class="codeline">                                            bool &WholeAllocaOp) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">  uint64_t Size = DL.getTypeStoreSize(AllocaTy).getFixedValue();</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">  uint64_t Size = DL.getTypeStoreSize(AllocaTy).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline"></td>
    <td class="lineNumber">2167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline">  uint64_t RelBegin = S.beginOffset() - AllocBeginOffset;</td>
    <td class="lineNumber">2168</td>
    <td class="codeline">  uint64_t RelBegin = S.beginOffset() - AllocBeginOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">  uint64_t RelEnd = S.endOffset() - AllocBeginOffset;</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">  uint64_t RelEnd = S.endOffset() - AllocBeginOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline"></td>
    <td class="lineNumber">2170</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">  Use *U = S.getUse();</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">  Use *U = S.getUse();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline"></td>
    <td class="lineNumber">2172</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline">  // Lifetime intrinsics operate over the whole alloca whose sizes are usually</td>
    <td class="lineNumber">2173</td>
    <td class="codeline">  // Lifetime intrinsics operate over the whole alloca whose sizes are usually</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">  // larger than other load/store slices (RelEnd > Size). But lifetime are</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">  // larger than other load/store slices (RelEnd > Size). But lifetime are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">  // always promotable and should not impact other slices' promotability of the</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">  // always promotable and should not impact other slices' promotability of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">  // partition.</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">  // partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline">  if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(U->getUser())) {</td>
    <td class="lineNumber">2177</td>
    <td class="codeline">  if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(U->getUser())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">    if (II->isLifetimeStartOrEnd() || II->isDroppable())</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">    if (II->isLifetimeStartOrEnd() || II->isDroppable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline"></td>
    <td class="lineNumber">2181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">  // We can't reasonably handle cases where the load or store extends past</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">  // We can't reasonably handle cases where the load or store extends past</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">  // the end of the alloca's type and into its padding.</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">  // the end of the alloca's type and into its padding.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">  if (RelEnd > Size)</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">  if (RelEnd > Size)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline"></td>
    <td class="lineNumber">2186</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">  if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">  if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">    if (LI->isVolatile())</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">    if (LI->isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">    // We can't handle loads that extend past the allocated memory.</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">    // We can't handle loads that extend past the allocated memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline">    if (DL.getTypeStoreSize(LI->getType()).getFixedValue() > Size)</td>
    <td class="lineNumber">2191</td>
    <td class="codeline">    if (DL.getTypeStoreSize(LI->getType()).getFixedValue() > Size)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">    // So far, AllocaSliceRewriter does not support widening split slice tails</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">    // So far, AllocaSliceRewriter does not support widening split slice tails</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">    // in rewriteIntegerLoad.</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">    // in rewriteIntegerLoad.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline">    if (S.beginOffset() < AllocBeginOffset)</td>
    <td class="lineNumber">2195</td>
    <td class="codeline">    if (S.beginOffset() < AllocBeginOffset)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">    // Note that we don't count vector loads or stores as whole-alloca</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">    // Note that we don't count vector loads or stores as whole-alloca</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline">    // operations which enable integer widening because we would prefer to use</td>
    <td class="lineNumber">2198</td>
    <td class="codeline">    // operations which enable integer widening because we would prefer to use</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">    // vector widening instead.</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">    // vector widening instead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">    if (!isa<VectorType>(LI->getType()) && RelBegin == 0 && RelEnd == Size)</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">    if (!isa<VectorType>(LI->getType()) && RelBegin == 0 && RelEnd == Size)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">      WholeAllocaOp = true;</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">      WholeAllocaOp = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">    if (IntegerType *ITy = dyn_cast<IntegerType>(LI->getType())) {</td>
    <td class="lineNumber">2202</td>
    <td class="codeline">    if (IntegerType *ITy = dyn_cast<IntegerType>(LI->getType())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">      if (ITy->getBitWidth() < DL.getTypeStoreSizeInBits(ITy).getFixedValue())</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">      if (ITy->getBitWidth() < DL.getTypeStoreSizeInBits(ITy).getFixedValue())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">2204</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">    } else if (RelBegin != 0 || RelEnd != Size ||</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">    } else if (RelBegin != 0 || RelEnd != Size ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">               !canConvertValue(DL, AllocaTy, LI->getType())) {</td>
    <td class="lineNumber">2206</td>
    <td class="codeline">               !canConvertValue(DL, AllocaTy, LI->getType())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">      // Non-integer loads need to be convertible from the alloca type so that</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">      // Non-integer loads need to be convertible from the alloca type so that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline">      // they are promotable.</td>
    <td class="lineNumber">2208</td>
    <td class="codeline">      // they are promotable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">  } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">  } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline">    Type *ValueTy = SI->getValueOperand()->getType();</td>
    <td class="lineNumber">2212</td>
    <td class="codeline">    Type *ValueTy = SI->getValueOperand()->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">    if (SI->isVolatile())</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">    if (SI->isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">    // We can't handle stores that extend past the allocated memory.</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">    // We can't handle stores that extend past the allocated memory.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline">    if (DL.getTypeStoreSize(ValueTy).getFixedValue() > Size)</td>
    <td class="lineNumber">2216</td>
    <td class="codeline">    if (DL.getTypeStoreSize(ValueTy).getFixedValue() > Size)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline">    // So far, AllocaSliceRewriter does not support widening split slice tails</td>
    <td class="lineNumber">2218</td>
    <td class="codeline">    // So far, AllocaSliceRewriter does not support widening split slice tails</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">    // in rewriteIntegerStore.</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">    // in rewriteIntegerStore.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">    if (S.beginOffset() < AllocBeginOffset)</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">    if (S.beginOffset() < AllocBeginOffset)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">    // Note that we don't count vector loads or stores as whole-alloca</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">    // Note that we don't count vector loads or stores as whole-alloca</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline">    // operations which enable integer widening because we would prefer to use</td>
    <td class="lineNumber">2223</td>
    <td class="codeline">    // operations which enable integer widening because we would prefer to use</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">    // vector widening instead.</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">    // vector widening instead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline">    if (!isa<VectorType>(ValueTy) && RelBegin == 0 && RelEnd == Size)</td>
    <td class="lineNumber">2225</td>
    <td class="codeline">    if (!isa<VectorType>(ValueTy) && RelBegin == 0 && RelEnd == Size)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">      WholeAllocaOp = true;</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">      WholeAllocaOp = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">    if (IntegerType *ITy = dyn_cast<IntegerType>(ValueTy)) {</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">    if (IntegerType *ITy = dyn_cast<IntegerType>(ValueTy)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline">      if (ITy->getBitWidth() < DL.getTypeStoreSizeInBits(ITy).getFixedValue())</td>
    <td class="lineNumber">2228</td>
    <td class="codeline">      if (ITy->getBitWidth() < DL.getTypeStoreSizeInBits(ITy).getFixedValue())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">    } else if (RelBegin != 0 || RelEnd != Size ||</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">    } else if (RelBegin != 0 || RelEnd != Size ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline">               !canConvertValue(DL, ValueTy, AllocaTy)) {</td>
    <td class="lineNumber">2231</td>
    <td class="codeline">               !canConvertValue(DL, ValueTy, AllocaTy)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">      // Non-integer stores need to be convertible to the alloca type so that</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">      // Non-integer stores need to be convertible to the alloca type so that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">      // they are promotable.</td>
    <td class="lineNumber">2233</td>
    <td class="codeline">      // they are promotable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">  } else if (MemIntrinsic *MI = dyn_cast<MemIntrinsic>(U->getUser())) {</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">  } else if (MemIntrinsic *MI = dyn_cast<MemIntrinsic>(U->getUser())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">    if (MI->isVolatile() || !isa<Constant>(MI->getLength()))</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">    if (MI->isVolatile() || !isa<Constant>(MI->getLength()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2238</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">    if (!S.isSplittable())</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">    if (!S.isSplittable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">      return false; // Skip any unsplittable intrinsics.</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">      return false; // Skip any unsplittable intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2243</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline"></td>
    <td class="lineNumber">2244</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2246</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline"></td>
    <td class="lineNumber">2247</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline">/// Test whether the given alloca partition's integer operations can be</td>
    <td class="lineNumber">2248</td>
    <td class="codeline">/// Test whether the given alloca partition's integer operations can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline">/// widened to promotable ones.</td>
    <td class="lineNumber">2249</td>
    <td class="codeline">/// widened to promotable ones.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">/// This is a quick test to check whether we can rewrite the integer loads and</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">/// This is a quick test to check whether we can rewrite the integer loads and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline">/// stores to a particular alloca into wider loads and stores and be able to</td>
    <td class="lineNumber">2252</td>
    <td class="codeline">/// stores to a particular alloca into wider loads and stores and be able to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">/// promote the resulting alloca.</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">/// promote the resulting alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">static bool isIntegerWideningViable(Partition &P, Type *AllocaTy,</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">static bool isIntegerWideningViable(Partition &P, Type *AllocaTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline">                                    const DataLayout &DL) {</td>
    <td class="lineNumber">2255</td>
    <td class="codeline">                                    const DataLayout &DL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">  uint64_t SizeInBits = DL.getTypeSizeInBits(AllocaTy).getFixedValue();</td>
    <td class="lineNumber">2256</td>
    <td class="codeline">  uint64_t SizeInBits = DL.getTypeSizeInBits(AllocaTy).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline">  // Don't create integer types larger than the maximum bitwidth.</td>
    <td class="lineNumber">2257</td>
    <td class="codeline">  // Don't create integer types larger than the maximum bitwidth.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">  if (SizeInBits > IntegerType::MAX_INT_BITS)</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">  if (SizeInBits > IntegerType::MAX_INT_BITS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline"></td>
    <td class="lineNumber">2260</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">  // Don't try to handle allocas with bit-padding.</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">  // Don't try to handle allocas with bit-padding.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">  if (SizeInBits != DL.getTypeStoreSizeInBits(AllocaTy).getFixedValue())</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">  if (SizeInBits != DL.getTypeStoreSizeInBits(AllocaTy).getFixedValue())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2263</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline"></td>
    <td class="lineNumber">2264</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">  // We need to ensure that an integer type with the appropriate bitwidth can</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">  // We need to ensure that an integer type with the appropriate bitwidth can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">  // be converted to the alloca type, whatever that is. We don't want to force</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">  // be converted to the alloca type, whatever that is. We don't want to force</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline">  // the alloca itself to have an integer type if there is a more suitable one.</td>
    <td class="lineNumber">2267</td>
    <td class="codeline">  // the alloca itself to have an integer type if there is a more suitable one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">  Type *IntTy = Type::getIntNTy(AllocaTy->getContext(), SizeInBits);</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">  Type *IntTy = Type::getIntNTy(AllocaTy->getContext(), SizeInBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">  if (!canConvertValue(DL, AllocaTy, IntTy) ||</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">  if (!canConvertValue(DL, AllocaTy, IntTy) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">      !canConvertValue(DL, IntTy, AllocaTy))</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">      !canConvertValue(DL, IntTy, AllocaTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline"></td>
    <td class="lineNumber">2272</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline">  // While examining uses, we ensure that the alloca has a covering load or</td>
    <td class="lineNumber">2273</td>
    <td class="codeline">  // While examining uses, we ensure that the alloca has a covering load or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">  // store. We don't want to widen the integer operations only to fail to</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">  // store. We don't want to widen the integer operations only to fail to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">  // promote due to some other unsplittable entry (which we may make splittable</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">  // promote due to some other unsplittable entry (which we may make splittable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">  // later). However, if there are only splittable uses, go ahead and assume</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">  // later). However, if there are only splittable uses, go ahead and assume</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">  // that we cover the alloca.</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">  // that we cover the alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">  // FIXME: We shouldn't consider split slices that happen to start in the</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">  // FIXME: We shouldn't consider split slices that happen to start in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline">  // partition here...</td>
    <td class="lineNumber">2279</td>
    <td class="codeline">  // partition here...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">  bool WholeAllocaOp = P.empty() && DL.isLegalInteger(SizeInBits);</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">  bool WholeAllocaOp = P.empty() && DL.isLegalInteger(SizeInBits);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline"></td>
    <td class="lineNumber">2281</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">  for (const Slice &S : P)</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">  for (const Slice &S : P)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">    if (!isIntegerWideningViableForSlice(S, P.beginOffset(), AllocaTy, DL,</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">    if (!isIntegerWideningViableForSlice(S, P.beginOffset(), AllocaTy, DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline">                                         WholeAllocaOp))</td>
    <td class="lineNumber">2284</td>
    <td class="codeline">                                         WholeAllocaOp))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline"></td>
    <td class="lineNumber">2286</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">  for (const Slice *S : P.splitSliceTails())</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">  for (const Slice *S : P.splitSliceTails())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">    if (!isIntegerWideningViableForSlice(*S, P.beginOffset(), AllocaTy, DL,</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">    if (!isIntegerWideningViableForSlice(*S, P.beginOffset(), AllocaTy, DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">                                         WholeAllocaOp))</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">                                         WholeAllocaOp))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline"></td>
    <td class="lineNumber">2291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline">  return WholeAllocaOp;</td>
    <td class="lineNumber">2292</td>
    <td class="codeline">  return WholeAllocaOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline"></td>
    <td class="lineNumber">2294</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline">static Value *extractInteger(const DataLayout &DL, IRBuilderTy &IRB, Value *V,</td>
    <td class="lineNumber">2295</td>
    <td class="codeline">static Value *extractInteger(const DataLayout &DL, IRBuilderTy &IRB, Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">                             IntegerType *Ty, uint64_t Offset,</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">                             IntegerType *Ty, uint64_t Offset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">                             const Twine &Name) {</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">                             const Twine &Name) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "       start: " << *V << "\n");</td>
    <td class="lineNumber">2298</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "       start: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">  IntegerType *IntTy = cast<IntegerType>(V->getType());</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">  IntegerType *IntTy = cast<IntegerType>(V->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">  assert(DL.getTypeStoreSize(Ty).getFixedValue() + Offset <=</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">  assert(DL.getTypeStoreSize(Ty).getFixedValue() + Offset <=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline">             DL.getTypeStoreSize(IntTy).getFixedValue() &&</td>
    <td class="lineNumber">2301</td>
    <td class="codeline">             DL.getTypeStoreSize(IntTy).getFixedValue() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">         "Element extends past full value");</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">         "Element extends past full value");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">  uint64_t ShAmt = 8 * Offset;</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">  uint64_t ShAmt = 8 * Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline">  if (DL.isBigEndian())</td>
    <td class="lineNumber">2304</td>
    <td class="codeline">  if (DL.isBigEndian())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">    ShAmt = 8 * (DL.getTypeStoreSize(IntTy).getFixedValue() -</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">    ShAmt = 8 * (DL.getTypeStoreSize(IntTy).getFixedValue() -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">                 DL.getTypeStoreSize(Ty).getFixedValue() - Offset);</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">                 DL.getTypeStoreSize(Ty).getFixedValue() - Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline">  if (ShAmt) {</td>
    <td class="lineNumber">2307</td>
    <td class="codeline">  if (ShAmt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline">    V = IRB.CreateLShr(V, ShAmt, Name + ".shift");</td>
    <td class="lineNumber">2308</td>
    <td class="codeline">    V = IRB.CreateLShr(V, ShAmt, Name + ".shift");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "     shifted: " << *V << "\n");</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "     shifted: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2310</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline">  assert(Ty->getBitWidth() <= IntTy->getBitWidth() &&</td>
    <td class="lineNumber">2311</td>
    <td class="codeline">  assert(Ty->getBitWidth() <= IntTy->getBitWidth() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">         "Cannot extract to a larger integer!");</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">         "Cannot extract to a larger integer!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline">  if (Ty != IntTy) {</td>
    <td class="lineNumber">2313</td>
    <td class="codeline">  if (Ty != IntTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline">    V = IRB.CreateTrunc(V, Ty, Name + ".trunc");</td>
    <td class="lineNumber">2314</td>
    <td class="codeline">    V = IRB.CreateTrunc(V, Ty, Name + ".trunc");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "     trunced: " << *V << "\n");</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "     trunced: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">2317</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2318</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline"></td>
    <td class="lineNumber">2319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">static Value *insertInteger(const DataLayout &DL, IRBuilderTy &IRB, Value *Old,</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">static Value *insertInteger(const DataLayout &DL, IRBuilderTy &IRB, Value *Old,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline">                            Value *V, uint64_t Offset, const Twine &Name) {</td>
    <td class="lineNumber">2321</td>
    <td class="codeline">                            Value *V, uint64_t Offset, const Twine &Name) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">  IntegerType *IntTy = cast<IntegerType>(Old->getType());</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">  IntegerType *IntTy = cast<IntegerType>(Old->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">  IntegerType *Ty = cast<IntegerType>(V->getType());</td>
    <td class="lineNumber">2323</td>
    <td class="codeline">  IntegerType *Ty = cast<IntegerType>(V->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">  assert(Ty->getBitWidth() <= IntTy->getBitWidth() &&</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">  assert(Ty->getBitWidth() <= IntTy->getBitWidth() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">         "Cannot insert a larger integer!");</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">         "Cannot insert a larger integer!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "       start: " << *V << "\n");</td>
    <td class="lineNumber">2326</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "       start: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">  if (Ty != IntTy) {</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">  if (Ty != IntTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">    V = IRB.CreateZExt(V, IntTy, Name + ".ext");</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">    V = IRB.CreateZExt(V, IntTy, Name + ".ext");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    extended: " << *V << "\n");</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    extended: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline">  assert(DL.getTypeStoreSize(Ty).getFixedValue() + Offset <=</td>
    <td class="lineNumber">2331</td>
    <td class="codeline">  assert(DL.getTypeStoreSize(Ty).getFixedValue() + Offset <=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">             DL.getTypeStoreSize(IntTy).getFixedValue() &&</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">             DL.getTypeStoreSize(IntTy).getFixedValue() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">         "Element store outside of alloca store");</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">         "Element store outside of alloca store");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">  uint64_t ShAmt = 8 * Offset;</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">  uint64_t ShAmt = 8 * Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline">  if (DL.isBigEndian())</td>
    <td class="lineNumber">2335</td>
    <td class="codeline">  if (DL.isBigEndian())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">    ShAmt = 8 * (DL.getTypeStoreSize(IntTy).getFixedValue() -</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">    ShAmt = 8 * (DL.getTypeStoreSize(IntTy).getFixedValue() -</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">                 DL.getTypeStoreSize(Ty).getFixedValue() - Offset);</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">                 DL.getTypeStoreSize(Ty).getFixedValue() - Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">  if (ShAmt) {</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">  if (ShAmt) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">    V = IRB.CreateShl(V, ShAmt, Name + ".shift");</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">    V = IRB.CreateShl(V, ShAmt, Name + ".shift");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "     shifted: " << *V << "\n");</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "     shifted: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline"></td>
    <td class="lineNumber">2342</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">  if (ShAmt || Ty->getBitWidth() < IntTy->getBitWidth()) {</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">  if (ShAmt || Ty->getBitWidth() < IntTy->getBitWidth()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline">    APInt Mask = ~Ty->getMask().zext(IntTy->getBitWidth()).shl(ShAmt);</td>
    <td class="lineNumber">2344</td>
    <td class="codeline">    APInt Mask = ~Ty->getMask().zext(IntTy->getBitWidth()).shl(ShAmt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline">    Old = IRB.CreateAnd(Old, Mask, Name + ".mask");</td>
    <td class="lineNumber">2345</td>
    <td class="codeline">    Old = IRB.CreateAnd(Old, Mask, Name + ".mask");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "      masked: " << *Old << "\n");</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "      masked: " << *Old << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">    V = IRB.CreateOr(Old, V, Name + ".insert");</td>
    <td class="lineNumber">2347</td>
    <td class="codeline">    V = IRB.CreateOr(Old, V, Name + ".insert");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    inserted: " << *V << "\n");</td>
    <td class="lineNumber">2348</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    inserted: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2351</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline"></td>
    <td class="lineNumber">2352</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">static Value *extractVector(IRBuilderTy &IRB, Value *V, unsigned BeginIndex,</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">static Value *extractVector(IRBuilderTy &IRB, Value *V, unsigned BeginIndex,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">                            unsigned EndIndex, const Twine &Name) {</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">                            unsigned EndIndex, const Twine &Name) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline">  auto *VecTy = cast<FixedVectorType>(V->getType());</td>
    <td class="lineNumber">2355</td>
    <td class="codeline">  auto *VecTy = cast<FixedVectorType>(V->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">  unsigned NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">  unsigned NumElements = EndIndex - BeginIndex;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline">  assert(NumElements <= VecTy->getNumElements() && "Too many elements!");</td>
    <td class="lineNumber">2357</td>
    <td class="codeline">  assert(NumElements <= VecTy->getNumElements() && "Too many elements!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline"></td>
    <td class="lineNumber">2358</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline">  if (NumElements == VecTy->getNumElements())</td>
    <td class="lineNumber">2359</td>
    <td class="codeline">  if (NumElements == VecTy->getNumElements())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline"></td>
    <td class="lineNumber">2361</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline">  if (NumElements == 1) {</td>
    <td class="lineNumber">2362</td>
    <td class="codeline">  if (NumElements == 1) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">    V = IRB.CreateExtractElement(V, IRB.getInt32(BeginIndex),</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">    V = IRB.CreateExtractElement(V, IRB.getInt32(BeginIndex),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline">                                 Name + ".extract");</td>
    <td class="lineNumber">2364</td>
    <td class="codeline">                                 Name + ".extract");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "     extract: " << *V << "\n");</td>
    <td class="lineNumber">2365</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "     extract: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">2366</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2367</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline"></td>
    <td class="lineNumber">2368</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">  auto Mask = llvm::to_vector<8>(llvm::seq<int>(BeginIndex, EndIndex));</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">  auto Mask = llvm::to_vector<8>(llvm::seq<int>(BeginIndex, EndIndex));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline">  V = IRB.CreateShuffleVector(V, Mask, Name + ".extract");</td>
    <td class="lineNumber">2370</td>
    <td class="codeline">  V = IRB.CreateShuffleVector(V, Mask, Name + ".extract");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "     shuffle: " << *V << "\n");</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "     shuffle: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">2372</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline"></td>
    <td class="lineNumber">2374</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline">static Value *insertVector(IRBuilderTy &IRB, Value *Old, Value *V,</td>
    <td class="lineNumber">2375</td>
    <td class="codeline">static Value *insertVector(IRBuilderTy &IRB, Value *Old, Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline">                           unsigned BeginIndex, const Twine &Name) {</td>
    <td class="lineNumber">2376</td>
    <td class="codeline">                           unsigned BeginIndex, const Twine &Name) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline">  VectorType *VecTy = cast<VectorType>(Old->getType());</td>
    <td class="lineNumber">2377</td>
    <td class="codeline">  VectorType *VecTy = cast<VectorType>(Old->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">  assert(VecTy && "Can only insert a vector into a vector");</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">  assert(VecTy && "Can only insert a vector into a vector");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline"></td>
    <td class="lineNumber">2379</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">  VectorType *Ty = dyn_cast<VectorType>(V->getType());</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">  VectorType *Ty = dyn_cast<VectorType>(V->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">  if (!Ty) {</td>
    <td class="lineNumber">2381</td>
    <td class="codeline">  if (!Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">    // Single element to insert.</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">    // Single element to insert.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">    V = IRB.CreateInsertElement(Old, V, IRB.getInt32(BeginIndex),</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">    V = IRB.CreateInsertElement(Old, V, IRB.getInt32(BeginIndex),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">                                Name + ".insert");</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">                                Name + ".insert");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "     insert: " << *V << "\n");</td>
    <td class="lineNumber">2385</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "     insert: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2387</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline"></td>
    <td class="lineNumber">2388</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline">  assert(cast<FixedVectorType>(Ty)->getNumElements() <=</td>
    <td class="lineNumber">2389</td>
    <td class="codeline">  assert(cast<FixedVectorType>(Ty)->getNumElements() <=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeline">             cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
    <td class="lineNumber">2390</td>
    <td class="codeline">             cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeline">         "Too many elements!");</td>
    <td class="lineNumber">2391</td>
    <td class="codeline">         "Too many elements!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeline">  if (cast<FixedVectorType>(Ty)->getNumElements() ==</td>
    <td class="lineNumber">2392</td>
    <td class="codeline">  if (cast<FixedVectorType>(Ty)->getNumElements() ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeline">      cast<FixedVectorType>(VecTy)->getNumElements()) {</td>
    <td class="lineNumber">2393</td>
    <td class="codeline">      cast<FixedVectorType>(VecTy)->getNumElements()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeline">    assert(V->getType() == VecTy && "Vector type mismatch");</td>
    <td class="lineNumber">2394</td>
    <td class="codeline">    assert(V->getType() == VecTy && "Vector type mismatch");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">2395</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2396</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeline">  unsigned EndIndex = BeginIndex + cast<FixedVectorType>(Ty)->getNumElements();</td>
    <td class="lineNumber">2397</td>
    <td class="codeline">  unsigned EndIndex = BeginIndex + cast<FixedVectorType>(Ty)->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeline"></td>
    <td class="lineNumber">2398</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeline">  // When inserting a smaller vector into the larger to store, we first</td>
    <td class="lineNumber">2399</td>
    <td class="codeline">  // When inserting a smaller vector into the larger to store, we first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeline">  // use a shuffle vector to widen it with undef elements, and then</td>
    <td class="lineNumber">2400</td>
    <td class="codeline">  // use a shuffle vector to widen it with undef elements, and then</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeline">  // a second shuffle vector to select between the loaded vector and the</td>
    <td class="lineNumber">2401</td>
    <td class="codeline">  // a second shuffle vector to select between the loaded vector and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeline">  // incoming vector.</td>
    <td class="lineNumber">2402</td>
    <td class="codeline">  // incoming vector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeline">  SmallVector<int, 8> Mask;</td>
    <td class="lineNumber">2403</td>
    <td class="codeline">  SmallVector<int, 8> Mask;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeline">  Mask.reserve(cast<FixedVectorType>(VecTy)->getNumElements());</td>
    <td class="lineNumber">2404</td>
    <td class="codeline">  Mask.reserve(cast<FixedVectorType>(VecTy)->getNumElements());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeline">  for (unsigned i = 0; i != cast<FixedVectorType>(VecTy)->getNumElements(); ++i)</td>
    <td class="lineNumber">2405</td>
    <td class="codeline">  for (unsigned i = 0; i != cast<FixedVectorType>(VecTy)->getNumElements(); ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeline">    if (i >= BeginIndex && i < EndIndex)</td>
    <td class="lineNumber">2406</td>
    <td class="codeline">    if (i >= BeginIndex && i < EndIndex)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeline">      Mask.push_back(i - BeginIndex);</td>
    <td class="lineNumber">2407</td>
    <td class="codeline">      Mask.push_back(i - BeginIndex);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">2408</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeline">      Mask.push_back(-1);</td>
    <td class="lineNumber">2409</td>
    <td class="codeline">      Mask.push_back(-1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeline">  V = IRB.CreateShuffleVector(V, Mask, Name + ".expand");</td>
    <td class="lineNumber">2410</td>
    <td class="codeline">  V = IRB.CreateShuffleVector(V, Mask, Name + ".expand");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    shuffle: " << *V << "\n");</td>
    <td class="lineNumber">2411</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    shuffle: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeline"></td>
    <td class="lineNumber">2412</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeline">  SmallVector<Constant *, 8> Mask2;</td>
    <td class="lineNumber">2413</td>
    <td class="codeline">  SmallVector<Constant *, 8> Mask2;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeline">  Mask2.reserve(cast<FixedVectorType>(VecTy)->getNumElements());</td>
    <td class="lineNumber">2414</td>
    <td class="codeline">  Mask2.reserve(cast<FixedVectorType>(VecTy)->getNumElements());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeline">  for (unsigned i = 0; i != cast<FixedVectorType>(VecTy)->getNumElements(); ++i)</td>
    <td class="lineNumber">2415</td>
    <td class="codeline">  for (unsigned i = 0; i != cast<FixedVectorType>(VecTy)->getNumElements(); ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeline">    Mask2.push_back(IRB.getInt1(i >= BeginIndex && i < EndIndex));</td>
    <td class="lineNumber">2416</td>
    <td class="codeline">    Mask2.push_back(IRB.getInt1(i >= BeginIndex && i < EndIndex));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeline"></td>
    <td class="lineNumber">2417</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeline">  V = IRB.CreateSelect(ConstantVector::get(Mask2), V, Old, Name + "blend");</td>
    <td class="lineNumber">2418</td>
    <td class="codeline">  V = IRB.CreateSelect(ConstantVector::get(Mask2), V, Old, Name + "blend");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeline"></td>
    <td class="lineNumber">2419</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    blend: " << *V << "\n");</td>
    <td class="lineNumber">2420</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "    blend: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeline">  return V;</td>
    <td class="lineNumber">2421</td>
    <td class="codeline">  return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeline">}</td>
    <td class="lineNumber">2422</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeline"></td>
    <td class="lineNumber">2423</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeline">/// Visitor to rewrite instructions using p particular slice of an alloca</td>
    <td class="lineNumber">2424</td>
    <td class="codeline">/// Visitor to rewrite instructions using p particular slice of an alloca</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeline">/// to use a new alloca.</td>
    <td class="lineNumber">2425</td>
    <td class="codeline">/// to use a new alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2426</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeline">/// Also implements the rewriting to vector-based accesses when the partition</td>
    <td class="lineNumber">2427</td>
    <td class="codeline">/// Also implements the rewriting to vector-based accesses when the partition</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeline">/// passes the isVectorPromotionViable predicate. Most of the rewriting logic</td>
    <td class="lineNumber">2428</td>
    <td class="codeline">/// passes the isVectorPromotionViable predicate. Most of the rewriting logic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeline">/// lives here.</td>
    <td class="lineNumber">2429</td>
    <td class="codeline">/// lives here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeline">class llvm::sroa::AllocaSliceRewriter</td>
    <td class="lineNumber">2430</td>
    <td class="codeline">class llvm::sroa::AllocaSliceRewriter</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeline">    : public InstVisitor<AllocaSliceRewriter, bool> {</td>
    <td class="lineNumber">2431</td>
    <td class="codeline">    : public InstVisitor<AllocaSliceRewriter, bool> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeline">  // Befriend the base class so it can delegate to private visit methods.</td>
    <td class="lineNumber">2432</td>
    <td class="codeline">  // Befriend the base class so it can delegate to private visit methods.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeline">  friend class InstVisitor<AllocaSliceRewriter, bool>;</td>
    <td class="lineNumber">2433</td>
    <td class="codeline">  friend class InstVisitor<AllocaSliceRewriter, bool>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeline"></td>
    <td class="lineNumber">2434</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeline">  using Base = InstVisitor<AllocaSliceRewriter, bool>;</td>
    <td class="lineNumber">2435</td>
    <td class="codeline">  using Base = InstVisitor<AllocaSliceRewriter, bool>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeline"></td>
    <td class="lineNumber">2436</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeline">  const DataLayout &DL;</td>
    <td class="lineNumber">2437</td>
    <td class="codeline">  const DataLayout &DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeline">  AllocaSlices &AS;</td>
    <td class="lineNumber">2438</td>
    <td class="codeline">  AllocaSlices &AS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeline">  SROAPass &Pass;</td>
    <td class="lineNumber">2439</td>
    <td class="codeline">  SROAPass &Pass;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeline">  AllocaInst &OldAI, &NewAI;</td>
    <td class="lineNumber">2440</td>
    <td class="codeline">  AllocaInst &OldAI, &NewAI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeline">  const uint64_t NewAllocaBeginOffset, NewAllocaEndOffset;</td>
    <td class="lineNumber">2441</td>
    <td class="codeline">  const uint64_t NewAllocaBeginOffset, NewAllocaEndOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeline">  Type *NewAllocaTy;</td>
    <td class="lineNumber">2442</td>
    <td class="codeline">  Type *NewAllocaTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeline"></td>
    <td class="lineNumber">2443</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeline">  // This is a convenience and flag variable that will be null unless the new</td>
    <td class="lineNumber">2444</td>
    <td class="codeline">  // This is a convenience and flag variable that will be null unless the new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeline">  // alloca's integer operations should be widened to this integer type due to</td>
    <td class="lineNumber">2445</td>
    <td class="codeline">  // alloca's integer operations should be widened to this integer type due to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeline">  // passing isIntegerWideningViable above. If it is non-null, the desired</td>
    <td class="lineNumber">2446</td>
    <td class="codeline">  // passing isIntegerWideningViable above. If it is non-null, the desired</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeline">  // integer type will be stored here for easy access during rewriting.</td>
    <td class="lineNumber">2447</td>
    <td class="codeline">  // integer type will be stored here for easy access during rewriting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeline">  IntegerType *IntTy;</td>
    <td class="lineNumber">2448</td>
    <td class="codeline">  IntegerType *IntTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeline"></td>
    <td class="lineNumber">2449</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeline">  // If we are rewriting an alloca partition which can be written as pure</td>
    <td class="lineNumber">2450</td>
    <td class="codeline">  // If we are rewriting an alloca partition which can be written as pure</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeline">  // vector operations, we stash extra information here. When VecTy is</td>
    <td class="lineNumber">2451</td>
    <td class="codeline">  // vector operations, we stash extra information here. When VecTy is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeline">  // non-null, we have some strict guarantees about the rewritten alloca:</td>
    <td class="lineNumber">2452</td>
    <td class="codeline">  // non-null, we have some strict guarantees about the rewritten alloca:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeline">  //   - The new alloca is exactly the size of the vector type here.</td>
    <td class="lineNumber">2453</td>
    <td class="codeline">  //   - The new alloca is exactly the size of the vector type here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeline">  //   - The accesses all either map to the entire vector or to a single</td>
    <td class="lineNumber">2454</td>
    <td class="codeline">  //   - The accesses all either map to the entire vector or to a single</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeline">  //     element.</td>
    <td class="lineNumber">2455</td>
    <td class="codeline">  //     element.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeline">  //   - The set of accessing instructions is only one of those handled above</td>
    <td class="lineNumber">2456</td>
    <td class="codeline">  //   - The set of accessing instructions is only one of those handled above</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeline">  //     in isVectorPromotionViable. Generally these are the same access kinds</td>
    <td class="lineNumber">2457</td>
    <td class="codeline">  //     in isVectorPromotionViable. Generally these are the same access kinds</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeline">  //     which are promotable via mem2reg.</td>
    <td class="lineNumber">2458</td>
    <td class="codeline">  //     which are promotable via mem2reg.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeline">  VectorType *VecTy;</td>
    <td class="lineNumber">2459</td>
    <td class="codeline">  VectorType *VecTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeline">  Type *ElementTy;</td>
    <td class="lineNumber">2460</td>
    <td class="codeline">  Type *ElementTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeline">  uint64_t ElementSize;</td>
    <td class="lineNumber">2461</td>
    <td class="codeline">  uint64_t ElementSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeline"></td>
    <td class="lineNumber">2462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeline">  // The original offset of the slice currently being rewritten relative to</td>
    <td class="lineNumber">2463</td>
    <td class="codeline">  // The original offset of the slice currently being rewritten relative to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeline">  // the original alloca.</td>
    <td class="lineNumber">2464</td>
    <td class="codeline">  // the original alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeline">  uint64_t BeginOffset = 0;</td>
    <td class="lineNumber">2465</td>
    <td class="codeline">  uint64_t BeginOffset = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeline">  uint64_t EndOffset = 0;</td>
    <td class="lineNumber">2466</td>
    <td class="codeline">  uint64_t EndOffset = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeline"></td>
    <td class="lineNumber">2467</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeline">  // The new offsets of the slice currently being rewritten relative to the</td>
    <td class="lineNumber">2468</td>
    <td class="codeline">  // The new offsets of the slice currently being rewritten relative to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeline">  // original alloca.</td>
    <td class="lineNumber">2469</td>
    <td class="codeline">  // original alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeline">  uint64_t NewBeginOffset = 0, NewEndOffset = 0;</td>
    <td class="lineNumber">2470</td>
    <td class="codeline">  uint64_t NewBeginOffset = 0, NewEndOffset = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeline"></td>
    <td class="lineNumber">2471</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeline">  uint64_t SliceSize = 0;</td>
    <td class="lineNumber">2472</td>
    <td class="codeline">  uint64_t SliceSize = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeline">  bool IsSplittable = false;</td>
    <td class="lineNumber">2473</td>
    <td class="codeline">  bool IsSplittable = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeline">  bool IsSplit = false;</td>
    <td class="lineNumber">2474</td>
    <td class="codeline">  bool IsSplit = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeline">  Use *OldUse = nullptr;</td>
    <td class="lineNumber">2475</td>
    <td class="codeline">  Use *OldUse = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeline">  Instruction *OldPtr = nullptr;</td>
    <td class="lineNumber">2476</td>
    <td class="codeline">  Instruction *OldPtr = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeline"></td>
    <td class="lineNumber">2477</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeline">  // Track post-rewrite users which are PHI nodes and Selects.</td>
    <td class="lineNumber">2478</td>
    <td class="codeline">  // Track post-rewrite users which are PHI nodes and Selects.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeline">  SmallSetVector<PHINode *, 8> &PHIUsers;</td>
    <td class="lineNumber">2479</td>
    <td class="codeline">  SmallSetVector<PHINode *, 8> &PHIUsers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeline">  SmallSetVector<SelectInst *, 8> &SelectUsers;</td>
    <td class="lineNumber">2480</td>
    <td class="codeline">  SmallSetVector<SelectInst *, 8> &SelectUsers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeline"></td>
    <td class="lineNumber">2481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeline">  // Utility IR builder, whose name prefix is setup for each visited use, and</td>
    <td class="lineNumber">2482</td>
    <td class="codeline">  // Utility IR builder, whose name prefix is setup for each visited use, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeline">  // the insertion point is set to point to the user.</td>
    <td class="lineNumber">2483</td>
    <td class="codeline">  // the insertion point is set to point to the user.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeline">  IRBuilderTy IRB;</td>
    <td class="lineNumber">2484</td>
    <td class="codeline">  IRBuilderTy IRB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeline"></td>
    <td class="lineNumber">2485</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeline">  // Return the new alloca, addrspacecasted if required to avoid changing the</td>
    <td class="lineNumber">2486</td>
    <td class="codeline">  // Return the new alloca, addrspacecasted if required to avoid changing the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeline">  // addrspace of a volatile access.</td>
    <td class="lineNumber">2487</td>
    <td class="codeline">  // addrspace of a volatile access.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeline">  Value *getPtrToNewAI(unsigned AddrSpace, bool IsVolatile) {</td>
    <td class="lineNumber">2488</td>
    <td class="codeline">  Value *getPtrToNewAI(unsigned AddrSpace, bool IsVolatile) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeline">    if (!IsVolatile || AddrSpace == NewAI.getType()->getPointerAddressSpace())</td>
    <td class="lineNumber">2489</td>
    <td class="codeline">    if (!IsVolatile || AddrSpace == NewAI.getType()->getPointerAddressSpace())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeline">      return &NewAI;</td>
    <td class="lineNumber">2490</td>
    <td class="codeline">      return &NewAI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeline"></td>
    <td class="lineNumber">2491</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeline">    Type *AccessTy = NewAI.getAllocatedType()->getPointerTo(AddrSpace);</td>
    <td class="lineNumber">2492</td>
    <td class="codeline">    Type *AccessTy = NewAI.getAllocatedType()->getPointerTo(AddrSpace);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeline">    return IRB.CreateAddrSpaceCast(&NewAI, AccessTy);</td>
    <td class="lineNumber">2493</td>
    <td class="codeline">    return IRB.CreateAddrSpaceCast(&NewAI, AccessTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2494</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeline"></td>
    <td class="lineNumber">2495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2496</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeline">  AllocaSliceRewriter(const DataLayout &DL, AllocaSlices &AS, SROAPass &Pass,</td>
    <td class="lineNumber">2497</td>
    <td class="codeline">  AllocaSliceRewriter(const DataLayout &DL, AllocaSlices &AS, SROAPass &Pass,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeline">                      AllocaInst &OldAI, AllocaInst &NewAI,</td>
    <td class="lineNumber">2498</td>
    <td class="codeline">                      AllocaInst &OldAI, AllocaInst &NewAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeline">                      uint64_t NewAllocaBeginOffset,</td>
    <td class="lineNumber">2499</td>
    <td class="codeline">                      uint64_t NewAllocaBeginOffset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeline">                      uint64_t NewAllocaEndOffset, bool IsIntegerPromotable,</td>
    <td class="lineNumber">2500</td>
    <td class="codeline">                      uint64_t NewAllocaEndOffset, bool IsIntegerPromotable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeline">                      VectorType *PromotableVecTy,</td>
    <td class="lineNumber">2501</td>
    <td class="codeline">                      VectorType *PromotableVecTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeline">                      SmallSetVector<PHINode *, 8> &PHIUsers,</td>
    <td class="lineNumber">2502</td>
    <td class="codeline">                      SmallSetVector<PHINode *, 8> &PHIUsers,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeline">                      SmallSetVector<SelectInst *, 8> &SelectUsers)</td>
    <td class="lineNumber">2503</td>
    <td class="codeline">                      SmallSetVector<SelectInst *, 8> &SelectUsers)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeline">      : DL(DL), AS(AS), Pass(Pass), OldAI(OldAI), NewAI(NewAI),</td>
    <td class="lineNumber">2504</td>
    <td class="codeline">      : DL(DL), AS(AS), Pass(Pass), OldAI(OldAI), NewAI(NewAI),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeline">        NewAllocaBeginOffset(NewAllocaBeginOffset),</td>
    <td class="lineNumber">2505</td>
    <td class="codeline">        NewAllocaBeginOffset(NewAllocaBeginOffset),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeline">        NewAllocaEndOffset(NewAllocaEndOffset),</td>
    <td class="lineNumber">2506</td>
    <td class="codeline">        NewAllocaEndOffset(NewAllocaEndOffset),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeline">        NewAllocaTy(NewAI.getAllocatedType()),</td>
    <td class="lineNumber">2507</td>
    <td class="codeline">        NewAllocaTy(NewAI.getAllocatedType()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeline">        IntTy(</td>
    <td class="lineNumber">2508</td>
    <td class="codeline">        IntTy(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeline">            IsIntegerPromotable</td>
    <td class="lineNumber">2509</td>
    <td class="codeline">            IsIntegerPromotable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeline">                ? Type::getIntNTy(NewAI.getContext(),</td>
    <td class="lineNumber">2510</td>
    <td class="codeline">                ? Type::getIntNTy(NewAI.getContext(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeline">                                  DL.getTypeSizeInBits(NewAI.getAllocatedType())</td>
    <td class="lineNumber">2511</td>
    <td class="codeline">                                  DL.getTypeSizeInBits(NewAI.getAllocatedType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeline">                                      .getFixedValue())</td>
    <td class="lineNumber">2512</td>
    <td class="codeline">                                      .getFixedValue())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeline">                : nullptr),</td>
    <td class="lineNumber">2513</td>
    <td class="codeline">                : nullptr),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeline">        VecTy(PromotableVecTy),</td>
    <td class="lineNumber">2514</td>
    <td class="codeline">        VecTy(PromotableVecTy),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeline">        ElementTy(VecTy ? VecTy->getElementType() : nullptr),</td>
    <td class="lineNumber">2515</td>
    <td class="codeline">        ElementTy(VecTy ? VecTy->getElementType() : nullptr),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeline">        ElementSize(VecTy ? DL.getTypeSizeInBits(ElementTy).getFixedValue() / 8</td>
    <td class="lineNumber">2516</td>
    <td class="codeline">        ElementSize(VecTy ? DL.getTypeSizeInBits(ElementTy).getFixedValue() / 8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeline">                          : 0),</td>
    <td class="lineNumber">2517</td>
    <td class="codeline">                          : 0),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeline">        PHIUsers(PHIUsers), SelectUsers(SelectUsers),</td>
    <td class="lineNumber">2518</td>
    <td class="codeline">        PHIUsers(PHIUsers), SelectUsers(SelectUsers),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeline">        IRB(NewAI.getContext(), ConstantFolder()) {</td>
    <td class="lineNumber">2519</td>
    <td class="codeline">        IRB(NewAI.getContext(), ConstantFolder()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeline">    if (VecTy) {</td>
    <td class="lineNumber">2520</td>
    <td class="codeline">    if (VecTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeline">      assert((DL.getTypeSizeInBits(ElementTy).getFixedValue() % 8) == 0 &&</td>
    <td class="lineNumber">2521</td>
    <td class="codeline">      assert((DL.getTypeSizeInBits(ElementTy).getFixedValue() % 8) == 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeline">             "Only multiple-of-8 sized vector elements are viable");</td>
    <td class="lineNumber">2522</td>
    <td class="codeline">             "Only multiple-of-8 sized vector elements are viable");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeline">      ++NumVectorized;</td>
    <td class="lineNumber">2523</td>
    <td class="codeline">      ++NumVectorized;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2524</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeline">    assert((!IntTy && !VecTy) || (IntTy && !VecTy) || (!IntTy && VecTy));</td>
    <td class="lineNumber">2525</td>
    <td class="codeline">    assert((!IntTy && !VecTy) || (IntTy && !VecTy) || (!IntTy && VecTy));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2526</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeline"></td>
    <td class="lineNumber">2527</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeline">  bool visit(AllocaSlices::const_iterator I) {</td>
    <td class="lineNumber">2528</td>
    <td class="codeline">  bool visit(AllocaSlices::const_iterator I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeline">    bool CanSROA = true;</td>
    <td class="lineNumber">2529</td>
    <td class="codeline">    bool CanSROA = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeline">    BeginOffset = I->beginOffset();</td>
    <td class="lineNumber">2530</td>
    <td class="codeline">    BeginOffset = I->beginOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeline">    EndOffset = I->endOffset();</td>
    <td class="lineNumber">2531</td>
    <td class="codeline">    EndOffset = I->endOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeline">    IsSplittable = I->isSplittable();</td>
    <td class="lineNumber">2532</td>
    <td class="codeline">    IsSplittable = I->isSplittable();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeline">    IsSplit =</td>
    <td class="lineNumber">2533</td>
    <td class="codeline">    IsSplit =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeline">        BeginOffset < NewAllocaBeginOffset || EndOffset > NewAllocaEndOffset;</td>
    <td class="lineNumber">2534</td>
    <td class="codeline">        BeginOffset < NewAllocaBeginOffset || EndOffset > NewAllocaEndOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  rewriting " << (IsSplit ? "split " : ""));</td>
    <td class="lineNumber">2535</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  rewriting " << (IsSplit ? "split " : ""));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeline">    LLVM_DEBUG(AS.printSlice(dbgs(), I, ""));</td>
    <td class="lineNumber">2536</td>
    <td class="codeline">    LLVM_DEBUG(AS.printSlice(dbgs(), I, ""));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "\n");</td>
    <td class="lineNumber">2537</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeline"></td>
    <td class="lineNumber">2538</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeline">    // Compute the intersecting offset range.</td>
    <td class="lineNumber">2539</td>
    <td class="codeline">    // Compute the intersecting offset range.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeline">    assert(BeginOffset < NewAllocaEndOffset);</td>
    <td class="lineNumber">2540</td>
    <td class="codeline">    assert(BeginOffset < NewAllocaEndOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeline">    assert(EndOffset > NewAllocaBeginOffset);</td>
    <td class="lineNumber">2541</td>
    <td class="codeline">    assert(EndOffset > NewAllocaBeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeline">    NewBeginOffset = std::max(BeginOffset, NewAllocaBeginOffset);</td>
    <td class="lineNumber">2542</td>
    <td class="codeline">    NewBeginOffset = std::max(BeginOffset, NewAllocaBeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeline">    NewEndOffset = std::min(EndOffset, NewAllocaEndOffset);</td>
    <td class="lineNumber">2543</td>
    <td class="codeline">    NewEndOffset = std::min(EndOffset, NewAllocaEndOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeline"></td>
    <td class="lineNumber">2544</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeline">    SliceSize = NewEndOffset - NewBeginOffset;</td>
    <td class="lineNumber">2545</td>
    <td class="codeline">    SliceSize = NewEndOffset - NewBeginOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "   Begin:(" << BeginOffset << ", " << EndOffset</td>
    <td class="lineNumber">2546</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "   Begin:(" << BeginOffset << ", " << EndOffset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeline">                      << ") NewBegin:(" << NewBeginOffset << ", "</td>
    <td class="lineNumber">2547</td>
    <td class="codeline">                      << ") NewBegin:(" << NewBeginOffset << ", "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeline">                      << NewEndOffset << ") NewAllocaBegin:("</td>
    <td class="lineNumber">2548</td>
    <td class="codeline">                      << NewEndOffset << ") NewAllocaBegin:("</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeline">                      << NewAllocaBeginOffset << ", " << NewAllocaEndOffset</td>
    <td class="lineNumber">2549</td>
    <td class="codeline">                      << NewAllocaBeginOffset << ", " << NewAllocaEndOffset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeline">                      << ")\n");</td>
    <td class="lineNumber">2550</td>
    <td class="codeline">                      << ")\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeline">    assert(IsSplit || NewBeginOffset == BeginOffset);</td>
    <td class="lineNumber">2551</td>
    <td class="codeline">    assert(IsSplit || NewBeginOffset == BeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeline">    OldUse = I->getUse();</td>
    <td class="lineNumber">2552</td>
    <td class="codeline">    OldUse = I->getUse();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeline">    OldPtr = cast<Instruction>(OldUse->get());</td>
    <td class="lineNumber">2553</td>
    <td class="codeline">    OldPtr = cast<Instruction>(OldUse->get());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeline"></td>
    <td class="lineNumber">2554</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeline">    Instruction *OldUserI = cast<Instruction>(OldUse->getUser());</td>
    <td class="lineNumber">2555</td>
    <td class="codeline">    Instruction *OldUserI = cast<Instruction>(OldUse->getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeline">    IRB.SetInsertPoint(OldUserI);</td>
    <td class="lineNumber">2556</td>
    <td class="codeline">    IRB.SetInsertPoint(OldUserI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeline">    IRB.SetCurrentDebugLocation(OldUserI->getDebugLoc());</td>
    <td class="lineNumber">2557</td>
    <td class="codeline">    IRB.SetCurrentDebugLocation(OldUserI->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeline">    IRB.getInserter().SetNamePrefix(</td>
    <td class="lineNumber">2558</td>
    <td class="codeline">    IRB.getInserter().SetNamePrefix(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeline">        Twine(NewAI.getName()) + "." + Twine(BeginOffset) + ".");</td>
    <td class="lineNumber">2559</td>
    <td class="codeline">        Twine(NewAI.getName()) + "." + Twine(BeginOffset) + ".");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeline"></td>
    <td class="lineNumber">2560</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeline">    CanSROA &= visit(cast<Instruction>(OldUse->getUser()));</td>
    <td class="lineNumber">2561</td>
    <td class="codeline">    CanSROA &= visit(cast<Instruction>(OldUse->getUser()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeline">    if (VecTy || IntTy)</td>
    <td class="lineNumber">2562</td>
    <td class="codeline">    if (VecTy || IntTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeline">      assert(CanSROA);</td>
    <td class="lineNumber">2563</td>
    <td class="codeline">      assert(CanSROA);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeline">    return CanSROA;</td>
    <td class="lineNumber">2564</td>
    <td class="codeline">    return CanSROA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2565</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeline"></td>
    <td class="lineNumber">2566</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">2567</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeline">  // Make sure the other visit overloads are visible.</td>
    <td class="lineNumber">2568</td>
    <td class="codeline">  // Make sure the other visit overloads are visible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeline">  using Base::visit;</td>
    <td class="lineNumber">2569</td>
    <td class="codeline">  using Base::visit;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeline"></td>
    <td class="lineNumber">2570</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeline">  // Every instruction which can end up as a user must have a rewrite rule.</td>
    <td class="lineNumber">2571</td>
    <td class="codeline">  // Every instruction which can end up as a user must have a rewrite rule.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeline">  bool visitInstruction(Instruction &I) {</td>
    <td class="lineNumber">2572</td>
    <td class="codeline">  bool visitInstruction(Instruction &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    !!!! Cannot rewrite: " << I << "\n");</td>
    <td class="lineNumber">2573</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    !!!! Cannot rewrite: " << I << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeline">    llvm_unreachable("No rewrite rule for this instruction!");</td>
    <td class="lineNumber">2574</td>
    <td class="codeline">    llvm_unreachable("No rewrite rule for this instruction!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2575</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeline"></td>
    <td class="lineNumber">2576</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeline">  Value *getNewAllocaSlicePtr(IRBuilderTy &IRB, Type *PointerTy) {</td>
    <td class="lineNumber">2577</td>
    <td class="codeline">  Value *getNewAllocaSlicePtr(IRBuilderTy &IRB, Type *PointerTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeline">    // Note that the offset computation can use BeginOffset or NewBeginOffset</td>
    <td class="lineNumber">2578</td>
    <td class="codeline">    // Note that the offset computation can use BeginOffset or NewBeginOffset</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeline">    // interchangeably for unsplit slices.</td>
    <td class="lineNumber">2579</td>
    <td class="codeline">    // interchangeably for unsplit slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeline">    assert(IsSplit || BeginOffset == NewBeginOffset);</td>
    <td class="lineNumber">2580</td>
    <td class="codeline">    assert(IsSplit || BeginOffset == NewBeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeline">    uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">2581</td>
    <td class="codeline">    uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeline"></td>
    <td class="lineNumber">2582</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">2583</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeline">    StringRef OldName = OldPtr->getName();</td>
    <td class="lineNumber">2584</td>
    <td class="codeline">    StringRef OldName = OldPtr->getName();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeline">    // Skip through the last '.sroa.' component of the name.</td>
    <td class="lineNumber">2585</td>
    <td class="codeline">    // Skip through the last '.sroa.' component of the name.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeline">    size_t LastSROAPrefix = OldName.rfind(".sroa.");</td>
    <td class="lineNumber">2586</td>
    <td class="codeline">    size_t LastSROAPrefix = OldName.rfind(".sroa.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeline">    if (LastSROAPrefix != StringRef::npos) {</td>
    <td class="lineNumber">2587</td>
    <td class="codeline">    if (LastSROAPrefix != StringRef::npos) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeline">      OldName = OldName.substr(LastSROAPrefix + strlen(".sroa."));</td>
    <td class="lineNumber">2588</td>
    <td class="codeline">      OldName = OldName.substr(LastSROAPrefix + strlen(".sroa."));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeline">      // Look for an SROA slice index.</td>
    <td class="lineNumber">2589</td>
    <td class="codeline">      // Look for an SROA slice index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeline">      size_t IndexEnd = OldName.find_first_not_of("0123456789");</td>
    <td class="lineNumber">2590</td>
    <td class="codeline">      size_t IndexEnd = OldName.find_first_not_of("0123456789");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeline">      if (IndexEnd != StringRef::npos && OldName[IndexEnd] == '.') {</td>
    <td class="lineNumber">2591</td>
    <td class="codeline">      if (IndexEnd != StringRef::npos && OldName[IndexEnd] == '.') {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeline">        // Strip the index and look for the offset.</td>
    <td class="lineNumber">2592</td>
    <td class="codeline">        // Strip the index and look for the offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeline">        OldName = OldName.substr(IndexEnd + 1);</td>
    <td class="lineNumber">2593</td>
    <td class="codeline">        OldName = OldName.substr(IndexEnd + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeline">        size_t OffsetEnd = OldName.find_first_not_of("0123456789");</td>
    <td class="lineNumber">2594</td>
    <td class="codeline">        size_t OffsetEnd = OldName.find_first_not_of("0123456789");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeline">        if (OffsetEnd != StringRef::npos && OldName[OffsetEnd] == '.')</td>
    <td class="lineNumber">2595</td>
    <td class="codeline">        if (OffsetEnd != StringRef::npos && OldName[OffsetEnd] == '.')</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeline">          // Strip the offset.</td>
    <td class="lineNumber">2596</td>
    <td class="codeline">          // Strip the offset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeline">          OldName = OldName.substr(OffsetEnd + 1);</td>
    <td class="lineNumber">2597</td>
    <td class="codeline">          OldName = OldName.substr(OffsetEnd + 1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">2598</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2599</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeline">    // Strip any SROA suffixes as well.</td>
    <td class="lineNumber">2600</td>
    <td class="codeline">    // Strip any SROA suffixes as well.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeline">    OldName = OldName.substr(0, OldName.find(".sroa_"));</td>
    <td class="lineNumber">2601</td>
    <td class="codeline">    OldName = OldName.substr(0, OldName.find(".sroa_"));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">2602</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeline"></td>
    <td class="lineNumber">2603</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeline">    return getAdjustedPtr(IRB, DL, &NewAI,</td>
    <td class="lineNumber">2604</td>
    <td class="codeline">    return getAdjustedPtr(IRB, DL, &NewAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeline">                          APInt(DL.getIndexTypeSizeInBits(PointerTy), Offset),</td>
    <td class="lineNumber">2605</td>
    <td class="codeline">                          APInt(DL.getIndexTypeSizeInBits(PointerTy), Offset),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeline">                          PointerTy,</td>
    <td class="lineNumber">2606</td>
    <td class="codeline">                          PointerTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">2607</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeline">                          Twine(OldName) + "."</td>
    <td class="lineNumber">2608</td>
    <td class="codeline">                          Twine(OldName) + "."</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeline">#else</td>
    <td class="lineNumber">2609</td>
    <td class="codeline">#else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeline">                          Twine()</td>
    <td class="lineNumber">2610</td>
    <td class="codeline">                          Twine()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">2611</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeline">                          );</td>
    <td class="lineNumber">2612</td>
    <td class="codeline">                          );</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2613</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeline"></td>
    <td class="lineNumber">2614</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeline">  /// Compute suitable alignment to access this slice of the *new*</td>
    <td class="lineNumber">2615</td>
    <td class="codeline">  /// Compute suitable alignment to access this slice of the *new*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeline">  /// alloca.</td>
    <td class="lineNumber">2616</td>
    <td class="codeline">  /// alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2617</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeline">  /// You can optionally pass a type to this routine and if that type's ABI</td>
    <td class="lineNumber">2618</td>
    <td class="codeline">  /// You can optionally pass a type to this routine and if that type's ABI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeline">  /// alignment is itself suitable, this will return zero.</td>
    <td class="lineNumber">2619</td>
    <td class="codeline">  /// alignment is itself suitable, this will return zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeline">  Align getSliceAlign() {</td>
    <td class="lineNumber">2620</td>
    <td class="codeline">  Align getSliceAlign() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeline">    return commonAlignment(NewAI.getAlign(),</td>
    <td class="lineNumber">2621</td>
    <td class="codeline">    return commonAlignment(NewAI.getAlign(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeline">                           NewBeginOffset - NewAllocaBeginOffset);</td>
    <td class="lineNumber">2622</td>
    <td class="codeline">                           NewBeginOffset - NewAllocaBeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2623</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeline"></td>
    <td class="lineNumber">2624</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeline">  unsigned getIndex(uint64_t Offset) {</td>
    <td class="lineNumber">2625</td>
    <td class="codeline">  unsigned getIndex(uint64_t Offset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeline">    assert(VecTy && "Can only call getIndex when rewriting a vector");</td>
    <td class="lineNumber">2626</td>
    <td class="codeline">    assert(VecTy && "Can only call getIndex when rewriting a vector");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeline">    uint64_t RelOffset = Offset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">2627</td>
    <td class="codeline">    uint64_t RelOffset = Offset - NewAllocaBeginOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeline">    assert(RelOffset / ElementSize < UINT32_MAX && "Index out of bounds");</td>
    <td class="lineNumber">2628</td>
    <td class="codeline">    assert(RelOffset / ElementSize < UINT32_MAX && "Index out of bounds");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeline">    uint32_t Index = RelOffset / ElementSize;</td>
    <td class="lineNumber">2629</td>
    <td class="codeline">    uint32_t Index = RelOffset / ElementSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeline">    assert(Index * ElementSize == RelOffset);</td>
    <td class="lineNumber">2630</td>
    <td class="codeline">    assert(Index * ElementSize == RelOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeline">    return Index;</td>
    <td class="lineNumber">2631</td>
    <td class="codeline">    return Index;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2632</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeline"></td>
    <td class="lineNumber">2633</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeline">  void deleteIfTriviallyDead(Value *V) {</td>
    <td class="lineNumber">2634</td>
    <td class="codeline">  void deleteIfTriviallyDead(Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeline">    Instruction *I = cast<Instruction>(V);</td>
    <td class="lineNumber">2635</td>
    <td class="codeline">    Instruction *I = cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeline">    if (isInstructionTriviallyDead(I))</td>
    <td class="lineNumber">2636</td>
    <td class="codeline">    if (isInstructionTriviallyDead(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeline">      Pass.DeadInsts.push_back(I);</td>
    <td class="lineNumber">2637</td>
    <td class="codeline">      Pass.DeadInsts.push_back(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2638</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeline"></td>
    <td class="lineNumber">2639</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeline">  Value *rewriteVectorizedLoadInst(LoadInst &LI) {</td>
    <td class="lineNumber">2640</td>
    <td class="codeline">  Value *rewriteVectorizedLoadInst(LoadInst &LI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeline">    unsigned BeginIndex = getIndex(NewBeginOffset);</td>
    <td class="lineNumber">2641</td>
    <td class="codeline">    unsigned BeginIndex = getIndex(NewBeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeline">    unsigned EndIndex = getIndex(NewEndOffset);</td>
    <td class="lineNumber">2642</td>
    <td class="codeline">    unsigned EndIndex = getIndex(NewEndOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeline">    assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td class="lineNumber">2643</td>
    <td class="codeline">    assert(EndIndex > BeginIndex && "Empty vector!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeline"></td>
    <td class="lineNumber">2644</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeline">    LoadInst *Load = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">2645</td>
    <td class="codeline">    LoadInst *Load = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeline">                                           NewAI.getAlign(), "load");</td>
    <td class="lineNumber">2646</td>
    <td class="codeline">                                           NewAI.getAlign(), "load");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeline"></td>
    <td class="lineNumber">2647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeline">    Load->copyMetadata(LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">2648</td>
    <td class="codeline">    Load->copyMetadata(LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeline">                            LLVMContext::MD_access_group});</td>
    <td class="lineNumber">2649</td>
    <td class="codeline">                            LLVMContext::MD_access_group});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeline">    return extractVector(IRB, Load, BeginIndex, EndIndex, "vec");</td>
    <td class="lineNumber">2650</td>
    <td class="codeline">    return extractVector(IRB, Load, BeginIndex, EndIndex, "vec");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2651</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeline"></td>
    <td class="lineNumber">2652</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeline">  Value *rewriteIntegerLoad(LoadInst &LI) {</td>
    <td class="lineNumber">2653</td>
    <td class="codeline">  Value *rewriteIntegerLoad(LoadInst &LI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeline">    assert(IntTy && "We cannot insert an integer to the alloca");</td>
    <td class="lineNumber">2654</td>
    <td class="codeline">    assert(IntTy && "We cannot insert an integer to the alloca");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeline">    assert(!LI.isVolatile());</td>
    <td class="lineNumber">2655</td>
    <td class="codeline">    assert(!LI.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeline">    Value *V = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">2656</td>
    <td class="codeline">    Value *V = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeline">                                     NewAI.getAlign(), "load");</td>
    <td class="lineNumber">2657</td>
    <td class="codeline">                                     NewAI.getAlign(), "load");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeline">    V = convertValue(DL, IRB, V, IntTy);</td>
    <td class="lineNumber">2658</td>
    <td class="codeline">    V = convertValue(DL, IRB, V, IntTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeline">    assert(NewBeginOffset >= NewAllocaBeginOffset && "Out of bounds offset");</td>
    <td class="lineNumber">2659</td>
    <td class="codeline">    assert(NewBeginOffset >= NewAllocaBeginOffset && "Out of bounds offset");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeline">    uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">2660</td>
    <td class="codeline">    uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeline">    if (Offset > 0 || NewEndOffset < NewAllocaEndOffset) {</td>
    <td class="lineNumber">2661</td>
    <td class="codeline">    if (Offset > 0 || NewEndOffset < NewAllocaEndOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeline">      IntegerType *ExtractTy = Type::getIntNTy(LI.getContext(), SliceSize * 8);</td>
    <td class="lineNumber">2662</td>
    <td class="codeline">      IntegerType *ExtractTy = Type::getIntNTy(LI.getContext(), SliceSize * 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeline">      V = extractInteger(DL, IRB, V, ExtractTy, Offset, "extract");</td>
    <td class="lineNumber">2663</td>
    <td class="codeline">      V = extractInteger(DL, IRB, V, ExtractTy, Offset, "extract");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2664</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeline">    // It is possible that the extracted type is not the load type. This</td>
    <td class="lineNumber">2665</td>
    <td class="codeline">    // It is possible that the extracted type is not the load type. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeline">    // happens if there is a load past the end of the alloca, and as</td>
    <td class="lineNumber">2666</td>
    <td class="codeline">    // happens if there is a load past the end of the alloca, and as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeline">    // a consequence the slice is narrower but still a candidate for integer</td>
    <td class="lineNumber">2667</td>
    <td class="codeline">    // a consequence the slice is narrower but still a candidate for integer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeline">    // lowering. To handle this case, we just zero extend the extracted</td>
    <td class="lineNumber">2668</td>
    <td class="codeline">    // lowering. To handle this case, we just zero extend the extracted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeline">    // integer.</td>
    <td class="lineNumber">2669</td>
    <td class="codeline">    // integer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeline">    assert(cast<IntegerType>(LI.getType())->getBitWidth() >= SliceSize * 8 &&</td>
    <td class="lineNumber">2670</td>
    <td class="codeline">    assert(cast<IntegerType>(LI.getType())->getBitWidth() >= SliceSize * 8 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeline">           "Can only handle an extract for an overly wide load");</td>
    <td class="lineNumber">2671</td>
    <td class="codeline">           "Can only handle an extract for an overly wide load");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeline">    if (cast<IntegerType>(LI.getType())->getBitWidth() > SliceSize * 8)</td>
    <td class="lineNumber">2672</td>
    <td class="codeline">    if (cast<IntegerType>(LI.getType())->getBitWidth() > SliceSize * 8)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeline">      V = IRB.CreateZExt(V, LI.getType());</td>
    <td class="lineNumber">2673</td>
    <td class="codeline">      V = IRB.CreateZExt(V, LI.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">2674</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2675</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeline"></td>
    <td class="lineNumber">2676</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeline">  bool visitLoadInst(LoadInst &LI) {</td>
    <td class="lineNumber">2677</td>
    <td class="codeline">  bool visitLoadInst(LoadInst &LI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << LI << "\n");</td>
    <td class="lineNumber">2678</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << LI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeline">    Value *OldOp = LI.getOperand(0);</td>
    <td class="lineNumber">2679</td>
    <td class="codeline">    Value *OldOp = LI.getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeline">    assert(OldOp == OldPtr);</td>
    <td class="lineNumber">2680</td>
    <td class="codeline">    assert(OldOp == OldPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeline"></td>
    <td class="lineNumber">2681</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeline">    AAMDNodes AATags = LI.getAAMetadata();</td>
    <td class="lineNumber">2682</td>
    <td class="codeline">    AAMDNodes AATags = LI.getAAMetadata();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeline"></td>
    <td class="lineNumber">2683</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeline">    unsigned AS = LI.getPointerAddressSpace();</td>
    <td class="lineNumber">2684</td>
    <td class="codeline">    unsigned AS = LI.getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeline"></td>
    <td class="lineNumber">2685</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeline">    Type *TargetTy = IsSplit ? Type::getIntNTy(LI.getContext(), SliceSize * 8)</td>
    <td class="lineNumber">2686</td>
    <td class="codeline">    Type *TargetTy = IsSplit ? Type::getIntNTy(LI.getContext(), SliceSize * 8)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeline">                             : LI.getType();</td>
    <td class="lineNumber">2687</td>
    <td class="codeline">                             : LI.getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeline">    const bool IsLoadPastEnd =</td>
    <td class="lineNumber">2688</td>
    <td class="codeline">    const bool IsLoadPastEnd =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeline">        DL.getTypeStoreSize(TargetTy).getFixedValue() > SliceSize;</td>
    <td class="lineNumber">2689</td>
    <td class="codeline">        DL.getTypeStoreSize(TargetTy).getFixedValue() > SliceSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeline">    bool IsPtrAdjusted = false;</td>
    <td class="lineNumber">2690</td>
    <td class="codeline">    bool IsPtrAdjusted = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeline">    Value *V;</td>
    <td class="lineNumber">2691</td>
    <td class="codeline">    Value *V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeline">    if (VecTy) {</td>
    <td class="lineNumber">2692</td>
    <td class="codeline">    if (VecTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeline">      V = rewriteVectorizedLoadInst(LI);</td>
    <td class="lineNumber">2693</td>
    <td class="codeline">      V = rewriteVectorizedLoadInst(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeline">    } else if (IntTy && LI.getType()->isIntegerTy()) {</td>
    <td class="lineNumber">2694</td>
    <td class="codeline">    } else if (IntTy && LI.getType()->isIntegerTy()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeline">      V = rewriteIntegerLoad(LI);</td>
    <td class="lineNumber">2695</td>
    <td class="codeline">      V = rewriteIntegerLoad(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeline">    } else if (NewBeginOffset == NewAllocaBeginOffset &&</td>
    <td class="lineNumber">2696</td>
    <td class="codeline">    } else if (NewBeginOffset == NewAllocaBeginOffset &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeline">               NewEndOffset == NewAllocaEndOffset &&</td>
    <td class="lineNumber">2697</td>
    <td class="codeline">               NewEndOffset == NewAllocaEndOffset &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeline">               (canConvertValue(DL, NewAllocaTy, TargetTy) ||</td>
    <td class="lineNumber">2698</td>
    <td class="codeline">               (canConvertValue(DL, NewAllocaTy, TargetTy) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeline">                (IsLoadPastEnd && NewAllocaTy->isIntegerTy() &&</td>
    <td class="lineNumber">2699</td>
    <td class="codeline">                (IsLoadPastEnd && NewAllocaTy->isIntegerTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeline">                 TargetTy->isIntegerTy()))) {</td>
    <td class="lineNumber">2700</td>
    <td class="codeline">                 TargetTy->isIntegerTy()))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeline">      Value *NewPtr =</td>
    <td class="lineNumber">2701</td>
    <td class="codeline">      Value *NewPtr =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeline">          getPtrToNewAI(LI.getPointerAddressSpace(), LI.isVolatile());</td>
    <td class="lineNumber">2702</td>
    <td class="codeline">          getPtrToNewAI(LI.getPointerAddressSpace(), LI.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeline">      LoadInst *NewLI = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), NewPtr,</td>
    <td class="lineNumber">2703</td>
    <td class="codeline">      LoadInst *NewLI = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), NewPtr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeline">                                              NewAI.getAlign(), LI.isVolatile(),</td>
    <td class="lineNumber">2704</td>
    <td class="codeline">                                              NewAI.getAlign(), LI.isVolatile(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeline">                                              LI.getName());</td>
    <td class="lineNumber">2705</td>
    <td class="codeline">                                              LI.getName());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeline">      if (LI.isVolatile())</td>
    <td class="lineNumber">2706</td>
    <td class="codeline">      if (LI.isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeline">        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());</td>
    <td class="lineNumber">2707</td>
    <td class="codeline">        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeline">      if (NewLI->isAtomic())</td>
    <td class="lineNumber">2708</td>
    <td class="codeline">      if (NewLI->isAtomic())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeline">        NewLI->setAlignment(LI.getAlign());</td>
    <td class="lineNumber">2709</td>
    <td class="codeline">        NewLI->setAlignment(LI.getAlign());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeline"></td>
    <td class="lineNumber">2710</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeline">      // Copy any metadata that is valid for the new load. This may require</td>
    <td class="lineNumber">2711</td>
    <td class="codeline">      // Copy any metadata that is valid for the new load. This may require</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeline">      // conversion to a different kind of metadata, e.g. !nonnull might change</td>
    <td class="lineNumber">2712</td>
    <td class="codeline">      // conversion to a different kind of metadata, e.g. !nonnull might change</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeline">      // to !range or vice versa.</td>
    <td class="lineNumber">2713</td>
    <td class="codeline">      // to !range or vice versa.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeline">      copyMetadataForLoad(*NewLI, LI);</td>
    <td class="lineNumber">2714</td>
    <td class="codeline">      copyMetadataForLoad(*NewLI, LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeline"></td>
    <td class="lineNumber">2715</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeline">      // Do this after copyMetadataForLoad() to preserve the TBAA shift.</td>
    <td class="lineNumber">2716</td>
    <td class="codeline">      // Do this after copyMetadataForLoad() to preserve the TBAA shift.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeline">      if (AATags)</td>
    <td class="lineNumber">2717</td>
    <td class="codeline">      if (AATags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeline">        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">2718</td>
    <td class="codeline">        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeline"></td>
    <td class="lineNumber">2719</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeline">      // Try to preserve nonnull metadata</td>
    <td class="lineNumber">2720</td>
    <td class="codeline">      // Try to preserve nonnull metadata</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeline">      V = NewLI;</td>
    <td class="lineNumber">2721</td>
    <td class="codeline">      V = NewLI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeline"></td>
    <td class="lineNumber">2722</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeline">      // If this is an integer load past the end of the slice (which means the</td>
    <td class="lineNumber">2723</td>
    <td class="codeline">      // If this is an integer load past the end of the slice (which means the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeline">      // bytes outside the slice are undef or this load is dead) just forcibly</td>
    <td class="lineNumber">2724</td>
    <td class="codeline">      // bytes outside the slice are undef or this load is dead) just forcibly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeline">      // fix the integer size with correct handling of endianness.</td>
    <td class="lineNumber">2725</td>
    <td class="codeline">      // fix the integer size with correct handling of endianness.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeline">      if (auto *AITy = dyn_cast<IntegerType>(NewAllocaTy))</td>
    <td class="lineNumber">2726</td>
    <td class="codeline">      if (auto *AITy = dyn_cast<IntegerType>(NewAllocaTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeline">        if (auto *TITy = dyn_cast<IntegerType>(TargetTy))</td>
    <td class="lineNumber">2727</td>
    <td class="codeline">        if (auto *TITy = dyn_cast<IntegerType>(TargetTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeline">          if (AITy->getBitWidth() < TITy->getBitWidth()) {</td>
    <td class="lineNumber">2728</td>
    <td class="codeline">          if (AITy->getBitWidth() < TITy->getBitWidth()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeline">            V = IRB.CreateZExt(V, TITy, "load.ext");</td>
    <td class="lineNumber">2729</td>
    <td class="codeline">            V = IRB.CreateZExt(V, TITy, "load.ext");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeline">            if (DL.isBigEndian())</td>
    <td class="lineNumber">2730</td>
    <td class="codeline">            if (DL.isBigEndian())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeline">              V = IRB.CreateShl(V, TITy->getBitWidth() - AITy->getBitWidth(),</td>
    <td class="lineNumber">2731</td>
    <td class="codeline">              V = IRB.CreateShl(V, TITy->getBitWidth() - AITy->getBitWidth(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeline">                                "endian_shift");</td>
    <td class="lineNumber">2732</td>
    <td class="codeline">                                "endian_shift");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">2733</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2734</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeline">      Type *LTy = TargetTy->getPointerTo(AS);</td>
    <td class="lineNumber">2735</td>
    <td class="codeline">      Type *LTy = TargetTy->getPointerTo(AS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeline">      LoadInst *NewLI =</td>
    <td class="lineNumber">2736</td>
    <td class="codeline">      LoadInst *NewLI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeline">          IRB.CreateAlignedLoad(TargetTy, getNewAllocaSlicePtr(IRB, LTy),</td>
    <td class="lineNumber">2737</td>
    <td class="codeline">          IRB.CreateAlignedLoad(TargetTy, getNewAllocaSlicePtr(IRB, LTy),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeline">                                getSliceAlign(), LI.isVolatile(), LI.getName());</td>
    <td class="lineNumber">2738</td>
    <td class="codeline">                                getSliceAlign(), LI.isVolatile(), LI.getName());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeline">      if (AATags)</td>
    <td class="lineNumber">2739</td>
    <td class="codeline">      if (AATags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeline">        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">2740</td>
    <td class="codeline">        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeline">      if (LI.isVolatile())</td>
    <td class="lineNumber">2741</td>
    <td class="codeline">      if (LI.isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeline">        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());</td>
    <td class="lineNumber">2742</td>
    <td class="codeline">        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeline">      NewLI->copyMetadata(LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">2743</td>
    <td class="codeline">      NewLI->copyMetadata(LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeline">                               LLVMContext::MD_access_group});</td>
    <td class="lineNumber">2744</td>
    <td class="codeline">                               LLVMContext::MD_access_group});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeline"></td>
    <td class="lineNumber">2745</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeline">      V = NewLI;</td>
    <td class="lineNumber">2746</td>
    <td class="codeline">      V = NewLI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeline">      IsPtrAdjusted = true;</td>
    <td class="lineNumber">2747</td>
    <td class="codeline">      IsPtrAdjusted = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2748</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeline">    V = convertValue(DL, IRB, V, TargetTy);</td>
    <td class="lineNumber">2749</td>
    <td class="codeline">    V = convertValue(DL, IRB, V, TargetTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeline"></td>
    <td class="lineNumber">2750</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeline">    if (IsSplit) {</td>
    <td class="lineNumber">2751</td>
    <td class="codeline">    if (IsSplit) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeline">      assert(!LI.isVolatile());</td>
    <td class="lineNumber">2752</td>
    <td class="codeline">      assert(!LI.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeline">      assert(LI.getType()->isIntegerTy() &&</td>
    <td class="lineNumber">2753</td>
    <td class="codeline">      assert(LI.getType()->isIntegerTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeline">             "Only integer type loads and stores are split");</td>
    <td class="lineNumber">2754</td>
    <td class="codeline">             "Only integer type loads and stores are split");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeline">      assert(SliceSize < DL.getTypeStoreSize(LI.getType()).getFixedValue() &&</td>
    <td class="lineNumber">2755</td>
    <td class="codeline">      assert(SliceSize < DL.getTypeStoreSize(LI.getType()).getFixedValue() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeline">             "Split load isn't smaller than original load");</td>
    <td class="lineNumber">2756</td>
    <td class="codeline">             "Split load isn't smaller than original load");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeline">      assert(DL.typeSizeEqualsStoreSize(LI.getType()) &&</td>
    <td class="lineNumber">2757</td>
    <td class="codeline">      assert(DL.typeSizeEqualsStoreSize(LI.getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeline">             "Non-byte-multiple bit width");</td>
    <td class="lineNumber">2758</td>
    <td class="codeline">             "Non-byte-multiple bit width");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeline">      // Move the insertion point just past the load so that we can refer to it.</td>
    <td class="lineNumber">2759</td>
    <td class="codeline">      // Move the insertion point just past the load so that we can refer to it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeline">      IRB.SetInsertPoint(&*std::next(BasicBlock::iterator(&LI)));</td>
    <td class="lineNumber">2760</td>
    <td class="codeline">      IRB.SetInsertPoint(&*std::next(BasicBlock::iterator(&LI)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeline">      // Create a placeholder value with the same type as LI to use as the</td>
    <td class="lineNumber">2761</td>
    <td class="codeline">      // Create a placeholder value with the same type as LI to use as the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeline">      // basis for the new value. This allows us to replace the uses of LI with</td>
    <td class="lineNumber">2762</td>
    <td class="codeline">      // basis for the new value. This allows us to replace the uses of LI with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeline">      // the computed value, and then replace the placeholder with LI, leaving</td>
    <td class="lineNumber">2763</td>
    <td class="codeline">      // the computed value, and then replace the placeholder with LI, leaving</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeline">      // LI only used for this computation.</td>
    <td class="lineNumber">2764</td>
    <td class="codeline">      // LI only used for this computation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeline">      Value *Placeholder = new LoadInst(</td>
    <td class="lineNumber">2765</td>
    <td class="codeline">      Value *Placeholder = new LoadInst(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeline">          LI.getType(), PoisonValue::get(LI.getType()->getPointerTo(AS)), "",</td>
    <td class="lineNumber">2766</td>
    <td class="codeline">          LI.getType(), PoisonValue::get(LI.getType()->getPointerTo(AS)), "",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeline">          false, Align(1));</td>
    <td class="lineNumber">2767</td>
    <td class="codeline">          false, Align(1));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeline">      V = insertInteger(DL, IRB, Placeholder, V, NewBeginOffset - BeginOffset,</td>
    <td class="lineNumber">2768</td>
    <td class="codeline">      V = insertInteger(DL, IRB, Placeholder, V, NewBeginOffset - BeginOffset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeline">                        "insert");</td>
    <td class="lineNumber">2769</td>
    <td class="codeline">                        "insert");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeline">      LI.replaceAllUsesWith(V);</td>
    <td class="lineNumber">2770</td>
    <td class="codeline">      LI.replaceAllUsesWith(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeline">      Placeholder->replaceAllUsesWith(&LI);</td>
    <td class="lineNumber">2771</td>
    <td class="codeline">      Placeholder->replaceAllUsesWith(&LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeline">      Placeholder->deleteValue();</td>
    <td class="lineNumber">2772</td>
    <td class="codeline">      Placeholder->deleteValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2773</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeline">      LI.replaceAllUsesWith(V);</td>
    <td class="lineNumber">2774</td>
    <td class="codeline">      LI.replaceAllUsesWith(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2775</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeline"></td>
    <td class="lineNumber">2776</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&LI);</td>
    <td class="lineNumber">2777</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeline">    deleteIfTriviallyDead(OldOp);</td>
    <td class="lineNumber">2778</td>
    <td class="codeline">    deleteIfTriviallyDead(OldOp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *V << "\n");</td>
    <td class="lineNumber">2779</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeline">    return !LI.isVolatile() && !IsPtrAdjusted;</td>
    <td class="lineNumber">2780</td>
    <td class="codeline">    return !LI.isVolatile() && !IsPtrAdjusted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2781</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeline"></td>
    <td class="lineNumber">2782</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeline">  bool rewriteVectorizedStoreInst(Value *V, StoreInst &SI, Value *OldOp,</td>
    <td class="lineNumber">2783</td>
    <td class="codeline">  bool rewriteVectorizedStoreInst(Value *V, StoreInst &SI, Value *OldOp,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeline">                                  AAMDNodes AATags) {</td>
    <td class="lineNumber">2784</td>
    <td class="codeline">                                  AAMDNodes AATags) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeline">    // Capture V for the purpose of debug-info accounting once it's converted</td>
    <td class="lineNumber">2785</td>
    <td class="codeline">    // Capture V for the purpose of debug-info accounting once it's converted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeline">    // to a vector store.</td>
    <td class="lineNumber">2786</td>
    <td class="codeline">    // to a vector store.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeline">    Value *OrigV = V;</td>
    <td class="lineNumber">2787</td>
    <td class="codeline">    Value *OrigV = V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeline">    if (V->getType() != VecTy) {</td>
    <td class="lineNumber">2788</td>
    <td class="codeline">    if (V->getType() != VecTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeline">      unsigned BeginIndex = getIndex(NewBeginOffset);</td>
    <td class="lineNumber">2789</td>
    <td class="codeline">      unsigned BeginIndex = getIndex(NewBeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeline">      unsigned EndIndex = getIndex(NewEndOffset);</td>
    <td class="lineNumber">2790</td>
    <td class="codeline">      unsigned EndIndex = getIndex(NewEndOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeline">      assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td class="lineNumber">2791</td>
    <td class="codeline">      assert(EndIndex > BeginIndex && "Empty vector!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeline">      unsigned NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">2792</td>
    <td class="codeline">      unsigned NumElements = EndIndex - BeginIndex;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeline">      assert(NumElements <= cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
    <td class="lineNumber">2793</td>
    <td class="codeline">      assert(NumElements <= cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeline">             "Too many elements!");</td>
    <td class="lineNumber">2794</td>
    <td class="codeline">             "Too many elements!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeline">      Type *SliceTy = (NumElements == 1)</td>
    <td class="lineNumber">2795</td>
    <td class="codeline">      Type *SliceTy = (NumElements == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeline">                          ? ElementTy</td>
    <td class="lineNumber">2796</td>
    <td class="codeline">                          ? ElementTy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeline">                          : FixedVectorType::get(ElementTy, NumElements);</td>
    <td class="lineNumber">2797</td>
    <td class="codeline">                          : FixedVectorType::get(ElementTy, NumElements);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeline">      if (V->getType() != SliceTy)</td>
    <td class="lineNumber">2798</td>
    <td class="codeline">      if (V->getType() != SliceTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeline">        V = convertValue(DL, IRB, V, SliceTy);</td>
    <td class="lineNumber">2799</td>
    <td class="codeline">        V = convertValue(DL, IRB, V, SliceTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeline"></td>
    <td class="lineNumber">2800</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeline">      // Mix in the existing elements.</td>
    <td class="lineNumber">2801</td>
    <td class="codeline">      // Mix in the existing elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeline">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">2802</td>
    <td class="codeline">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeline">                                         NewAI.getAlign(), "load");</td>
    <td class="lineNumber">2803</td>
    <td class="codeline">                                         NewAI.getAlign(), "load");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeline">      V = insertVector(IRB, Old, V, BeginIndex, "vec");</td>
    <td class="lineNumber">2804</td>
    <td class="codeline">      V = insertVector(IRB, Old, V, BeginIndex, "vec");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2805</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeline">    StoreInst *Store = IRB.CreateAlignedStore(V, &NewAI, NewAI.getAlign());</td>
    <td class="lineNumber">2806</td>
    <td class="codeline">    StoreInst *Store = IRB.CreateAlignedStore(V, &NewAI, NewAI.getAlign());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeline">    Store->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">2807</td>
    <td class="codeline">    Store->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeline">                             LLVMContext::MD_access_group});</td>
    <td class="lineNumber">2808</td>
    <td class="codeline">                             LLVMContext::MD_access_group});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeline">    if (AATags)</td>
    <td class="lineNumber">2809</td>
    <td class="codeline">    if (AATags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeline">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">2810</td>
    <td class="codeline">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&SI);</td>
    <td class="lineNumber">2811</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeline"></td>
    <td class="lineNumber">2812</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeline">    // NOTE: Careful to use OrigV rather than V.</td>
    <td class="lineNumber">2813</td>
    <td class="codeline">    // NOTE: Careful to use OrigV rather than V.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeline">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
    <td class="lineNumber">2814</td>
    <td class="codeline">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeline">                     Store, Store->getPointerOperand(), OrigV, DL);</td>
    <td class="lineNumber">2815</td>
    <td class="codeline">                     Store, Store->getPointerOperand(), OrigV, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td class="lineNumber">2816</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2817</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2818</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeline"></td>
    <td class="lineNumber">2819</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeline">  bool rewriteIntegerStore(Value *V, StoreInst &SI, AAMDNodes AATags) {</td>
    <td class="lineNumber">2820</td>
    <td class="codeline">  bool rewriteIntegerStore(Value *V, StoreInst &SI, AAMDNodes AATags) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeline">    assert(IntTy && "We cannot extract an integer from the alloca");</td>
    <td class="lineNumber">2821</td>
    <td class="codeline">    assert(IntTy && "We cannot extract an integer from the alloca");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeline">    assert(!SI.isVolatile());</td>
    <td class="lineNumber">2822</td>
    <td class="codeline">    assert(!SI.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeline">    if (DL.getTypeSizeInBits(V->getType()).getFixedValue() !=</td>
    <td class="lineNumber">2823</td>
    <td class="codeline">    if (DL.getTypeSizeInBits(V->getType()).getFixedValue() !=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeline">        IntTy->getBitWidth()) {</td>
    <td class="lineNumber">2824</td>
    <td class="codeline">        IntTy->getBitWidth()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeline">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">2825</td>
    <td class="codeline">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeline">                                         NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">2826</td>
    <td class="codeline">                                         NewAI.getAlign(), "oldload");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeline">      Old = convertValue(DL, IRB, Old, IntTy);</td>
    <td class="lineNumber">2827</td>
    <td class="codeline">      Old = convertValue(DL, IRB, Old, IntTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeline">      assert(BeginOffset >= NewAllocaBeginOffset && "Out of bounds offset");</td>
    <td class="lineNumber">2828</td>
    <td class="codeline">      assert(BeginOffset >= NewAllocaBeginOffset && "Out of bounds offset");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeline">      uint64_t Offset = BeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">2829</td>
    <td class="codeline">      uint64_t Offset = BeginOffset - NewAllocaBeginOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeline">      V = insertInteger(DL, IRB, Old, SI.getValueOperand(), Offset, "insert");</td>
    <td class="lineNumber">2830</td>
    <td class="codeline">      V = insertInteger(DL, IRB, Old, SI.getValueOperand(), Offset, "insert");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2831</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeline">    V = convertValue(DL, IRB, V, NewAllocaTy);</td>
    <td class="lineNumber">2832</td>
    <td class="codeline">    V = convertValue(DL, IRB, V, NewAllocaTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeline">    StoreInst *Store = IRB.CreateAlignedStore(V, &NewAI, NewAI.getAlign());</td>
    <td class="lineNumber">2833</td>
    <td class="codeline">    StoreInst *Store = IRB.CreateAlignedStore(V, &NewAI, NewAI.getAlign());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeline">    Store->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">2834</td>
    <td class="codeline">    Store->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeline">                             LLVMContext::MD_access_group});</td>
    <td class="lineNumber">2835</td>
    <td class="codeline">                             LLVMContext::MD_access_group});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeline">    if (AATags)</td>
    <td class="lineNumber">2836</td>
    <td class="codeline">    if (AATags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeline">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">2837</td>
    <td class="codeline">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeline"></td>
    <td class="lineNumber">2838</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeline">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
    <td class="lineNumber">2839</td>
    <td class="codeline">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeline">                     Store, Store->getPointerOperand(),</td>
    <td class="lineNumber">2840</td>
    <td class="codeline">                     Store, Store->getPointerOperand(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeline">                     Store->getValueOperand(), DL);</td>
    <td class="lineNumber">2841</td>
    <td class="codeline">                     Store->getValueOperand(), DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeline"></td>
    <td class="lineNumber">2842</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&SI);</td>
    <td class="lineNumber">2843</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td class="lineNumber">2844</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">2845</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2846</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeline"></td>
    <td class="lineNumber">2847</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeline">  bool visitStoreInst(StoreInst &SI) {</td>
    <td class="lineNumber">2848</td>
    <td class="codeline">  bool visitStoreInst(StoreInst &SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
    <td class="lineNumber">2849</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeline">    Value *OldOp = SI.getOperand(1);</td>
    <td class="lineNumber">2850</td>
    <td class="codeline">    Value *OldOp = SI.getOperand(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="codeline">    assert(OldOp == OldPtr);</td>
    <td class="lineNumber">2851</td>
    <td class="codeline">    assert(OldOp == OldPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="codeline"></td>
    <td class="lineNumber">2852</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="codeline">    AAMDNodes AATags = SI.getAAMetadata();</td>
    <td class="lineNumber">2853</td>
    <td class="codeline">    AAMDNodes AATags = SI.getAAMetadata();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="codeline">    Value *V = SI.getValueOperand();</td>
    <td class="lineNumber">2854</td>
    <td class="codeline">    Value *V = SI.getValueOperand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="codeline"></td>
    <td class="lineNumber">2855</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="codeline">    // Strip all inbounds GEPs and pointer casts to try to dig out any root</td>
    <td class="lineNumber">2856</td>
    <td class="codeline">    // Strip all inbounds GEPs and pointer casts to try to dig out any root</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="codeline">    // alloca that should be re-examined after promoting this alloca.</td>
    <td class="lineNumber">2857</td>
    <td class="codeline">    // alloca that should be re-examined after promoting this alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="codeline">    if (V->getType()->isPointerTy())</td>
    <td class="lineNumber">2858</td>
    <td class="codeline">    if (V->getType()->isPointerTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="codeline">      if (AllocaInst *AI = dyn_cast<AllocaInst>(V->stripInBoundsOffsets()))</td>
    <td class="lineNumber">2859</td>
    <td class="codeline">      if (AllocaInst *AI = dyn_cast<AllocaInst>(V->stripInBoundsOffsets()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="codeline">        Pass.PostPromotionWorklist.insert(AI);</td>
    <td class="lineNumber">2860</td>
    <td class="codeline">        Pass.PostPromotionWorklist.insert(AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="codeline"></td>
    <td class="lineNumber">2861</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="codeline">    if (SliceSize < DL.getTypeStoreSize(V->getType()).getFixedValue()) {</td>
    <td class="lineNumber">2862</td>
    <td class="codeline">    if (SliceSize < DL.getTypeStoreSize(V->getType()).getFixedValue()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="codeline">      assert(!SI.isVolatile());</td>
    <td class="lineNumber">2863</td>
    <td class="codeline">      assert(!SI.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="codeline">      assert(V->getType()->isIntegerTy() &&</td>
    <td class="lineNumber">2864</td>
    <td class="codeline">      assert(V->getType()->isIntegerTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="codeline">             "Only integer type loads and stores are split");</td>
    <td class="lineNumber">2865</td>
    <td class="codeline">             "Only integer type loads and stores are split");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="codeline">      assert(DL.typeSizeEqualsStoreSize(V->getType()) &&</td>
    <td class="lineNumber">2866</td>
    <td class="codeline">      assert(DL.typeSizeEqualsStoreSize(V->getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="codeline">             "Non-byte-multiple bit width");</td>
    <td class="lineNumber">2867</td>
    <td class="codeline">             "Non-byte-multiple bit width");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="codeline">      IntegerType *NarrowTy = Type::getIntNTy(SI.getContext(), SliceSize * 8);</td>
    <td class="lineNumber">2868</td>
    <td class="codeline">      IntegerType *NarrowTy = Type::getIntNTy(SI.getContext(), SliceSize * 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="codeline">      V = extractInteger(DL, IRB, V, NarrowTy, NewBeginOffset - BeginOffset,</td>
    <td class="lineNumber">2869</td>
    <td class="codeline">      V = extractInteger(DL, IRB, V, NarrowTy, NewBeginOffset - BeginOffset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="codeline">                         "extract");</td>
    <td class="lineNumber">2870</td>
    <td class="codeline">                         "extract");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2871</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="codeline"></td>
    <td class="lineNumber">2872</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="codeline">    if (VecTy)</td>
    <td class="lineNumber">2873</td>
    <td class="codeline">    if (VecTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="codeline">      return rewriteVectorizedStoreInst(V, SI, OldOp, AATags);</td>
    <td class="lineNumber">2874</td>
    <td class="codeline">      return rewriteVectorizedStoreInst(V, SI, OldOp, AATags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="codeline">    if (IntTy && V->getType()->isIntegerTy())</td>
    <td class="lineNumber">2875</td>
    <td class="codeline">    if (IntTy && V->getType()->isIntegerTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="codeline">      return rewriteIntegerStore(V, SI, AATags);</td>
    <td class="lineNumber">2876</td>
    <td class="codeline">      return rewriteIntegerStore(V, SI, AATags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="codeline"></td>
    <td class="lineNumber">2877</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="codeline">    const bool IsStorePastEnd =</td>
    <td class="lineNumber">2878</td>
    <td class="codeline">    const bool IsStorePastEnd =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="codeline">        DL.getTypeStoreSize(V->getType()).getFixedValue() > SliceSize;</td>
    <td class="lineNumber">2879</td>
    <td class="codeline">        DL.getTypeStoreSize(V->getType()).getFixedValue() > SliceSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="codeline">    StoreInst *NewSI;</td>
    <td class="lineNumber">2880</td>
    <td class="codeline">    StoreInst *NewSI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="codeline">    if (NewBeginOffset == NewAllocaBeginOffset &&</td>
    <td class="lineNumber">2881</td>
    <td class="codeline">    if (NewBeginOffset == NewAllocaBeginOffset &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="codeline">        NewEndOffset == NewAllocaEndOffset &&</td>
    <td class="lineNumber">2882</td>
    <td class="codeline">        NewEndOffset == NewAllocaEndOffset &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="codeline">        (canConvertValue(DL, V->getType(), NewAllocaTy) ||</td>
    <td class="lineNumber">2883</td>
    <td class="codeline">        (canConvertValue(DL, V->getType(), NewAllocaTy) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="codeline">         (IsStorePastEnd && NewAllocaTy->isIntegerTy() &&</td>
    <td class="lineNumber">2884</td>
    <td class="codeline">         (IsStorePastEnd && NewAllocaTy->isIntegerTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="codeline">          V->getType()->isIntegerTy()))) {</td>
    <td class="lineNumber">2885</td>
    <td class="codeline">          V->getType()->isIntegerTy()))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="codeline">      // If this is an integer store past the end of slice (and thus the bytes</td>
    <td class="lineNumber">2886</td>
    <td class="codeline">      // If this is an integer store past the end of slice (and thus the bytes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="codeline">      // past that point are irrelevant or this is unreachable), truncate the</td>
    <td class="lineNumber">2887</td>
    <td class="codeline">      // past that point are irrelevant or this is unreachable), truncate the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="codeline">      // value prior to storing.</td>
    <td class="lineNumber">2888</td>
    <td class="codeline">      // value prior to storing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="codeline">      if (auto *VITy = dyn_cast<IntegerType>(V->getType()))</td>
    <td class="lineNumber">2889</td>
    <td class="codeline">      if (auto *VITy = dyn_cast<IntegerType>(V->getType()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="codeline">        if (auto *AITy = dyn_cast<IntegerType>(NewAllocaTy))</td>
    <td class="lineNumber">2890</td>
    <td class="codeline">        if (auto *AITy = dyn_cast<IntegerType>(NewAllocaTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="codeline">          if (VITy->getBitWidth() > AITy->getBitWidth()) {</td>
    <td class="lineNumber">2891</td>
    <td class="codeline">          if (VITy->getBitWidth() > AITy->getBitWidth()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="codeline">            if (DL.isBigEndian())</td>
    <td class="lineNumber">2892</td>
    <td class="codeline">            if (DL.isBigEndian())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="codeline">              V = IRB.CreateLShr(V, VITy->getBitWidth() - AITy->getBitWidth(),</td>
    <td class="lineNumber">2893</td>
    <td class="codeline">              V = IRB.CreateLShr(V, VITy->getBitWidth() - AITy->getBitWidth(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="codeline">                                 "endian_shift");</td>
    <td class="lineNumber">2894</td>
    <td class="codeline">                                 "endian_shift");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="codeline">            V = IRB.CreateTrunc(V, AITy, "load.trunc");</td>
    <td class="lineNumber">2895</td>
    <td class="codeline">            V = IRB.CreateTrunc(V, AITy, "load.trunc");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">2896</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="codeline"></td>
    <td class="lineNumber">2897</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="codeline">      V = convertValue(DL, IRB, V, NewAllocaTy);</td>
    <td class="lineNumber">2898</td>
    <td class="codeline">      V = convertValue(DL, IRB, V, NewAllocaTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="codeline">      Value *NewPtr =</td>
    <td class="lineNumber">2899</td>
    <td class="codeline">      Value *NewPtr =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="codeline">          getPtrToNewAI(SI.getPointerAddressSpace(), SI.isVolatile());</td>
    <td class="lineNumber">2900</td>
    <td class="codeline">          getPtrToNewAI(SI.getPointerAddressSpace(), SI.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="codeline"></td>
    <td class="lineNumber">2901</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="codeline">      NewSI =</td>
    <td class="lineNumber">2902</td>
    <td class="codeline">      NewSI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="codeline">          IRB.CreateAlignedStore(V, NewPtr, NewAI.getAlign(), SI.isVolatile());</td>
    <td class="lineNumber">2903</td>
    <td class="codeline">          IRB.CreateAlignedStore(V, NewPtr, NewAI.getAlign(), SI.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">2904</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="codeline">      unsigned AS = SI.getPointerAddressSpace();</td>
    <td class="lineNumber">2905</td>
    <td class="codeline">      unsigned AS = SI.getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="codeline">      Value *NewPtr = getNewAllocaSlicePtr(IRB, V->getType()->getPointerTo(AS));</td>
    <td class="lineNumber">2906</td>
    <td class="codeline">      Value *NewPtr = getNewAllocaSlicePtr(IRB, V->getType()->getPointerTo(AS));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="codeline">      NewSI =</td>
    <td class="lineNumber">2907</td>
    <td class="codeline">      NewSI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="codeline">          IRB.CreateAlignedStore(V, NewPtr, getSliceAlign(), SI.isVolatile());</td>
    <td class="lineNumber">2908</td>
    <td class="codeline">          IRB.CreateAlignedStore(V, NewPtr, getSliceAlign(), SI.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2909</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="codeline">    NewSI->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">2910</td>
    <td class="codeline">    NewSI->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="codeline">                             LLVMContext::MD_access_group});</td>
    <td class="lineNumber">2911</td>
    <td class="codeline">                             LLVMContext::MD_access_group});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="codeline">    if (AATags)</td>
    <td class="lineNumber">2912</td>
    <td class="codeline">    if (AATags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="codeline">      NewSI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">2913</td>
    <td class="codeline">      NewSI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="codeline">    if (SI.isVolatile())</td>
    <td class="lineNumber">2914</td>
    <td class="codeline">    if (SI.isVolatile())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="codeline">      NewSI->setAtomic(SI.getOrdering(), SI.getSyncScopeID());</td>
    <td class="lineNumber">2915</td>
    <td class="codeline">      NewSI->setAtomic(SI.getOrdering(), SI.getSyncScopeID());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="codeline">    if (NewSI->isAtomic())</td>
    <td class="lineNumber">2916</td>
    <td class="codeline">    if (NewSI->isAtomic())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="codeline">      NewSI->setAlignment(SI.getAlign());</td>
    <td class="lineNumber">2917</td>
    <td class="codeline">      NewSI->setAlignment(SI.getAlign());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="codeline"></td>
    <td class="lineNumber">2918</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="codeline">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
    <td class="lineNumber">2919</td>
    <td class="codeline">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="codeline">                     NewSI, NewSI->getPointerOperand(),</td>
    <td class="lineNumber">2920</td>
    <td class="codeline">                     NewSI, NewSI->getPointerOperand(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="codeline">                     NewSI->getValueOperand(), DL);</td>
    <td class="lineNumber">2921</td>
    <td class="codeline">                     NewSI->getValueOperand(), DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="codeline"></td>
    <td class="lineNumber">2922</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&SI);</td>
    <td class="lineNumber">2923</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="codeline">    deleteIfTriviallyDead(OldOp);</td>
    <td class="lineNumber">2924</td>
    <td class="codeline">    deleteIfTriviallyDead(OldOp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="codeline"></td>
    <td class="lineNumber">2925</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *NewSI << "\n");</td>
    <td class="lineNumber">2926</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *NewSI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="codeline">    return NewSI->getPointerOperand() == &NewAI &&</td>
    <td class="lineNumber">2927</td>
    <td class="codeline">    return NewSI->getPointerOperand() == &NewAI &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="codeline">           NewSI->getValueOperand()->getType() == NewAllocaTy &&</td>
    <td class="lineNumber">2928</td>
    <td class="codeline">           NewSI->getValueOperand()->getType() == NewAllocaTy &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="codeline">           !SI.isVolatile();</td>
    <td class="lineNumber">2929</td>
    <td class="codeline">           !SI.isVolatile();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2930</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="codeline"></td>
    <td class="lineNumber">2931</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="codeline">  /// Compute an integer value from splatting an i8 across the given</td>
    <td class="lineNumber">2932</td>
    <td class="codeline">  /// Compute an integer value from splatting an i8 across the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="codeline">  /// number of bytes.</td>
    <td class="lineNumber">2933</td>
    <td class="codeline">  /// number of bytes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2934</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="codeline">  /// Note that this routine assumes an i8 is a byte. If that isn't true, don't</td>
    <td class="lineNumber">2935</td>
    <td class="codeline">  /// Note that this routine assumes an i8 is a byte. If that isn't true, don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="codeline">  /// call this routine.</td>
    <td class="lineNumber">2936</td>
    <td class="codeline">  /// call this routine.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="codeline">  /// FIXME: Heed the advice above.</td>
    <td class="lineNumber">2937</td>
    <td class="codeline">  /// FIXME: Heed the advice above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2938</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="codeline">  /// \param V The i8 value to splat.</td>
    <td class="lineNumber">2939</td>
    <td class="codeline">  /// \param V The i8 value to splat.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="codeline">  /// \param Size The number of bytes in the output (assuming i8 is one byte)</td>
    <td class="lineNumber">2940</td>
    <td class="codeline">  /// \param Size The number of bytes in the output (assuming i8 is one byte)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="codeline">  Value *getIntegerSplat(Value *V, unsigned Size) {</td>
    <td class="lineNumber">2941</td>
    <td class="codeline">  Value *getIntegerSplat(Value *V, unsigned Size) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="codeline">    assert(Size > 0 && "Expected a positive number of bytes.");</td>
    <td class="lineNumber">2942</td>
    <td class="codeline">    assert(Size > 0 && "Expected a positive number of bytes.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="codeline">    IntegerType *VTy = cast<IntegerType>(V->getType());</td>
    <td class="lineNumber">2943</td>
    <td class="codeline">    IntegerType *VTy = cast<IntegerType>(V->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="codeline">    assert(VTy->getBitWidth() == 8 && "Expected an i8 value for the byte");</td>
    <td class="lineNumber">2944</td>
    <td class="codeline">    assert(VTy->getBitWidth() == 8 && "Expected an i8 value for the byte");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="codeline">    if (Size == 1)</td>
    <td class="lineNumber">2945</td>
    <td class="codeline">    if (Size == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="codeline">      return V;</td>
    <td class="lineNumber">2946</td>
    <td class="codeline">      return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="codeline"></td>
    <td class="lineNumber">2947</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="codeline">    Type *SplatIntTy = Type::getIntNTy(VTy->getContext(), Size * 8);</td>
    <td class="lineNumber">2948</td>
    <td class="codeline">    Type *SplatIntTy = Type::getIntNTy(VTy->getContext(), Size * 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="codeline">    V = IRB.CreateMul(</td>
    <td class="lineNumber">2949</td>
    <td class="codeline">    V = IRB.CreateMul(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="codeline">        IRB.CreateZExt(V, SplatIntTy, "zext"),</td>
    <td class="lineNumber">2950</td>
    <td class="codeline">        IRB.CreateZExt(V, SplatIntTy, "zext"),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="codeline">        IRB.CreateUDiv(Constant::getAllOnesValue(SplatIntTy),</td>
    <td class="lineNumber">2951</td>
    <td class="codeline">        IRB.CreateUDiv(Constant::getAllOnesValue(SplatIntTy),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="codeline">                       IRB.CreateZExt(Constant::getAllOnesValue(V->getType()),</td>
    <td class="lineNumber">2952</td>
    <td class="codeline">                       IRB.CreateZExt(Constant::getAllOnesValue(V->getType()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="codeline">                                      SplatIntTy)),</td>
    <td class="lineNumber">2953</td>
    <td class="codeline">                                      SplatIntTy)),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="codeline">        "isplat");</td>
    <td class="lineNumber">2954</td>
    <td class="codeline">        "isplat");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">2955</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2956</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="codeline"></td>
    <td class="lineNumber">2957</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="codeline">  /// Compute a vector splat for a given element value.</td>
    <td class="lineNumber">2958</td>
    <td class="codeline">  /// Compute a vector splat for a given element value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="codeline">  Value *getVectorSplat(Value *V, unsigned NumElements) {</td>
    <td class="lineNumber">2959</td>
    <td class="codeline">  Value *getVectorSplat(Value *V, unsigned NumElements) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="codeline">    V = IRB.CreateVectorSplat(NumElements, V, "vsplat");</td>
    <td class="lineNumber">2960</td>
    <td class="codeline">    V = IRB.CreateVectorSplat(NumElements, V, "vsplat");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "       splat: " << *V << "\n");</td>
    <td class="lineNumber">2961</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "       splat: " << *V << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="codeline">    return V;</td>
    <td class="lineNumber">2962</td>
    <td class="codeline">    return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2963</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="codeline"></td>
    <td class="lineNumber">2964</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="codeline">  bool visitMemSetInst(MemSetInst &II) {</td>
    <td class="lineNumber">2965</td>
    <td class="codeline">  bool visitMemSetInst(MemSetInst &II) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
    <td class="lineNumber">2966</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="codeline">    assert(II.getRawDest() == OldPtr);</td>
    <td class="lineNumber">2967</td>
    <td class="codeline">    assert(II.getRawDest() == OldPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="codeline"></td>
    <td class="lineNumber">2968</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="codeline">    AAMDNodes AATags = II.getAAMetadata();</td>
    <td class="lineNumber">2969</td>
    <td class="codeline">    AAMDNodes AATags = II.getAAMetadata();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="codeline"></td>
    <td class="lineNumber">2970</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="codeline">    // If the memset has a variable size, it cannot be split, just adjust the</td>
    <td class="lineNumber">2971</td>
    <td class="codeline">    // If the memset has a variable size, it cannot be split, just adjust the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="codeline">    // pointer to the new alloca.</td>
    <td class="lineNumber">2972</td>
    <td class="codeline">    // pointer to the new alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="codeline">    if (!isa<ConstantInt>(II.getLength())) {</td>
    <td class="lineNumber">2973</td>
    <td class="codeline">    if (!isa<ConstantInt>(II.getLength())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="codeline">      assert(!IsSplit);</td>
    <td class="lineNumber">2974</td>
    <td class="codeline">      assert(!IsSplit);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="codeline">      assert(NewBeginOffset == BeginOffset);</td>
    <td class="lineNumber">2975</td>
    <td class="codeline">      assert(NewBeginOffset == BeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="codeline">      II.setDest(getNewAllocaSlicePtr(IRB, OldPtr->getType()));</td>
    <td class="lineNumber">2976</td>
    <td class="codeline">      II.setDest(getNewAllocaSlicePtr(IRB, OldPtr->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="codeline">      II.setDestAlignment(getSliceAlign());</td>
    <td class="lineNumber">2977</td>
    <td class="codeline">      II.setDestAlignment(getSliceAlign());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="codeline">      // In theory we should call migrateDebugInfo here. However, we do not</td>
    <td class="lineNumber">2978</td>
    <td class="codeline">      // In theory we should call migrateDebugInfo here. However, we do not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="codeline">      // emit dbg.assign intrinsics for mem intrinsics storing through non-</td>
    <td class="lineNumber">2979</td>
    <td class="codeline">      // emit dbg.assign intrinsics for mem intrinsics storing through non-</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="codeline">      // constant geps, or storing a variable number of bytes.</td>
    <td class="lineNumber">2980</td>
    <td class="codeline">      // constant geps, or storing a variable number of bytes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="codeline">      assert(at::getAssignmentMarkers(&II).empty() &&</td>
    <td class="lineNumber">2981</td>
    <td class="codeline">      assert(at::getAssignmentMarkers(&II).empty() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="codeline">             "AT: Unexpected link to non-const GEP");</td>
    <td class="lineNumber">2982</td>
    <td class="codeline">             "AT: Unexpected link to non-const GEP");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="codeline">      deleteIfTriviallyDead(OldPtr);</td>
    <td class="lineNumber">2983</td>
    <td class="codeline">      deleteIfTriviallyDead(OldPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">2984</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">2985</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="codeline"></td>
    <td class="lineNumber">2986</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="codeline">    // Record this instruction for deletion.</td>
    <td class="lineNumber">2987</td>
    <td class="codeline">    // Record this instruction for deletion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&II);</td>
    <td class="lineNumber">2988</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="codeline"></td>
    <td class="lineNumber">2989</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="codeline">    Type *AllocaTy = NewAI.getAllocatedType();</td>
    <td class="lineNumber">2990</td>
    <td class="codeline">    Type *AllocaTy = NewAI.getAllocatedType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="codeline">    Type *ScalarTy = AllocaTy->getScalarType();</td>
    <td class="lineNumber">2991</td>
    <td class="codeline">    Type *ScalarTy = AllocaTy->getScalarType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="codeline"></td>
    <td class="lineNumber">2992</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class="codeline">    const bool CanContinue = [&]() {</td>
    <td class="lineNumber">2993</td>
    <td class="codeline">    const bool CanContinue = [&]() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="codeline">      if (VecTy || IntTy)</td>
    <td class="lineNumber">2994</td>
    <td class="codeline">      if (VecTy || IntTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="codeline">        return true;</td>
    <td class="lineNumber">2995</td>
    <td class="codeline">        return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class="codeline">      if (BeginOffset > NewAllocaBeginOffset ||</td>
    <td class="lineNumber">2996</td>
    <td class="codeline">      if (BeginOffset > NewAllocaBeginOffset ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class="codeline">          EndOffset < NewAllocaEndOffset)</td>
    <td class="lineNumber">2997</td>
    <td class="codeline">          EndOffset < NewAllocaEndOffset)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">2998</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="codeline">      // Length must be in range for FixedVectorType.</td>
    <td class="lineNumber">2999</td>
    <td class="codeline">      // Length must be in range for FixedVectorType.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="codeline">      auto *C = cast<ConstantInt>(II.getLength());</td>
    <td class="lineNumber">3000</td>
    <td class="codeline">      auto *C = cast<ConstantInt>(II.getLength());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="codeline">      const uint64_t Len = C->getLimitedValue();</td>
    <td class="lineNumber">3001</td>
    <td class="codeline">      const uint64_t Len = C->getLimitedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="codeline">      if (Len > std::numeric_limits<unsigned>::max())</td>
    <td class="lineNumber">3002</td>
    <td class="codeline">      if (Len > std::numeric_limits<unsigned>::max())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="codeline">        return false;</td>
    <td class="lineNumber">3003</td>
    <td class="codeline">        return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="codeline">      auto *Int8Ty = IntegerType::getInt8Ty(NewAI.getContext());</td>
    <td class="lineNumber">3004</td>
    <td class="codeline">      auto *Int8Ty = IntegerType::getInt8Ty(NewAI.getContext());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="codeline">      auto *SrcTy = FixedVectorType::get(Int8Ty, Len);</td>
    <td class="lineNumber">3005</td>
    <td class="codeline">      auto *SrcTy = FixedVectorType::get(Int8Ty, Len);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="codeline">      return canConvertValue(DL, SrcTy, AllocaTy) &&</td>
    <td class="lineNumber">3006</td>
    <td class="codeline">      return canConvertValue(DL, SrcTy, AllocaTy) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="codeline">             DL.isLegalInteger(DL.getTypeSizeInBits(ScalarTy).getFixedValue());</td>
    <td class="lineNumber">3007</td>
    <td class="codeline">             DL.isLegalInteger(DL.getTypeSizeInBits(ScalarTy).getFixedValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="codeline">    }();</td>
    <td class="lineNumber">3008</td>
    <td class="codeline">    }();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="codeline"></td>
    <td class="lineNumber">3009</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="codeline">    // If this doesn't map cleanly onto the alloca type, and that type isn't</td>
    <td class="lineNumber">3010</td>
    <td class="codeline">    // If this doesn't map cleanly onto the alloca type, and that type isn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="codeline">    // a single value type, just emit a memset.</td>
    <td class="lineNumber">3011</td>
    <td class="codeline">    // a single value type, just emit a memset.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="codeline">    if (!CanContinue) {</td>
    <td class="lineNumber">3012</td>
    <td class="codeline">    if (!CanContinue) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class="codeline">      Type *SizeTy = II.getLength()->getType();</td>
    <td class="lineNumber">3013</td>
    <td class="codeline">      Type *SizeTy = II.getLength()->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="codeline">      Constant *Size = ConstantInt::get(SizeTy, NewEndOffset - NewBeginOffset);</td>
    <td class="lineNumber">3014</td>
    <td class="codeline">      Constant *Size = ConstantInt::get(SizeTy, NewEndOffset - NewBeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="codeline">      MemIntrinsic *New = cast<MemIntrinsic>(IRB.CreateMemSet(</td>
    <td class="lineNumber">3015</td>
    <td class="codeline">      MemIntrinsic *New = cast<MemIntrinsic>(IRB.CreateMemSet(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="codeline">          getNewAllocaSlicePtr(IRB, OldPtr->getType()), II.getValue(), Size,</td>
    <td class="lineNumber">3016</td>
    <td class="codeline">          getNewAllocaSlicePtr(IRB, OldPtr->getType()), II.getValue(), Size,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="codeline">          MaybeAlign(getSliceAlign()), II.isVolatile()));</td>
    <td class="lineNumber">3017</td>
    <td class="codeline">          MaybeAlign(getSliceAlign()), II.isVolatile()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="codeline">      if (AATags)</td>
    <td class="lineNumber">3018</td>
    <td class="codeline">      if (AATags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="codeline">        New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">3019</td>
    <td class="codeline">        New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="codeline"></td>
    <td class="lineNumber">3020</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="codeline">      migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
    <td class="lineNumber">3021</td>
    <td class="codeline">      migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="codeline">                       New, New->getRawDest(), nullptr, DL);</td>
    <td class="lineNumber">3022</td>
    <td class="codeline">                       New, New->getRawDest(), nullptr, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class="codeline"></td>
    <td class="lineNumber">3023</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td class="lineNumber">3024</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3025</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3026</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class="codeline"></td>
    <td class="lineNumber">3027</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="codeline">    // If we can represent this as a simple value, we have to build the actual</td>
    <td class="lineNumber">3028</td>
    <td class="codeline">    // If we can represent this as a simple value, we have to build the actual</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="codeline">    // value to store, which requires expanding the byte present in memset to</td>
    <td class="lineNumber">3029</td>
    <td class="codeline">    // value to store, which requires expanding the byte present in memset to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="codeline">    // a sensible representation for the alloca type. This is essentially</td>
    <td class="lineNumber">3030</td>
    <td class="codeline">    // a sensible representation for the alloca type. This is essentially</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="codeline">    // splatting the byte to a sufficiently wide integer, splatting it across</td>
    <td class="lineNumber">3031</td>
    <td class="codeline">    // splatting the byte to a sufficiently wide integer, splatting it across</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="codeline">    // any desired vector width, and bitcasting to the final type.</td>
    <td class="lineNumber">3032</td>
    <td class="codeline">    // any desired vector width, and bitcasting to the final type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="codeline">    Value *V;</td>
    <td class="lineNumber">3033</td>
    <td class="codeline">    Value *V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class="codeline"></td>
    <td class="lineNumber">3034</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="codeline">    if (VecTy) {</td>
    <td class="lineNumber">3035</td>
    <td class="codeline">    if (VecTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="codeline">      // If this is a memset of a vectorized alloca, insert it.</td>
    <td class="lineNumber">3036</td>
    <td class="codeline">      // If this is a memset of a vectorized alloca, insert it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="codeline">      assert(ElementTy == ScalarTy);</td>
    <td class="lineNumber">3037</td>
    <td class="codeline">      assert(ElementTy == ScalarTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="codeline"></td>
    <td class="lineNumber">3038</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="codeline">      unsigned BeginIndex = getIndex(NewBeginOffset);</td>
    <td class="lineNumber">3039</td>
    <td class="codeline">      unsigned BeginIndex = getIndex(NewBeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="codeline">      unsigned EndIndex = getIndex(NewEndOffset);</td>
    <td class="lineNumber">3040</td>
    <td class="codeline">      unsigned EndIndex = getIndex(NewEndOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class="codeline">      assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td class="lineNumber">3041</td>
    <td class="codeline">      assert(EndIndex > BeginIndex && "Empty vector!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="codeline">      unsigned NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">3042</td>
    <td class="codeline">      unsigned NumElements = EndIndex - BeginIndex;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="codeline">      assert(NumElements <= cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
    <td class="lineNumber">3043</td>
    <td class="codeline">      assert(NumElements <= cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="codeline">             "Too many elements!");</td>
    <td class="lineNumber">3044</td>
    <td class="codeline">             "Too many elements!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="codeline"></td>
    <td class="lineNumber">3045</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="codeline">      Value *Splat = getIntegerSplat(</td>
    <td class="lineNumber">3046</td>
    <td class="codeline">      Value *Splat = getIntegerSplat(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="codeline">          II.getValue(), DL.getTypeSizeInBits(ElementTy).getFixedValue() / 8);</td>
    <td class="lineNumber">3047</td>
    <td class="codeline">          II.getValue(), DL.getTypeSizeInBits(ElementTy).getFixedValue() / 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="codeline">      Splat = convertValue(DL, IRB, Splat, ElementTy);</td>
    <td class="lineNumber">3048</td>
    <td class="codeline">      Splat = convertValue(DL, IRB, Splat, ElementTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="codeline">      if (NumElements > 1)</td>
    <td class="lineNumber">3049</td>
    <td class="codeline">      if (NumElements > 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="codeline">        Splat = getVectorSplat(Splat, NumElements);</td>
    <td class="lineNumber">3050</td>
    <td class="codeline">        Splat = getVectorSplat(Splat, NumElements);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class="codeline"></td>
    <td class="lineNumber">3051</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="codeline">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">3052</td>
    <td class="codeline">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class="codeline">                                         NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">3053</td>
    <td class="codeline">                                         NewAI.getAlign(), "oldload");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="codeline">      V = insertVector(IRB, Old, Splat, BeginIndex, "vec");</td>
    <td class="lineNumber">3054</td>
    <td class="codeline">      V = insertVector(IRB, Old, Splat, BeginIndex, "vec");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="codeline">    } else if (IntTy) {</td>
    <td class="lineNumber">3055</td>
    <td class="codeline">    } else if (IntTy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="codeline">      // If this is a memset on an alloca where we can widen stores, insert the</td>
    <td class="lineNumber">3056</td>
    <td class="codeline">      // If this is a memset on an alloca where we can widen stores, insert the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="codeline">      // set integer.</td>
    <td class="lineNumber">3057</td>
    <td class="codeline">      // set integer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="codeline">      assert(!II.isVolatile());</td>
    <td class="lineNumber">3058</td>
    <td class="codeline">      assert(!II.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class="codeline"></td>
    <td class="lineNumber">3059</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="codeline">      uint64_t Size = NewEndOffset - NewBeginOffset;</td>
    <td class="lineNumber">3060</td>
    <td class="codeline">      uint64_t Size = NewEndOffset - NewBeginOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="codeline">      V = getIntegerSplat(II.getValue(), Size);</td>
    <td class="lineNumber">3061</td>
    <td class="codeline">      V = getIntegerSplat(II.getValue(), Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class="codeline"></td>
    <td class="lineNumber">3062</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="codeline">      if (IntTy && (BeginOffset != NewAllocaBeginOffset ||</td>
    <td class="lineNumber">3063</td>
    <td class="codeline">      if (IntTy && (BeginOffset != NewAllocaBeginOffset ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="codeline">                    EndOffset != NewAllocaBeginOffset)) {</td>
    <td class="lineNumber">3064</td>
    <td class="codeline">                    EndOffset != NewAllocaBeginOffset)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="codeline">        Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">3065</td>
    <td class="codeline">        Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="codeline">                                           NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">3066</td>
    <td class="codeline">                                           NewAI.getAlign(), "oldload");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="codeline">        Old = convertValue(DL, IRB, Old, IntTy);</td>
    <td class="lineNumber">3067</td>
    <td class="codeline">        Old = convertValue(DL, IRB, Old, IntTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="codeline">        uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">3068</td>
    <td class="codeline">        uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="codeline">        V = insertInteger(DL, IRB, Old, V, Offset, "insert");</td>
    <td class="lineNumber">3069</td>
    <td class="codeline">        V = insertInteger(DL, IRB, Old, V, Offset, "insert");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">3070</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="codeline">        assert(V->getType() == IntTy &&</td>
    <td class="lineNumber">3071</td>
    <td class="codeline">        assert(V->getType() == IntTy &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="codeline">               "Wrong type for an alloca wide integer!");</td>
    <td class="lineNumber">3072</td>
    <td class="codeline">               "Wrong type for an alloca wide integer!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3073</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="codeline">      V = convertValue(DL, IRB, V, AllocaTy);</td>
    <td class="lineNumber">3074</td>
    <td class="codeline">      V = convertValue(DL, IRB, V, AllocaTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">3075</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="codeline">      // Established these invariants above.</td>
    <td class="lineNumber">3076</td>
    <td class="codeline">      // Established these invariants above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="codeline">      assert(NewBeginOffset == NewAllocaBeginOffset);</td>
    <td class="lineNumber">3077</td>
    <td class="codeline">      assert(NewBeginOffset == NewAllocaBeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="codeline">      assert(NewEndOffset == NewAllocaEndOffset);</td>
    <td class="lineNumber">3078</td>
    <td class="codeline">      assert(NewEndOffset == NewAllocaEndOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class="codeline"></td>
    <td class="lineNumber">3079</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3080</td>
    <td class="codeline">      V = getIntegerSplat(II.getValue(),</td>
    <td class="lineNumber">3080</td>
    <td class="codeline">      V = getIntegerSplat(II.getValue(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3081</td>
    <td class="codeline">                          DL.getTypeSizeInBits(ScalarTy).getFixedValue() / 8);</td>
    <td class="lineNumber">3081</td>
    <td class="codeline">                          DL.getTypeSizeInBits(ScalarTy).getFixedValue() / 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3082</td>
    <td class="codeline">      if (VectorType *AllocaVecTy = dyn_cast<VectorType>(AllocaTy))</td>
    <td class="lineNumber">3082</td>
    <td class="codeline">      if (VectorType *AllocaVecTy = dyn_cast<VectorType>(AllocaTy))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3083</td>
    <td class="codeline">        V = getVectorSplat(</td>
    <td class="lineNumber">3083</td>
    <td class="codeline">        V = getVectorSplat(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3084</td>
    <td class="codeline">            V, cast<FixedVectorType>(AllocaVecTy)->getNumElements());</td>
    <td class="lineNumber">3084</td>
    <td class="codeline">            V, cast<FixedVectorType>(AllocaVecTy)->getNumElements());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3085</td>
    <td class="codeline"></td>
    <td class="lineNumber">3085</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3086</td>
    <td class="codeline">      V = convertValue(DL, IRB, V, AllocaTy);</td>
    <td class="lineNumber">3086</td>
    <td class="codeline">      V = convertValue(DL, IRB, V, AllocaTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3087</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3087</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3088</td>
    <td class="codeline"></td>
    <td class="lineNumber">3088</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3089</td>
    <td class="codeline">    Value *NewPtr = getPtrToNewAI(II.getDestAddressSpace(), II.isVolatile());</td>
    <td class="lineNumber">3089</td>
    <td class="codeline">    Value *NewPtr = getPtrToNewAI(II.getDestAddressSpace(), II.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3090</td>
    <td class="codeline">    StoreInst *New =</td>
    <td class="lineNumber">3090</td>
    <td class="codeline">    StoreInst *New =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3091</td>
    <td class="codeline">        IRB.CreateAlignedStore(V, NewPtr, NewAI.getAlign(), II.isVolatile());</td>
    <td class="lineNumber">3091</td>
    <td class="codeline">        IRB.CreateAlignedStore(V, NewPtr, NewAI.getAlign(), II.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3092</td>
    <td class="codeline">    New->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">3092</td>
    <td class="codeline">    New->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3093</td>
    <td class="codeline">                           LLVMContext::MD_access_group});</td>
    <td class="lineNumber">3093</td>
    <td class="codeline">                           LLVMContext::MD_access_group});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3094</td>
    <td class="codeline">    if (AATags)</td>
    <td class="lineNumber">3094</td>
    <td class="codeline">    if (AATags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3095</td>
    <td class="codeline">      New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">3095</td>
    <td class="codeline">      New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3096</td>
    <td class="codeline"></td>
    <td class="lineNumber">3096</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3097</td>
    <td class="codeline">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
    <td class="lineNumber">3097</td>
    <td class="codeline">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3098</td>
    <td class="codeline">                     New, New->getPointerOperand(), V, DL);</td>
    <td class="lineNumber">3098</td>
    <td class="codeline">                     New, New->getPointerOperand(), V, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3099</td>
    <td class="codeline"></td>
    <td class="lineNumber">3099</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3100</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td class="lineNumber">3100</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3101</td>
    <td class="codeline">    return !II.isVolatile();</td>
    <td class="lineNumber">3101</td>
    <td class="codeline">    return !II.isVolatile();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3102</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3102</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3103</td>
    <td class="codeline"></td>
    <td class="lineNumber">3103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3104</td>
    <td class="codeline">  bool visitMemTransferInst(MemTransferInst &II) {</td>
    <td class="lineNumber">3104</td>
    <td class="codeline">  bool visitMemTransferInst(MemTransferInst &II) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3105</td>
    <td class="codeline">    // Rewriting of memory transfer instructions can be a bit tricky. We break</td>
    <td class="lineNumber">3105</td>
    <td class="codeline">    // Rewriting of memory transfer instructions can be a bit tricky. We break</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3106</td>
    <td class="codeline">    // them into two categories: split intrinsics and unsplit intrinsics.</td>
    <td class="lineNumber">3106</td>
    <td class="codeline">    // them into two categories: split intrinsics and unsplit intrinsics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3107</td>
    <td class="codeline"></td>
    <td class="lineNumber">3107</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3108</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
    <td class="lineNumber">3108</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3109</td>
    <td class="codeline"></td>
    <td class="lineNumber">3109</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3110</td>
    <td class="codeline">    AAMDNodes AATags = II.getAAMetadata();</td>
    <td class="lineNumber">3110</td>
    <td class="codeline">    AAMDNodes AATags = II.getAAMetadata();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3111</td>
    <td class="codeline"></td>
    <td class="lineNumber">3111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3112</td>
    <td class="codeline">    bool IsDest = &II.getRawDestUse() == OldUse;</td>
    <td class="lineNumber">3112</td>
    <td class="codeline">    bool IsDest = &II.getRawDestUse() == OldUse;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3113</td>
    <td class="codeline">    assert((IsDest && II.getRawDest() == OldPtr) ||</td>
    <td class="lineNumber">3113</td>
    <td class="codeline">    assert((IsDest && II.getRawDest() == OldPtr) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3114</td>
    <td class="codeline">           (!IsDest && II.getRawSource() == OldPtr));</td>
    <td class="lineNumber">3114</td>
    <td class="codeline">           (!IsDest && II.getRawSource() == OldPtr));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3115</td>
    <td class="codeline"></td>
    <td class="lineNumber">3115</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3116</td>
    <td class="codeline">    Align SliceAlign = getSliceAlign();</td>
    <td class="lineNumber">3116</td>
    <td class="codeline">    Align SliceAlign = getSliceAlign();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3117</td>
    <td class="codeline">    // For unsplit intrinsics, we simply modify the source and destination</td>
    <td class="lineNumber">3117</td>
    <td class="codeline">    // For unsplit intrinsics, we simply modify the source and destination</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3118</td>
    <td class="codeline">    // pointers in place. This isn't just an optimization, it is a matter of</td>
    <td class="lineNumber">3118</td>
    <td class="codeline">    // pointers in place. This isn't just an optimization, it is a matter of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3119</td>
    <td class="codeline">    // correctness. With unsplit intrinsics we may be dealing with transfers</td>
    <td class="lineNumber">3119</td>
    <td class="codeline">    // correctness. With unsplit intrinsics we may be dealing with transfers</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3120</td>
    <td class="codeline">    // within a single alloca before SROA ran, or with transfers that have</td>
    <td class="lineNumber">3120</td>
    <td class="codeline">    // within a single alloca before SROA ran, or with transfers that have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3121</td>
    <td class="codeline">    // a variable length. We may also be dealing with memmove instead of</td>
    <td class="lineNumber">3121</td>
    <td class="codeline">    // a variable length. We may also be dealing with memmove instead of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3122</td>
    <td class="codeline">    // memcpy, and so simply updating the pointers is the necessary for us to</td>
    <td class="lineNumber">3122</td>
    <td class="codeline">    // memcpy, and so simply updating the pointers is the necessary for us to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3123</td>
    <td class="codeline">    // update both source and dest of a single call.</td>
    <td class="lineNumber">3123</td>
    <td class="codeline">    // update both source and dest of a single call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3124</td>
    <td class="codeline">    if (!IsSplittable) {</td>
    <td class="lineNumber">3124</td>
    <td class="codeline">    if (!IsSplittable) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3125</td>
    <td class="codeline">      Value *AdjustedPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td class="lineNumber">3125</td>
    <td class="codeline">      Value *AdjustedPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3126</td>
    <td class="codeline">      if (IsDest) {</td>
    <td class="lineNumber">3126</td>
    <td class="codeline">      if (IsDest) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3127</td>
    <td class="codeline">        // Update the address component of linked dbg.assigns.</td>
    <td class="lineNumber">3127</td>
    <td class="codeline">        // Update the address component of linked dbg.assigns.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3128</td>
    <td class="codeline">        for (auto *DAI : at::getAssignmentMarkers(&II)) {</td>
    <td class="lineNumber">3128</td>
    <td class="codeline">        for (auto *DAI : at::getAssignmentMarkers(&II)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3129</td>
    <td class="codeline">          if (any_of(DAI->location_ops(),</td>
    <td class="lineNumber">3129</td>
    <td class="codeline">          if (any_of(DAI->location_ops(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3130</td>
    <td class="codeline">                     [&](Value *V) { return V == II.getDest(); }) ||</td>
    <td class="lineNumber">3130</td>
    <td class="codeline">                     [&](Value *V) { return V == II.getDest(); }) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3131</td>
    <td class="codeline">              DAI->getAddress() == II.getDest())</td>
    <td class="lineNumber">3131</td>
    <td class="codeline">              DAI->getAddress() == II.getDest())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3132</td>
    <td class="codeline">            DAI->replaceVariableLocationOp(II.getDest(), AdjustedPtr);</td>
    <td class="lineNumber">3132</td>
    <td class="codeline">            DAI->replaceVariableLocationOp(II.getDest(), AdjustedPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3133</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">3133</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3134</td>
    <td class="codeline">        II.setDest(AdjustedPtr);</td>
    <td class="lineNumber">3134</td>
    <td class="codeline">        II.setDest(AdjustedPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3135</td>
    <td class="codeline">        II.setDestAlignment(SliceAlign);</td>
    <td class="lineNumber">3135</td>
    <td class="codeline">        II.setDestAlignment(SliceAlign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3136</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">3136</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3137</td>
    <td class="codeline">        II.setSource(AdjustedPtr);</td>
    <td class="lineNumber">3137</td>
    <td class="codeline">        II.setSource(AdjustedPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3138</td>
    <td class="codeline">        II.setSourceAlignment(SliceAlign);</td>
    <td class="lineNumber">3138</td>
    <td class="codeline">        II.setSourceAlignment(SliceAlign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3139</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3139</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3140</td>
    <td class="codeline"></td>
    <td class="lineNumber">3140</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3141</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "          to: " << II << "\n");</td>
    <td class="lineNumber">3141</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "          to: " << II << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3142</td>
    <td class="codeline">      deleteIfTriviallyDead(OldPtr);</td>
    <td class="lineNumber">3142</td>
    <td class="codeline">      deleteIfTriviallyDead(OldPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3143</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3143</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3144</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3144</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3145</td>
    <td class="codeline">    // For split transfer intrinsics we have an incredibly useful assurance:</td>
    <td class="lineNumber">3145</td>
    <td class="codeline">    // For split transfer intrinsics we have an incredibly useful assurance:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3146</td>
    <td class="codeline">    // the source and destination do not reside within the same alloca, and at</td>
    <td class="lineNumber">3146</td>
    <td class="codeline">    // the source and destination do not reside within the same alloca, and at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3147</td>
    <td class="codeline">    // least one of them does not escape. This means that we can replace</td>
    <td class="lineNumber">3147</td>
    <td class="codeline">    // least one of them does not escape. This means that we can replace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3148</td>
    <td class="codeline">    // memmove with memcpy, and we don't need to worry about all manner of</td>
    <td class="lineNumber">3148</td>
    <td class="codeline">    // memmove with memcpy, and we don't need to worry about all manner of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3149</td>
    <td class="codeline">    // downsides to splitting and transforming the operations.</td>
    <td class="lineNumber">3149</td>
    <td class="codeline">    // downsides to splitting and transforming the operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3150</td>
    <td class="codeline"></td>
    <td class="lineNumber">3150</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3151</td>
    <td class="codeline">    // If this doesn't map cleanly onto the alloca type, and that type isn't</td>
    <td class="lineNumber">3151</td>
    <td class="codeline">    // If this doesn't map cleanly onto the alloca type, and that type isn't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3152</td>
    <td class="codeline">    // a single value type, just emit a memcpy.</td>
    <td class="lineNumber">3152</td>
    <td class="codeline">    // a single value type, just emit a memcpy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3153</td>
    <td class="codeline">    bool EmitMemCpy =</td>
    <td class="lineNumber">3153</td>
    <td class="codeline">    bool EmitMemCpy =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3154</td>
    <td class="codeline">        !VecTy && !IntTy &&</td>
    <td class="lineNumber">3154</td>
    <td class="codeline">        !VecTy && !IntTy &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3155</td>
    <td class="codeline">        (BeginOffset > NewAllocaBeginOffset || EndOffset < NewAllocaEndOffset ||</td>
    <td class="lineNumber">3155</td>
    <td class="codeline">        (BeginOffset > NewAllocaBeginOffset || EndOffset < NewAllocaEndOffset ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3156</td>
    <td class="codeline">         SliceSize !=</td>
    <td class="lineNumber">3156</td>
    <td class="codeline">         SliceSize !=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3157</td>
    <td class="codeline">             DL.getTypeStoreSize(NewAI.getAllocatedType()).getFixedValue() ||</td>
    <td class="lineNumber">3157</td>
    <td class="codeline">             DL.getTypeStoreSize(NewAI.getAllocatedType()).getFixedValue() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3158</td>
    <td class="codeline">         !NewAI.getAllocatedType()->isSingleValueType());</td>
    <td class="lineNumber">3158</td>
    <td class="codeline">         !NewAI.getAllocatedType()->isSingleValueType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3159</td>
    <td class="codeline"></td>
    <td class="lineNumber">3159</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3160</td>
    <td class="codeline">    // If we're just going to emit a memcpy, the alloca hasn't changed, and the</td>
    <td class="lineNumber">3160</td>
    <td class="codeline">    // If we're just going to emit a memcpy, the alloca hasn't changed, and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3161</td>
    <td class="codeline">    // size hasn't been shrunk based on analysis of the viable range, this is</td>
    <td class="lineNumber">3161</td>
    <td class="codeline">    // size hasn't been shrunk based on analysis of the viable range, this is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3162</td>
    <td class="codeline">    // a no-op.</td>
    <td class="lineNumber">3162</td>
    <td class="codeline">    // a no-op.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3163</td>
    <td class="codeline">    if (EmitMemCpy && &OldAI == &NewAI) {</td>
    <td class="lineNumber">3163</td>
    <td class="codeline">    if (EmitMemCpy && &OldAI == &NewAI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3164</td>
    <td class="codeline">      // Ensure the start lines up.</td>
    <td class="lineNumber">3164</td>
    <td class="codeline">      // Ensure the start lines up.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3165</td>
    <td class="codeline">      assert(NewBeginOffset == BeginOffset);</td>
    <td class="lineNumber">3165</td>
    <td class="codeline">      assert(NewBeginOffset == BeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3166</td>
    <td class="codeline"></td>
    <td class="lineNumber">3166</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3167</td>
    <td class="codeline">      // Rewrite the size as needed.</td>
    <td class="lineNumber">3167</td>
    <td class="codeline">      // Rewrite the size as needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3168</td>
    <td class="codeline">      if (NewEndOffset != EndOffset)</td>
    <td class="lineNumber">3168</td>
    <td class="codeline">      if (NewEndOffset != EndOffset)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3169</td>
    <td class="codeline">        II.setLength(ConstantInt::get(II.getLength()->getType(),</td>
    <td class="lineNumber">3169</td>
    <td class="codeline">        II.setLength(ConstantInt::get(II.getLength()->getType(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3170</td>
    <td class="codeline">                                      NewEndOffset - NewBeginOffset));</td>
    <td class="lineNumber">3170</td>
    <td class="codeline">                                      NewEndOffset - NewBeginOffset));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3171</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3171</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3172</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3172</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3173</td>
    <td class="codeline">    // Record this instruction for deletion.</td>
    <td class="lineNumber">3173</td>
    <td class="codeline">    // Record this instruction for deletion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3174</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&II);</td>
    <td class="lineNumber">3174</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3175</td>
    <td class="codeline"></td>
    <td class="lineNumber">3175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3176</td>
    <td class="codeline">    // Strip all inbounds GEPs and pointer casts to try to dig out any root</td>
    <td class="lineNumber">3176</td>
    <td class="codeline">    // Strip all inbounds GEPs and pointer casts to try to dig out any root</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3177</td>
    <td class="codeline">    // alloca that should be re-examined after rewriting this instruction.</td>
    <td class="lineNumber">3177</td>
    <td class="codeline">    // alloca that should be re-examined after rewriting this instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3178</td>
    <td class="codeline">    Value *OtherPtr = IsDest ? II.getRawSource() : II.getRawDest();</td>
    <td class="lineNumber">3178</td>
    <td class="codeline">    Value *OtherPtr = IsDest ? II.getRawSource() : II.getRawDest();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3179</td>
    <td class="codeline">    if (AllocaInst *AI =</td>
    <td class="lineNumber">3179</td>
    <td class="codeline">    if (AllocaInst *AI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3180</td>
    <td class="codeline">            dyn_cast<AllocaInst>(OtherPtr->stripInBoundsOffsets())) {</td>
    <td class="lineNumber">3180</td>
    <td class="codeline">            dyn_cast<AllocaInst>(OtherPtr->stripInBoundsOffsets())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3181</td>
    <td class="codeline">      assert(AI != &OldAI && AI != &NewAI &&</td>
    <td class="lineNumber">3181</td>
    <td class="codeline">      assert(AI != &OldAI && AI != &NewAI &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3182</td>
    <td class="codeline">             "Splittable transfers cannot reach the same alloca on both ends.");</td>
    <td class="lineNumber">3182</td>
    <td class="codeline">             "Splittable transfers cannot reach the same alloca on both ends.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3183</td>
    <td class="codeline">      Pass.Worklist.insert(AI);</td>
    <td class="lineNumber">3183</td>
    <td class="codeline">      Pass.Worklist.insert(AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3184</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3184</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3185</td>
    <td class="codeline"></td>
    <td class="lineNumber">3185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3186</td>
    <td class="codeline">    Type *OtherPtrTy = OtherPtr->getType();</td>
    <td class="lineNumber">3186</td>
    <td class="codeline">    Type *OtherPtrTy = OtherPtr->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3187</td>
    <td class="codeline">    unsigned OtherAS = OtherPtrTy->getPointerAddressSpace();</td>
    <td class="lineNumber">3187</td>
    <td class="codeline">    unsigned OtherAS = OtherPtrTy->getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3188</td>
    <td class="codeline"></td>
    <td class="lineNumber">3188</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3189</td>
    <td class="codeline">    // Compute the relative offset for the other pointer within the transfer.</td>
    <td class="lineNumber">3189</td>
    <td class="codeline">    // Compute the relative offset for the other pointer within the transfer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3190</td>
    <td class="codeline">    unsigned OffsetWidth = DL.getIndexSizeInBits(OtherAS);</td>
    <td class="lineNumber">3190</td>
    <td class="codeline">    unsigned OffsetWidth = DL.getIndexSizeInBits(OtherAS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3191</td>
    <td class="codeline">    APInt OtherOffset(OffsetWidth, NewBeginOffset - BeginOffset);</td>
    <td class="lineNumber">3191</td>
    <td class="codeline">    APInt OtherOffset(OffsetWidth, NewBeginOffset - BeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3192</td>
    <td class="codeline">    Align OtherAlign =</td>
    <td class="lineNumber">3192</td>
    <td class="codeline">    Align OtherAlign =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3193</td>
    <td class="codeline">        (IsDest ? II.getSourceAlign() : II.getDestAlign()).valueOrOne();</td>
    <td class="lineNumber">3193</td>
    <td class="codeline">        (IsDest ? II.getSourceAlign() : II.getDestAlign()).valueOrOne();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3194</td>
    <td class="codeline">    OtherAlign =</td>
    <td class="lineNumber">3194</td>
    <td class="codeline">    OtherAlign =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3195</td>
    <td class="codeline">        commonAlignment(OtherAlign, OtherOffset.zextOrTrunc(64).getZExtValue());</td>
    <td class="lineNumber">3195</td>
    <td class="codeline">        commonAlignment(OtherAlign, OtherOffset.zextOrTrunc(64).getZExtValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3196</td>
    <td class="codeline"></td>
    <td class="lineNumber">3196</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3197</td>
    <td class="codeline">    if (EmitMemCpy) {</td>
    <td class="lineNumber">3197</td>
    <td class="codeline">    if (EmitMemCpy) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3198</td>
    <td class="codeline">      // Compute the other pointer, folding as much as possible to produce</td>
    <td class="lineNumber">3198</td>
    <td class="codeline">      // Compute the other pointer, folding as much as possible to produce</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3199</td>
    <td class="codeline">      // a single, simple GEP in most cases.</td>
    <td class="lineNumber">3199</td>
    <td class="codeline">      // a single, simple GEP in most cases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3200</td>
    <td class="codeline">      OtherPtr = getAdjustedPtr(IRB, DL, OtherPtr, OtherOffset, OtherPtrTy,</td>
    <td class="lineNumber">3200</td>
    <td class="codeline">      OtherPtr = getAdjustedPtr(IRB, DL, OtherPtr, OtherOffset, OtherPtrTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3201</td>
    <td class="codeline">                                OtherPtr->getName() + ".");</td>
    <td class="lineNumber">3201</td>
    <td class="codeline">                                OtherPtr->getName() + ".");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3202</td>
    <td class="codeline"></td>
    <td class="lineNumber">3202</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3203</td>
    <td class="codeline">      Value *OurPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td class="lineNumber">3203</td>
    <td class="codeline">      Value *OurPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3204</td>
    <td class="codeline">      Type *SizeTy = II.getLength()->getType();</td>
    <td class="lineNumber">3204</td>
    <td class="codeline">      Type *SizeTy = II.getLength()->getType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3205</td>
    <td class="codeline">      Constant *Size = ConstantInt::get(SizeTy, NewEndOffset - NewBeginOffset);</td>
    <td class="lineNumber">3205</td>
    <td class="codeline">      Constant *Size = ConstantInt::get(SizeTy, NewEndOffset - NewBeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3206</td>
    <td class="codeline"></td>
    <td class="lineNumber">3206</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3207</td>
    <td class="codeline">      Value *DestPtr, *SrcPtr;</td>
    <td class="lineNumber">3207</td>
    <td class="codeline">      Value *DestPtr, *SrcPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3208</td>
    <td class="codeline">      MaybeAlign DestAlign, SrcAlign;</td>
    <td class="lineNumber">3208</td>
    <td class="codeline">      MaybeAlign DestAlign, SrcAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3209</td>
    <td class="codeline">      // Note: IsDest is true iff we're copying into the new alloca slice</td>
    <td class="lineNumber">3209</td>
    <td class="codeline">      // Note: IsDest is true iff we're copying into the new alloca slice</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3210</td>
    <td class="codeline">      if (IsDest) {</td>
    <td class="lineNumber">3210</td>
    <td class="codeline">      if (IsDest) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3211</td>
    <td class="codeline">        DestPtr = OurPtr;</td>
    <td class="lineNumber">3211</td>
    <td class="codeline">        DestPtr = OurPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3212</td>
    <td class="codeline">        DestAlign = SliceAlign;</td>
    <td class="lineNumber">3212</td>
    <td class="codeline">        DestAlign = SliceAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3213</td>
    <td class="codeline">        SrcPtr = OtherPtr;</td>
    <td class="lineNumber">3213</td>
    <td class="codeline">        SrcPtr = OtherPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3214</td>
    <td class="codeline">        SrcAlign = OtherAlign;</td>
    <td class="lineNumber">3214</td>
    <td class="codeline">        SrcAlign = OtherAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3215</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">3215</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3216</td>
    <td class="codeline">        DestPtr = OtherPtr;</td>
    <td class="lineNumber">3216</td>
    <td class="codeline">        DestPtr = OtherPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3217</td>
    <td class="codeline">        DestAlign = OtherAlign;</td>
    <td class="lineNumber">3217</td>
    <td class="codeline">        DestAlign = OtherAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3218</td>
    <td class="codeline">        SrcPtr = OurPtr;</td>
    <td class="lineNumber">3218</td>
    <td class="codeline">        SrcPtr = OurPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3219</td>
    <td class="codeline">        SrcAlign = SliceAlign;</td>
    <td class="lineNumber">3219</td>
    <td class="codeline">        SrcAlign = SliceAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3220</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3220</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3221</td>
    <td class="codeline">      CallInst *New = IRB.CreateMemCpy(DestPtr, DestAlign, SrcPtr, SrcAlign,</td>
    <td class="lineNumber">3221</td>
    <td class="codeline">      CallInst *New = IRB.CreateMemCpy(DestPtr, DestAlign, SrcPtr, SrcAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3222</td>
    <td class="codeline">                                       Size, II.isVolatile());</td>
    <td class="lineNumber">3222</td>
    <td class="codeline">                                       Size, II.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3223</td>
    <td class="codeline">      if (AATags)</td>
    <td class="lineNumber">3223</td>
    <td class="codeline">      if (AATags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3224</td>
    <td class="codeline">        New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">3224</td>
    <td class="codeline">        New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3225</td>
    <td class="codeline"></td>
    <td class="lineNumber">3225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3226</td>
    <td class="codeline">      APInt Offset(DL.getIndexTypeSizeInBits(DestPtr->getType()), 0);</td>
    <td class="lineNumber">3226</td>
    <td class="codeline">      APInt Offset(DL.getIndexTypeSizeInBits(DestPtr->getType()), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3227</td>
    <td class="codeline">      if (IsDest) {</td>
    <td class="lineNumber">3227</td>
    <td class="codeline">      if (IsDest) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3228</td>
    <td class="codeline">        migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8,</td>
    <td class="lineNumber">3228</td>
    <td class="codeline">        migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3229</td>
    <td class="codeline">                         &II, New, DestPtr, nullptr, DL);</td>
    <td class="lineNumber">3229</td>
    <td class="codeline">                         &II, New, DestPtr, nullptr, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3230</td>
    <td class="codeline">      } else if (AllocaInst *Base = dyn_cast<AllocaInst>(</td>
    <td class="lineNumber">3230</td>
    <td class="codeline">      } else if (AllocaInst *Base = dyn_cast<AllocaInst>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3231</td>
    <td class="codeline">                     DestPtr->stripAndAccumulateConstantOffsets(</td>
    <td class="lineNumber">3231</td>
    <td class="codeline">                     DestPtr->stripAndAccumulateConstantOffsets(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3232</td>
    <td class="codeline">                         DL, Offset, /*AllowNonInbounds*/ true))) {</td>
    <td class="lineNumber">3232</td>
    <td class="codeline">                         DL, Offset, /*AllowNonInbounds*/ true))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3233</td>
    <td class="codeline">        migrateDebugInfo(Base, IsSplit, Offset.getZExtValue() * 8,</td>
    <td class="lineNumber">3233</td>
    <td class="codeline">        migrateDebugInfo(Base, IsSplit, Offset.getZExtValue() * 8,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3234</td>
    <td class="codeline">                         SliceSize * 8, &II, New, DestPtr, nullptr, DL);</td>
    <td class="lineNumber">3234</td>
    <td class="codeline">                         SliceSize * 8, &II, New, DestPtr, nullptr, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3235</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3235</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3236</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td class="lineNumber">3236</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3237</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3237</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3238</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3238</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3239</td>
    <td class="codeline"></td>
    <td class="lineNumber">3239</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3240</td>
    <td class="codeline">    bool IsWholeAlloca = NewBeginOffset == NewAllocaBeginOffset &&</td>
    <td class="lineNumber">3240</td>
    <td class="codeline">    bool IsWholeAlloca = NewBeginOffset == NewAllocaBeginOffset &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3241</td>
    <td class="codeline">                         NewEndOffset == NewAllocaEndOffset;</td>
    <td class="lineNumber">3241</td>
    <td class="codeline">                         NewEndOffset == NewAllocaEndOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3242</td>
    <td class="codeline">    uint64_t Size = NewEndOffset - NewBeginOffset;</td>
    <td class="lineNumber">3242</td>
    <td class="codeline">    uint64_t Size = NewEndOffset - NewBeginOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3243</td>
    <td class="codeline">    unsigned BeginIndex = VecTy ? getIndex(NewBeginOffset) : 0;</td>
    <td class="lineNumber">3243</td>
    <td class="codeline">    unsigned BeginIndex = VecTy ? getIndex(NewBeginOffset) : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3244</td>
    <td class="codeline">    unsigned EndIndex = VecTy ? getIndex(NewEndOffset) : 0;</td>
    <td class="lineNumber">3244</td>
    <td class="codeline">    unsigned EndIndex = VecTy ? getIndex(NewEndOffset) : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3245</td>
    <td class="codeline">    unsigned NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">3245</td>
    <td class="codeline">    unsigned NumElements = EndIndex - BeginIndex;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3246</td>
    <td class="codeline">    IntegerType *SubIntTy =</td>
    <td class="lineNumber">3246</td>
    <td class="codeline">    IntegerType *SubIntTy =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3247</td>
    <td class="codeline">        IntTy ? Type::getIntNTy(IntTy->getContext(), Size * 8) : nullptr;</td>
    <td class="lineNumber">3247</td>
    <td class="codeline">        IntTy ? Type::getIntNTy(IntTy->getContext(), Size * 8) : nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3248</td>
    <td class="codeline"></td>
    <td class="lineNumber">3248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3249</td>
    <td class="codeline">    // Reset the other pointer type to match the register type we're going to</td>
    <td class="lineNumber">3249</td>
    <td class="codeline">    // Reset the other pointer type to match the register type we're going to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3250</td>
    <td class="codeline">    // use, but using the address space of the original other pointer.</td>
    <td class="lineNumber">3250</td>
    <td class="codeline">    // use, but using the address space of the original other pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3251</td>
    <td class="codeline">    Type *OtherTy;</td>
    <td class="lineNumber">3251</td>
    <td class="codeline">    Type *OtherTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3252</td>
    <td class="codeline">    if (VecTy && !IsWholeAlloca) {</td>
    <td class="lineNumber">3252</td>
    <td class="codeline">    if (VecTy && !IsWholeAlloca) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3253</td>
    <td class="codeline">      if (NumElements == 1)</td>
    <td class="lineNumber">3253</td>
    <td class="codeline">      if (NumElements == 1)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3254</td>
    <td class="codeline">        OtherTy = VecTy->getElementType();</td>
    <td class="lineNumber">3254</td>
    <td class="codeline">        OtherTy = VecTy->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3255</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">3255</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3256</td>
    <td class="codeline">        OtherTy = FixedVectorType::get(VecTy->getElementType(), NumElements);</td>
    <td class="lineNumber">3256</td>
    <td class="codeline">        OtherTy = FixedVectorType::get(VecTy->getElementType(), NumElements);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3257</td>
    <td class="codeline">    } else if (IntTy && !IsWholeAlloca) {</td>
    <td class="lineNumber">3257</td>
    <td class="codeline">    } else if (IntTy && !IsWholeAlloca) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3258</td>
    <td class="codeline">      OtherTy = SubIntTy;</td>
    <td class="lineNumber">3258</td>
    <td class="codeline">      OtherTy = SubIntTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3259</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">3259</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3260</td>
    <td class="codeline">      OtherTy = NewAllocaTy;</td>
    <td class="lineNumber">3260</td>
    <td class="codeline">      OtherTy = NewAllocaTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3261</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3261</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3262</td>
    <td class="codeline">    OtherPtrTy = OtherTy->getPointerTo(OtherAS);</td>
    <td class="lineNumber">3262</td>
    <td class="codeline">    OtherPtrTy = OtherTy->getPointerTo(OtherAS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3263</td>
    <td class="codeline"></td>
    <td class="lineNumber">3263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3264</td>
    <td class="codeline">    Value *AdjPtr = getAdjustedPtr(IRB, DL, OtherPtr, OtherOffset, OtherPtrTy,</td>
    <td class="lineNumber">3264</td>
    <td class="codeline">    Value *AdjPtr = getAdjustedPtr(IRB, DL, OtherPtr, OtherOffset, OtherPtrTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3265</td>
    <td class="codeline">                                   OtherPtr->getName() + ".");</td>
    <td class="lineNumber">3265</td>
    <td class="codeline">                                   OtherPtr->getName() + ".");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3266</td>
    <td class="codeline">    MaybeAlign SrcAlign = OtherAlign;</td>
    <td class="lineNumber">3266</td>
    <td class="codeline">    MaybeAlign SrcAlign = OtherAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3267</td>
    <td class="codeline">    MaybeAlign DstAlign = SliceAlign;</td>
    <td class="lineNumber">3267</td>
    <td class="codeline">    MaybeAlign DstAlign = SliceAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3268</td>
    <td class="codeline">    if (!IsDest)</td>
    <td class="lineNumber">3268</td>
    <td class="codeline">    if (!IsDest)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3269</td>
    <td class="codeline">      std::swap(SrcAlign, DstAlign);</td>
    <td class="lineNumber">3269</td>
    <td class="codeline">      std::swap(SrcAlign, DstAlign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3270</td>
    <td class="codeline"></td>
    <td class="lineNumber">3270</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3271</td>
    <td class="codeline">    Value *SrcPtr;</td>
    <td class="lineNumber">3271</td>
    <td class="codeline">    Value *SrcPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3272</td>
    <td class="codeline">    Value *DstPtr;</td>
    <td class="lineNumber">3272</td>
    <td class="codeline">    Value *DstPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3273</td>
    <td class="codeline"></td>
    <td class="lineNumber">3273</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3274</td>
    <td class="codeline">    if (IsDest) {</td>
    <td class="lineNumber">3274</td>
    <td class="codeline">    if (IsDest) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3275</td>
    <td class="codeline">      DstPtr = getPtrToNewAI(II.getDestAddressSpace(), II.isVolatile());</td>
    <td class="lineNumber">3275</td>
    <td class="codeline">      DstPtr = getPtrToNewAI(II.getDestAddressSpace(), II.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3276</td>
    <td class="codeline">      SrcPtr = AdjPtr;</td>
    <td class="lineNumber">3276</td>
    <td class="codeline">      SrcPtr = AdjPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3277</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">3277</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3278</td>
    <td class="codeline">      DstPtr = AdjPtr;</td>
    <td class="lineNumber">3278</td>
    <td class="codeline">      DstPtr = AdjPtr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3279</td>
    <td class="codeline">      SrcPtr = getPtrToNewAI(II.getSourceAddressSpace(), II.isVolatile());</td>
    <td class="lineNumber">3279</td>
    <td class="codeline">      SrcPtr = getPtrToNewAI(II.getSourceAddressSpace(), II.isVolatile());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3280</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3280</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3281</td>
    <td class="codeline"></td>
    <td class="lineNumber">3281</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3282</td>
    <td class="codeline">    Value *Src;</td>
    <td class="lineNumber">3282</td>
    <td class="codeline">    Value *Src;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3283</td>
    <td class="codeline">    if (VecTy && !IsWholeAlloca && !IsDest) {</td>
    <td class="lineNumber">3283</td>
    <td class="codeline">    if (VecTy && !IsWholeAlloca && !IsDest) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3284</td>
    <td class="codeline">      Src = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">3284</td>
    <td class="codeline">      Src = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3285</td>
    <td class="codeline">                                  NewAI.getAlign(), "load");</td>
    <td class="lineNumber">3285</td>
    <td class="codeline">                                  NewAI.getAlign(), "load");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3286</td>
    <td class="codeline">      Src = extractVector(IRB, Src, BeginIndex, EndIndex, "vec");</td>
    <td class="lineNumber">3286</td>
    <td class="codeline">      Src = extractVector(IRB, Src, BeginIndex, EndIndex, "vec");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3287</td>
    <td class="codeline">    } else if (IntTy && !IsWholeAlloca && !IsDest) {</td>
    <td class="lineNumber">3287</td>
    <td class="codeline">    } else if (IntTy && !IsWholeAlloca && !IsDest) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3288</td>
    <td class="codeline">      Src = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">3288</td>
    <td class="codeline">      Src = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3289</td>
    <td class="codeline">                                  NewAI.getAlign(), "load");</td>
    <td class="lineNumber">3289</td>
    <td class="codeline">                                  NewAI.getAlign(), "load");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3290</td>
    <td class="codeline">      Src = convertValue(DL, IRB, Src, IntTy);</td>
    <td class="lineNumber">3290</td>
    <td class="codeline">      Src = convertValue(DL, IRB, Src, IntTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3291</td>
    <td class="codeline">      uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">3291</td>
    <td class="codeline">      uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3292</td>
    <td class="codeline">      Src = extractInteger(DL, IRB, Src, SubIntTy, Offset, "extract");</td>
    <td class="lineNumber">3292</td>
    <td class="codeline">      Src = extractInteger(DL, IRB, Src, SubIntTy, Offset, "extract");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3293</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">3293</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3294</td>
    <td class="codeline">      LoadInst *Load = IRB.CreateAlignedLoad(OtherTy, SrcPtr, SrcAlign,</td>
    <td class="lineNumber">3294</td>
    <td class="codeline">      LoadInst *Load = IRB.CreateAlignedLoad(OtherTy, SrcPtr, SrcAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3295</td>
    <td class="codeline">                                             II.isVolatile(), "copyload");</td>
    <td class="lineNumber">3295</td>
    <td class="codeline">                                             II.isVolatile(), "copyload");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3296</td>
    <td class="codeline">      Load->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">3296</td>
    <td class="codeline">      Load->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3297</td>
    <td class="codeline">                              LLVMContext::MD_access_group});</td>
    <td class="lineNumber">3297</td>
    <td class="codeline">                              LLVMContext::MD_access_group});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3298</td>
    <td class="codeline">      if (AATags)</td>
    <td class="lineNumber">3298</td>
    <td class="codeline">      if (AATags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3299</td>
    <td class="codeline">        Load->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">3299</td>
    <td class="codeline">        Load->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3300</td>
    <td class="codeline">      Src = Load;</td>
    <td class="lineNumber">3300</td>
    <td class="codeline">      Src = Load;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3301</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3301</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3302</td>
    <td class="codeline"></td>
    <td class="lineNumber">3302</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3303</td>
    <td class="codeline">    if (VecTy && !IsWholeAlloca && IsDest) {</td>
    <td class="lineNumber">3303</td>
    <td class="codeline">    if (VecTy && !IsWholeAlloca && IsDest) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3304</td>
    <td class="codeline">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">3304</td>
    <td class="codeline">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3305</td>
    <td class="codeline">                                         NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">3305</td>
    <td class="codeline">                                         NewAI.getAlign(), "oldload");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3306</td>
    <td class="codeline">      Src = insertVector(IRB, Old, Src, BeginIndex, "vec");</td>
    <td class="lineNumber">3306</td>
    <td class="codeline">      Src = insertVector(IRB, Old, Src, BeginIndex, "vec");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3307</td>
    <td class="codeline">    } else if (IntTy && !IsWholeAlloca && IsDest) {</td>
    <td class="lineNumber">3307</td>
    <td class="codeline">    } else if (IntTy && !IsWholeAlloca && IsDest) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3308</td>
    <td class="codeline">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">3308</td>
    <td class="codeline">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3309</td>
    <td class="codeline">                                         NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">3309</td>
    <td class="codeline">                                         NewAI.getAlign(), "oldload");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3310</td>
    <td class="codeline">      Old = convertValue(DL, IRB, Old, IntTy);</td>
    <td class="lineNumber">3310</td>
    <td class="codeline">      Old = convertValue(DL, IRB, Old, IntTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3311</td>
    <td class="codeline">      uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">3311</td>
    <td class="codeline">      uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3312</td>
    <td class="codeline">      Src = insertInteger(DL, IRB, Old, Src, Offset, "insert");</td>
    <td class="lineNumber">3312</td>
    <td class="codeline">      Src = insertInteger(DL, IRB, Old, Src, Offset, "insert");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3313</td>
    <td class="codeline">      Src = convertValue(DL, IRB, Src, NewAllocaTy);</td>
    <td class="lineNumber">3313</td>
    <td class="codeline">      Src = convertValue(DL, IRB, Src, NewAllocaTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3314</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3314</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3315</td>
    <td class="codeline"></td>
    <td class="lineNumber">3315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3316</td>
    <td class="codeline">    StoreInst *Store = cast<StoreInst>(</td>
    <td class="lineNumber">3316</td>
    <td class="codeline">    StoreInst *Store = cast<StoreInst>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3317</td>
    <td class="codeline">        IRB.CreateAlignedStore(Src, DstPtr, DstAlign, II.isVolatile()));</td>
    <td class="lineNumber">3317</td>
    <td class="codeline">        IRB.CreateAlignedStore(Src, DstPtr, DstAlign, II.isVolatile()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3318</td>
    <td class="codeline">    Store->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">3318</td>
    <td class="codeline">    Store->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3319</td>
    <td class="codeline">                             LLVMContext::MD_access_group});</td>
    <td class="lineNumber">3319</td>
    <td class="codeline">                             LLVMContext::MD_access_group});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3320</td>
    <td class="codeline">    if (AATags)</td>
    <td class="lineNumber">3320</td>
    <td class="codeline">    if (AATags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3321</td>
    <td class="codeline">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">3321</td>
    <td class="codeline">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3322</td>
    <td class="codeline"></td>
    <td class="lineNumber">3322</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3323</td>
    <td class="codeline">    APInt Offset(DL.getIndexTypeSizeInBits(DstPtr->getType()), 0);</td>
    <td class="lineNumber">3323</td>
    <td class="codeline">    APInt Offset(DL.getIndexTypeSizeInBits(DstPtr->getType()), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3324</td>
    <td class="codeline">    if (IsDest) {</td>
    <td class="lineNumber">3324</td>
    <td class="codeline">    if (IsDest) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3325</td>
    <td class="codeline"></td>
    <td class="lineNumber">3325</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3326</td>
    <td class="codeline">      migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
    <td class="lineNumber">3326</td>
    <td class="codeline">      migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3327</td>
    <td class="codeline">                       Store, DstPtr, Src, DL);</td>
    <td class="lineNumber">3327</td>
    <td class="codeline">                       Store, DstPtr, Src, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3328</td>
    <td class="codeline">    } else if (AllocaInst *Base = dyn_cast<AllocaInst>(</td>
    <td class="lineNumber">3328</td>
    <td class="codeline">    } else if (AllocaInst *Base = dyn_cast<AllocaInst>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3329</td>
    <td class="codeline">                   DstPtr->stripAndAccumulateConstantOffsets(</td>
    <td class="lineNumber">3329</td>
    <td class="codeline">                   DstPtr->stripAndAccumulateConstantOffsets(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3330</td>
    <td class="codeline">                       DL, Offset, /*AllowNonInbounds*/ true))) {</td>
    <td class="lineNumber">3330</td>
    <td class="codeline">                       DL, Offset, /*AllowNonInbounds*/ true))) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3331</td>
    <td class="codeline">      migrateDebugInfo(Base, IsSplit, Offset.getZExtValue() * 8, SliceSize * 8,</td>
    <td class="lineNumber">3331</td>
    <td class="codeline">      migrateDebugInfo(Base, IsSplit, Offset.getZExtValue() * 8, SliceSize * 8,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3332</td>
    <td class="codeline">                       &II, Store, DstPtr, Src, DL);</td>
    <td class="lineNumber">3332</td>
    <td class="codeline">                       &II, Store, DstPtr, Src, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3333</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3333</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3334</td>
    <td class="codeline"></td>
    <td class="lineNumber">3334</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3335</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td class="lineNumber">3335</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3336</td>
    <td class="codeline">    return !II.isVolatile();</td>
    <td class="lineNumber">3336</td>
    <td class="codeline">    return !II.isVolatile();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3337</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3337</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3338</td>
    <td class="codeline"></td>
    <td class="lineNumber">3338</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3339</td>
    <td class="codeline">  bool visitIntrinsicInst(IntrinsicInst &II) {</td>
    <td class="lineNumber">3339</td>
    <td class="codeline">  bool visitIntrinsicInst(IntrinsicInst &II) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3340</td>
    <td class="codeline">    assert((II.isLifetimeStartOrEnd() || II.isDroppable()) &&</td>
    <td class="lineNumber">3340</td>
    <td class="codeline">    assert((II.isLifetimeStartOrEnd() || II.isDroppable()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3341</td>
    <td class="codeline">           "Unexpected intrinsic!");</td>
    <td class="lineNumber">3341</td>
    <td class="codeline">           "Unexpected intrinsic!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3342</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
    <td class="lineNumber">3342</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3343</td>
    <td class="codeline"></td>
    <td class="lineNumber">3343</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3344</td>
    <td class="codeline">    // Record this instruction for deletion.</td>
    <td class="lineNumber">3344</td>
    <td class="codeline">    // Record this instruction for deletion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3345</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&II);</td>
    <td class="lineNumber">3345</td>
    <td class="codeline">    Pass.DeadInsts.push_back(&II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3346</td>
    <td class="codeline"></td>
    <td class="lineNumber">3346</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3347</td>
    <td class="codeline">    if (II.isDroppable()) {</td>
    <td class="lineNumber">3347</td>
    <td class="codeline">    if (II.isDroppable()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3348</td>
    <td class="codeline">      assert(II.getIntrinsicID() == Intrinsic::assume && "Expected assume");</td>
    <td class="lineNumber">3348</td>
    <td class="codeline">      assert(II.getIntrinsicID() == Intrinsic::assume && "Expected assume");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3349</td>
    <td class="codeline">      // TODO For now we forget assumed information, this can be improved.</td>
    <td class="lineNumber">3349</td>
    <td class="codeline">      // TODO For now we forget assumed information, this can be improved.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3350</td>
    <td class="codeline">      OldPtr->dropDroppableUsesIn(II);</td>
    <td class="lineNumber">3350</td>
    <td class="codeline">      OldPtr->dropDroppableUsesIn(II);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3351</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">3351</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3352</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3352</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3353</td>
    <td class="codeline"></td>
    <td class="lineNumber">3353</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3354</td>
    <td class="codeline">    assert(II.getArgOperand(1) == OldPtr);</td>
    <td class="lineNumber">3354</td>
    <td class="codeline">    assert(II.getArgOperand(1) == OldPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3355</td>
    <td class="codeline">    // Lifetime intrinsics are only promotable if they cover the whole alloca.</td>
    <td class="lineNumber">3355</td>
    <td class="codeline">    // Lifetime intrinsics are only promotable if they cover the whole alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3356</td>
    <td class="codeline">    // Therefore, we drop lifetime intrinsics which don't cover the whole</td>
    <td class="lineNumber">3356</td>
    <td class="codeline">    // Therefore, we drop lifetime intrinsics which don't cover the whole</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3357</td>
    <td class="codeline">    // alloca.</td>
    <td class="lineNumber">3357</td>
    <td class="codeline">    // alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3358</td>
    <td class="codeline">    // (In theory, intrinsics which partially cover an alloca could be</td>
    <td class="lineNumber">3358</td>
    <td class="codeline">    // (In theory, intrinsics which partially cover an alloca could be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3359</td>
    <td class="codeline">    // promoted, but PromoteMemToReg doesn't handle that case.)</td>
    <td class="lineNumber">3359</td>
    <td class="codeline">    // promoted, but PromoteMemToReg doesn't handle that case.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3360</td>
    <td class="codeline">    // FIXME: Check whether the alloca is promotable before dropping the</td>
    <td class="lineNumber">3360</td>
    <td class="codeline">    // FIXME: Check whether the alloca is promotable before dropping the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3361</td>
    <td class="codeline">    // lifetime intrinsics?</td>
    <td class="lineNumber">3361</td>
    <td class="codeline">    // lifetime intrinsics?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3362</td>
    <td class="codeline">    if (NewBeginOffset != NewAllocaBeginOffset ||</td>
    <td class="lineNumber">3362</td>
    <td class="codeline">    if (NewBeginOffset != NewAllocaBeginOffset ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3363</td>
    <td class="codeline">        NewEndOffset != NewAllocaEndOffset)</td>
    <td class="lineNumber">3363</td>
    <td class="codeline">        NewEndOffset != NewAllocaEndOffset)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3364</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">3364</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3365</td>
    <td class="codeline"></td>
    <td class="lineNumber">3365</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3366</td>
    <td class="codeline">    ConstantInt *Size =</td>
    <td class="lineNumber">3366</td>
    <td class="codeline">    ConstantInt *Size =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3367</td>
    <td class="codeline">        ConstantInt::get(cast<IntegerType>(II.getArgOperand(0)->getType()),</td>
    <td class="lineNumber">3367</td>
    <td class="codeline">        ConstantInt::get(cast<IntegerType>(II.getArgOperand(0)->getType()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3368</td>
    <td class="codeline">                         NewEndOffset - NewBeginOffset);</td>
    <td class="lineNumber">3368</td>
    <td class="codeline">                         NewEndOffset - NewBeginOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3369</td>
    <td class="codeline">    // Lifetime intrinsics always expect an i8* so directly get such a pointer</td>
    <td class="lineNumber">3369</td>
    <td class="codeline">    // Lifetime intrinsics always expect an i8* so directly get such a pointer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3370</td>
    <td class="codeline">    // for the new alloca slice.</td>
    <td class="lineNumber">3370</td>
    <td class="codeline">    // for the new alloca slice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3371</td>
    <td class="codeline">    Type *PointerTy = IRB.getInt8PtrTy(OldPtr->getType()->getPointerAddressSpace());</td>
    <td class="lineNumber">3371</td>
    <td class="codeline">    Type *PointerTy = IRB.getInt8PtrTy(OldPtr->getType()->getPointerAddressSpace());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3372</td>
    <td class="codeline">    Value *Ptr = getNewAllocaSlicePtr(IRB, PointerTy);</td>
    <td class="lineNumber">3372</td>
    <td class="codeline">    Value *Ptr = getNewAllocaSlicePtr(IRB, PointerTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3373</td>
    <td class="codeline">    Value *New;</td>
    <td class="lineNumber">3373</td>
    <td class="codeline">    Value *New;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3374</td>
    <td class="codeline">    if (II.getIntrinsicID() == Intrinsic::lifetime_start)</td>
    <td class="lineNumber">3374</td>
    <td class="codeline">    if (II.getIntrinsicID() == Intrinsic::lifetime_start)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3375</td>
    <td class="codeline">      New = IRB.CreateLifetimeStart(Ptr, Size);</td>
    <td class="lineNumber">3375</td>
    <td class="codeline">      New = IRB.CreateLifetimeStart(Ptr, Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3376</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">3376</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3377</td>
    <td class="codeline">      New = IRB.CreateLifetimeEnd(Ptr, Size);</td>
    <td class="lineNumber">3377</td>
    <td class="codeline">      New = IRB.CreateLifetimeEnd(Ptr, Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3378</td>
    <td class="codeline"></td>
    <td class="lineNumber">3378</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3379</td>
    <td class="codeline">    (void)New;</td>
    <td class="lineNumber">3379</td>
    <td class="codeline">    (void)New;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3380</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td class="lineNumber">3380</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3381</td>
    <td class="codeline"></td>
    <td class="lineNumber">3381</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3382</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">3382</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3383</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3383</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3384</td>
    <td class="codeline"></td>
    <td class="lineNumber">3384</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3385</td>
    <td class="codeline">  void fixLoadStoreAlign(Instruction &Root) {</td>
    <td class="lineNumber">3385</td>
    <td class="codeline">  void fixLoadStoreAlign(Instruction &Root) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3386</td>
    <td class="codeline">    // This algorithm implements the same visitor loop as</td>
    <td class="lineNumber">3386</td>
    <td class="codeline">    // This algorithm implements the same visitor loop as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3387</td>
    <td class="codeline">    // hasUnsafePHIOrSelectUse, and fixes the alignment of each load</td>
    <td class="lineNumber">3387</td>
    <td class="codeline">    // hasUnsafePHIOrSelectUse, and fixes the alignment of each load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3388</td>
    <td class="codeline">    // or store found.</td>
    <td class="lineNumber">3388</td>
    <td class="codeline">    // or store found.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3389</td>
    <td class="codeline">    SmallPtrSet<Instruction *, 4> Visited;</td>
    <td class="lineNumber">3389</td>
    <td class="codeline">    SmallPtrSet<Instruction *, 4> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3390</td>
    <td class="codeline">    SmallVector<Instruction *, 4> Uses;</td>
    <td class="lineNumber">3390</td>
    <td class="codeline">    SmallVector<Instruction *, 4> Uses;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3391</td>
    <td class="codeline">    Visited.insert(&Root);</td>
    <td class="lineNumber">3391</td>
    <td class="codeline">    Visited.insert(&Root);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3392</td>
    <td class="codeline">    Uses.push_back(&Root);</td>
    <td class="lineNumber">3392</td>
    <td class="codeline">    Uses.push_back(&Root);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3393</td>
    <td class="codeline">    do {</td>
    <td class="lineNumber">3393</td>
    <td class="codeline">    do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3394</td>
    <td class="codeline">      Instruction *I = Uses.pop_back_val();</td>
    <td class="lineNumber">3394</td>
    <td class="codeline">      Instruction *I = Uses.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3395</td>
    <td class="codeline"></td>
    <td class="lineNumber">3395</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3396</td>
    <td class="codeline">      if (LoadInst *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">3396</td>
    <td class="codeline">      if (LoadInst *LI = dyn_cast<LoadInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3397</td>
    <td class="codeline">        LI->setAlignment(std::min(LI->getAlign(), getSliceAlign()));</td>
    <td class="lineNumber">3397</td>
    <td class="codeline">        LI->setAlignment(std::min(LI->getAlign(), getSliceAlign()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3398</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">3398</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3399</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3399</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3400</td>
    <td class="codeline">      if (StoreInst *SI = dyn_cast<StoreInst>(I)) {</td>
    <td class="lineNumber">3400</td>
    <td class="codeline">      if (StoreInst *SI = dyn_cast<StoreInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3401</td>
    <td class="codeline">        SI->setAlignment(std::min(SI->getAlign(), getSliceAlign()));</td>
    <td class="lineNumber">3401</td>
    <td class="codeline">        SI->setAlignment(std::min(SI->getAlign(), getSliceAlign()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3402</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">3402</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3403</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3403</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3404</td>
    <td class="codeline"></td>
    <td class="lineNumber">3404</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3405</td>
    <td class="codeline">      assert(isa<BitCastInst>(I) || isa<AddrSpaceCastInst>(I) ||</td>
    <td class="lineNumber">3405</td>
    <td class="codeline">      assert(isa<BitCastInst>(I) || isa<AddrSpaceCastInst>(I) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3406</td>
    <td class="codeline">             isa<PHINode>(I) || isa<SelectInst>(I) ||</td>
    <td class="lineNumber">3406</td>
    <td class="codeline">             isa<PHINode>(I) || isa<SelectInst>(I) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3407</td>
    <td class="codeline">             isa<GetElementPtrInst>(I));</td>
    <td class="lineNumber">3407</td>
    <td class="codeline">             isa<GetElementPtrInst>(I));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3408</td>
    <td class="codeline">      for (User *U : I->users())</td>
    <td class="lineNumber">3408</td>
    <td class="codeline">      for (User *U : I->users())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3409</td>
    <td class="codeline">        if (Visited.insert(cast<Instruction>(U)).second)</td>
    <td class="lineNumber">3409</td>
    <td class="codeline">        if (Visited.insert(cast<Instruction>(U)).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3410</td>
    <td class="codeline">          Uses.push_back(cast<Instruction>(U));</td>
    <td class="lineNumber">3410</td>
    <td class="codeline">          Uses.push_back(cast<Instruction>(U));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3411</td>
    <td class="codeline">    } while (!Uses.empty());</td>
    <td class="lineNumber">3411</td>
    <td class="codeline">    } while (!Uses.empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3412</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3412</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3413</td>
    <td class="codeline"></td>
    <td class="lineNumber">3413</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3414</td>
    <td class="codeline">  bool visitPHINode(PHINode &PN) {</td>
    <td class="lineNumber">3414</td>
    <td class="codeline">  bool visitPHINode(PHINode &PN) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3415</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << PN << "\n");</td>
    <td class="lineNumber">3415</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << PN << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3416</td>
    <td class="codeline">    assert(BeginOffset >= NewAllocaBeginOffset && "PHIs are unsplittable");</td>
    <td class="lineNumber">3416</td>
    <td class="codeline">    assert(BeginOffset >= NewAllocaBeginOffset && "PHIs are unsplittable");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3417</td>
    <td class="codeline">    assert(EndOffset <= NewAllocaEndOffset && "PHIs are unsplittable");</td>
    <td class="lineNumber">3417</td>
    <td class="codeline">    assert(EndOffset <= NewAllocaEndOffset && "PHIs are unsplittable");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3418</td>
    <td class="codeline"></td>
    <td class="lineNumber">3418</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3419</td>
    <td class="codeline">    // We would like to compute a new pointer in only one place, but have it be</td>
    <td class="lineNumber">3419</td>
    <td class="codeline">    // We would like to compute a new pointer in only one place, but have it be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3420</td>
    <td class="codeline">    // as local as possible to the PHI. To do that, we re-use the location of</td>
    <td class="lineNumber">3420</td>
    <td class="codeline">    // as local as possible to the PHI. To do that, we re-use the location of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3421</td>
    <td class="codeline">    // the old pointer, which necessarily must be in the right position to</td>
    <td class="lineNumber">3421</td>
    <td class="codeline">    // the old pointer, which necessarily must be in the right position to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3422</td>
    <td class="codeline">    // dominate the PHI.</td>
    <td class="lineNumber">3422</td>
    <td class="codeline">    // dominate the PHI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3423</td>
    <td class="codeline">    IRBuilderBase::InsertPointGuard Guard(IRB);</td>
    <td class="lineNumber">3423</td>
    <td class="codeline">    IRBuilderBase::InsertPointGuard Guard(IRB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3424</td>
    <td class="codeline">    if (isa<PHINode>(OldPtr))</td>
    <td class="lineNumber">3424</td>
    <td class="codeline">    if (isa<PHINode>(OldPtr))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3425</td>
    <td class="codeline">      IRB.SetInsertPoint(&*OldPtr->getParent()->getFirstInsertionPt());</td>
    <td class="lineNumber">3425</td>
    <td class="codeline">      IRB.SetInsertPoint(&*OldPtr->getParent()->getFirstInsertionPt());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3426</td>
    <td class="codeline">    else</td>
    <td class="lineNumber">3426</td>
    <td class="codeline">    else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3427</td>
    <td class="codeline">      IRB.SetInsertPoint(OldPtr);</td>
    <td class="lineNumber">3427</td>
    <td class="codeline">      IRB.SetInsertPoint(OldPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3428</td>
    <td class="codeline">    IRB.SetCurrentDebugLocation(OldPtr->getDebugLoc());</td>
    <td class="lineNumber">3428</td>
    <td class="codeline">    IRB.SetCurrentDebugLocation(OldPtr->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3429</td>
    <td class="codeline"></td>
    <td class="lineNumber">3429</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3430</td>
    <td class="codeline">    Value *NewPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td class="lineNumber">3430</td>
    <td class="codeline">    Value *NewPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3431</td>
    <td class="codeline">    // Replace the operands which were using the old pointer.</td>
    <td class="lineNumber">3431</td>
    <td class="codeline">    // Replace the operands which were using the old pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3432</td>
    <td class="codeline">    std::replace(PN.op_begin(), PN.op_end(), cast<Value>(OldPtr), NewPtr);</td>
    <td class="lineNumber">3432</td>
    <td class="codeline">    std::replace(PN.op_begin(), PN.op_end(), cast<Value>(OldPtr), NewPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3433</td>
    <td class="codeline"></td>
    <td class="lineNumber">3433</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3434</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << PN << "\n");</td>
    <td class="lineNumber">3434</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << PN << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3435</td>
    <td class="codeline">    deleteIfTriviallyDead(OldPtr);</td>
    <td class="lineNumber">3435</td>
    <td class="codeline">    deleteIfTriviallyDead(OldPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3436</td>
    <td class="codeline"></td>
    <td class="lineNumber">3436</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3437</td>
    <td class="codeline">    // Fix the alignment of any loads or stores using this PHI node.</td>
    <td class="lineNumber">3437</td>
    <td class="codeline">    // Fix the alignment of any loads or stores using this PHI node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3438</td>
    <td class="codeline">    fixLoadStoreAlign(PN);</td>
    <td class="lineNumber">3438</td>
    <td class="codeline">    fixLoadStoreAlign(PN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3439</td>
    <td class="codeline"></td>
    <td class="lineNumber">3439</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3440</td>
    <td class="codeline">    // PHIs can't be promoted on their own, but often can be speculated. We</td>
    <td class="lineNumber">3440</td>
    <td class="codeline">    // PHIs can't be promoted on their own, but often can be speculated. We</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3441</td>
    <td class="codeline">    // check the speculation outside of the rewriter so that we see the</td>
    <td class="lineNumber">3441</td>
    <td class="codeline">    // check the speculation outside of the rewriter so that we see the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3442</td>
    <td class="codeline">    // fully-rewritten alloca.</td>
    <td class="lineNumber">3442</td>
    <td class="codeline">    // fully-rewritten alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3443</td>
    <td class="codeline">    PHIUsers.insert(&PN);</td>
    <td class="lineNumber">3443</td>
    <td class="codeline">    PHIUsers.insert(&PN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3444</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">3444</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3445</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3445</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3446</td>
    <td class="codeline"></td>
    <td class="lineNumber">3446</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3447</td>
    <td class="codeline">  bool visitSelectInst(SelectInst &SI) {</td>
    <td class="lineNumber">3447</td>
    <td class="codeline">  bool visitSelectInst(SelectInst &SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3448</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
    <td class="lineNumber">3448</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3449</td>
    <td class="codeline">    assert((SI.getTrueValue() == OldPtr || SI.getFalseValue() == OldPtr) &&</td>
    <td class="lineNumber">3449</td>
    <td class="codeline">    assert((SI.getTrueValue() == OldPtr || SI.getFalseValue() == OldPtr) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3450</td>
    <td class="codeline">           "Pointer isn't an operand!");</td>
    <td class="lineNumber">3450</td>
    <td class="codeline">           "Pointer isn't an operand!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3451</td>
    <td class="codeline">    assert(BeginOffset >= NewAllocaBeginOffset && "Selects are unsplittable");</td>
    <td class="lineNumber">3451</td>
    <td class="codeline">    assert(BeginOffset >= NewAllocaBeginOffset && "Selects are unsplittable");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3452</td>
    <td class="codeline">    assert(EndOffset <= NewAllocaEndOffset && "Selects are unsplittable");</td>
    <td class="lineNumber">3452</td>
    <td class="codeline">    assert(EndOffset <= NewAllocaEndOffset && "Selects are unsplittable");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3453</td>
    <td class="codeline"></td>
    <td class="lineNumber">3453</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3454</td>
    <td class="codeline">    Value *NewPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td class="lineNumber">3454</td>
    <td class="codeline">    Value *NewPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3455</td>
    <td class="codeline">    // Replace the operands which were using the old pointer.</td>
    <td class="lineNumber">3455</td>
    <td class="codeline">    // Replace the operands which were using the old pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3456</td>
    <td class="codeline">    if (SI.getOperand(1) == OldPtr)</td>
    <td class="lineNumber">3456</td>
    <td class="codeline">    if (SI.getOperand(1) == OldPtr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3457</td>
    <td class="codeline">      SI.setOperand(1, NewPtr);</td>
    <td class="lineNumber">3457</td>
    <td class="codeline">      SI.setOperand(1, NewPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3458</td>
    <td class="codeline">    if (SI.getOperand(2) == OldPtr)</td>
    <td class="lineNumber">3458</td>
    <td class="codeline">    if (SI.getOperand(2) == OldPtr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3459</td>
    <td class="codeline">      SI.setOperand(2, NewPtr);</td>
    <td class="lineNumber">3459</td>
    <td class="codeline">      SI.setOperand(2, NewPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3460</td>
    <td class="codeline"></td>
    <td class="lineNumber">3460</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3461</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << SI << "\n");</td>
    <td class="lineNumber">3461</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "          to: " << SI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3462</td>
    <td class="codeline">    deleteIfTriviallyDead(OldPtr);</td>
    <td class="lineNumber">3462</td>
    <td class="codeline">    deleteIfTriviallyDead(OldPtr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3463</td>
    <td class="codeline"></td>
    <td class="lineNumber">3463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3464</td>
    <td class="codeline">    // Fix the alignment of any loads or stores using this select.</td>
    <td class="lineNumber">3464</td>
    <td class="codeline">    // Fix the alignment of any loads or stores using this select.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3465</td>
    <td class="codeline">    fixLoadStoreAlign(SI);</td>
    <td class="lineNumber">3465</td>
    <td class="codeline">    fixLoadStoreAlign(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3466</td>
    <td class="codeline"></td>
    <td class="lineNumber">3466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3467</td>
    <td class="codeline">    // Selects can't be promoted on their own, but often can be speculated. We</td>
    <td class="lineNumber">3467</td>
    <td class="codeline">    // Selects can't be promoted on their own, but often can be speculated. We</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3468</td>
    <td class="codeline">    // check the speculation outside of the rewriter so that we see the</td>
    <td class="lineNumber">3468</td>
    <td class="codeline">    // check the speculation outside of the rewriter so that we see the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3469</td>
    <td class="codeline">    // fully-rewritten alloca.</td>
    <td class="lineNumber">3469</td>
    <td class="codeline">    // fully-rewritten alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3470</td>
    <td class="codeline">    SelectUsers.insert(&SI);</td>
    <td class="lineNumber">3470</td>
    <td class="codeline">    SelectUsers.insert(&SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3471</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">3471</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3472</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3472</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3473</td>
    <td class="codeline">};</td>
    <td class="lineNumber">3473</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3474</td>
    <td class="codeline"></td>
    <td class="lineNumber">3474</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3475</td>
    <td class="codeline">namespace {</td>
    <td class="lineNumber">3475</td>
    <td class="codeline">namespace {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3476</td>
    <td class="codeline"></td>
    <td class="lineNumber">3476</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3477</td>
    <td class="codeline">/// Visitor to rewrite aggregate loads and stores as scalar.</td>
    <td class="lineNumber">3477</td>
    <td class="codeline">/// Visitor to rewrite aggregate loads and stores as scalar.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3478</td>
    <td class="codeline">///</td>
    <td class="lineNumber">3478</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3479</td>
    <td class="codeline">/// This pass aggressively rewrites all aggregate loads and stores on</td>
    <td class="lineNumber">3479</td>
    <td class="codeline">/// This pass aggressively rewrites all aggregate loads and stores on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3480</td>
    <td class="codeline">/// a particular pointer (or any pointer derived from it which we can identify)</td>
    <td class="lineNumber">3480</td>
    <td class="codeline">/// a particular pointer (or any pointer derived from it which we can identify)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3481</td>
    <td class="codeline">/// with scalar loads and stores.</td>
    <td class="lineNumber">3481</td>
    <td class="codeline">/// with scalar loads and stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3482</td>
    <td class="codeline">class AggLoadStoreRewriter : public InstVisitor<AggLoadStoreRewriter, bool> {</td>
    <td class="lineNumber">3482</td>
    <td class="codeline">class AggLoadStoreRewriter : public InstVisitor<AggLoadStoreRewriter, bool> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3483</td>
    <td class="codeline">  // Befriend the base class so it can delegate to private visit methods.</td>
    <td class="lineNumber">3483</td>
    <td class="codeline">  // Befriend the base class so it can delegate to private visit methods.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3484</td>
    <td class="codeline">  friend class InstVisitor<AggLoadStoreRewriter, bool>;</td>
    <td class="lineNumber">3484</td>
    <td class="codeline">  friend class InstVisitor<AggLoadStoreRewriter, bool>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3485</td>
    <td class="codeline"></td>
    <td class="lineNumber">3485</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3486</td>
    <td class="codeline">  /// Queue of pointer uses to analyze and potentially rewrite.</td>
    <td class="lineNumber">3486</td>
    <td class="codeline">  /// Queue of pointer uses to analyze and potentially rewrite.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3487</td>
    <td class="codeline">  SmallVector<Use *, 8> Queue;</td>
    <td class="lineNumber">3487</td>
    <td class="codeline">  SmallVector<Use *, 8> Queue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3488</td>
    <td class="codeline"></td>
    <td class="lineNumber">3488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3489</td>
    <td class="codeline">  /// Set to prevent us from cycling with phi nodes and loops.</td>
    <td class="lineNumber">3489</td>
    <td class="codeline">  /// Set to prevent us from cycling with phi nodes and loops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3490</td>
    <td class="codeline">  SmallPtrSet<User *, 8> Visited;</td>
    <td class="lineNumber">3490</td>
    <td class="codeline">  SmallPtrSet<User *, 8> Visited;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3491</td>
    <td class="codeline"></td>
    <td class="lineNumber">3491</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3492</td>
    <td class="codeline">  /// The current pointer use being rewritten. This is used to dig up the used</td>
    <td class="lineNumber">3492</td>
    <td class="codeline">  /// The current pointer use being rewritten. This is used to dig up the used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3493</td>
    <td class="codeline">  /// value (as opposed to the user).</td>
    <td class="lineNumber">3493</td>
    <td class="codeline">  /// value (as opposed to the user).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3494</td>
    <td class="codeline">  Use *U = nullptr;</td>
    <td class="lineNumber">3494</td>
    <td class="codeline">  Use *U = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3495</td>
    <td class="codeline"></td>
    <td class="lineNumber">3495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3496</td>
    <td class="codeline">  /// Used to calculate offsets, and hence alignment, of subobjects.</td>
    <td class="lineNumber">3496</td>
    <td class="codeline">  /// Used to calculate offsets, and hence alignment, of subobjects.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3497</td>
    <td class="codeline">  const DataLayout &DL;</td>
    <td class="lineNumber">3497</td>
    <td class="codeline">  const DataLayout &DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3498</td>
    <td class="codeline"></td>
    <td class="lineNumber">3498</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3499</td>
    <td class="codeline">  IRBuilderTy &IRB;</td>
    <td class="lineNumber">3499</td>
    <td class="codeline">  IRBuilderTy &IRB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3500</td>
    <td class="codeline"></td>
    <td class="lineNumber">3500</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3501</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">3501</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3502</td>
    <td class="codeline">  AggLoadStoreRewriter(const DataLayout &DL, IRBuilderTy &IRB)</td>
    <td class="lineNumber">3502</td>
    <td class="codeline">  AggLoadStoreRewriter(const DataLayout &DL, IRBuilderTy &IRB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3503</td>
    <td class="codeline">      : DL(DL), IRB(IRB) {}</td>
    <td class="lineNumber">3503</td>
    <td class="codeline">      : DL(DL), IRB(IRB) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3504</td>
    <td class="codeline"></td>
    <td class="lineNumber">3504</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3505</td>
    <td class="codeline">  /// Rewrite loads and stores through a pointer and all pointers derived from</td>
    <td class="lineNumber">3505</td>
    <td class="codeline">  /// Rewrite loads and stores through a pointer and all pointers derived from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3506</td>
    <td class="codeline">  /// it.</td>
    <td class="lineNumber">3506</td>
    <td class="codeline">  /// it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3507</td>
    <td class="codeline">  bool rewrite(Instruction &I) {</td>
    <td class="lineNumber">3507</td>
    <td class="codeline">  bool rewrite(Instruction &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3508</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  Rewriting FCA loads and stores...\n");</td>
    <td class="lineNumber">3508</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  Rewriting FCA loads and stores...\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3509</td>
    <td class="codeline">    enqueueUsers(I);</td>
    <td class="lineNumber">3509</td>
    <td class="codeline">    enqueueUsers(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3510</td>
    <td class="codeline">    bool Changed = false;</td>
    <td class="lineNumber">3510</td>
    <td class="codeline">    bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3511</td>
    <td class="codeline">    while (!Queue.empty()) {</td>
    <td class="lineNumber">3511</td>
    <td class="codeline">    while (!Queue.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3512</td>
    <td class="codeline">      U = Queue.pop_back_val();</td>
    <td class="lineNumber">3512</td>
    <td class="codeline">      U = Queue.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3513</td>
    <td class="codeline">      Changed |= visit(cast<Instruction>(U->getUser()));</td>
    <td class="lineNumber">3513</td>
    <td class="codeline">      Changed |= visit(cast<Instruction>(U->getUser()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3514</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3514</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3515</td>
    <td class="codeline">    return Changed;</td>
    <td class="lineNumber">3515</td>
    <td class="codeline">    return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3516</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3516</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3517</td>
    <td class="codeline"></td>
    <td class="lineNumber">3517</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3518</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">3518</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3519</td>
    <td class="codeline">  /// Enqueue all the users of the given instruction for further processing.</td>
    <td class="lineNumber">3519</td>
    <td class="codeline">  /// Enqueue all the users of the given instruction for further processing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3520</td>
    <td class="codeline">  /// This uses a set to de-duplicate users.</td>
    <td class="lineNumber">3520</td>
    <td class="codeline">  /// This uses a set to de-duplicate users.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3521</td>
    <td class="codeline">  void enqueueUsers(Instruction &I) {</td>
    <td class="lineNumber">3521</td>
    <td class="codeline">  void enqueueUsers(Instruction &I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3522</td>
    <td class="codeline">    for (Use &U : I.uses())</td>
    <td class="lineNumber">3522</td>
    <td class="codeline">    for (Use &U : I.uses())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3523</td>
    <td class="codeline">      if (Visited.insert(U.getUser()).second)</td>
    <td class="lineNumber">3523</td>
    <td class="codeline">      if (Visited.insert(U.getUser()).second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3524</td>
    <td class="codeline">        Queue.push_back(&U);</td>
    <td class="lineNumber">3524</td>
    <td class="codeline">        Queue.push_back(&U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3525</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3525</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3526</td>
    <td class="codeline"></td>
    <td class="lineNumber">3526</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3527</td>
    <td class="codeline">  // Conservative default is to not rewrite anything.</td>
    <td class="lineNumber">3527</td>
    <td class="codeline">  // Conservative default is to not rewrite anything.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3528</td>
    <td class="codeline">  bool visitInstruction(Instruction &I) { return false; }</td>
    <td class="lineNumber">3528</td>
    <td class="codeline">  bool visitInstruction(Instruction &I) { return false; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3529</td>
    <td class="codeline"></td>
    <td class="lineNumber">3529</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3530</td>
    <td class="codeline">  /// Generic recursive split emission class.</td>
    <td class="lineNumber">3530</td>
    <td class="codeline">  /// Generic recursive split emission class.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3531</td>
    <td class="codeline">  template <typename Derived> class OpSplitter {</td>
    <td class="lineNumber">3531</td>
    <td class="codeline">  template <typename Derived> class OpSplitter {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3532</td>
    <td class="codeline">  protected:</td>
    <td class="lineNumber">3532</td>
    <td class="codeline">  protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3533</td>
    <td class="codeline">    /// The builder used to form new instructions.</td>
    <td class="lineNumber">3533</td>
    <td class="codeline">    /// The builder used to form new instructions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3534</td>
    <td class="codeline">    IRBuilderTy &IRB;</td>
    <td class="lineNumber">3534</td>
    <td class="codeline">    IRBuilderTy &IRB;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3535</td>
    <td class="codeline"></td>
    <td class="lineNumber">3535</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3536</td>
    <td class="codeline">    /// The indices which to be used with insert- or extractvalue to select the</td>
    <td class="lineNumber">3536</td>
    <td class="codeline">    /// The indices which to be used with insert- or extractvalue to select the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3537</td>
    <td class="codeline">    /// appropriate value within the aggregate.</td>
    <td class="lineNumber">3537</td>
    <td class="codeline">    /// appropriate value within the aggregate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3538</td>
    <td class="codeline">    SmallVector<unsigned, 4> Indices;</td>
    <td class="lineNumber">3538</td>
    <td class="codeline">    SmallVector<unsigned, 4> Indices;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3539</td>
    <td class="codeline"></td>
    <td class="lineNumber">3539</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3540</td>
    <td class="codeline">    /// The indices to a GEP instruction which will move Ptr to the correct slot</td>
    <td class="lineNumber">3540</td>
    <td class="codeline">    /// The indices to a GEP instruction which will move Ptr to the correct slot</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3541</td>
    <td class="codeline">    /// within the aggregate.</td>
    <td class="lineNumber">3541</td>
    <td class="codeline">    /// within the aggregate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3542</td>
    <td class="codeline">    SmallVector<Value *, 4> GEPIndices;</td>
    <td class="lineNumber">3542</td>
    <td class="codeline">    SmallVector<Value *, 4> GEPIndices;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3543</td>
    <td class="codeline"></td>
    <td class="lineNumber">3543</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3544</td>
    <td class="codeline">    /// The base pointer of the original op, used as a base for GEPing the</td>
    <td class="lineNumber">3544</td>
    <td class="codeline">    /// The base pointer of the original op, used as a base for GEPing the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3545</td>
    <td class="codeline">    /// split operations.</td>
    <td class="lineNumber">3545</td>
    <td class="codeline">    /// split operations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3546</td>
    <td class="codeline">    Value *Ptr;</td>
    <td class="lineNumber">3546</td>
    <td class="codeline">    Value *Ptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3547</td>
    <td class="codeline"></td>
    <td class="lineNumber">3547</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3548</td>
    <td class="codeline">    /// The base pointee type being GEPed into.</td>
    <td class="lineNumber">3548</td>
    <td class="codeline">    /// The base pointee type being GEPed into.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3549</td>
    <td class="codeline">    Type *BaseTy;</td>
    <td class="lineNumber">3549</td>
    <td class="codeline">    Type *BaseTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3550</td>
    <td class="codeline"></td>
    <td class="lineNumber">3550</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3551</td>
    <td class="codeline">    /// Known alignment of the base pointer.</td>
    <td class="lineNumber">3551</td>
    <td class="codeline">    /// Known alignment of the base pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3552</td>
    <td class="codeline">    Align BaseAlign;</td>
    <td class="lineNumber">3552</td>
    <td class="codeline">    Align BaseAlign;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3553</td>
    <td class="codeline"></td>
    <td class="lineNumber">3553</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3554</td>
    <td class="codeline">    /// To calculate offset of each component so we can correctly deduce</td>
    <td class="lineNumber">3554</td>
    <td class="codeline">    /// To calculate offset of each component so we can correctly deduce</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3555</td>
    <td class="codeline">    /// alignments.</td>
    <td class="lineNumber">3555</td>
    <td class="codeline">    /// alignments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3556</td>
    <td class="codeline">    const DataLayout &DL;</td>
    <td class="lineNumber">3556</td>
    <td class="codeline">    const DataLayout &DL;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3557</td>
    <td class="codeline"></td>
    <td class="lineNumber">3557</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3558</td>
    <td class="codeline">    /// Initialize the splitter with an insertion point, Ptr and start with a</td>
    <td class="lineNumber">3558</td>
    <td class="codeline">    /// Initialize the splitter with an insertion point, Ptr and start with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3559</td>
    <td class="codeline">    /// single zero GEP index.</td>
    <td class="lineNumber">3559</td>
    <td class="codeline">    /// single zero GEP index.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3560</td>
    <td class="codeline">    OpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
    <td class="lineNumber">3560</td>
    <td class="codeline">    OpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3561</td>
    <td class="codeline">               Align BaseAlign, const DataLayout &DL, IRBuilderTy &IRB)</td>
    <td class="lineNumber">3561</td>
    <td class="codeline">               Align BaseAlign, const DataLayout &DL, IRBuilderTy &IRB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3562</td>
    <td class="codeline">        : IRB(IRB), GEPIndices(1, IRB.getInt32(0)), Ptr(Ptr), BaseTy(BaseTy),</td>
    <td class="lineNumber">3562</td>
    <td class="codeline">        : IRB(IRB), GEPIndices(1, IRB.getInt32(0)), Ptr(Ptr), BaseTy(BaseTy),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3563</td>
    <td class="codeline">          BaseAlign(BaseAlign), DL(DL) {</td>
    <td class="lineNumber">3563</td>
    <td class="codeline">          BaseAlign(BaseAlign), DL(DL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3564</td>
    <td class="codeline">      IRB.SetInsertPoint(InsertionPoint);</td>
    <td class="lineNumber">3564</td>
    <td class="codeline">      IRB.SetInsertPoint(InsertionPoint);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3565</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3565</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3566</td>
    <td class="codeline"></td>
    <td class="lineNumber">3566</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3567</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">3567</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3568</td>
    <td class="codeline">    /// Generic recursive split emission routine.</td>
    <td class="lineNumber">3568</td>
    <td class="codeline">    /// Generic recursive split emission routine.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3569</td>
    <td class="codeline">    ///</td>
    <td class="lineNumber">3569</td>
    <td class="codeline">    ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3570</td>
    <td class="codeline">    /// This method recursively splits an aggregate op (load or store) into</td>
    <td class="lineNumber">3570</td>
    <td class="codeline">    /// This method recursively splits an aggregate op (load or store) into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3571</td>
    <td class="codeline">    /// scalar or vector ops. It splits recursively until it hits a single value</td>
    <td class="lineNumber">3571</td>
    <td class="codeline">    /// scalar or vector ops. It splits recursively until it hits a single value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3572</td>
    <td class="codeline">    /// and emits that single value operation via the template argument.</td>
    <td class="lineNumber">3572</td>
    <td class="codeline">    /// and emits that single value operation via the template argument.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3573</td>
    <td class="codeline">    ///</td>
    <td class="lineNumber">3573</td>
    <td class="codeline">    ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3574</td>
    <td class="codeline">    /// The logic of this routine relies on GEPs and insertvalue and</td>
    <td class="lineNumber">3574</td>
    <td class="codeline">    /// The logic of this routine relies on GEPs and insertvalue and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3575</td>
    <td class="codeline">    /// extractvalue all operating with the same fundamental index list, merely</td>
    <td class="lineNumber">3575</td>
    <td class="codeline">    /// extractvalue all operating with the same fundamental index list, merely</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3576</td>
    <td class="codeline">    /// formatted differently (GEPs need actual values).</td>
    <td class="lineNumber">3576</td>
    <td class="codeline">    /// formatted differently (GEPs need actual values).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3577</td>
    <td class="codeline">    ///</td>
    <td class="lineNumber">3577</td>
    <td class="codeline">    ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3578</td>
    <td class="codeline">    /// \param Ty  The type being split recursively into smaller ops.</td>
    <td class="lineNumber">3578</td>
    <td class="codeline">    /// \param Ty  The type being split recursively into smaller ops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3579</td>
    <td class="codeline">    /// \param Agg The aggregate value being built up or stored, depending on</td>
    <td class="lineNumber">3579</td>
    <td class="codeline">    /// \param Agg The aggregate value being built up or stored, depending on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3580</td>
    <td class="codeline">    /// whether this is splitting a load or a store respectively.</td>
    <td class="lineNumber">3580</td>
    <td class="codeline">    /// whether this is splitting a load or a store respectively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3581</td>
    <td class="codeline">    void emitSplitOps(Type *Ty, Value *&Agg, const Twine &Name) {</td>
    <td class="lineNumber">3581</td>
    <td class="codeline">    void emitSplitOps(Type *Ty, Value *&Agg, const Twine &Name) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3582</td>
    <td class="codeline">      if (Ty->isSingleValueType()) {</td>
    <td class="lineNumber">3582</td>
    <td class="codeline">      if (Ty->isSingleValueType()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3583</td>
    <td class="codeline">        unsigned Offset = DL.getIndexedOffsetInType(BaseTy, GEPIndices);</td>
    <td class="lineNumber">3583</td>
    <td class="codeline">        unsigned Offset = DL.getIndexedOffsetInType(BaseTy, GEPIndices);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3584</td>
    <td class="codeline">        return static_cast<Derived *>(this)->emitFunc(</td>
    <td class="lineNumber">3584</td>
    <td class="codeline">        return static_cast<Derived *>(this)->emitFunc(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3585</td>
    <td class="codeline">            Ty, Agg, commonAlignment(BaseAlign, Offset), Name);</td>
    <td class="lineNumber">3585</td>
    <td class="codeline">            Ty, Agg, commonAlignment(BaseAlign, Offset), Name);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3586</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3586</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3587</td>
    <td class="codeline"></td>
    <td class="lineNumber">3587</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3588</td>
    <td class="codeline">      if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">3588</td>
    <td class="codeline">      if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3589</td>
    <td class="codeline">        unsigned OldSize = Indices.size();</td>
    <td class="lineNumber">3589</td>
    <td class="codeline">        unsigned OldSize = Indices.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3590</td>
    <td class="codeline">        (void)OldSize;</td>
    <td class="lineNumber">3590</td>
    <td class="codeline">        (void)OldSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3591</td>
    <td class="codeline">        for (unsigned Idx = 0, Size = ATy->getNumElements(); Idx != Size;</td>
    <td class="lineNumber">3591</td>
    <td class="codeline">        for (unsigned Idx = 0, Size = ATy->getNumElements(); Idx != Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3592</td>
    <td class="codeline">             ++Idx) {</td>
    <td class="lineNumber">3592</td>
    <td class="codeline">             ++Idx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3593</td>
    <td class="codeline">          assert(Indices.size() == OldSize && "Did not return to the old size");</td>
    <td class="lineNumber">3593</td>
    <td class="codeline">          assert(Indices.size() == OldSize && "Did not return to the old size");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3594</td>
    <td class="codeline">          Indices.push_back(Idx);</td>
    <td class="lineNumber">3594</td>
    <td class="codeline">          Indices.push_back(Idx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3595</td>
    <td class="codeline">          GEPIndices.push_back(IRB.getInt32(Idx));</td>
    <td class="lineNumber">3595</td>
    <td class="codeline">          GEPIndices.push_back(IRB.getInt32(Idx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3596</td>
    <td class="codeline">          emitSplitOps(ATy->getElementType(), Agg, Name + "." + Twine(Idx));</td>
    <td class="lineNumber">3596</td>
    <td class="codeline">          emitSplitOps(ATy->getElementType(), Agg, Name + "." + Twine(Idx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3597</td>
    <td class="codeline">          GEPIndices.pop_back();</td>
    <td class="lineNumber">3597</td>
    <td class="codeline">          GEPIndices.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3598</td>
    <td class="codeline">          Indices.pop_back();</td>
    <td class="lineNumber">3598</td>
    <td class="codeline">          Indices.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3599</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">3599</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3600</td>
    <td class="codeline">        return;</td>
    <td class="lineNumber">3600</td>
    <td class="codeline">        return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3601</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3601</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3602</td>
    <td class="codeline"></td>
    <td class="lineNumber">3602</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3603</td>
    <td class="codeline">      if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td class="lineNumber">3603</td>
    <td class="codeline">      if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3604</td>
    <td class="codeline">        unsigned OldSize = Indices.size();</td>
    <td class="lineNumber">3604</td>
    <td class="codeline">        unsigned OldSize = Indices.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3605</td>
    <td class="codeline">        (void)OldSize;</td>
    <td class="lineNumber">3605</td>
    <td class="codeline">        (void)OldSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3606</td>
    <td class="codeline">        for (unsigned Idx = 0, Size = STy->getNumElements(); Idx != Size;</td>
    <td class="lineNumber">3606</td>
    <td class="codeline">        for (unsigned Idx = 0, Size = STy->getNumElements(); Idx != Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3607</td>
    <td class="codeline">             ++Idx) {</td>
    <td class="lineNumber">3607</td>
    <td class="codeline">             ++Idx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3608</td>
    <td class="codeline">          assert(Indices.size() == OldSize && "Did not return to the old size");</td>
    <td class="lineNumber">3608</td>
    <td class="codeline">          assert(Indices.size() == OldSize && "Did not return to the old size");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3609</td>
    <td class="codeline">          Indices.push_back(Idx);</td>
    <td class="lineNumber">3609</td>
    <td class="codeline">          Indices.push_back(Idx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3610</td>
    <td class="codeline">          GEPIndices.push_back(IRB.getInt32(Idx));</td>
    <td class="lineNumber">3610</td>
    <td class="codeline">          GEPIndices.push_back(IRB.getInt32(Idx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3611</td>
    <td class="codeline">          emitSplitOps(STy->getElementType(Idx), Agg, Name + "." + Twine(Idx));</td>
    <td class="lineNumber">3611</td>
    <td class="codeline">          emitSplitOps(STy->getElementType(Idx), Agg, Name + "." + Twine(Idx));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3612</td>
    <td class="codeline">          GEPIndices.pop_back();</td>
    <td class="lineNumber">3612</td>
    <td class="codeline">          GEPIndices.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3613</td>
    <td class="codeline">          Indices.pop_back();</td>
    <td class="lineNumber">3613</td>
    <td class="codeline">          Indices.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3614</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">3614</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3615</td>
    <td class="codeline">        return;</td>
    <td class="lineNumber">3615</td>
    <td class="codeline">        return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3616</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3616</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3617</td>
    <td class="codeline"></td>
    <td class="lineNumber">3617</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3618</td>
    <td class="codeline">      llvm_unreachable("Only arrays and structs are aggregate loadable types");</td>
    <td class="lineNumber">3618</td>
    <td class="codeline">      llvm_unreachable("Only arrays and structs are aggregate loadable types");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3619</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3619</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3620</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">3620</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3621</td>
    <td class="codeline"></td>
    <td class="lineNumber">3621</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3622</td>
    <td class="codeline">  struct LoadOpSplitter : public OpSplitter<LoadOpSplitter> {</td>
    <td class="lineNumber">3622</td>
    <td class="codeline">  struct LoadOpSplitter : public OpSplitter<LoadOpSplitter> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3623</td>
    <td class="codeline">    AAMDNodes AATags;</td>
    <td class="lineNumber">3623</td>
    <td class="codeline">    AAMDNodes AATags;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3624</td>
    <td class="codeline"></td>
    <td class="lineNumber">3624</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3625</td>
    <td class="codeline">    LoadOpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
    <td class="lineNumber">3625</td>
    <td class="codeline">    LoadOpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3626</td>
    <td class="codeline">                   AAMDNodes AATags, Align BaseAlign, const DataLayout &DL,</td>
    <td class="lineNumber">3626</td>
    <td class="codeline">                   AAMDNodes AATags, Align BaseAlign, const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3627</td>
    <td class="codeline">                   IRBuilderTy &IRB)</td>
    <td class="lineNumber">3627</td>
    <td class="codeline">                   IRBuilderTy &IRB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3628</td>
    <td class="codeline">        : OpSplitter<LoadOpSplitter>(InsertionPoint, Ptr, BaseTy, BaseAlign, DL,</td>
    <td class="lineNumber">3628</td>
    <td class="codeline">        : OpSplitter<LoadOpSplitter>(InsertionPoint, Ptr, BaseTy, BaseAlign, DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3629</td>
    <td class="codeline">                                     IRB),</td>
    <td class="lineNumber">3629</td>
    <td class="codeline">                                     IRB),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3630</td>
    <td class="codeline">          AATags(AATags) {}</td>
    <td class="lineNumber">3630</td>
    <td class="codeline">          AATags(AATags) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3631</td>
    <td class="codeline"></td>
    <td class="lineNumber">3631</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3632</td>
    <td class="codeline">    /// Emit a leaf load of a single value. This is called at the leaves of the</td>
    <td class="lineNumber">3632</td>
    <td class="codeline">    /// Emit a leaf load of a single value. This is called at the leaves of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3633</td>
    <td class="codeline">    /// recursive emission to actually load values.</td>
    <td class="lineNumber">3633</td>
    <td class="codeline">    /// recursive emission to actually load values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3634</td>
    <td class="codeline">    void emitFunc(Type *Ty, Value *&Agg, Align Alignment, const Twine &Name) {</td>
    <td class="lineNumber">3634</td>
    <td class="codeline">    void emitFunc(Type *Ty, Value *&Agg, Align Alignment, const Twine &Name) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3635</td>
    <td class="codeline">      assert(Ty->isSingleValueType());</td>
    <td class="lineNumber">3635</td>
    <td class="codeline">      assert(Ty->isSingleValueType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3636</td>
    <td class="codeline">      // Load the single value and insert it using the indices.</td>
    <td class="lineNumber">3636</td>
    <td class="codeline">      // Load the single value and insert it using the indices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3637</td>
    <td class="codeline">      Value *GEP =</td>
    <td class="lineNumber">3637</td>
    <td class="codeline">      Value *GEP =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3638</td>
    <td class="codeline">          IRB.CreateInBoundsGEP(BaseTy, Ptr, GEPIndices, Name + ".gep");</td>
    <td class="lineNumber">3638</td>
    <td class="codeline">          IRB.CreateInBoundsGEP(BaseTy, Ptr, GEPIndices, Name + ".gep");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3639</td>
    <td class="codeline">      LoadInst *Load =</td>
    <td class="lineNumber">3639</td>
    <td class="codeline">      LoadInst *Load =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3640</td>
    <td class="codeline">          IRB.CreateAlignedLoad(Ty, GEP, Alignment, Name + ".load");</td>
    <td class="lineNumber">3640</td>
    <td class="codeline">          IRB.CreateAlignedLoad(Ty, GEP, Alignment, Name + ".load");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3641</td>
    <td class="codeline"></td>
    <td class="lineNumber">3641</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3642</td>
    <td class="codeline">      APInt Offset(</td>
    <td class="lineNumber">3642</td>
    <td class="codeline">      APInt Offset(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3643</td>
    <td class="codeline">          DL.getIndexSizeInBits(Ptr->getType()->getPointerAddressSpace()), 0);</td>
    <td class="lineNumber">3643</td>
    <td class="codeline">          DL.getIndexSizeInBits(Ptr->getType()->getPointerAddressSpace()), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3644</td>
    <td class="codeline">      if (AATags &&</td>
    <td class="lineNumber">3644</td>
    <td class="codeline">      if (AATags &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3645</td>
    <td class="codeline">          GEPOperator::accumulateConstantOffset(BaseTy, GEPIndices, DL, Offset))</td>
    <td class="lineNumber">3645</td>
    <td class="codeline">          GEPOperator::accumulateConstantOffset(BaseTy, GEPIndices, DL, Offset))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3646</td>
    <td class="codeline">        Load->setAAMetadata(AATags.shift(Offset.getZExtValue()));</td>
    <td class="lineNumber">3646</td>
    <td class="codeline">        Load->setAAMetadata(AATags.shift(Offset.getZExtValue()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3647</td>
    <td class="codeline"></td>
    <td class="lineNumber">3647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3648</td>
    <td class="codeline">      Agg = IRB.CreateInsertValue(Agg, Load, Indices, Name + ".insert");</td>
    <td class="lineNumber">3648</td>
    <td class="codeline">      Agg = IRB.CreateInsertValue(Agg, Load, Indices, Name + ".insert");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3649</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "          to: " << *Load << "\n");</td>
    <td class="lineNumber">3649</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "          to: " << *Load << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3650</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3650</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3651</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">3651</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3652</td>
    <td class="codeline"></td>
    <td class="lineNumber">3652</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3653</td>
    <td class="codeline">  bool visitLoadInst(LoadInst &LI) {</td>
    <td class="lineNumber">3653</td>
    <td class="codeline">  bool visitLoadInst(LoadInst &LI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3654</td>
    <td class="codeline">    assert(LI.getPointerOperand() == *U);</td>
    <td class="lineNumber">3654</td>
    <td class="codeline">    assert(LI.getPointerOperand() == *U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3655</td>
    <td class="codeline">    if (!LI.isSimple() || LI.getType()->isSingleValueType())</td>
    <td class="lineNumber">3655</td>
    <td class="codeline">    if (!LI.isSimple() || LI.getType()->isSingleValueType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3656</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3656</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3657</td>
    <td class="codeline"></td>
    <td class="lineNumber">3657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3658</td>
    <td class="codeline">    // We have an aggregate being loaded, split it apart.</td>
    <td class="lineNumber">3658</td>
    <td class="codeline">    // We have an aggregate being loaded, split it apart.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3659</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << LI << "\n");</td>
    <td class="lineNumber">3659</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << LI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3660</td>
    <td class="codeline">    LoadOpSplitter Splitter(&LI, *U, LI.getType(), LI.getAAMetadata(),</td>
    <td class="lineNumber">3660</td>
    <td class="codeline">    LoadOpSplitter Splitter(&LI, *U, LI.getType(), LI.getAAMetadata(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3661</td>
    <td class="codeline">                            getAdjustedAlignment(&LI, 0), DL, IRB);</td>
    <td class="lineNumber">3661</td>
    <td class="codeline">                            getAdjustedAlignment(&LI, 0), DL, IRB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3662</td>
    <td class="codeline">    Value *V = PoisonValue::get(LI.getType());</td>
    <td class="lineNumber">3662</td>
    <td class="codeline">    Value *V = PoisonValue::get(LI.getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3663</td>
    <td class="codeline">    Splitter.emitSplitOps(LI.getType(), V, LI.getName() + ".fca");</td>
    <td class="lineNumber">3663</td>
    <td class="codeline">    Splitter.emitSplitOps(LI.getType(), V, LI.getName() + ".fca");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3664</td>
    <td class="codeline">    Visited.erase(&LI);</td>
    <td class="lineNumber">3664</td>
    <td class="codeline">    Visited.erase(&LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3665</td>
    <td class="codeline">    LI.replaceAllUsesWith(V);</td>
    <td class="lineNumber">3665</td>
    <td class="codeline">    LI.replaceAllUsesWith(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3666</td>
    <td class="codeline">    LI.eraseFromParent();</td>
    <td class="lineNumber">3666</td>
    <td class="codeline">    LI.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3667</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">3667</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3668</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3668</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3669</td>
    <td class="codeline"></td>
    <td class="lineNumber">3669</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3670</td>
    <td class="codeline">  struct StoreOpSplitter : public OpSplitter<StoreOpSplitter> {</td>
    <td class="lineNumber">3670</td>
    <td class="codeline">  struct StoreOpSplitter : public OpSplitter<StoreOpSplitter> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3671</td>
    <td class="codeline">    StoreOpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
    <td class="lineNumber">3671</td>
    <td class="codeline">    StoreOpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3672</td>
    <td class="codeline">                    AAMDNodes AATags, StoreInst *AggStore, Align BaseAlign,</td>
    <td class="lineNumber">3672</td>
    <td class="codeline">                    AAMDNodes AATags, StoreInst *AggStore, Align BaseAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3673</td>
    <td class="codeline">                    const DataLayout &DL, IRBuilderTy &IRB)</td>
    <td class="lineNumber">3673</td>
    <td class="codeline">                    const DataLayout &DL, IRBuilderTy &IRB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3674</td>
    <td class="codeline">        : OpSplitter<StoreOpSplitter>(InsertionPoint, Ptr, BaseTy, BaseAlign,</td>
    <td class="lineNumber">3674</td>
    <td class="codeline">        : OpSplitter<StoreOpSplitter>(InsertionPoint, Ptr, BaseTy, BaseAlign,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3675</td>
    <td class="codeline">                                      DL, IRB),</td>
    <td class="lineNumber">3675</td>
    <td class="codeline">                                      DL, IRB),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3676</td>
    <td class="codeline">          AATags(AATags), AggStore(AggStore) {}</td>
    <td class="lineNumber">3676</td>
    <td class="codeline">          AATags(AATags), AggStore(AggStore) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3677</td>
    <td class="codeline">    AAMDNodes AATags;</td>
    <td class="lineNumber">3677</td>
    <td class="codeline">    AAMDNodes AATags;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3678</td>
    <td class="codeline">    StoreInst *AggStore;</td>
    <td class="lineNumber">3678</td>
    <td class="codeline">    StoreInst *AggStore;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3679</td>
    <td class="codeline">    /// Emit a leaf store of a single value. This is called at the leaves of the</td>
    <td class="lineNumber">3679</td>
    <td class="codeline">    /// Emit a leaf store of a single value. This is called at the leaves of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3680</td>
    <td class="codeline">    /// recursive emission to actually produce stores.</td>
    <td class="lineNumber">3680</td>
    <td class="codeline">    /// recursive emission to actually produce stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3681</td>
    <td class="codeline">    void emitFunc(Type *Ty, Value *&Agg, Align Alignment, const Twine &Name) {</td>
    <td class="lineNumber">3681</td>
    <td class="codeline">    void emitFunc(Type *Ty, Value *&Agg, Align Alignment, const Twine &Name) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3682</td>
    <td class="codeline">      assert(Ty->isSingleValueType());</td>
    <td class="lineNumber">3682</td>
    <td class="codeline">      assert(Ty->isSingleValueType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3683</td>
    <td class="codeline">      // Extract the single value and store it using the indices.</td>
    <td class="lineNumber">3683</td>
    <td class="codeline">      // Extract the single value and store it using the indices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3684</td>
    <td class="codeline">      //</td>
    <td class="lineNumber">3684</td>
    <td class="codeline">      //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3685</td>
    <td class="codeline">      // The gep and extractvalue values are factored out of the CreateStore</td>
    <td class="lineNumber">3685</td>
    <td class="codeline">      // The gep and extractvalue values are factored out of the CreateStore</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3686</td>
    <td class="codeline">      // call to make the output independent of the argument evaluation order.</td>
    <td class="lineNumber">3686</td>
    <td class="codeline">      // call to make the output independent of the argument evaluation order.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3687</td>
    <td class="codeline">      Value *ExtractValue =</td>
    <td class="lineNumber">3687</td>
    <td class="codeline">      Value *ExtractValue =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3688</td>
    <td class="codeline">          IRB.CreateExtractValue(Agg, Indices, Name + ".extract");</td>
    <td class="lineNumber">3688</td>
    <td class="codeline">          IRB.CreateExtractValue(Agg, Indices, Name + ".extract");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3689</td>
    <td class="codeline">      Value *InBoundsGEP =</td>
    <td class="lineNumber">3689</td>
    <td class="codeline">      Value *InBoundsGEP =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3690</td>
    <td class="codeline">          IRB.CreateInBoundsGEP(BaseTy, Ptr, GEPIndices, Name + ".gep");</td>
    <td class="lineNumber">3690</td>
    <td class="codeline">          IRB.CreateInBoundsGEP(BaseTy, Ptr, GEPIndices, Name + ".gep");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3691</td>
    <td class="codeline">      StoreInst *Store =</td>
    <td class="lineNumber">3691</td>
    <td class="codeline">      StoreInst *Store =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3692</td>
    <td class="codeline">          IRB.CreateAlignedStore(ExtractValue, InBoundsGEP, Alignment);</td>
    <td class="lineNumber">3692</td>
    <td class="codeline">          IRB.CreateAlignedStore(ExtractValue, InBoundsGEP, Alignment);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3693</td>
    <td class="codeline"></td>
    <td class="lineNumber">3693</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3694</td>
    <td class="codeline">      APInt Offset(</td>
    <td class="lineNumber">3694</td>
    <td class="codeline">      APInt Offset(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3695</td>
    <td class="codeline">          DL.getIndexSizeInBits(Ptr->getType()->getPointerAddressSpace()), 0);</td>
    <td class="lineNumber">3695</td>
    <td class="codeline">          DL.getIndexSizeInBits(Ptr->getType()->getPointerAddressSpace()), 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3696</td>
    <td class="codeline">      GEPOperator::accumulateConstantOffset(BaseTy, GEPIndices, DL, Offset);</td>
    <td class="lineNumber">3696</td>
    <td class="codeline">      GEPOperator::accumulateConstantOffset(BaseTy, GEPIndices, DL, Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3697</td>
    <td class="codeline">      if (AATags)</td>
    <td class="lineNumber">3697</td>
    <td class="codeline">      if (AATags)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3698</td>
    <td class="codeline">        Store->setAAMetadata(AATags.shift(Offset.getZExtValue()));</td>
    <td class="lineNumber">3698</td>
    <td class="codeline">        Store->setAAMetadata(AATags.shift(Offset.getZExtValue()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3699</td>
    <td class="codeline"></td>
    <td class="lineNumber">3699</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3700</td>
    <td class="codeline">      // migrateDebugInfo requires the base Alloca. Walk to it from this gep.</td>
    <td class="lineNumber">3700</td>
    <td class="codeline">      // migrateDebugInfo requires the base Alloca. Walk to it from this gep.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3701</td>
    <td class="codeline">      // If we cannot (because there's an intervening non-const or unbounded</td>
    <td class="lineNumber">3701</td>
    <td class="codeline">      // If we cannot (because there's an intervening non-const or unbounded</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3702</td>
    <td class="codeline">      // gep) then we wouldn't expect to see dbg.assign intrinsics linked to</td>
    <td class="lineNumber">3702</td>
    <td class="codeline">      // gep) then we wouldn't expect to see dbg.assign intrinsics linked to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3703</td>
    <td class="codeline">      // this instruction.</td>
    <td class="lineNumber">3703</td>
    <td class="codeline">      // this instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3704</td>
    <td class="codeline">      Value *Base = AggStore->getPointerOperand()->stripInBoundsOffsets();</td>
    <td class="lineNumber">3704</td>
    <td class="codeline">      Value *Base = AggStore->getPointerOperand()->stripInBoundsOffsets();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3705</td>
    <td class="codeline">      if (auto *OldAI = dyn_cast<AllocaInst>(Base)) {</td>
    <td class="lineNumber">3705</td>
    <td class="codeline">      if (auto *OldAI = dyn_cast<AllocaInst>(Base)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3706</td>
    <td class="codeline">        uint64_t SizeInBits =</td>
    <td class="lineNumber">3706</td>
    <td class="codeline">        uint64_t SizeInBits =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3707</td>
    <td class="codeline">            DL.getTypeSizeInBits(Store->getValueOperand()->getType());</td>
    <td class="lineNumber">3707</td>
    <td class="codeline">            DL.getTypeSizeInBits(Store->getValueOperand()->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3708</td>
    <td class="codeline">        migrateDebugInfo(OldAI, /*IsSplit*/ true, Offset.getZExtValue() * 8,</td>
    <td class="lineNumber">3708</td>
    <td class="codeline">        migrateDebugInfo(OldAI, /*IsSplit*/ true, Offset.getZExtValue() * 8,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3709</td>
    <td class="codeline">                         SizeInBits, AggStore, Store,</td>
    <td class="lineNumber">3709</td>
    <td class="codeline">                         SizeInBits, AggStore, Store,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3710</td>
    <td class="codeline">                         Store->getPointerOperand(), Store->getValueOperand(),</td>
    <td class="lineNumber">3710</td>
    <td class="codeline">                         Store->getPointerOperand(), Store->getValueOperand(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3711</td>
    <td class="codeline">                         DL);</td>
    <td class="lineNumber">3711</td>
    <td class="codeline">                         DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3712</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">3712</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3713</td>
    <td class="codeline">        assert(at::getAssignmentMarkers(Store).empty() &&</td>
    <td class="lineNumber">3713</td>
    <td class="codeline">        assert(at::getAssignmentMarkers(Store).empty() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3714</td>
    <td class="codeline">               "AT: unexpected debug.assign linked to store through "</td>
    <td class="lineNumber">3714</td>
    <td class="codeline">               "AT: unexpected debug.assign linked to store through "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3715</td>
    <td class="codeline">               "unbounded GEP");</td>
    <td class="lineNumber">3715</td>
    <td class="codeline">               "unbounded GEP");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3716</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3716</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3717</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td class="lineNumber">3717</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3718</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3718</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3719</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">3719</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3720</td>
    <td class="codeline"></td>
    <td class="lineNumber">3720</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3721</td>
    <td class="codeline">  bool visitStoreInst(StoreInst &SI) {</td>
    <td class="lineNumber">3721</td>
    <td class="codeline">  bool visitStoreInst(StoreInst &SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3722</td>
    <td class="codeline">    if (!SI.isSimple() || SI.getPointerOperand() != *U)</td>
    <td class="lineNumber">3722</td>
    <td class="codeline">    if (!SI.isSimple() || SI.getPointerOperand() != *U)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3723</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3723</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3724</td>
    <td class="codeline">    Value *V = SI.getValueOperand();</td>
    <td class="lineNumber">3724</td>
    <td class="codeline">    Value *V = SI.getValueOperand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3725</td>
    <td class="codeline">    if (V->getType()->isSingleValueType())</td>
    <td class="lineNumber">3725</td>
    <td class="codeline">    if (V->getType()->isSingleValueType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3726</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3726</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3727</td>
    <td class="codeline"></td>
    <td class="lineNumber">3727</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3728</td>
    <td class="codeline">    // We have an aggregate being stored, split it apart.</td>
    <td class="lineNumber">3728</td>
    <td class="codeline">    // We have an aggregate being stored, split it apart.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3729</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
    <td class="lineNumber">3729</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3730</td>
    <td class="codeline">    StoreOpSplitter Splitter(&SI, *U, V->getType(), SI.getAAMetadata(), &SI,</td>
    <td class="lineNumber">3730</td>
    <td class="codeline">    StoreOpSplitter Splitter(&SI, *U, V->getType(), SI.getAAMetadata(), &SI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3731</td>
    <td class="codeline">                             getAdjustedAlignment(&SI, 0), DL, IRB);</td>
    <td class="lineNumber">3731</td>
    <td class="codeline">                             getAdjustedAlignment(&SI, 0), DL, IRB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3732</td>
    <td class="codeline">    Splitter.emitSplitOps(V->getType(), V, V->getName() + ".fca");</td>
    <td class="lineNumber">3732</td>
    <td class="codeline">    Splitter.emitSplitOps(V->getType(), V, V->getName() + ".fca");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3733</td>
    <td class="codeline">    Visited.erase(&SI);</td>
    <td class="lineNumber">3733</td>
    <td class="codeline">    Visited.erase(&SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3734</td>
    <td class="codeline">    // The stores replacing SI each have markers describing fragments of the</td>
    <td class="lineNumber">3734</td>
    <td class="codeline">    // The stores replacing SI each have markers describing fragments of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3735</td>
    <td class="codeline">    // assignment so delete the assignment markers linked to SI.</td>
    <td class="lineNumber">3735</td>
    <td class="codeline">    // assignment so delete the assignment markers linked to SI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3736</td>
    <td class="codeline">    at::deleteAssignmentMarkers(&SI);</td>
    <td class="lineNumber">3736</td>
    <td class="codeline">    at::deleteAssignmentMarkers(&SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3737</td>
    <td class="codeline">    SI.eraseFromParent();</td>
    <td class="lineNumber">3737</td>
    <td class="codeline">    SI.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3738</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">3738</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3739</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3739</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3740</td>
    <td class="codeline"></td>
    <td class="lineNumber">3740</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3741</td>
    <td class="codeline">  bool visitBitCastInst(BitCastInst &BC) {</td>
    <td class="lineNumber">3741</td>
    <td class="codeline">  bool visitBitCastInst(BitCastInst &BC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3742</td>
    <td class="codeline">    enqueueUsers(BC);</td>
    <td class="lineNumber">3742</td>
    <td class="codeline">    enqueueUsers(BC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3743</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3743</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3744</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3744</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3745</td>
    <td class="codeline"></td>
    <td class="lineNumber">3745</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3746</td>
    <td class="codeline">  bool visitAddrSpaceCastInst(AddrSpaceCastInst &ASC) {</td>
    <td class="lineNumber">3746</td>
    <td class="codeline">  bool visitAddrSpaceCastInst(AddrSpaceCastInst &ASC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3747</td>
    <td class="codeline">    enqueueUsers(ASC);</td>
    <td class="lineNumber">3747</td>
    <td class="codeline">    enqueueUsers(ASC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3748</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3748</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3749</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3749</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3750</td>
    <td class="codeline"></td>
    <td class="lineNumber">3750</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3751</td>
    <td class="codeline">  // Fold gep (select cond, ptr1, ptr2) => select cond, gep(ptr1), gep(ptr2)</td>
    <td class="lineNumber">3751</td>
    <td class="codeline">  // Fold gep (select cond, ptr1, ptr2) => select cond, gep(ptr1), gep(ptr2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3752</td>
    <td class="codeline">  bool foldGEPSelect(GetElementPtrInst &GEPI) {</td>
    <td class="lineNumber">3752</td>
    <td class="codeline">  bool foldGEPSelect(GetElementPtrInst &GEPI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3753</td>
    <td class="codeline">    if (!GEPI.hasAllConstantIndices())</td>
    <td class="lineNumber">3753</td>
    <td class="codeline">    if (!GEPI.hasAllConstantIndices())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3754</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3754</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3755</td>
    <td class="codeline"></td>
    <td class="lineNumber">3755</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3756</td>
    <td class="codeline">    SelectInst *Sel = cast<SelectInst>(GEPI.getPointerOperand());</td>
    <td class="lineNumber">3756</td>
    <td class="codeline">    SelectInst *Sel = cast<SelectInst>(GEPI.getPointerOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3757</td>
    <td class="codeline"></td>
    <td class="lineNumber">3757</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3758</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  Rewriting gep(select) -> select(gep):"</td>
    <td class="lineNumber">3758</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  Rewriting gep(select) -> select(gep):"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3759</td>
    <td class="codeline">                      << "\n    original: " << *Sel</td>
    <td class="lineNumber">3759</td>
    <td class="codeline">                      << "\n    original: " << *Sel</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3760</td>
    <td class="codeline">                      << "\n              " << GEPI);</td>
    <td class="lineNumber">3760</td>
    <td class="codeline">                      << "\n              " << GEPI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3761</td>
    <td class="codeline"></td>
    <td class="lineNumber">3761</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3762</td>
    <td class="codeline">    IRB.SetInsertPoint(&GEPI);</td>
    <td class="lineNumber">3762</td>
    <td class="codeline">    IRB.SetInsertPoint(&GEPI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3763</td>
    <td class="codeline">    SmallVector<Value *, 4> Index(GEPI.indices());</td>
    <td class="lineNumber">3763</td>
    <td class="codeline">    SmallVector<Value *, 4> Index(GEPI.indices());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3764</td>
    <td class="codeline">    bool IsInBounds = GEPI.isInBounds();</td>
    <td class="lineNumber">3764</td>
    <td class="codeline">    bool IsInBounds = GEPI.isInBounds();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3765</td>
    <td class="codeline"></td>
    <td class="lineNumber">3765</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3766</td>
    <td class="codeline">    Type *Ty = GEPI.getSourceElementType();</td>
    <td class="lineNumber">3766</td>
    <td class="codeline">    Type *Ty = GEPI.getSourceElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3767</td>
    <td class="codeline">    Value *True = Sel->getTrueValue();</td>
    <td class="lineNumber">3767</td>
    <td class="codeline">    Value *True = Sel->getTrueValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3768</td>
    <td class="codeline">    Value *NTrue = IRB.CreateGEP(Ty, True, Index, True->getName() + ".sroa.gep",</td>
    <td class="lineNumber">3768</td>
    <td class="codeline">    Value *NTrue = IRB.CreateGEP(Ty, True, Index, True->getName() + ".sroa.gep",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3769</td>
    <td class="codeline">                                 IsInBounds);</td>
    <td class="lineNumber">3769</td>
    <td class="codeline">                                 IsInBounds);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3770</td>
    <td class="codeline"></td>
    <td class="lineNumber">3770</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3771</td>
    <td class="codeline">    Value *False = Sel->getFalseValue();</td>
    <td class="lineNumber">3771</td>
    <td class="codeline">    Value *False = Sel->getFalseValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3772</td>
    <td class="codeline"></td>
    <td class="lineNumber">3772</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3773</td>
    <td class="codeline">    Value *NFalse = IRB.CreateGEP(Ty, False, Index,</td>
    <td class="lineNumber">3773</td>
    <td class="codeline">    Value *NFalse = IRB.CreateGEP(Ty, False, Index,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3774</td>
    <td class="codeline">                                  False->getName() + ".sroa.gep", IsInBounds);</td>
    <td class="lineNumber">3774</td>
    <td class="codeline">                                  False->getName() + ".sroa.gep", IsInBounds);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3775</td>
    <td class="codeline"></td>
    <td class="lineNumber">3775</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3776</td>
    <td class="codeline">    Value *NSel = IRB.CreateSelect(Sel->getCondition(), NTrue, NFalse,</td>
    <td class="lineNumber">3776</td>
    <td class="codeline">    Value *NSel = IRB.CreateSelect(Sel->getCondition(), NTrue, NFalse,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3777</td>
    <td class="codeline">                                   Sel->getName() + ".sroa.sel");</td>
    <td class="lineNumber">3777</td>
    <td class="codeline">                                   Sel->getName() + ".sroa.sel");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3778</td>
    <td class="codeline">    Visited.erase(&GEPI);</td>
    <td class="lineNumber">3778</td>
    <td class="codeline">    Visited.erase(&GEPI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3779</td>
    <td class="codeline">    GEPI.replaceAllUsesWith(NSel);</td>
    <td class="lineNumber">3779</td>
    <td class="codeline">    GEPI.replaceAllUsesWith(NSel);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3780</td>
    <td class="codeline">    GEPI.eraseFromParent();</td>
    <td class="lineNumber">3780</td>
    <td class="codeline">    GEPI.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3781</td>
    <td class="codeline">    Instruction *NSelI = cast<Instruction>(NSel);</td>
    <td class="lineNumber">3781</td>
    <td class="codeline">    Instruction *NSelI = cast<Instruction>(NSel);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3782</td>
    <td class="codeline">    Visited.insert(NSelI);</td>
    <td class="lineNumber">3782</td>
    <td class="codeline">    Visited.insert(NSelI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3783</td>
    <td class="codeline">    enqueueUsers(*NSelI);</td>
    <td class="lineNumber">3783</td>
    <td class="codeline">    enqueueUsers(*NSelI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3784</td>
    <td class="codeline"></td>
    <td class="lineNumber">3784</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3785</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "\n          to: " << *NTrue</td>
    <td class="lineNumber">3785</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "\n          to: " << *NTrue</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3786</td>
    <td class="codeline">                      << "\n              " << *NFalse</td>
    <td class="lineNumber">3786</td>
    <td class="codeline">                      << "\n              " << *NFalse</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3787</td>
    <td class="codeline">                      << "\n              " << *NSel << '\n');</td>
    <td class="lineNumber">3787</td>
    <td class="codeline">                      << "\n              " << *NSel << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3788</td>
    <td class="codeline"></td>
    <td class="lineNumber">3788</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3789</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">3789</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3790</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3790</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3791</td>
    <td class="codeline"></td>
    <td class="lineNumber">3791</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3792</td>
    <td class="codeline">  // Fold gep (phi ptr1, ptr2) => phi gep(ptr1), gep(ptr2)</td>
    <td class="lineNumber">3792</td>
    <td class="codeline">  // Fold gep (phi ptr1, ptr2) => phi gep(ptr1), gep(ptr2)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3793</td>
    <td class="codeline">  bool foldGEPPhi(GetElementPtrInst &GEPI) {</td>
    <td class="lineNumber">3793</td>
    <td class="codeline">  bool foldGEPPhi(GetElementPtrInst &GEPI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3794</td>
    <td class="codeline">    if (!GEPI.hasAllConstantIndices())</td>
    <td class="lineNumber">3794</td>
    <td class="codeline">    if (!GEPI.hasAllConstantIndices())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3795</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3795</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3796</td>
    <td class="codeline"></td>
    <td class="lineNumber">3796</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3797</td>
    <td class="codeline">    PHINode *PHI = cast<PHINode>(GEPI.getPointerOperand());</td>
    <td class="lineNumber">3797</td>
    <td class="codeline">    PHINode *PHI = cast<PHINode>(GEPI.getPointerOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3798</td>
    <td class="codeline">    if (GEPI.getParent() != PHI->getParent() ||</td>
    <td class="lineNumber">3798</td>
    <td class="codeline">    if (GEPI.getParent() != PHI->getParent() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3799</td>
    <td class="codeline">        llvm::any_of(PHI->incoming_values(), [](Value *In)</td>
    <td class="lineNumber">3799</td>
    <td class="codeline">        llvm::any_of(PHI->incoming_values(), [](Value *In)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3800</td>
    <td class="codeline">          { Instruction *I = dyn_cast<Instruction>(In);</td>
    <td class="lineNumber">3800</td>
    <td class="codeline">          { Instruction *I = dyn_cast<Instruction>(In);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3801</td>
    <td class="codeline">            return !I || isa<GetElementPtrInst>(I) || isa<PHINode>(I) ||</td>
    <td class="lineNumber">3801</td>
    <td class="codeline">            return !I || isa<GetElementPtrInst>(I) || isa<PHINode>(I) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3802</td>
    <td class="codeline">                   succ_empty(I->getParent()) ||</td>
    <td class="lineNumber">3802</td>
    <td class="codeline">                   succ_empty(I->getParent()) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3803</td>
    <td class="codeline">                   !I->getParent()->isLegalToHoistInto();</td>
    <td class="lineNumber">3803</td>
    <td class="codeline">                   !I->getParent()->isLegalToHoistInto();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3804</td>
    <td class="codeline">          }))</td>
    <td class="lineNumber">3804</td>
    <td class="codeline">          }))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3805</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">3805</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3806</td>
    <td class="codeline"></td>
    <td class="lineNumber">3806</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3807</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  Rewriting gep(phi) -> phi(gep):"</td>
    <td class="lineNumber">3807</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  Rewriting gep(phi) -> phi(gep):"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3808</td>
    <td class="codeline">                      << "\n    original: " << *PHI</td>
    <td class="lineNumber">3808</td>
    <td class="codeline">                      << "\n    original: " << *PHI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3809</td>
    <td class="codeline">                      << "\n              " << GEPI</td>
    <td class="lineNumber">3809</td>
    <td class="codeline">                      << "\n              " << GEPI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3810</td>
    <td class="codeline">                      << "\n          to: ");</td>
    <td class="lineNumber">3810</td>
    <td class="codeline">                      << "\n          to: ");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3811</td>
    <td class="codeline"></td>
    <td class="lineNumber">3811</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3812</td>
    <td class="codeline">    SmallVector<Value *, 4> Index(GEPI.indices());</td>
    <td class="lineNumber">3812</td>
    <td class="codeline">    SmallVector<Value *, 4> Index(GEPI.indices());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3813</td>
    <td class="codeline">    bool IsInBounds = GEPI.isInBounds();</td>
    <td class="lineNumber">3813</td>
    <td class="codeline">    bool IsInBounds = GEPI.isInBounds();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3814</td>
    <td class="codeline">    IRB.SetInsertPoint(GEPI.getParent()->getFirstNonPHI());</td>
    <td class="lineNumber">3814</td>
    <td class="codeline">    IRB.SetInsertPoint(GEPI.getParent()->getFirstNonPHI());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3815</td>
    <td class="codeline">    PHINode *NewPN = IRB.CreatePHI(GEPI.getType(), PHI->getNumIncomingValues(),</td>
    <td class="lineNumber">3815</td>
    <td class="codeline">    PHINode *NewPN = IRB.CreatePHI(GEPI.getType(), PHI->getNumIncomingValues(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3816</td>
    <td class="codeline">                                   PHI->getName() + ".sroa.phi");</td>
    <td class="lineNumber">3816</td>
    <td class="codeline">                                   PHI->getName() + ".sroa.phi");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3817</td>
    <td class="codeline">    for (unsigned I = 0, E = PHI->getNumIncomingValues(); I != E; ++I) {</td>
    <td class="lineNumber">3817</td>
    <td class="codeline">    for (unsigned I = 0, E = PHI->getNumIncomingValues(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3818</td>
    <td class="codeline">      BasicBlock *B = PHI->getIncomingBlock(I);</td>
    <td class="lineNumber">3818</td>
    <td class="codeline">      BasicBlock *B = PHI->getIncomingBlock(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3819</td>
    <td class="codeline">      Value *NewVal = nullptr;</td>
    <td class="lineNumber">3819</td>
    <td class="codeline">      Value *NewVal = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3820</td>
    <td class="codeline">      int Idx = NewPN->getBasicBlockIndex(B);</td>
    <td class="lineNumber">3820</td>
    <td class="codeline">      int Idx = NewPN->getBasicBlockIndex(B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3821</td>
    <td class="codeline">      if (Idx >= 0) {</td>
    <td class="lineNumber">3821</td>
    <td class="codeline">      if (Idx >= 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3822</td>
    <td class="codeline">        NewVal = NewPN->getIncomingValue(Idx);</td>
    <td class="lineNumber">3822</td>
    <td class="codeline">        NewVal = NewPN->getIncomingValue(Idx);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3823</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">3823</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3824</td>
    <td class="codeline">        Instruction *In = cast<Instruction>(PHI->getIncomingValue(I));</td>
    <td class="lineNumber">3824</td>
    <td class="codeline">        Instruction *In = cast<Instruction>(PHI->getIncomingValue(I));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3825</td>
    <td class="codeline"></td>
    <td class="lineNumber">3825</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3826</td>
    <td class="codeline">        IRB.SetInsertPoint(In->getParent(), std::next(In->getIterator()));</td>
    <td class="lineNumber">3826</td>
    <td class="codeline">        IRB.SetInsertPoint(In->getParent(), std::next(In->getIterator()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3827</td>
    <td class="codeline">        Type *Ty = GEPI.getSourceElementType();</td>
    <td class="lineNumber">3827</td>
    <td class="codeline">        Type *Ty = GEPI.getSourceElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3828</td>
    <td class="codeline">        NewVal = IRB.CreateGEP(Ty, In, Index, In->getName() + ".sroa.gep",</td>
    <td class="lineNumber">3828</td>
    <td class="codeline">        NewVal = IRB.CreateGEP(Ty, In, Index, In->getName() + ".sroa.gep",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3829</td>
    <td class="codeline">                               IsInBounds);</td>
    <td class="lineNumber">3829</td>
    <td class="codeline">                               IsInBounds);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3830</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">3830</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3831</td>
    <td class="codeline">      NewPN->addIncoming(NewVal, B);</td>
    <td class="lineNumber">3831</td>
    <td class="codeline">      NewPN->addIncoming(NewVal, B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3832</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3832</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3833</td>
    <td class="codeline"></td>
    <td class="lineNumber">3833</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3834</td>
    <td class="codeline">    Visited.erase(&GEPI);</td>
    <td class="lineNumber">3834</td>
    <td class="codeline">    Visited.erase(&GEPI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3835</td>
    <td class="codeline">    GEPI.replaceAllUsesWith(NewPN);</td>
    <td class="lineNumber">3835</td>
    <td class="codeline">    GEPI.replaceAllUsesWith(NewPN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3836</td>
    <td class="codeline">    GEPI.eraseFromParent();</td>
    <td class="lineNumber">3836</td>
    <td class="codeline">    GEPI.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3837</td>
    <td class="codeline">    Visited.insert(NewPN);</td>
    <td class="lineNumber">3837</td>
    <td class="codeline">    Visited.insert(NewPN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3838</td>
    <td class="codeline">    enqueueUsers(*NewPN);</td>
    <td class="lineNumber">3838</td>
    <td class="codeline">    enqueueUsers(*NewPN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3839</td>
    <td class="codeline"></td>
    <td class="lineNumber">3839</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3840</td>
    <td class="codeline">    LLVM_DEBUG(for (Value *In : NewPN->incoming_values())</td>
    <td class="lineNumber">3840</td>
    <td class="codeline">    LLVM_DEBUG(for (Value *In : NewPN->incoming_values())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3841</td>
    <td class="codeline">                 dbgs() << "\n              " << *In;</td>
    <td class="lineNumber">3841</td>
    <td class="codeline">                 dbgs() << "\n              " << *In;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3842</td>
    <td class="codeline">               dbgs() << "\n              " << *NewPN << '\n');</td>
    <td class="lineNumber">3842</td>
    <td class="codeline">               dbgs() << "\n              " << *NewPN << '\n');</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3843</td>
    <td class="codeline"></td>
    <td class="lineNumber">3843</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3844</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">3844</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3845</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3845</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3846</td>
    <td class="codeline"></td>
    <td class="lineNumber">3846</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3847</td>
    <td class="codeline">  bool visitGetElementPtrInst(GetElementPtrInst &GEPI) {</td>
    <td class="lineNumber">3847</td>
    <td class="codeline">  bool visitGetElementPtrInst(GetElementPtrInst &GEPI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3848</td>
    <td class="codeline">    if (isa<SelectInst>(GEPI.getPointerOperand()) &&</td>
    <td class="lineNumber">3848</td>
    <td class="codeline">    if (isa<SelectInst>(GEPI.getPointerOperand()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3849</td>
    <td class="codeline">        foldGEPSelect(GEPI))</td>
    <td class="lineNumber">3849</td>
    <td class="codeline">        foldGEPSelect(GEPI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3850</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">3850</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3851</td>
    <td class="codeline"></td>
    <td class="lineNumber">3851</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3852</td>
    <td class="codeline">    if (isa<PHINode>(GEPI.getPointerOperand()) &&</td>
    <td class="lineNumber">3852</td>
    <td class="codeline">    if (isa<PHINode>(GEPI.getPointerOperand()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3853</td>
    <td class="codeline">        foldGEPPhi(GEPI))</td>
    <td class="lineNumber">3853</td>
    <td class="codeline">        foldGEPPhi(GEPI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3854</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">3854</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3855</td>
    <td class="codeline"></td>
    <td class="lineNumber">3855</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3856</td>
    <td class="codeline">    enqueueUsers(GEPI);</td>
    <td class="lineNumber">3856</td>
    <td class="codeline">    enqueueUsers(GEPI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3857</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3857</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3858</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3858</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3859</td>
    <td class="codeline"></td>
    <td class="lineNumber">3859</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3860</td>
    <td class="codeline">  bool visitPHINode(PHINode &PN) {</td>
    <td class="lineNumber">3860</td>
    <td class="codeline">  bool visitPHINode(PHINode &PN) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3861</td>
    <td class="codeline">    enqueueUsers(PN);</td>
    <td class="lineNumber">3861</td>
    <td class="codeline">    enqueueUsers(PN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3862</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3862</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3863</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3863</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3864</td>
    <td class="codeline"></td>
    <td class="lineNumber">3864</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3865</td>
    <td class="codeline">  bool visitSelectInst(SelectInst &SI) {</td>
    <td class="lineNumber">3865</td>
    <td class="codeline">  bool visitSelectInst(SelectInst &SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3866</td>
    <td class="codeline">    enqueueUsers(SI);</td>
    <td class="lineNumber">3866</td>
    <td class="codeline">    enqueueUsers(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3867</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">3867</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3868</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3868</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3869</td>
    <td class="codeline">};</td>
    <td class="lineNumber">3869</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3870</td>
    <td class="codeline"></td>
    <td class="lineNumber">3870</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3871</td>
    <td class="codeline">} // end anonymous namespace</td>
    <td class="lineNumber">3871</td>
    <td class="codeline">} // end anonymous namespace</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3872</td>
    <td class="codeline"></td>
    <td class="lineNumber">3872</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3873</td>
    <td class="codeline">/// Strip aggregate type wrapping.</td>
    <td class="lineNumber">3873</td>
    <td class="codeline">/// Strip aggregate type wrapping.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3874</td>
    <td class="codeline">///</td>
    <td class="lineNumber">3874</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3875</td>
    <td class="codeline">/// This removes no-op aggregate types wrapping an underlying type. It will</td>
    <td class="lineNumber">3875</td>
    <td class="codeline">/// This removes no-op aggregate types wrapping an underlying type. It will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3876</td>
    <td class="codeline">/// strip as many layers of types as it can without changing either the type</td>
    <td class="lineNumber">3876</td>
    <td class="codeline">/// strip as many layers of types as it can without changing either the type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3877</td>
    <td class="codeline">/// size or the allocated size.</td>
    <td class="lineNumber">3877</td>
    <td class="codeline">/// size or the allocated size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3878</td>
    <td class="codeline">static Type *stripAggregateTypeWrapping(const DataLayout &DL, Type *Ty) {</td>
    <td class="lineNumber">3878</td>
    <td class="codeline">static Type *stripAggregateTypeWrapping(const DataLayout &DL, Type *Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3879</td>
    <td class="codeline">  if (Ty->isSingleValueType())</td>
    <td class="lineNumber">3879</td>
    <td class="codeline">  if (Ty->isSingleValueType())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3880</td>
    <td class="codeline">    return Ty;</td>
    <td class="lineNumber">3880</td>
    <td class="codeline">    return Ty;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3881</td>
    <td class="codeline"></td>
    <td class="lineNumber">3881</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3882</td>
    <td class="codeline">  uint64_t AllocSize = DL.getTypeAllocSize(Ty).getFixedValue();</td>
    <td class="lineNumber">3882</td>
    <td class="codeline">  uint64_t AllocSize = DL.getTypeAllocSize(Ty).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3883</td>
    <td class="codeline">  uint64_t TypeSize = DL.getTypeSizeInBits(Ty).getFixedValue();</td>
    <td class="lineNumber">3883</td>
    <td class="codeline">  uint64_t TypeSize = DL.getTypeSizeInBits(Ty).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3884</td>
    <td class="codeline"></td>
    <td class="lineNumber">3884</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3885</td>
    <td class="codeline">  Type *InnerTy;</td>
    <td class="lineNumber">3885</td>
    <td class="codeline">  Type *InnerTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3886</td>
    <td class="codeline">  if (ArrayType *ArrTy = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">3886</td>
    <td class="codeline">  if (ArrayType *ArrTy = dyn_cast<ArrayType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3887</td>
    <td class="codeline">    InnerTy = ArrTy->getElementType();</td>
    <td class="lineNumber">3887</td>
    <td class="codeline">    InnerTy = ArrTy->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3888</td>
    <td class="codeline">  } else if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td class="lineNumber">3888</td>
    <td class="codeline">  } else if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3889</td>
    <td class="codeline">    const StructLayout *SL = DL.getStructLayout(STy);</td>
    <td class="lineNumber">3889</td>
    <td class="codeline">    const StructLayout *SL = DL.getStructLayout(STy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3890</td>
    <td class="codeline">    unsigned Index = SL->getElementContainingOffset(0);</td>
    <td class="lineNumber">3890</td>
    <td class="codeline">    unsigned Index = SL->getElementContainingOffset(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3891</td>
    <td class="codeline">    InnerTy = STy->getElementType(Index);</td>
    <td class="lineNumber">3891</td>
    <td class="codeline">    InnerTy = STy->getElementType(Index);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3892</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">3892</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3893</td>
    <td class="codeline">    return Ty;</td>
    <td class="lineNumber">3893</td>
    <td class="codeline">    return Ty;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3894</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3894</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3895</td>
    <td class="codeline"></td>
    <td class="lineNumber">3895</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3896</td>
    <td class="codeline">  if (AllocSize > DL.getTypeAllocSize(InnerTy).getFixedValue() ||</td>
    <td class="lineNumber">3896</td>
    <td class="codeline">  if (AllocSize > DL.getTypeAllocSize(InnerTy).getFixedValue() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3897</td>
    <td class="codeline">      TypeSize > DL.getTypeSizeInBits(InnerTy).getFixedValue())</td>
    <td class="lineNumber">3897</td>
    <td class="codeline">      TypeSize > DL.getTypeSizeInBits(InnerTy).getFixedValue())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3898</td>
    <td class="codeline">    return Ty;</td>
    <td class="lineNumber">3898</td>
    <td class="codeline">    return Ty;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3899</td>
    <td class="codeline"></td>
    <td class="lineNumber">3899</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3900</td>
    <td class="codeline">  return stripAggregateTypeWrapping(DL, InnerTy);</td>
    <td class="lineNumber">3900</td>
    <td class="codeline">  return stripAggregateTypeWrapping(DL, InnerTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3901</td>
    <td class="codeline">}</td>
    <td class="lineNumber">3901</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3902</td>
    <td class="codeline"></td>
    <td class="lineNumber">3902</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3903</td>
    <td class="codeline">/// Try to find a partition of the aggregate type passed in for a given</td>
    <td class="lineNumber">3903</td>
    <td class="codeline">/// Try to find a partition of the aggregate type passed in for a given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3904</td>
    <td class="codeline">/// offset and size.</td>
    <td class="lineNumber">3904</td>
    <td class="codeline">/// offset and size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3905</td>
    <td class="codeline">///</td>
    <td class="lineNumber">3905</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3906</td>
    <td class="codeline">/// This recurses through the aggregate type and tries to compute a subtype</td>
    <td class="lineNumber">3906</td>
    <td class="codeline">/// This recurses through the aggregate type and tries to compute a subtype</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3907</td>
    <td class="codeline">/// based on the offset and size. When the offset and size span a sub-section</td>
    <td class="lineNumber">3907</td>
    <td class="codeline">/// based on the offset and size. When the offset and size span a sub-section</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3908</td>
    <td class="codeline">/// of an array, it will even compute a new array type for that sub-section,</td>
    <td class="lineNumber">3908</td>
    <td class="codeline">/// of an array, it will even compute a new array type for that sub-section,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3909</td>
    <td class="codeline">/// and the same for structs.</td>
    <td class="lineNumber">3909</td>
    <td class="codeline">/// and the same for structs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3910</td>
    <td class="codeline">///</td>
    <td class="lineNumber">3910</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3911</td>
    <td class="codeline">/// Note that this routine is very strict and tries to find a partition of the</td>
    <td class="lineNumber">3911</td>
    <td class="codeline">/// Note that this routine is very strict and tries to find a partition of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3912</td>
    <td class="codeline">/// type which produces the *exact* right offset and size. It is not forgiving</td>
    <td class="lineNumber">3912</td>
    <td class="codeline">/// type which produces the *exact* right offset and size. It is not forgiving</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3913</td>
    <td class="codeline">/// when the size or offset cause either end of type-based partition to be off.</td>
    <td class="lineNumber">3913</td>
    <td class="codeline">/// when the size or offset cause either end of type-based partition to be off.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3914</td>
    <td class="codeline">/// Also, this is a best-effort routine. It is reasonable to give up and not</td>
    <td class="lineNumber">3914</td>
    <td class="codeline">/// Also, this is a best-effort routine. It is reasonable to give up and not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3915</td>
    <td class="codeline">/// return a type if necessary.</td>
    <td class="lineNumber">3915</td>
    <td class="codeline">/// return a type if necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3916</td>
    <td class="codeline">static Type *getTypePartition(const DataLayout &DL, Type *Ty, uint64_t Offset,</td>
    <td class="lineNumber">3916</td>
    <td class="codeline">static Type *getTypePartition(const DataLayout &DL, Type *Ty, uint64_t Offset,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3917</td>
    <td class="codeline">                              uint64_t Size) {</td>
    <td class="lineNumber">3917</td>
    <td class="codeline">                              uint64_t Size) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3918</td>
    <td class="codeline">  if (Offset == 0 && DL.getTypeAllocSize(Ty).getFixedValue() == Size)</td>
    <td class="lineNumber">3918</td>
    <td class="codeline">  if (Offset == 0 && DL.getTypeAllocSize(Ty).getFixedValue() == Size)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3919</td>
    <td class="codeline">    return stripAggregateTypeWrapping(DL, Ty);</td>
    <td class="lineNumber">3919</td>
    <td class="codeline">    return stripAggregateTypeWrapping(DL, Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3920</td>
    <td class="codeline">  if (Offset > DL.getTypeAllocSize(Ty).getFixedValue() ||</td>
    <td class="lineNumber">3920</td>
    <td class="codeline">  if (Offset > DL.getTypeAllocSize(Ty).getFixedValue() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3921</td>
    <td class="codeline">      (DL.getTypeAllocSize(Ty).getFixedValue() - Offset) < Size)</td>
    <td class="lineNumber">3921</td>
    <td class="codeline">      (DL.getTypeAllocSize(Ty).getFixedValue() - Offset) < Size)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3922</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">3922</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3923</td>
    <td class="codeline"></td>
    <td class="lineNumber">3923</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3924</td>
    <td class="codeline">  if (isa<ArrayType>(Ty) || isa<VectorType>(Ty)) {</td>
    <td class="lineNumber">3924</td>
    <td class="codeline">  if (isa<ArrayType>(Ty) || isa<VectorType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3925</td>
    <td class="codeline">     Type *ElementTy;</td>
    <td class="lineNumber">3925</td>
    <td class="codeline">     Type *ElementTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3926</td>
    <td class="codeline">     uint64_t TyNumElements;</td>
    <td class="lineNumber">3926</td>
    <td class="codeline">     uint64_t TyNumElements;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3927</td>
    <td class="codeline">     if (auto *AT = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">3927</td>
    <td class="codeline">     if (auto *AT = dyn_cast<ArrayType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3928</td>
    <td class="codeline">       ElementTy = AT->getElementType();</td>
    <td class="lineNumber">3928</td>
    <td class="codeline">       ElementTy = AT->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3929</td>
    <td class="codeline">       TyNumElements = AT->getNumElements();</td>
    <td class="lineNumber">3929</td>
    <td class="codeline">       TyNumElements = AT->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3930</td>
    <td class="codeline">     } else {</td>
    <td class="lineNumber">3930</td>
    <td class="codeline">     } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3931</td>
    <td class="codeline">       // FIXME: This isn't right for vectors with non-byte-sized or</td>
    <td class="lineNumber">3931</td>
    <td class="codeline">       // FIXME: This isn't right for vectors with non-byte-sized or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3932</td>
    <td class="codeline">       // non-power-of-two sized elements.</td>
    <td class="lineNumber">3932</td>
    <td class="codeline">       // non-power-of-two sized elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3933</td>
    <td class="codeline">       auto *VT = cast<FixedVectorType>(Ty);</td>
    <td class="lineNumber">3933</td>
    <td class="codeline">       auto *VT = cast<FixedVectorType>(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3934</td>
    <td class="codeline">       ElementTy = VT->getElementType();</td>
    <td class="lineNumber">3934</td>
    <td class="codeline">       ElementTy = VT->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3935</td>
    <td class="codeline">       TyNumElements = VT->getNumElements();</td>
    <td class="lineNumber">3935</td>
    <td class="codeline">       TyNumElements = VT->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3936</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3936</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3937</td>
    <td class="codeline">    uint64_t ElementSize = DL.getTypeAllocSize(ElementTy).getFixedValue();</td>
    <td class="lineNumber">3937</td>
    <td class="codeline">    uint64_t ElementSize = DL.getTypeAllocSize(ElementTy).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3938</td>
    <td class="codeline">    uint64_t NumSkippedElements = Offset / ElementSize;</td>
    <td class="lineNumber">3938</td>
    <td class="codeline">    uint64_t NumSkippedElements = Offset / ElementSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3939</td>
    <td class="codeline">    if (NumSkippedElements >= TyNumElements)</td>
    <td class="lineNumber">3939</td>
    <td class="codeline">    if (NumSkippedElements >= TyNumElements)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3940</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">3940</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3941</td>
    <td class="codeline">    Offset -= NumSkippedElements * ElementSize;</td>
    <td class="lineNumber">3941</td>
    <td class="codeline">    Offset -= NumSkippedElements * ElementSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3942</td>
    <td class="codeline"></td>
    <td class="lineNumber">3942</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3943</td>
    <td class="codeline">    // First check if we need to recurse.</td>
    <td class="lineNumber">3943</td>
    <td class="codeline">    // First check if we need to recurse.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3944</td>
    <td class="codeline">    if (Offset > 0 || Size < ElementSize) {</td>
    <td class="lineNumber">3944</td>
    <td class="codeline">    if (Offset > 0 || Size < ElementSize) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3945</td>
    <td class="codeline">      // Bail if the partition ends in a different array element.</td>
    <td class="lineNumber">3945</td>
    <td class="codeline">      // Bail if the partition ends in a different array element.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3946</td>
    <td class="codeline">      if ((Offset + Size) > ElementSize)</td>
    <td class="lineNumber">3946</td>
    <td class="codeline">      if ((Offset + Size) > ElementSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3947</td>
    <td class="codeline">        return nullptr;</td>
    <td class="lineNumber">3947</td>
    <td class="codeline">        return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3948</td>
    <td class="codeline">      // Recurse through the element type trying to peel off offset bytes.</td>
    <td class="lineNumber">3948</td>
    <td class="codeline">      // Recurse through the element type trying to peel off offset bytes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3949</td>
    <td class="codeline">      return getTypePartition(DL, ElementTy, Offset, Size);</td>
    <td class="lineNumber">3949</td>
    <td class="codeline">      return getTypePartition(DL, ElementTy, Offset, Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3950</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">3950</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3951</td>
    <td class="codeline">    assert(Offset == 0);</td>
    <td class="lineNumber">3951</td>
    <td class="codeline">    assert(Offset == 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3952</td>
    <td class="codeline"></td>
    <td class="lineNumber">3952</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3953</td>
    <td class="codeline">    if (Size == ElementSize)</td>
    <td class="lineNumber">3953</td>
    <td class="codeline">    if (Size == ElementSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3954</td>
    <td class="codeline">      return stripAggregateTypeWrapping(DL, ElementTy);</td>
    <td class="lineNumber">3954</td>
    <td class="codeline">      return stripAggregateTypeWrapping(DL, ElementTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3955</td>
    <td class="codeline">    assert(Size > ElementSize);</td>
    <td class="lineNumber">3955</td>
    <td class="codeline">    assert(Size > ElementSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3956</td>
    <td class="codeline">    uint64_t NumElements = Size / ElementSize;</td>
    <td class="lineNumber">3956</td>
    <td class="codeline">    uint64_t NumElements = Size / ElementSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3957</td>
    <td class="codeline">    if (NumElements * ElementSize != Size)</td>
    <td class="lineNumber">3957</td>
    <td class="codeline">    if (NumElements * ElementSize != Size)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3958</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">3958</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3959</td>
    <td class="codeline">    return ArrayType::get(ElementTy, NumElements);</td>
    <td class="lineNumber">3959</td>
    <td class="codeline">    return ArrayType::get(ElementTy, NumElements);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3960</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3960</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3961</td>
    <td class="codeline"></td>
    <td class="lineNumber">3961</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3962</td>
    <td class="codeline">  StructType *STy = dyn_cast<StructType>(Ty);</td>
    <td class="lineNumber">3962</td>
    <td class="codeline">  StructType *STy = dyn_cast<StructType>(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3963</td>
    <td class="codeline">  if (!STy)</td>
    <td class="lineNumber">3963</td>
    <td class="codeline">  if (!STy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3964</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">3964</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3965</td>
    <td class="codeline"></td>
    <td class="lineNumber">3965</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3966</td>
    <td class="codeline">  const StructLayout *SL = DL.getStructLayout(STy);</td>
    <td class="lineNumber">3966</td>
    <td class="codeline">  const StructLayout *SL = DL.getStructLayout(STy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3967</td>
    <td class="codeline"></td>
    <td class="lineNumber">3967</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3968</td>
    <td class="codeline">  if (SL->getSizeInBits().isScalable())</td>
    <td class="lineNumber">3968</td>
    <td class="codeline">  if (SL->getSizeInBits().isScalable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3969</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">3969</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3970</td>
    <td class="codeline"></td>
    <td class="lineNumber">3970</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3971</td>
    <td class="codeline">  if (Offset >= SL->getSizeInBytes())</td>
    <td class="lineNumber">3971</td>
    <td class="codeline">  if (Offset >= SL->getSizeInBytes())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3972</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">3972</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3973</td>
    <td class="codeline">  uint64_t EndOffset = Offset + Size;</td>
    <td class="lineNumber">3973</td>
    <td class="codeline">  uint64_t EndOffset = Offset + Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3974</td>
    <td class="codeline">  if (EndOffset > SL->getSizeInBytes())</td>
    <td class="lineNumber">3974</td>
    <td class="codeline">  if (EndOffset > SL->getSizeInBytes())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3975</td>
    <td class="codeline">    return nullptr;</td>
    <td class="lineNumber">3975</td>
    <td class="codeline">    return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3976</td>
    <td class="codeline"></td>
    <td class="lineNumber">3976</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3977</td>
    <td class="codeline">  unsigned Index = SL->getElementContainingOffset(Offset);</td>
    <td class="lineNumber">3977</td>
    <td class="codeline">  unsigned Index = SL->getElementContainingOffset(Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3978</td>
    <td class="codeline">  Offset -= SL->getElementOffset(Index);</td>
    <td class="lineNumber">3978</td>
    <td class="codeline">  Offset -= SL->getElementOffset(Index);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3979</td>
    <td class="codeline"></td>
    <td class="lineNumber">3979</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3980</td>
    <td class="codeline">  Type *ElementTy = STy->getElementType(Index);</td>
    <td class="lineNumber">3980</td>
    <td class="codeline">  Type *ElementTy = STy->getElementType(Index);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3981</td>
    <td class="codeline">  uint64_t ElementSize = DL.getTypeAllocSize(ElementTy).getFixedValue();</td>
    <td class="lineNumber">3981</td>
    <td class="codeline">  uint64_t ElementSize = DL.getTypeAllocSize(ElementTy).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3982</td>
    <td class="codeline">  if (Offset >= ElementSize)</td>
    <td class="lineNumber">3982</td>
    <td class="codeline">  if (Offset >= ElementSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3983</td>
    <td class="codeline">    return nullptr; // The offset points into alignment padding.</td>
    <td class="lineNumber">3983</td>
    <td class="codeline">    return nullptr; // The offset points into alignment padding.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3984</td>
    <td class="codeline"></td>
    <td class="lineNumber">3984</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3985</td>
    <td class="codeline">  // See if any partition must be contained by the element.</td>
    <td class="lineNumber">3985</td>
    <td class="codeline">  // See if any partition must be contained by the element.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3986</td>
    <td class="codeline">  if (Offset > 0 || Size < ElementSize) {</td>
    <td class="lineNumber">3986</td>
    <td class="codeline">  if (Offset > 0 || Size < ElementSize) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3987</td>
    <td class="codeline">    if ((Offset + Size) > ElementSize)</td>
    <td class="lineNumber">3987</td>
    <td class="codeline">    if ((Offset + Size) > ElementSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3988</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">3988</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3989</td>
    <td class="codeline">    return getTypePartition(DL, ElementTy, Offset, Size);</td>
    <td class="lineNumber">3989</td>
    <td class="codeline">    return getTypePartition(DL, ElementTy, Offset, Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3990</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">3990</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3991</td>
    <td class="codeline">  assert(Offset == 0);</td>
    <td class="lineNumber">3991</td>
    <td class="codeline">  assert(Offset == 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3992</td>
    <td class="codeline"></td>
    <td class="lineNumber">3992</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3993</td>
    <td class="codeline">  if (Size == ElementSize)</td>
    <td class="lineNumber">3993</td>
    <td class="codeline">  if (Size == ElementSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3994</td>
    <td class="codeline">    return stripAggregateTypeWrapping(DL, ElementTy);</td>
    <td class="lineNumber">3994</td>
    <td class="codeline">    return stripAggregateTypeWrapping(DL, ElementTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3995</td>
    <td class="codeline"></td>
    <td class="lineNumber">3995</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3996</td>
    <td class="codeline">  StructType::element_iterator EI = STy->element_begin() + Index,</td>
    <td class="lineNumber">3996</td>
    <td class="codeline">  StructType::element_iterator EI = STy->element_begin() + Index,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3997</td>
    <td class="codeline">                               EE = STy->element_end();</td>
    <td class="lineNumber">3997</td>
    <td class="codeline">                               EE = STy->element_end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3998</td>
    <td class="codeline">  if (EndOffset < SL->getSizeInBytes()) {</td>
    <td class="lineNumber">3998</td>
    <td class="codeline">  if (EndOffset < SL->getSizeInBytes()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3999</td>
    <td class="codeline">    unsigned EndIndex = SL->getElementContainingOffset(EndOffset);</td>
    <td class="lineNumber">3999</td>
    <td class="codeline">    unsigned EndIndex = SL->getElementContainingOffset(EndOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4000</td>
    <td class="codeline">    if (Index == EndIndex)</td>
    <td class="lineNumber">4000</td>
    <td class="codeline">    if (Index == EndIndex)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4001</td>
    <td class="codeline">      return nullptr; // Within a single element and its padding.</td>
    <td class="lineNumber">4001</td>
    <td class="codeline">      return nullptr; // Within a single element and its padding.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4002</td>
    <td class="codeline"></td>
    <td class="lineNumber">4002</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4003</td>
    <td class="codeline">    // Don't try to form "natural" types if the elements don't line up with the</td>
    <td class="lineNumber">4003</td>
    <td class="codeline">    // Don't try to form "natural" types if the elements don't line up with the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4004</td>
    <td class="codeline">    // expected size.</td>
    <td class="lineNumber">4004</td>
    <td class="codeline">    // expected size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4005</td>
    <td class="codeline">    // FIXME: We could potentially recurse down through the last element in the</td>
    <td class="lineNumber">4005</td>
    <td class="codeline">    // FIXME: We could potentially recurse down through the last element in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4006</td>
    <td class="codeline">    // sub-struct to find a natural end point.</td>
    <td class="lineNumber">4006</td>
    <td class="codeline">    // sub-struct to find a natural end point.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4007</td>
    <td class="codeline">    if (SL->getElementOffset(EndIndex) != EndOffset)</td>
    <td class="lineNumber">4007</td>
    <td class="codeline">    if (SL->getElementOffset(EndIndex) != EndOffset)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4008</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">4008</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4009</td>
    <td class="codeline"></td>
    <td class="lineNumber">4009</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4010</td>
    <td class="codeline">    assert(Index < EndIndex);</td>
    <td class="lineNumber">4010</td>
    <td class="codeline">    assert(Index < EndIndex);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4011</td>
    <td class="codeline">    EE = STy->element_begin() + EndIndex;</td>
    <td class="lineNumber">4011</td>
    <td class="codeline">    EE = STy->element_begin() + EndIndex;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4012</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4012</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4013</td>
    <td class="codeline"></td>
    <td class="lineNumber">4013</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4014</td>
    <td class="codeline">  // Try to build up a sub-structure.</td>
    <td class="lineNumber">4014</td>
    <td class="codeline">  // Try to build up a sub-structure.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4015</td>
    <td class="codeline">  StructType *SubTy =</td>
    <td class="lineNumber">4015</td>
    <td class="codeline">  StructType *SubTy =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4016</td>
    <td class="codeline">      StructType::get(STy->getContext(), ArrayRef(EI, EE), STy->isPacked());</td>
    <td class="lineNumber">4016</td>
    <td class="codeline">      StructType::get(STy->getContext(), ArrayRef(EI, EE), STy->isPacked());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4017</td>
    <td class="codeline">  const StructLayout *SubSL = DL.getStructLayout(SubTy);</td>
    <td class="lineNumber">4017</td>
    <td class="codeline">  const StructLayout *SubSL = DL.getStructLayout(SubTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4018</td>
    <td class="codeline">  if (Size != SubSL->getSizeInBytes())</td>
    <td class="lineNumber">4018</td>
    <td class="codeline">  if (Size != SubSL->getSizeInBytes())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4019</td>
    <td class="codeline">    return nullptr; // The sub-struct doesn't have quite the size needed.</td>
    <td class="lineNumber">4019</td>
    <td class="codeline">    return nullptr; // The sub-struct doesn't have quite the size needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4020</td>
    <td class="codeline"></td>
    <td class="lineNumber">4020</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4021</td>
    <td class="codeline">  return SubTy;</td>
    <td class="lineNumber">4021</td>
    <td class="codeline">  return SubTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4022</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4022</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4023</td>
    <td class="codeline"></td>
    <td class="lineNumber">4023</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4024</td>
    <td class="codeline">/// Pre-split loads and stores to simplify rewriting.</td>
    <td class="lineNumber">4024</td>
    <td class="codeline">/// Pre-split loads and stores to simplify rewriting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4025</td>
    <td class="codeline">///</td>
    <td class="lineNumber">4025</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4026</td>
    <td class="codeline">/// We want to break up the splittable load+store pairs as much as</td>
    <td class="lineNumber">4026</td>
    <td class="codeline">/// We want to break up the splittable load+store pairs as much as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4027</td>
    <td class="codeline">/// possible. This is important to do as a preprocessing step, as once we</td>
    <td class="lineNumber">4027</td>
    <td class="codeline">/// possible. This is important to do as a preprocessing step, as once we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4028</td>
    <td class="codeline">/// start rewriting the accesses to partitions of the alloca we lose the</td>
    <td class="lineNumber">4028</td>
    <td class="codeline">/// start rewriting the accesses to partitions of the alloca we lose the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4029</td>
    <td class="codeline">/// necessary information to correctly split apart paired loads and stores</td>
    <td class="lineNumber">4029</td>
    <td class="codeline">/// necessary information to correctly split apart paired loads and stores</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4030</td>
    <td class="codeline">/// which both point into this alloca. The case to consider is something like</td>
    <td class="lineNumber">4030</td>
    <td class="codeline">/// which both point into this alloca. The case to consider is something like</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4031</td>
    <td class="codeline">/// the following:</td>
    <td class="lineNumber">4031</td>
    <td class="codeline">/// the following:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4032</td>
    <td class="codeline">///</td>
    <td class="lineNumber">4032</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4033</td>
    <td class="codeline">///   %a = alloca [12 x i8]</td>
    <td class="lineNumber">4033</td>
    <td class="codeline">///   %a = alloca [12 x i8]</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4034</td>
    <td class="codeline">///   %gep1 = getelementptr i8, ptr %a, i32 0</td>
    <td class="lineNumber">4034</td>
    <td class="codeline">///   %gep1 = getelementptr i8, ptr %a, i32 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4035</td>
    <td class="codeline">///   %gep2 = getelementptr i8, ptr %a, i32 4</td>
    <td class="lineNumber">4035</td>
    <td class="codeline">///   %gep2 = getelementptr i8, ptr %a, i32 4</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4036</td>
    <td class="codeline">///   %gep3 = getelementptr i8, ptr %a, i32 8</td>
    <td class="lineNumber">4036</td>
    <td class="codeline">///   %gep3 = getelementptr i8, ptr %a, i32 8</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4037</td>
    <td class="codeline">///   store float 0.0, ptr %gep1</td>
    <td class="lineNumber">4037</td>
    <td class="codeline">///   store float 0.0, ptr %gep1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4038</td>
    <td class="codeline">///   store float 1.0, ptr %gep2</td>
    <td class="lineNumber">4038</td>
    <td class="codeline">///   store float 1.0, ptr %gep2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4039</td>
    <td class="codeline">///   %v = load i64, ptr %gep1</td>
    <td class="lineNumber">4039</td>
    <td class="codeline">///   %v = load i64, ptr %gep1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4040</td>
    <td class="codeline">///   store i64 %v, ptr %gep2</td>
    <td class="lineNumber">4040</td>
    <td class="codeline">///   store i64 %v, ptr %gep2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4041</td>
    <td class="codeline">///   %f1 = load float, ptr %gep2</td>
    <td class="lineNumber">4041</td>
    <td class="codeline">///   %f1 = load float, ptr %gep2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4042</td>
    <td class="codeline">///   %f2 = load float, ptr %gep3</td>
    <td class="lineNumber">4042</td>
    <td class="codeline">///   %f2 = load float, ptr %gep3</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4043</td>
    <td class="codeline">///</td>
    <td class="lineNumber">4043</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4044</td>
    <td class="codeline">/// Here we want to form 3 partitions of the alloca, each 4 bytes large, and</td>
    <td class="lineNumber">4044</td>
    <td class="codeline">/// Here we want to form 3 partitions of the alloca, each 4 bytes large, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4045</td>
    <td class="codeline">/// promote everything so we recover the 2 SSA values that should have been</td>
    <td class="lineNumber">4045</td>
    <td class="codeline">/// promote everything so we recover the 2 SSA values that should have been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4046</td>
    <td class="codeline">/// there all along.</td>
    <td class="lineNumber">4046</td>
    <td class="codeline">/// there all along.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4047</td>
    <td class="codeline">///</td>
    <td class="lineNumber">4047</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4048</td>
    <td class="codeline">/// \returns true if any changes are made.</td>
    <td class="lineNumber">4048</td>
    <td class="codeline">/// \returns true if any changes are made.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4049</td>
    <td class="codeline">bool SROAPass::presplitLoadsAndStores(AllocaInst &AI, AllocaSlices &AS) {</td>
    <td class="lineNumber">4049</td>
    <td class="codeline">bool SROAPass::presplitLoadsAndStores(AllocaInst &AI, AllocaSlices &AS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4050</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Pre-splitting loads and stores\n");</td>
    <td class="lineNumber">4050</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Pre-splitting loads and stores\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4051</td>
    <td class="codeline"></td>
    <td class="lineNumber">4051</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4052</td>
    <td class="codeline">  // Track the loads and stores which are candidates for pre-splitting here, in</td>
    <td class="lineNumber">4052</td>
    <td class="codeline">  // Track the loads and stores which are candidates for pre-splitting here, in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4053</td>
    <td class="codeline">  // the order they first appear during the partition scan. These give stable</td>
    <td class="lineNumber">4053</td>
    <td class="codeline">  // the order they first appear during the partition scan. These give stable</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4054</td>
    <td class="codeline">  // iteration order and a basis for tracking which loads and stores we</td>
    <td class="lineNumber">4054</td>
    <td class="codeline">  // iteration order and a basis for tracking which loads and stores we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4055</td>
    <td class="codeline">  // actually split.</td>
    <td class="lineNumber">4055</td>
    <td class="codeline">  // actually split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4056</td>
    <td class="codeline">  SmallVector<LoadInst *, 4> Loads;</td>
    <td class="lineNumber">4056</td>
    <td class="codeline">  SmallVector<LoadInst *, 4> Loads;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4057</td>
    <td class="codeline">  SmallVector<StoreInst *, 4> Stores;</td>
    <td class="lineNumber">4057</td>
    <td class="codeline">  SmallVector<StoreInst *, 4> Stores;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4058</td>
    <td class="codeline"></td>
    <td class="lineNumber">4058</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4059</td>
    <td class="codeline">  // We need to accumulate the splits required of each load or store where we</td>
    <td class="lineNumber">4059</td>
    <td class="codeline">  // We need to accumulate the splits required of each load or store where we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4060</td>
    <td class="codeline">  // can find them via a direct lookup. This is important to cross-check loads</td>
    <td class="lineNumber">4060</td>
    <td class="codeline">  // can find them via a direct lookup. This is important to cross-check loads</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4061</td>
    <td class="codeline">  // and stores against each other. We also track the slice so that we can kill</td>
    <td class="lineNumber">4061</td>
    <td class="codeline">  // and stores against each other. We also track the slice so that we can kill</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4062</td>
    <td class="codeline">  // all the slices that end up split.</td>
    <td class="lineNumber">4062</td>
    <td class="codeline">  // all the slices that end up split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4063</td>
    <td class="codeline">  struct SplitOffsets {</td>
    <td class="lineNumber">4063</td>
    <td class="codeline">  struct SplitOffsets {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4064</td>
    <td class="codeline">    Slice *S;</td>
    <td class="lineNumber">4064</td>
    <td class="codeline">    Slice *S;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4065</td>
    <td class="codeline">    std::vector<uint64_t> Splits;</td>
    <td class="lineNumber">4065</td>
    <td class="codeline">    std::vector<uint64_t> Splits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4066</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">4066</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4067</td>
    <td class="codeline">  SmallDenseMap<Instruction *, SplitOffsets, 8> SplitOffsetsMap;</td>
    <td class="lineNumber">4067</td>
    <td class="codeline">  SmallDenseMap<Instruction *, SplitOffsets, 8> SplitOffsetsMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4068</td>
    <td class="codeline"></td>
    <td class="lineNumber">4068</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4069</td>
    <td class="codeline">  // Track loads out of this alloca which cannot, for any reason, be pre-split.</td>
    <td class="lineNumber">4069</td>
    <td class="codeline">  // Track loads out of this alloca which cannot, for any reason, be pre-split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4070</td>
    <td class="codeline">  // This is important as we also cannot pre-split stores of those loads!</td>
    <td class="lineNumber">4070</td>
    <td class="codeline">  // This is important as we also cannot pre-split stores of those loads!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4071</td>
    <td class="codeline">  // FIXME: This is all pretty gross. It means that we can be more aggressive</td>
    <td class="lineNumber">4071</td>
    <td class="codeline">  // FIXME: This is all pretty gross. It means that we can be more aggressive</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4072</td>
    <td class="codeline">  // in pre-splitting when the load feeding the store happens to come from</td>
    <td class="lineNumber">4072</td>
    <td class="codeline">  // in pre-splitting when the load feeding the store happens to come from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4073</td>
    <td class="codeline">  // a separate alloca. Put another way, the effectiveness of SROA would be</td>
    <td class="lineNumber">4073</td>
    <td class="codeline">  // a separate alloca. Put another way, the effectiveness of SROA would be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4074</td>
    <td class="codeline">  // decreased by a frontend which just concatenated all of its local allocas</td>
    <td class="lineNumber">4074</td>
    <td class="codeline">  // decreased by a frontend which just concatenated all of its local allocas</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4075</td>
    <td class="codeline">  // into one big flat alloca. But defeating such patterns is exactly the job</td>
    <td class="lineNumber">4075</td>
    <td class="codeline">  // into one big flat alloca. But defeating such patterns is exactly the job</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4076</td>
    <td class="codeline">  // SROA is tasked with! Sadly, to not have this discrepancy we would have</td>
    <td class="lineNumber">4076</td>
    <td class="codeline">  // SROA is tasked with! Sadly, to not have this discrepancy we would have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4077</td>
    <td class="codeline">  // change store pre-splitting to actually force pre-splitting of the load</td>
    <td class="lineNumber">4077</td>
    <td class="codeline">  // change store pre-splitting to actually force pre-splitting of the load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4078</td>
    <td class="codeline">  // that feeds it *and all stores*. That makes pre-splitting much harder, but</td>
    <td class="lineNumber">4078</td>
    <td class="codeline">  // that feeds it *and all stores*. That makes pre-splitting much harder, but</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4079</td>
    <td class="codeline">  // maybe it would make it more principled?</td>
    <td class="lineNumber">4079</td>
    <td class="codeline">  // maybe it would make it more principled?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4080</td>
    <td class="codeline">  SmallPtrSet<LoadInst *, 8> UnsplittableLoads;</td>
    <td class="lineNumber">4080</td>
    <td class="codeline">  SmallPtrSet<LoadInst *, 8> UnsplittableLoads;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4081</td>
    <td class="codeline"></td>
    <td class="lineNumber">4081</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4082</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Searching for candidate loads and stores\n");</td>
    <td class="lineNumber">4082</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Searching for candidate loads and stores\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4083</td>
    <td class="codeline">  for (auto &P : AS.partitions()) {</td>
    <td class="lineNumber">4083</td>
    <td class="codeline">  for (auto &P : AS.partitions()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4084</td>
    <td class="codeline">    for (Slice &S : P) {</td>
    <td class="lineNumber">4084</td>
    <td class="codeline">    for (Slice &S : P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4085</td>
    <td class="codeline">      Instruction *I = cast<Instruction>(S.getUse()->getUser());</td>
    <td class="lineNumber">4085</td>
    <td class="codeline">      Instruction *I = cast<Instruction>(S.getUse()->getUser());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4086</td>
    <td class="codeline">      if (!S.isSplittable() || S.endOffset() <= P.endOffset()) {</td>
    <td class="lineNumber">4086</td>
    <td class="codeline">      if (!S.isSplittable() || S.endOffset() <= P.endOffset()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4087</td>
    <td class="codeline">        // If this is a load we have to track that it can't participate in any</td>
    <td class="lineNumber">4087</td>
    <td class="codeline">        // If this is a load we have to track that it can't participate in any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4088</td>
    <td class="codeline">        // pre-splitting. If this is a store of a load we have to track that</td>
    <td class="lineNumber">4088</td>
    <td class="codeline">        // pre-splitting. If this is a store of a load we have to track that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4089</td>
    <td class="codeline">        // that load also can't participate in any pre-splitting.</td>
    <td class="lineNumber">4089</td>
    <td class="codeline">        // that load also can't participate in any pre-splitting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4090</td>
    <td class="codeline">        if (auto *LI = dyn_cast<LoadInst>(I))</td>
    <td class="lineNumber">4090</td>
    <td class="codeline">        if (auto *LI = dyn_cast<LoadInst>(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4091</td>
    <td class="codeline">          UnsplittableLoads.insert(LI);</td>
    <td class="lineNumber">4091</td>
    <td class="codeline">          UnsplittableLoads.insert(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4092</td>
    <td class="codeline">        else if (auto *SI = dyn_cast<StoreInst>(I))</td>
    <td class="lineNumber">4092</td>
    <td class="codeline">        else if (auto *SI = dyn_cast<StoreInst>(I))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4093</td>
    <td class="codeline">          if (auto *LI = dyn_cast<LoadInst>(SI->getValueOperand()))</td>
    <td class="lineNumber">4093</td>
    <td class="codeline">          if (auto *LI = dyn_cast<LoadInst>(SI->getValueOperand()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4094</td>
    <td class="codeline">            UnsplittableLoads.insert(LI);</td>
    <td class="lineNumber">4094</td>
    <td class="codeline">            UnsplittableLoads.insert(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4095</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">4095</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4096</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4096</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4097</td>
    <td class="codeline">      assert(P.endOffset() > S.beginOffset() &&</td>
    <td class="lineNumber">4097</td>
    <td class="codeline">      assert(P.endOffset() > S.beginOffset() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4098</td>
    <td class="codeline">             "Empty or backwards partition!");</td>
    <td class="lineNumber">4098</td>
    <td class="codeline">             "Empty or backwards partition!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4099</td>
    <td class="codeline"></td>
    <td class="lineNumber">4099</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4100</td>
    <td class="codeline">      // Determine if this is a pre-splittable slice.</td>
    <td class="lineNumber">4100</td>
    <td class="codeline">      // Determine if this is a pre-splittable slice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4101</td>
    <td class="codeline">      if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">4101</td>
    <td class="codeline">      if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4102</td>
    <td class="codeline">        assert(!LI->isVolatile() && "Cannot split volatile loads!");</td>
    <td class="lineNumber">4102</td>
    <td class="codeline">        assert(!LI->isVolatile() && "Cannot split volatile loads!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4103</td>
    <td class="codeline"></td>
    <td class="lineNumber">4103</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4104</td>
    <td class="codeline">        // The load must be used exclusively to store into other pointers for</td>
    <td class="lineNumber">4104</td>
    <td class="codeline">        // The load must be used exclusively to store into other pointers for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4105</td>
    <td class="codeline">        // us to be able to arbitrarily pre-split it. The stores must also be</td>
    <td class="lineNumber">4105</td>
    <td class="codeline">        // us to be able to arbitrarily pre-split it. The stores must also be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4106</td>
    <td class="codeline">        // simple to avoid changing semantics.</td>
    <td class="lineNumber">4106</td>
    <td class="codeline">        // simple to avoid changing semantics.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4107</td>
    <td class="codeline">        auto IsLoadSimplyStored = [](LoadInst *LI) {</td>
    <td class="lineNumber">4107</td>
    <td class="codeline">        auto IsLoadSimplyStored = [](LoadInst *LI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4108</td>
    <td class="codeline">          for (User *LU : LI->users()) {</td>
    <td class="lineNumber">4108</td>
    <td class="codeline">          for (User *LU : LI->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4109</td>
    <td class="codeline">            auto *SI = dyn_cast<StoreInst>(LU);</td>
    <td class="lineNumber">4109</td>
    <td class="codeline">            auto *SI = dyn_cast<StoreInst>(LU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4110</td>
    <td class="codeline">            if (!SI || !SI->isSimple())</td>
    <td class="lineNumber">4110</td>
    <td class="codeline">            if (!SI || !SI->isSimple())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4111</td>
    <td class="codeline">              return false;</td>
    <td class="lineNumber">4111</td>
    <td class="codeline">              return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4112</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">4112</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4113</td>
    <td class="codeline">          return true;</td>
    <td class="lineNumber">4113</td>
    <td class="codeline">          return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4114</td>
    <td class="codeline">        };</td>
    <td class="lineNumber">4114</td>
    <td class="codeline">        };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4115</td>
    <td class="codeline">        if (!IsLoadSimplyStored(LI)) {</td>
    <td class="lineNumber">4115</td>
    <td class="codeline">        if (!IsLoadSimplyStored(LI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4116</td>
    <td class="codeline">          UnsplittableLoads.insert(LI);</td>
    <td class="lineNumber">4116</td>
    <td class="codeline">          UnsplittableLoads.insert(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4117</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">4117</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4118</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">4118</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4119</td>
    <td class="codeline"></td>
    <td class="lineNumber">4119</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4120</td>
    <td class="codeline">        Loads.push_back(LI);</td>
    <td class="lineNumber">4120</td>
    <td class="codeline">        Loads.push_back(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4121</td>
    <td class="codeline">      } else if (auto *SI = dyn_cast<StoreInst>(I)) {</td>
    <td class="lineNumber">4121</td>
    <td class="codeline">      } else if (auto *SI = dyn_cast<StoreInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4122</td>
    <td class="codeline">        if (S.getUse() != &SI->getOperandUse(SI->getPointerOperandIndex()))</td>
    <td class="lineNumber">4122</td>
    <td class="codeline">        if (S.getUse() != &SI->getOperandUse(SI->getPointerOperandIndex()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4123</td>
    <td class="codeline">          // Skip stores *of* pointers. FIXME: This shouldn't even be possible!</td>
    <td class="lineNumber">4123</td>
    <td class="codeline">          // Skip stores *of* pointers. FIXME: This shouldn't even be possible!</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4124</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">4124</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4125</td>
    <td class="codeline">        auto *StoredLoad = dyn_cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">4125</td>
    <td class="codeline">        auto *StoredLoad = dyn_cast<LoadInst>(SI->getValueOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4126</td>
    <td class="codeline">        if (!StoredLoad || !StoredLoad->isSimple())</td>
    <td class="lineNumber">4126</td>
    <td class="codeline">        if (!StoredLoad || !StoredLoad->isSimple())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4127</td>
    <td class="codeline">          continue;</td>
    <td class="lineNumber">4127</td>
    <td class="codeline">          continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4128</td>
    <td class="codeline">        assert(!SI->isVolatile() && "Cannot split volatile stores!");</td>
    <td class="lineNumber">4128</td>
    <td class="codeline">        assert(!SI->isVolatile() && "Cannot split volatile stores!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4129</td>
    <td class="codeline"></td>
    <td class="lineNumber">4129</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4130</td>
    <td class="codeline">        Stores.push_back(SI);</td>
    <td class="lineNumber">4130</td>
    <td class="codeline">        Stores.push_back(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4131</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">4131</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4132</td>
    <td class="codeline">        // Other uses cannot be pre-split.</td>
    <td class="lineNumber">4132</td>
    <td class="codeline">        // Other uses cannot be pre-split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4133</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">4133</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4134</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4134</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4135</td>
    <td class="codeline"></td>
    <td class="lineNumber">4135</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4136</td>
    <td class="codeline">      // Record the initial split.</td>
    <td class="lineNumber">4136</td>
    <td class="codeline">      // Record the initial split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4137</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "    Candidate: " << *I << "\n");</td>
    <td class="lineNumber">4137</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "    Candidate: " << *I << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4138</td>
    <td class="codeline">      auto &Offsets = SplitOffsetsMap[I];</td>
    <td class="lineNumber">4138</td>
    <td class="codeline">      auto &Offsets = SplitOffsetsMap[I];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4139</td>
    <td class="codeline">      assert(Offsets.Splits.empty() &&</td>
    <td class="lineNumber">4139</td>
    <td class="codeline">      assert(Offsets.Splits.empty() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4140</td>
    <td class="codeline">             "Should not have splits the first time we see an instruction!");</td>
    <td class="lineNumber">4140</td>
    <td class="codeline">             "Should not have splits the first time we see an instruction!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4141</td>
    <td class="codeline">      Offsets.S = &S;</td>
    <td class="lineNumber">4141</td>
    <td class="codeline">      Offsets.S = &S;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4142</td>
    <td class="codeline">      Offsets.Splits.push_back(P.endOffset() - S.beginOffset());</td>
    <td class="lineNumber">4142</td>
    <td class="codeline">      Offsets.Splits.push_back(P.endOffset() - S.beginOffset());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4143</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4143</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4144</td>
    <td class="codeline"></td>
    <td class="lineNumber">4144</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4145</td>
    <td class="codeline">    // Now scan the already split slices, and add a split for any of them which</td>
    <td class="lineNumber">4145</td>
    <td class="codeline">    // Now scan the already split slices, and add a split for any of them which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4146</td>
    <td class="codeline">    // we're going to pre-split.</td>
    <td class="lineNumber">4146</td>
    <td class="codeline">    // we're going to pre-split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4147</td>
    <td class="codeline">    for (Slice *S : P.splitSliceTails()) {</td>
    <td class="lineNumber">4147</td>
    <td class="codeline">    for (Slice *S : P.splitSliceTails()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4148</td>
    <td class="codeline">      auto SplitOffsetsMapI =</td>
    <td class="lineNumber">4148</td>
    <td class="codeline">      auto SplitOffsetsMapI =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4149</td>
    <td class="codeline">          SplitOffsetsMap.find(cast<Instruction>(S->getUse()->getUser()));</td>
    <td class="lineNumber">4149</td>
    <td class="codeline">          SplitOffsetsMap.find(cast<Instruction>(S->getUse()->getUser()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4150</td>
    <td class="codeline">      if (SplitOffsetsMapI == SplitOffsetsMap.end())</td>
    <td class="lineNumber">4150</td>
    <td class="codeline">      if (SplitOffsetsMapI == SplitOffsetsMap.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4151</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">4151</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4152</td>
    <td class="codeline">      auto &Offsets = SplitOffsetsMapI->second;</td>
    <td class="lineNumber">4152</td>
    <td class="codeline">      auto &Offsets = SplitOffsetsMapI->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4153</td>
    <td class="codeline"></td>
    <td class="lineNumber">4153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4154</td>
    <td class="codeline">      assert(Offsets.S == S && "Found a mismatched slice!");</td>
    <td class="lineNumber">4154</td>
    <td class="codeline">      assert(Offsets.S == S && "Found a mismatched slice!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4155</td>
    <td class="codeline">      assert(!Offsets.Splits.empty() &&</td>
    <td class="lineNumber">4155</td>
    <td class="codeline">      assert(!Offsets.Splits.empty() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4156</td>
    <td class="codeline">             "Cannot have an empty set of splits on the second partition!");</td>
    <td class="lineNumber">4156</td>
    <td class="codeline">             "Cannot have an empty set of splits on the second partition!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4157</td>
    <td class="codeline">      assert(Offsets.Splits.back() ==</td>
    <td class="lineNumber">4157</td>
    <td class="codeline">      assert(Offsets.Splits.back() ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4158</td>
    <td class="codeline">                 P.beginOffset() - Offsets.S->beginOffset() &&</td>
    <td class="lineNumber">4158</td>
    <td class="codeline">                 P.beginOffset() - Offsets.S->beginOffset() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4159</td>
    <td class="codeline">             "Previous split does not end where this one begins!");</td>
    <td class="lineNumber">4159</td>
    <td class="codeline">             "Previous split does not end where this one begins!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4160</td>
    <td class="codeline"></td>
    <td class="lineNumber">4160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4161</td>
    <td class="codeline">      // Record each split. The last partition's end isn't needed as the size</td>
    <td class="lineNumber">4161</td>
    <td class="codeline">      // Record each split. The last partition's end isn't needed as the size</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4162</td>
    <td class="codeline">      // of the slice dictates that.</td>
    <td class="lineNumber">4162</td>
    <td class="codeline">      // of the slice dictates that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4163</td>
    <td class="codeline">      if (S->endOffset() > P.endOffset())</td>
    <td class="lineNumber">4163</td>
    <td class="codeline">      if (S->endOffset() > P.endOffset())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4164</td>
    <td class="codeline">        Offsets.Splits.push_back(P.endOffset() - Offsets.S->beginOffset());</td>
    <td class="lineNumber">4164</td>
    <td class="codeline">        Offsets.Splits.push_back(P.endOffset() - Offsets.S->beginOffset());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4165</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4165</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4166</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4166</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4167</td>
    <td class="codeline"></td>
    <td class="lineNumber">4167</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4168</td>
    <td class="codeline">  // We may have split loads where some of their stores are split stores. For</td>
    <td class="lineNumber">4168</td>
    <td class="codeline">  // We may have split loads where some of their stores are split stores. For</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4169</td>
    <td class="codeline">  // such loads and stores, we can only pre-split them if their splits exactly</td>
    <td class="lineNumber">4169</td>
    <td class="codeline">  // such loads and stores, we can only pre-split them if their splits exactly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4170</td>
    <td class="codeline">  // match relative to their starting offset. We have to verify this prior to</td>
    <td class="lineNumber">4170</td>
    <td class="codeline">  // match relative to their starting offset. We have to verify this prior to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4171</td>
    <td class="codeline">  // any rewriting.</td>
    <td class="lineNumber">4171</td>
    <td class="codeline">  // any rewriting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4172</td>
    <td class="codeline">  llvm::erase_if(Stores, [&UnsplittableLoads, &SplitOffsetsMap](StoreInst *SI) {</td>
    <td class="lineNumber">4172</td>
    <td class="codeline">  llvm::erase_if(Stores, [&UnsplittableLoads, &SplitOffsetsMap](StoreInst *SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4173</td>
    <td class="codeline">    // Lookup the load we are storing in our map of split</td>
    <td class="lineNumber">4173</td>
    <td class="codeline">    // Lookup the load we are storing in our map of split</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4174</td>
    <td class="codeline">    // offsets.</td>
    <td class="lineNumber">4174</td>
    <td class="codeline">    // offsets.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4175</td>
    <td class="codeline">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">4175</td>
    <td class="codeline">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4176</td>
    <td class="codeline">    // If it was completely unsplittable, then we're done,</td>
    <td class="lineNumber">4176</td>
    <td class="codeline">    // If it was completely unsplittable, then we're done,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4177</td>
    <td class="codeline">    // and this store can't be pre-split.</td>
    <td class="lineNumber">4177</td>
    <td class="codeline">    // and this store can't be pre-split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4178</td>
    <td class="codeline">    if (UnsplittableLoads.count(LI))</td>
    <td class="lineNumber">4178</td>
    <td class="codeline">    if (UnsplittableLoads.count(LI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4179</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">4179</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4180</td>
    <td class="codeline"></td>
    <td class="lineNumber">4180</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4181</td>
    <td class="codeline">    auto LoadOffsetsI = SplitOffsetsMap.find(LI);</td>
    <td class="lineNumber">4181</td>
    <td class="codeline">    auto LoadOffsetsI = SplitOffsetsMap.find(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4182</td>
    <td class="codeline">    if (LoadOffsetsI == SplitOffsetsMap.end())</td>
    <td class="lineNumber">4182</td>
    <td class="codeline">    if (LoadOffsetsI == SplitOffsetsMap.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4183</td>
    <td class="codeline">      return false; // Unrelated loads are definitely safe.</td>
    <td class="lineNumber">4183</td>
    <td class="codeline">      return false; // Unrelated loads are definitely safe.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4184</td>
    <td class="codeline">    auto &LoadOffsets = LoadOffsetsI->second;</td>
    <td class="lineNumber">4184</td>
    <td class="codeline">    auto &LoadOffsets = LoadOffsetsI->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4185</td>
    <td class="codeline"></td>
    <td class="lineNumber">4185</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4186</td>
    <td class="codeline">    // Now lookup the store's offsets.</td>
    <td class="lineNumber">4186</td>
    <td class="codeline">    // Now lookup the store's offsets.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4187</td>
    <td class="codeline">    auto &StoreOffsets = SplitOffsetsMap[SI];</td>
    <td class="lineNumber">4187</td>
    <td class="codeline">    auto &StoreOffsets = SplitOffsetsMap[SI];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4188</td>
    <td class="codeline"></td>
    <td class="lineNumber">4188</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4189</td>
    <td class="codeline">    // If the relative offsets of each split in the load and</td>
    <td class="lineNumber">4189</td>
    <td class="codeline">    // If the relative offsets of each split in the load and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4190</td>
    <td class="codeline">    // store match exactly, then we can split them and we</td>
    <td class="lineNumber">4190</td>
    <td class="codeline">    // store match exactly, then we can split them and we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4191</td>
    <td class="codeline">    // don't need to remove them here.</td>
    <td class="lineNumber">4191</td>
    <td class="codeline">    // don't need to remove them here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4192</td>
    <td class="codeline">    if (LoadOffsets.Splits == StoreOffsets.Splits)</td>
    <td class="lineNumber">4192</td>
    <td class="codeline">    if (LoadOffsets.Splits == StoreOffsets.Splits)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4193</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">4193</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4194</td>
    <td class="codeline"></td>
    <td class="lineNumber">4194</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4195</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    Mismatched splits for load and store:\n"</td>
    <td class="lineNumber">4195</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "    Mismatched splits for load and store:\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4196</td>
    <td class="codeline">                      << "      " << *LI << "\n"</td>
    <td class="lineNumber">4196</td>
    <td class="codeline">                      << "      " << *LI << "\n"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4197</td>
    <td class="codeline">                      << "      " << *SI << "\n");</td>
    <td class="lineNumber">4197</td>
    <td class="codeline">                      << "      " << *SI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4198</td>
    <td class="codeline"></td>
    <td class="lineNumber">4198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4199</td>
    <td class="codeline">    // We've found a store and load that we need to split</td>
    <td class="lineNumber">4199</td>
    <td class="codeline">    // We've found a store and load that we need to split</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4200</td>
    <td class="codeline">    // with mismatched relative splits. Just give up on them</td>
    <td class="lineNumber">4200</td>
    <td class="codeline">    // with mismatched relative splits. Just give up on them</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4201</td>
    <td class="codeline">    // and remove both instructions from our list of</td>
    <td class="lineNumber">4201</td>
    <td class="codeline">    // and remove both instructions from our list of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4202</td>
    <td class="codeline">    // candidates.</td>
    <td class="lineNumber">4202</td>
    <td class="codeline">    // candidates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4203</td>
    <td class="codeline">    UnsplittableLoads.insert(LI);</td>
    <td class="lineNumber">4203</td>
    <td class="codeline">    UnsplittableLoads.insert(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4204</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">4204</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4205</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">4205</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4206</td>
    <td class="codeline">  // Now we have to go *back* through all the stores, because a later store may</td>
    <td class="lineNumber">4206</td>
    <td class="codeline">  // Now we have to go *back* through all the stores, because a later store may</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4207</td>
    <td class="codeline">  // have caused an earlier store's load to become unsplittable and if it is</td>
    <td class="lineNumber">4207</td>
    <td class="codeline">  // have caused an earlier store's load to become unsplittable and if it is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4208</td>
    <td class="codeline">  // unsplittable for the later store, then we can't rely on it being split in</td>
    <td class="lineNumber">4208</td>
    <td class="codeline">  // unsplittable for the later store, then we can't rely on it being split in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4209</td>
    <td class="codeline">  // the earlier store either.</td>
    <td class="lineNumber">4209</td>
    <td class="codeline">  // the earlier store either.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4210</td>
    <td class="codeline">  llvm::erase_if(Stores, [&UnsplittableLoads](StoreInst *SI) {</td>
    <td class="lineNumber">4210</td>
    <td class="codeline">  llvm::erase_if(Stores, [&UnsplittableLoads](StoreInst *SI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4211</td>
    <td class="codeline">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">4211</td>
    <td class="codeline">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4212</td>
    <td class="codeline">    return UnsplittableLoads.count(LI);</td>
    <td class="lineNumber">4212</td>
    <td class="codeline">    return UnsplittableLoads.count(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4213</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">4213</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4214</td>
    <td class="codeline">  // Once we've established all the loads that can't be split for some reason,</td>
    <td class="lineNumber">4214</td>
    <td class="codeline">  // Once we've established all the loads that can't be split for some reason,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4215</td>
    <td class="codeline">  // filter any that made it into our list out.</td>
    <td class="lineNumber">4215</td>
    <td class="codeline">  // filter any that made it into our list out.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4216</td>
    <td class="codeline">  llvm::erase_if(Loads, [&UnsplittableLoads](LoadInst *LI) {</td>
    <td class="lineNumber">4216</td>
    <td class="codeline">  llvm::erase_if(Loads, [&UnsplittableLoads](LoadInst *LI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4217</td>
    <td class="codeline">    return UnsplittableLoads.count(LI);</td>
    <td class="lineNumber">4217</td>
    <td class="codeline">    return UnsplittableLoads.count(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4218</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">4218</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4219</td>
    <td class="codeline"></td>
    <td class="lineNumber">4219</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4220</td>
    <td class="codeline">  // If no loads or stores are left, there is no pre-splitting to be done for</td>
    <td class="lineNumber">4220</td>
    <td class="codeline">  // If no loads or stores are left, there is no pre-splitting to be done for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4221</td>
    <td class="codeline">  // this alloca.</td>
    <td class="lineNumber">4221</td>
    <td class="codeline">  // this alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4222</td>
    <td class="codeline">  if (Loads.empty() && Stores.empty())</td>
    <td class="lineNumber">4222</td>
    <td class="codeline">  if (Loads.empty() && Stores.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4223</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4223</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4224</td>
    <td class="codeline"></td>
    <td class="lineNumber">4224</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4225</td>
    <td class="codeline">  // From here on, we can't fail and will be building new accesses, so rig up</td>
    <td class="lineNumber">4225</td>
    <td class="codeline">  // From here on, we can't fail and will be building new accesses, so rig up</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4226</td>
    <td class="codeline">  // an IR builder.</td>
    <td class="lineNumber">4226</td>
    <td class="codeline">  // an IR builder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4227</td>
    <td class="codeline">  IRBuilderTy IRB(&AI);</td>
    <td class="lineNumber">4227</td>
    <td class="codeline">  IRBuilderTy IRB(&AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4228</td>
    <td class="codeline"></td>
    <td class="lineNumber">4228</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4229</td>
    <td class="codeline">  // Collect the new slices which we will merge into the alloca slices.</td>
    <td class="lineNumber">4229</td>
    <td class="codeline">  // Collect the new slices which we will merge into the alloca slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4230</td>
    <td class="codeline">  SmallVector<Slice, 4> NewSlices;</td>
    <td class="lineNumber">4230</td>
    <td class="codeline">  SmallVector<Slice, 4> NewSlices;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4231</td>
    <td class="codeline"></td>
    <td class="lineNumber">4231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4232</td>
    <td class="codeline">  // Track any allocas we end up splitting loads and stores for so we iterate</td>
    <td class="lineNumber">4232</td>
    <td class="codeline">  // Track any allocas we end up splitting loads and stores for so we iterate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4233</td>
    <td class="codeline">  // on them.</td>
    <td class="lineNumber">4233</td>
    <td class="codeline">  // on them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4234</td>
    <td class="codeline">  SmallPtrSet<AllocaInst *, 4> ResplitPromotableAllocas;</td>
    <td class="lineNumber">4234</td>
    <td class="codeline">  SmallPtrSet<AllocaInst *, 4> ResplitPromotableAllocas;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4235</td>
    <td class="codeline"></td>
    <td class="lineNumber">4235</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4236</td>
    <td class="codeline">  // At this point, we have collected all of the loads and stores we can</td>
    <td class="lineNumber">4236</td>
    <td class="codeline">  // At this point, we have collected all of the loads and stores we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4237</td>
    <td class="codeline">  // pre-split, and the specific splits needed for them. We actually do the</td>
    <td class="lineNumber">4237</td>
    <td class="codeline">  // pre-split, and the specific splits needed for them. We actually do the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4238</td>
    <td class="codeline">  // splitting in a specific order in order to handle when one of the loads in</td>
    <td class="lineNumber">4238</td>
    <td class="codeline">  // splitting in a specific order in order to handle when one of the loads in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4239</td>
    <td class="codeline">  // the value operand to one of the stores.</td>
    <td class="lineNumber">4239</td>
    <td class="codeline">  // the value operand to one of the stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4240</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">4240</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4241</td>
    <td class="codeline">  // First, we rewrite all of the split loads, and just accumulate each split</td>
    <td class="lineNumber">4241</td>
    <td class="codeline">  // First, we rewrite all of the split loads, and just accumulate each split</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4242</td>
    <td class="codeline">  // load in a parallel structure. We also build the slices for them and append</td>
    <td class="lineNumber">4242</td>
    <td class="codeline">  // load in a parallel structure. We also build the slices for them and append</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4243</td>
    <td class="codeline">  // them to the alloca slices.</td>
    <td class="lineNumber">4243</td>
    <td class="codeline">  // them to the alloca slices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4244</td>
    <td class="codeline">  SmallDenseMap<LoadInst *, std::vector<LoadInst *>, 1> SplitLoadsMap;</td>
    <td class="lineNumber">4244</td>
    <td class="codeline">  SmallDenseMap<LoadInst *, std::vector<LoadInst *>, 1> SplitLoadsMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4245</td>
    <td class="codeline">  std::vector<LoadInst *> SplitLoads;</td>
    <td class="lineNumber">4245</td>
    <td class="codeline">  std::vector<LoadInst *> SplitLoads;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4246</td>
    <td class="codeline">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td class="lineNumber">4246</td>
    <td class="codeline">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4247</td>
    <td class="codeline">  for (LoadInst *LI : Loads) {</td>
    <td class="lineNumber">4247</td>
    <td class="codeline">  for (LoadInst *LI : Loads) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4248</td>
    <td class="codeline">    SplitLoads.clear();</td>
    <td class="lineNumber">4248</td>
    <td class="codeline">    SplitLoads.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4249</td>
    <td class="codeline"></td>
    <td class="lineNumber">4249</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4250</td>
    <td class="codeline">    auto &Offsets = SplitOffsetsMap[LI];</td>
    <td class="lineNumber">4250</td>
    <td class="codeline">    auto &Offsets = SplitOffsetsMap[LI];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4251</td>
    <td class="codeline">    unsigned SliceSize = Offsets.S->endOffset() - Offsets.S->beginOffset();</td>
    <td class="lineNumber">4251</td>
    <td class="codeline">    unsigned SliceSize = Offsets.S->endOffset() - Offsets.S->beginOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4252</td>
    <td class="codeline">    assert(LI->getType()->getIntegerBitWidth() % 8 == 0 &&</td>
    <td class="lineNumber">4252</td>
    <td class="codeline">    assert(LI->getType()->getIntegerBitWidth() % 8 == 0 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4253</td>
    <td class="codeline">           "Load must have type size equal to store size");</td>
    <td class="lineNumber">4253</td>
    <td class="codeline">           "Load must have type size equal to store size");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4254</td>
    <td class="codeline">    assert(LI->getType()->getIntegerBitWidth() / 8 >= SliceSize &&</td>
    <td class="lineNumber">4254</td>
    <td class="codeline">    assert(LI->getType()->getIntegerBitWidth() / 8 >= SliceSize &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4255</td>
    <td class="codeline">           "Load must be >= slice size");</td>
    <td class="lineNumber">4255</td>
    <td class="codeline">           "Load must be >= slice size");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4256</td>
    <td class="codeline"></td>
    <td class="lineNumber">4256</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4257</td>
    <td class="codeline">    uint64_t BaseOffset = Offsets.S->beginOffset();</td>
    <td class="lineNumber">4257</td>
    <td class="codeline">    uint64_t BaseOffset = Offsets.S->beginOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4258</td>
    <td class="codeline">    assert(BaseOffset + SliceSize > BaseOffset &&</td>
    <td class="lineNumber">4258</td>
    <td class="codeline">    assert(BaseOffset + SliceSize > BaseOffset &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4259</td>
    <td class="codeline">           "Cannot represent alloca access size using 64-bit integers!");</td>
    <td class="lineNumber">4259</td>
    <td class="codeline">           "Cannot represent alloca access size using 64-bit integers!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4260</td>
    <td class="codeline"></td>
    <td class="lineNumber">4260</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4261</td>
    <td class="codeline">    Instruction *BasePtr = cast<Instruction>(LI->getPointerOperand());</td>
    <td class="lineNumber">4261</td>
    <td class="codeline">    Instruction *BasePtr = cast<Instruction>(LI->getPointerOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4262</td>
    <td class="codeline">    IRB.SetInsertPoint(LI);</td>
    <td class="lineNumber">4262</td>
    <td class="codeline">    IRB.SetInsertPoint(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4263</td>
    <td class="codeline"></td>
    <td class="lineNumber">4263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4264</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  Splitting load: " << *LI << "\n");</td>
    <td class="lineNumber">4264</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  Splitting load: " << *LI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4265</td>
    <td class="codeline"></td>
    <td class="lineNumber">4265</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4266</td>
    <td class="codeline">    uint64_t PartOffset = 0, PartSize = Offsets.Splits.front();</td>
    <td class="lineNumber">4266</td>
    <td class="codeline">    uint64_t PartOffset = 0, PartSize = Offsets.Splits.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4267</td>
    <td class="codeline">    int Idx = 0, Size = Offsets.Splits.size();</td>
    <td class="lineNumber">4267</td>
    <td class="codeline">    int Idx = 0, Size = Offsets.Splits.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4268</td>
    <td class="codeline">    for (;;) {</td>
    <td class="lineNumber">4268</td>
    <td class="codeline">    for (;;) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4269</td>
    <td class="codeline">      auto *PartTy = Type::getIntNTy(LI->getContext(), PartSize * 8);</td>
    <td class="lineNumber">4269</td>
    <td class="codeline">      auto *PartTy = Type::getIntNTy(LI->getContext(), PartSize * 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4270</td>
    <td class="codeline">      auto AS = LI->getPointerAddressSpace();</td>
    <td class="lineNumber">4270</td>
    <td class="codeline">      auto AS = LI->getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4271</td>
    <td class="codeline">      auto *PartPtrTy = PartTy->getPointerTo(AS);</td>
    <td class="lineNumber">4271</td>
    <td class="codeline">      auto *PartPtrTy = PartTy->getPointerTo(AS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4272</td>
    <td class="codeline">      LoadInst *PLoad = IRB.CreateAlignedLoad(</td>
    <td class="lineNumber">4272</td>
    <td class="codeline">      LoadInst *PLoad = IRB.CreateAlignedLoad(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4273</td>
    <td class="codeline">          PartTy,</td>
    <td class="lineNumber">4273</td>
    <td class="codeline">          PartTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4274</td>
    <td class="codeline">          getAdjustedPtr(IRB, DL, BasePtr,</td>
    <td class="lineNumber">4274</td>
    <td class="codeline">          getAdjustedPtr(IRB, DL, BasePtr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4275</td>
    <td class="codeline">                         APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td class="lineNumber">4275</td>
    <td class="codeline">                         APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4276</td>
    <td class="codeline">                         PartPtrTy, BasePtr->getName() + "."),</td>
    <td class="lineNumber">4276</td>
    <td class="codeline">                         PartPtrTy, BasePtr->getName() + "."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4277</td>
    <td class="codeline">          getAdjustedAlignment(LI, PartOffset),</td>
    <td class="lineNumber">4277</td>
    <td class="codeline">          getAdjustedAlignment(LI, PartOffset),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4278</td>
    <td class="codeline">          /*IsVolatile*/ false, LI->getName());</td>
    <td class="lineNumber">4278</td>
    <td class="codeline">          /*IsVolatile*/ false, LI->getName());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4279</td>
    <td class="codeline">      PLoad->copyMetadata(*LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">4279</td>
    <td class="codeline">      PLoad->copyMetadata(*LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4280</td>
    <td class="codeline">                                LLVMContext::MD_access_group});</td>
    <td class="lineNumber">4280</td>
    <td class="codeline">                                LLVMContext::MD_access_group});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4281</td>
    <td class="codeline"></td>
    <td class="lineNumber">4281</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4282</td>
    <td class="codeline">      // Append this load onto the list of split loads so we can find it later</td>
    <td class="lineNumber">4282</td>
    <td class="codeline">      // Append this load onto the list of split loads so we can find it later</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4283</td>
    <td class="codeline">      // to rewrite the stores.</td>
    <td class="lineNumber">4283</td>
    <td class="codeline">      // to rewrite the stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4284</td>
    <td class="codeline">      SplitLoads.push_back(PLoad);</td>
    <td class="lineNumber">4284</td>
    <td class="codeline">      SplitLoads.push_back(PLoad);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4285</td>
    <td class="codeline"></td>
    <td class="lineNumber">4285</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4286</td>
    <td class="codeline">      // Now build a new slice for the alloca.</td>
    <td class="lineNumber">4286</td>
    <td class="codeline">      // Now build a new slice for the alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4287</td>
    <td class="codeline">      NewSlices.push_back(</td>
    <td class="lineNumber">4287</td>
    <td class="codeline">      NewSlices.push_back(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4288</td>
    <td class="codeline">          Slice(BaseOffset + PartOffset, BaseOffset + PartOffset + PartSize,</td>
    <td class="lineNumber">4288</td>
    <td class="codeline">          Slice(BaseOffset + PartOffset, BaseOffset + PartOffset + PartSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4289</td>
    <td class="codeline">                &PLoad->getOperandUse(PLoad->getPointerOperandIndex()),</td>
    <td class="lineNumber">4289</td>
    <td class="codeline">                &PLoad->getOperandUse(PLoad->getPointerOperandIndex()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4290</td>
    <td class="codeline">                /*IsSplittable*/ false));</td>
    <td class="lineNumber">4290</td>
    <td class="codeline">                /*IsSplittable*/ false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4291</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "    new slice [" << NewSlices.back().beginOffset()</td>
    <td class="lineNumber">4291</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "    new slice [" << NewSlices.back().beginOffset()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4292</td>
    <td class="codeline">                        << ", " << NewSlices.back().endOffset()</td>
    <td class="lineNumber">4292</td>
    <td class="codeline">                        << ", " << NewSlices.back().endOffset()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4293</td>
    <td class="codeline">                        << "): " << *PLoad << "\n");</td>
    <td class="lineNumber">4293</td>
    <td class="codeline">                        << "): " << *PLoad << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4294</td>
    <td class="codeline"></td>
    <td class="lineNumber">4294</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4295</td>
    <td class="codeline">      // See if we've handled all the splits.</td>
    <td class="lineNumber">4295</td>
    <td class="codeline">      // See if we've handled all the splits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4296</td>
    <td class="codeline">      if (Idx >= Size)</td>
    <td class="lineNumber">4296</td>
    <td class="codeline">      if (Idx >= Size)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4297</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">4297</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4298</td>
    <td class="codeline"></td>
    <td class="lineNumber">4298</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4299</td>
    <td class="codeline">      // Setup the next partition.</td>
    <td class="lineNumber">4299</td>
    <td class="codeline">      // Setup the next partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4300</td>
    <td class="codeline">      PartOffset = Offsets.Splits[Idx];</td>
    <td class="lineNumber">4300</td>
    <td class="codeline">      PartOffset = Offsets.Splits[Idx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4301</td>
    <td class="codeline">      ++Idx;</td>
    <td class="lineNumber">4301</td>
    <td class="codeline">      ++Idx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4302</td>
    <td class="codeline">      PartSize = (Idx < Size ? Offsets.Splits[Idx] : SliceSize) - PartOffset;</td>
    <td class="lineNumber">4302</td>
    <td class="codeline">      PartSize = (Idx < Size ? Offsets.Splits[Idx] : SliceSize) - PartOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4303</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4303</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4304</td>
    <td class="codeline"></td>
    <td class="lineNumber">4304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4305</td>
    <td class="codeline">    // Now that we have the split loads, do the slow walk over all uses of the</td>
    <td class="lineNumber">4305</td>
    <td class="codeline">    // Now that we have the split loads, do the slow walk over all uses of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4306</td>
    <td class="codeline">    // load and rewrite them as split stores, or save the split loads to use</td>
    <td class="lineNumber">4306</td>
    <td class="codeline">    // load and rewrite them as split stores, or save the split loads to use</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4307</td>
    <td class="codeline">    // below if the store is going to be split there anyways.</td>
    <td class="lineNumber">4307</td>
    <td class="codeline">    // below if the store is going to be split there anyways.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4308</td>
    <td class="codeline">    bool DeferredStores = false;</td>
    <td class="lineNumber">4308</td>
    <td class="codeline">    bool DeferredStores = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4309</td>
    <td class="codeline">    for (User *LU : LI->users()) {</td>
    <td class="lineNumber">4309</td>
    <td class="codeline">    for (User *LU : LI->users()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4310</td>
    <td class="codeline">      StoreInst *SI = cast<StoreInst>(LU);</td>
    <td class="lineNumber">4310</td>
    <td class="codeline">      StoreInst *SI = cast<StoreInst>(LU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4311</td>
    <td class="codeline">      if (!Stores.empty() && SplitOffsetsMap.count(SI)) {</td>
    <td class="lineNumber">4311</td>
    <td class="codeline">      if (!Stores.empty() && SplitOffsetsMap.count(SI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4312</td>
    <td class="codeline">        DeferredStores = true;</td>
    <td class="lineNumber">4312</td>
    <td class="codeline">        DeferredStores = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4313</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "    Deferred splitting of store: " << *SI</td>
    <td class="lineNumber">4313</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "    Deferred splitting of store: " << *SI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4314</td>
    <td class="codeline">                          << "\n");</td>
    <td class="lineNumber">4314</td>
    <td class="codeline">                          << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4315</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">4315</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4316</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4316</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4317</td>
    <td class="codeline"></td>
    <td class="lineNumber">4317</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4318</td>
    <td class="codeline">      Value *StoreBasePtr = SI->getPointerOperand();</td>
    <td class="lineNumber">4318</td>
    <td class="codeline">      Value *StoreBasePtr = SI->getPointerOperand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4319</td>
    <td class="codeline">      IRB.SetInsertPoint(SI);</td>
    <td class="lineNumber">4319</td>
    <td class="codeline">      IRB.SetInsertPoint(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4320</td>
    <td class="codeline"></td>
    <td class="lineNumber">4320</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4321</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "    Splitting store of load: " << *SI << "\n");</td>
    <td class="lineNumber">4321</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "    Splitting store of load: " << *SI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4322</td>
    <td class="codeline"></td>
    <td class="lineNumber">4322</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4323</td>
    <td class="codeline">      for (int Idx = 0, Size = SplitLoads.size(); Idx < Size; ++Idx) {</td>
    <td class="lineNumber">4323</td>
    <td class="codeline">      for (int Idx = 0, Size = SplitLoads.size(); Idx < Size; ++Idx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4324</td>
    <td class="codeline">        LoadInst *PLoad = SplitLoads[Idx];</td>
    <td class="lineNumber">4324</td>
    <td class="codeline">        LoadInst *PLoad = SplitLoads[Idx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4325</td>
    <td class="codeline">        uint64_t PartOffset = Idx == 0 ? 0 : Offsets.Splits[Idx - 1];</td>
    <td class="lineNumber">4325</td>
    <td class="codeline">        uint64_t PartOffset = Idx == 0 ? 0 : Offsets.Splits[Idx - 1];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4326</td>
    <td class="codeline">        auto *PartPtrTy =</td>
    <td class="lineNumber">4326</td>
    <td class="codeline">        auto *PartPtrTy =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4327</td>
    <td class="codeline">            PLoad->getType()->getPointerTo(SI->getPointerAddressSpace());</td>
    <td class="lineNumber">4327</td>
    <td class="codeline">            PLoad->getType()->getPointerTo(SI->getPointerAddressSpace());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4328</td>
    <td class="codeline"></td>
    <td class="lineNumber">4328</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4329</td>
    <td class="codeline">        auto AS = SI->getPointerAddressSpace();</td>
    <td class="lineNumber">4329</td>
    <td class="codeline">        auto AS = SI->getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4330</td>
    <td class="codeline">        StoreInst *PStore = IRB.CreateAlignedStore(</td>
    <td class="lineNumber">4330</td>
    <td class="codeline">        StoreInst *PStore = IRB.CreateAlignedStore(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4331</td>
    <td class="codeline">            PLoad,</td>
    <td class="lineNumber">4331</td>
    <td class="codeline">            PLoad,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4332</td>
    <td class="codeline">            getAdjustedPtr(IRB, DL, StoreBasePtr,</td>
    <td class="lineNumber">4332</td>
    <td class="codeline">            getAdjustedPtr(IRB, DL, StoreBasePtr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4333</td>
    <td class="codeline">                           APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td class="lineNumber">4333</td>
    <td class="codeline">                           APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4334</td>
    <td class="codeline">                           PartPtrTy, StoreBasePtr->getName() + "."),</td>
    <td class="lineNumber">4334</td>
    <td class="codeline">                           PartPtrTy, StoreBasePtr->getName() + "."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4335</td>
    <td class="codeline">            getAdjustedAlignment(SI, PartOffset),</td>
    <td class="lineNumber">4335</td>
    <td class="codeline">            getAdjustedAlignment(SI, PartOffset),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4336</td>
    <td class="codeline">            /*IsVolatile*/ false);</td>
    <td class="lineNumber">4336</td>
    <td class="codeline">            /*IsVolatile*/ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4337</td>
    <td class="codeline">        PStore->copyMetadata(*SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">4337</td>
    <td class="codeline">        PStore->copyMetadata(*SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4338</td>
    <td class="codeline">                                   LLVMContext::MD_access_group,</td>
    <td class="lineNumber">4338</td>
    <td class="codeline">                                   LLVMContext::MD_access_group,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4339</td>
    <td class="codeline">                                   LLVMContext::MD_DIAssignID});</td>
    <td class="lineNumber">4339</td>
    <td class="codeline">                                   LLVMContext::MD_DIAssignID});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4340</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "      +" << PartOffset << ":" << *PStore << "\n");</td>
    <td class="lineNumber">4340</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "      +" << PartOffset << ":" << *PStore << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4341</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4341</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4342</td>
    <td class="codeline"></td>
    <td class="lineNumber">4342</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4343</td>
    <td class="codeline">      // We want to immediately iterate on any allocas impacted by splitting</td>
    <td class="lineNumber">4343</td>
    <td class="codeline">      // We want to immediately iterate on any allocas impacted by splitting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4344</td>
    <td class="codeline">      // this store, and we have to track any promotable alloca (indicated by</td>
    <td class="lineNumber">4344</td>
    <td class="codeline">      // this store, and we have to track any promotable alloca (indicated by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4345</td>
    <td class="codeline">      // a direct store) as needing to be resplit because it is no longer</td>
    <td class="lineNumber">4345</td>
    <td class="codeline">      // a direct store) as needing to be resplit because it is no longer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4346</td>
    <td class="codeline">      // promotable.</td>
    <td class="lineNumber">4346</td>
    <td class="codeline">      // promotable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4347</td>
    <td class="codeline">      if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(StoreBasePtr)) {</td>
    <td class="lineNumber">4347</td>
    <td class="codeline">      if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(StoreBasePtr)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4348</td>
    <td class="codeline">        ResplitPromotableAllocas.insert(OtherAI);</td>
    <td class="lineNumber">4348</td>
    <td class="codeline">        ResplitPromotableAllocas.insert(OtherAI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4349</td>
    <td class="codeline">        Worklist.insert(OtherAI);</td>
    <td class="lineNumber">4349</td>
    <td class="codeline">        Worklist.insert(OtherAI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4350</td>
    <td class="codeline">      } else if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(</td>
    <td class="lineNumber">4350</td>
    <td class="codeline">      } else if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4351</td>
    <td class="codeline">                     StoreBasePtr->stripInBoundsOffsets())) {</td>
    <td class="lineNumber">4351</td>
    <td class="codeline">                     StoreBasePtr->stripInBoundsOffsets())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4352</td>
    <td class="codeline">        Worklist.insert(OtherAI);</td>
    <td class="lineNumber">4352</td>
    <td class="codeline">        Worklist.insert(OtherAI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4353</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4353</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4354</td>
    <td class="codeline"></td>
    <td class="lineNumber">4354</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4355</td>
    <td class="codeline">      // Mark the original store as dead.</td>
    <td class="lineNumber">4355</td>
    <td class="codeline">      // Mark the original store as dead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4356</td>
    <td class="codeline">      DeadInsts.push_back(SI);</td>
    <td class="lineNumber">4356</td>
    <td class="codeline">      DeadInsts.push_back(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4357</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4357</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4358</td>
    <td class="codeline"></td>
    <td class="lineNumber">4358</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4359</td>
    <td class="codeline">    // Save the split loads if there are deferred stores among the users.</td>
    <td class="lineNumber">4359</td>
    <td class="codeline">    // Save the split loads if there are deferred stores among the users.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4360</td>
    <td class="codeline">    if (DeferredStores)</td>
    <td class="lineNumber">4360</td>
    <td class="codeline">    if (DeferredStores)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4361</td>
    <td class="codeline">      SplitLoadsMap.insert(std::make_pair(LI, std::move(SplitLoads)));</td>
    <td class="lineNumber">4361</td>
    <td class="codeline">      SplitLoadsMap.insert(std::make_pair(LI, std::move(SplitLoads)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4362</td>
    <td class="codeline"></td>
    <td class="lineNumber">4362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4363</td>
    <td class="codeline">    // Mark the original load as dead and kill the original slice.</td>
    <td class="lineNumber">4363</td>
    <td class="codeline">    // Mark the original load as dead and kill the original slice.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4364</td>
    <td class="codeline">    DeadInsts.push_back(LI);</td>
    <td class="lineNumber">4364</td>
    <td class="codeline">    DeadInsts.push_back(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4365</td>
    <td class="codeline">    Offsets.S->kill();</td>
    <td class="lineNumber">4365</td>
    <td class="codeline">    Offsets.S->kill();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4366</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4366</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4367</td>
    <td class="codeline"></td>
    <td class="lineNumber">4367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4368</td>
    <td class="codeline">  // Second, we rewrite all of the split stores. At this point, we know that</td>
    <td class="lineNumber">4368</td>
    <td class="codeline">  // Second, we rewrite all of the split stores. At this point, we know that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4369</td>
    <td class="codeline">  // all loads from this alloca have been split already. For stores of such</td>
    <td class="lineNumber">4369</td>
    <td class="codeline">  // all loads from this alloca have been split already. For stores of such</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4370</td>
    <td class="codeline">  // loads, we can simply look up the pre-existing split loads. For stores of</td>
    <td class="lineNumber">4370</td>
    <td class="codeline">  // loads, we can simply look up the pre-existing split loads. For stores of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4371</td>
    <td class="codeline">  // other loads, we split those loads first and then write split stores of</td>
    <td class="lineNumber">4371</td>
    <td class="codeline">  // other loads, we split those loads first and then write split stores of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4372</td>
    <td class="codeline">  // them.</td>
    <td class="lineNumber">4372</td>
    <td class="codeline">  // them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4373</td>
    <td class="codeline">  for (StoreInst *SI : Stores) {</td>
    <td class="lineNumber">4373</td>
    <td class="codeline">  for (StoreInst *SI : Stores) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4374</td>
    <td class="codeline">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">4374</td>
    <td class="codeline">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4375</td>
    <td class="codeline">    IntegerType *Ty = cast<IntegerType>(LI->getType());</td>
    <td class="lineNumber">4375</td>
    <td class="codeline">    IntegerType *Ty = cast<IntegerType>(LI->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4376</td>
    <td class="codeline">    assert(Ty->getBitWidth() % 8 == 0);</td>
    <td class="lineNumber">4376</td>
    <td class="codeline">    assert(Ty->getBitWidth() % 8 == 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4377</td>
    <td class="codeline">    uint64_t StoreSize = Ty->getBitWidth() / 8;</td>
    <td class="lineNumber">4377</td>
    <td class="codeline">    uint64_t StoreSize = Ty->getBitWidth() / 8;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4378</td>
    <td class="codeline">    assert(StoreSize > 0 && "Cannot have a zero-sized integer store!");</td>
    <td class="lineNumber">4378</td>
    <td class="codeline">    assert(StoreSize > 0 && "Cannot have a zero-sized integer store!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4379</td>
    <td class="codeline"></td>
    <td class="lineNumber">4379</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4380</td>
    <td class="codeline">    auto &Offsets = SplitOffsetsMap[SI];</td>
    <td class="lineNumber">4380</td>
    <td class="codeline">    auto &Offsets = SplitOffsetsMap[SI];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4381</td>
    <td class="codeline">    assert(StoreSize == Offsets.S->endOffset() - Offsets.S->beginOffset() &&</td>
    <td class="lineNumber">4381</td>
    <td class="codeline">    assert(StoreSize == Offsets.S->endOffset() - Offsets.S->beginOffset() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4382</td>
    <td class="codeline">           "Slice size should always match load size exactly!");</td>
    <td class="lineNumber">4382</td>
    <td class="codeline">           "Slice size should always match load size exactly!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4383</td>
    <td class="codeline">    uint64_t BaseOffset = Offsets.S->beginOffset();</td>
    <td class="lineNumber">4383</td>
    <td class="codeline">    uint64_t BaseOffset = Offsets.S->beginOffset();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4384</td>
    <td class="codeline">    assert(BaseOffset + StoreSize > BaseOffset &&</td>
    <td class="lineNumber">4384</td>
    <td class="codeline">    assert(BaseOffset + StoreSize > BaseOffset &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4385</td>
    <td class="codeline">           "Cannot represent alloca access size using 64-bit integers!");</td>
    <td class="lineNumber">4385</td>
    <td class="codeline">           "Cannot represent alloca access size using 64-bit integers!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4386</td>
    <td class="codeline"></td>
    <td class="lineNumber">4386</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4387</td>
    <td class="codeline">    Value *LoadBasePtr = LI->getPointerOperand();</td>
    <td class="lineNumber">4387</td>
    <td class="codeline">    Value *LoadBasePtr = LI->getPointerOperand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4388</td>
    <td class="codeline">    Instruction *StoreBasePtr = cast<Instruction>(SI->getPointerOperand());</td>
    <td class="lineNumber">4388</td>
    <td class="codeline">    Instruction *StoreBasePtr = cast<Instruction>(SI->getPointerOperand());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4389</td>
    <td class="codeline"></td>
    <td class="lineNumber">4389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4390</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  Splitting store: " << *SI << "\n");</td>
    <td class="lineNumber">4390</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "  Splitting store: " << *SI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4391</td>
    <td class="codeline"></td>
    <td class="lineNumber">4391</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4392</td>
    <td class="codeline">    // Check whether we have an already split load.</td>
    <td class="lineNumber">4392</td>
    <td class="codeline">    // Check whether we have an already split load.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4393</td>
    <td class="codeline">    auto SplitLoadsMapI = SplitLoadsMap.find(LI);</td>
    <td class="lineNumber">4393</td>
    <td class="codeline">    auto SplitLoadsMapI = SplitLoadsMap.find(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4394</td>
    <td class="codeline">    std::vector<LoadInst *> *SplitLoads = nullptr;</td>
    <td class="lineNumber">4394</td>
    <td class="codeline">    std::vector<LoadInst *> *SplitLoads = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4395</td>
    <td class="codeline">    if (SplitLoadsMapI != SplitLoadsMap.end()) {</td>
    <td class="lineNumber">4395</td>
    <td class="codeline">    if (SplitLoadsMapI != SplitLoadsMap.end()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4396</td>
    <td class="codeline">      SplitLoads = &SplitLoadsMapI->second;</td>
    <td class="lineNumber">4396</td>
    <td class="codeline">      SplitLoads = &SplitLoadsMapI->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4397</td>
    <td class="codeline">      assert(SplitLoads->size() == Offsets.Splits.size() + 1 &&</td>
    <td class="lineNumber">4397</td>
    <td class="codeline">      assert(SplitLoads->size() == Offsets.Splits.size() + 1 &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4398</td>
    <td class="codeline">             "Too few split loads for the number of splits in the store!");</td>
    <td class="lineNumber">4398</td>
    <td class="codeline">             "Too few split loads for the number of splits in the store!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4399</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">4399</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4400</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "          of load: " << *LI << "\n");</td>
    <td class="lineNumber">4400</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "          of load: " << *LI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4401</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4401</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4402</td>
    <td class="codeline"></td>
    <td class="lineNumber">4402</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4403</td>
    <td class="codeline">    uint64_t PartOffset = 0, PartSize = Offsets.Splits.front();</td>
    <td class="lineNumber">4403</td>
    <td class="codeline">    uint64_t PartOffset = 0, PartSize = Offsets.Splits.front();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4404</td>
    <td class="codeline">    int Idx = 0, Size = Offsets.Splits.size();</td>
    <td class="lineNumber">4404</td>
    <td class="codeline">    int Idx = 0, Size = Offsets.Splits.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4405</td>
    <td class="codeline">    for (;;) {</td>
    <td class="lineNumber">4405</td>
    <td class="codeline">    for (;;) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4406</td>
    <td class="codeline">      auto *PartTy = Type::getIntNTy(Ty->getContext(), PartSize * 8);</td>
    <td class="lineNumber">4406</td>
    <td class="codeline">      auto *PartTy = Type::getIntNTy(Ty->getContext(), PartSize * 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4407</td>
    <td class="codeline">      auto *LoadPartPtrTy = PartTy->getPointerTo(LI->getPointerAddressSpace());</td>
    <td class="lineNumber">4407</td>
    <td class="codeline">      auto *LoadPartPtrTy = PartTy->getPointerTo(LI->getPointerAddressSpace());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4408</td>
    <td class="codeline">      auto *StorePartPtrTy = PartTy->getPointerTo(SI->getPointerAddressSpace());</td>
    <td class="lineNumber">4408</td>
    <td class="codeline">      auto *StorePartPtrTy = PartTy->getPointerTo(SI->getPointerAddressSpace());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4409</td>
    <td class="codeline"></td>
    <td class="lineNumber">4409</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4410</td>
    <td class="codeline">      // Either lookup a split load or create one.</td>
    <td class="lineNumber">4410</td>
    <td class="codeline">      // Either lookup a split load or create one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4411</td>
    <td class="codeline">      LoadInst *PLoad;</td>
    <td class="lineNumber">4411</td>
    <td class="codeline">      LoadInst *PLoad;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4412</td>
    <td class="codeline">      if (SplitLoads) {</td>
    <td class="lineNumber">4412</td>
    <td class="codeline">      if (SplitLoads) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4413</td>
    <td class="codeline">        PLoad = (*SplitLoads)[Idx];</td>
    <td class="lineNumber">4413</td>
    <td class="codeline">        PLoad = (*SplitLoads)[Idx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4414</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">4414</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4415</td>
    <td class="codeline">        IRB.SetInsertPoint(LI);</td>
    <td class="lineNumber">4415</td>
    <td class="codeline">        IRB.SetInsertPoint(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4416</td>
    <td class="codeline">        auto AS = LI->getPointerAddressSpace();</td>
    <td class="lineNumber">4416</td>
    <td class="codeline">        auto AS = LI->getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4417</td>
    <td class="codeline">        PLoad = IRB.CreateAlignedLoad(</td>
    <td class="lineNumber">4417</td>
    <td class="codeline">        PLoad = IRB.CreateAlignedLoad(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4418</td>
    <td class="codeline">            PartTy,</td>
    <td class="lineNumber">4418</td>
    <td class="codeline">            PartTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4419</td>
    <td class="codeline">            getAdjustedPtr(IRB, DL, LoadBasePtr,</td>
    <td class="lineNumber">4419</td>
    <td class="codeline">            getAdjustedPtr(IRB, DL, LoadBasePtr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4420</td>
    <td class="codeline">                           APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td class="lineNumber">4420</td>
    <td class="codeline">                           APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4421</td>
    <td class="codeline">                           LoadPartPtrTy, LoadBasePtr->getName() + "."),</td>
    <td class="lineNumber">4421</td>
    <td class="codeline">                           LoadPartPtrTy, LoadBasePtr->getName() + "."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4422</td>
    <td class="codeline">            getAdjustedAlignment(LI, PartOffset),</td>
    <td class="lineNumber">4422</td>
    <td class="codeline">            getAdjustedAlignment(LI, PartOffset),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4423</td>
    <td class="codeline">            /*IsVolatile*/ false, LI->getName());</td>
    <td class="lineNumber">4423</td>
    <td class="codeline">            /*IsVolatile*/ false, LI->getName());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4424</td>
    <td class="codeline">        PLoad->copyMetadata(*LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">4424</td>
    <td class="codeline">        PLoad->copyMetadata(*LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4425</td>
    <td class="codeline">                                  LLVMContext::MD_access_group});</td>
    <td class="lineNumber">4425</td>
    <td class="codeline">                                  LLVMContext::MD_access_group});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4426</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4426</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4427</td>
    <td class="codeline"></td>
    <td class="lineNumber">4427</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4428</td>
    <td class="codeline">      // And store this partition.</td>
    <td class="lineNumber">4428</td>
    <td class="codeline">      // And store this partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4429</td>
    <td class="codeline">      IRB.SetInsertPoint(SI);</td>
    <td class="lineNumber">4429</td>
    <td class="codeline">      IRB.SetInsertPoint(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4430</td>
    <td class="codeline">      auto AS = SI->getPointerAddressSpace();</td>
    <td class="lineNumber">4430</td>
    <td class="codeline">      auto AS = SI->getPointerAddressSpace();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4431</td>
    <td class="codeline">      StoreInst *PStore = IRB.CreateAlignedStore(</td>
    <td class="lineNumber">4431</td>
    <td class="codeline">      StoreInst *PStore = IRB.CreateAlignedStore(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4432</td>
    <td class="codeline">          PLoad,</td>
    <td class="lineNumber">4432</td>
    <td class="codeline">          PLoad,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4433</td>
    <td class="codeline">          getAdjustedPtr(IRB, DL, StoreBasePtr,</td>
    <td class="lineNumber">4433</td>
    <td class="codeline">          getAdjustedPtr(IRB, DL, StoreBasePtr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4434</td>
    <td class="codeline">                         APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td class="lineNumber">4434</td>
    <td class="codeline">                         APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4435</td>
    <td class="codeline">                         StorePartPtrTy, StoreBasePtr->getName() + "."),</td>
    <td class="lineNumber">4435</td>
    <td class="codeline">                         StorePartPtrTy, StoreBasePtr->getName() + "."),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4436</td>
    <td class="codeline">          getAdjustedAlignment(SI, PartOffset),</td>
    <td class="lineNumber">4436</td>
    <td class="codeline">          getAdjustedAlignment(SI, PartOffset),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4437</td>
    <td class="codeline">          /*IsVolatile*/ false);</td>
    <td class="lineNumber">4437</td>
    <td class="codeline">          /*IsVolatile*/ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4438</td>
    <td class="codeline">      PStore->copyMetadata(*SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">4438</td>
    <td class="codeline">      PStore->copyMetadata(*SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4439</td>
    <td class="codeline">                                 LLVMContext::MD_access_group});</td>
    <td class="lineNumber">4439</td>
    <td class="codeline">                                 LLVMContext::MD_access_group});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4440</td>
    <td class="codeline"></td>
    <td class="lineNumber">4440</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4441</td>
    <td class="codeline">      // Now build a new slice for the alloca.</td>
    <td class="lineNumber">4441</td>
    <td class="codeline">      // Now build a new slice for the alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4442</td>
    <td class="codeline">      NewSlices.push_back(</td>
    <td class="lineNumber">4442</td>
    <td class="codeline">      NewSlices.push_back(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4443</td>
    <td class="codeline">          Slice(BaseOffset + PartOffset, BaseOffset + PartOffset + PartSize,</td>
    <td class="lineNumber">4443</td>
    <td class="codeline">          Slice(BaseOffset + PartOffset, BaseOffset + PartOffset + PartSize,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4444</td>
    <td class="codeline">                &PStore->getOperandUse(PStore->getPointerOperandIndex()),</td>
    <td class="lineNumber">4444</td>
    <td class="codeline">                &PStore->getOperandUse(PStore->getPointerOperandIndex()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4445</td>
    <td class="codeline">                /*IsSplittable*/ false));</td>
    <td class="lineNumber">4445</td>
    <td class="codeline">                /*IsSplittable*/ false));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4446</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "    new slice [" << NewSlices.back().beginOffset()</td>
    <td class="lineNumber">4446</td>
    <td class="codeline">      LLVM_DEBUG(dbgs() << "    new slice [" << NewSlices.back().beginOffset()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4447</td>
    <td class="codeline">                        << ", " << NewSlices.back().endOffset()</td>
    <td class="lineNumber">4447</td>
    <td class="codeline">                        << ", " << NewSlices.back().endOffset()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4448</td>
    <td class="codeline">                        << "): " << *PStore << "\n");</td>
    <td class="lineNumber">4448</td>
    <td class="codeline">                        << "): " << *PStore << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4449</td>
    <td class="codeline">      if (!SplitLoads) {</td>
    <td class="lineNumber">4449</td>
    <td class="codeline">      if (!SplitLoads) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4450</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "      of split load: " << *PLoad << "\n");</td>
    <td class="lineNumber">4450</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "      of split load: " << *PLoad << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4451</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4451</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4452</td>
    <td class="codeline"></td>
    <td class="lineNumber">4452</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4453</td>
    <td class="codeline">      // See if we've finished all the splits.</td>
    <td class="lineNumber">4453</td>
    <td class="codeline">      // See if we've finished all the splits.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4454</td>
    <td class="codeline">      if (Idx >= Size)</td>
    <td class="lineNumber">4454</td>
    <td class="codeline">      if (Idx >= Size)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4455</td>
    <td class="codeline">        break;</td>
    <td class="lineNumber">4455</td>
    <td class="codeline">        break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4456</td>
    <td class="codeline"></td>
    <td class="lineNumber">4456</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4457</td>
    <td class="codeline">      // Setup the next partition.</td>
    <td class="lineNumber">4457</td>
    <td class="codeline">      // Setup the next partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4458</td>
    <td class="codeline">      PartOffset = Offsets.Splits[Idx];</td>
    <td class="lineNumber">4458</td>
    <td class="codeline">      PartOffset = Offsets.Splits[Idx];</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4459</td>
    <td class="codeline">      ++Idx;</td>
    <td class="lineNumber">4459</td>
    <td class="codeline">      ++Idx;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4460</td>
    <td class="codeline">      PartSize = (Idx < Size ? Offsets.Splits[Idx] : StoreSize) - PartOffset;</td>
    <td class="lineNumber">4460</td>
    <td class="codeline">      PartSize = (Idx < Size ? Offsets.Splits[Idx] : StoreSize) - PartOffset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4461</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4461</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4462</td>
    <td class="codeline"></td>
    <td class="lineNumber">4462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4463</td>
    <td class="codeline">    // We want to immediately iterate on any allocas impacted by splitting</td>
    <td class="lineNumber">4463</td>
    <td class="codeline">    // We want to immediately iterate on any allocas impacted by splitting</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4464</td>
    <td class="codeline">    // this load, which is only relevant if it isn't a load of this alloca and</td>
    <td class="lineNumber">4464</td>
    <td class="codeline">    // this load, which is only relevant if it isn't a load of this alloca and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4465</td>
    <td class="codeline">    // thus we didn't already split the loads above. We also have to keep track</td>
    <td class="lineNumber">4465</td>
    <td class="codeline">    // thus we didn't already split the loads above. We also have to keep track</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4466</td>
    <td class="codeline">    // of any promotable allocas we split loads on as they can no longer be</td>
    <td class="lineNumber">4466</td>
    <td class="codeline">    // of any promotable allocas we split loads on as they can no longer be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4467</td>
    <td class="codeline">    // promoted.</td>
    <td class="lineNumber">4467</td>
    <td class="codeline">    // promoted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4468</td>
    <td class="codeline">    if (!SplitLoads) {</td>
    <td class="lineNumber">4468</td>
    <td class="codeline">    if (!SplitLoads) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4469</td>
    <td class="codeline">      if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(LoadBasePtr)) {</td>
    <td class="lineNumber">4469</td>
    <td class="codeline">      if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(LoadBasePtr)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4470</td>
    <td class="codeline">        assert(OtherAI != &AI && "We can't re-split our own alloca!");</td>
    <td class="lineNumber">4470</td>
    <td class="codeline">        assert(OtherAI != &AI && "We can't re-split our own alloca!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4471</td>
    <td class="codeline">        ResplitPromotableAllocas.insert(OtherAI);</td>
    <td class="lineNumber">4471</td>
    <td class="codeline">        ResplitPromotableAllocas.insert(OtherAI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4472</td>
    <td class="codeline">        Worklist.insert(OtherAI);</td>
    <td class="lineNumber">4472</td>
    <td class="codeline">        Worklist.insert(OtherAI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4473</td>
    <td class="codeline">      } else if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(</td>
    <td class="lineNumber">4473</td>
    <td class="codeline">      } else if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4474</td>
    <td class="codeline">                     LoadBasePtr->stripInBoundsOffsets())) {</td>
    <td class="lineNumber">4474</td>
    <td class="codeline">                     LoadBasePtr->stripInBoundsOffsets())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4475</td>
    <td class="codeline">        assert(OtherAI != &AI && "We can't re-split our own alloca!");</td>
    <td class="lineNumber">4475</td>
    <td class="codeline">        assert(OtherAI != &AI && "We can't re-split our own alloca!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4476</td>
    <td class="codeline">        Worklist.insert(OtherAI);</td>
    <td class="lineNumber">4476</td>
    <td class="codeline">        Worklist.insert(OtherAI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4477</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4477</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4478</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4478</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4479</td>
    <td class="codeline"></td>
    <td class="lineNumber">4479</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4480</td>
    <td class="codeline">    // Mark the original store as dead now that we've split it up and kill its</td>
    <td class="lineNumber">4480</td>
    <td class="codeline">    // Mark the original store as dead now that we've split it up and kill its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4481</td>
    <td class="codeline">    // slice. Note that we leave the original load in place unless this store</td>
    <td class="lineNumber">4481</td>
    <td class="codeline">    // slice. Note that we leave the original load in place unless this store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4482</td>
    <td class="codeline">    // was its only use. It may in turn be split up if it is an alloca load</td>
    <td class="lineNumber">4482</td>
    <td class="codeline">    // was its only use. It may in turn be split up if it is an alloca load</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4483</td>
    <td class="codeline">    // for some other alloca, but it may be a normal load. This may introduce</td>
    <td class="lineNumber">4483</td>
    <td class="codeline">    // for some other alloca, but it may be a normal load. This may introduce</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4484</td>
    <td class="codeline">    // redundant loads, but where those can be merged the rest of the optimizer</td>
    <td class="lineNumber">4484</td>
    <td class="codeline">    // redundant loads, but where those can be merged the rest of the optimizer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4485</td>
    <td class="codeline">    // should handle the merging, and this uncovers SSA splits which is more</td>
    <td class="lineNumber">4485</td>
    <td class="codeline">    // should handle the merging, and this uncovers SSA splits which is more</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4486</td>
    <td class="codeline">    // important. In practice, the original loads will almost always be fully</td>
    <td class="lineNumber">4486</td>
    <td class="codeline">    // important. In practice, the original loads will almost always be fully</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4487</td>
    <td class="codeline">    // split and removed eventually, and the splits will be merged by any</td>
    <td class="lineNumber">4487</td>
    <td class="codeline">    // split and removed eventually, and the splits will be merged by any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4488</td>
    <td class="codeline">    // trivial CSE, including instcombine.</td>
    <td class="lineNumber">4488</td>
    <td class="codeline">    // trivial CSE, including instcombine.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4489</td>
    <td class="codeline">    if (LI->hasOneUse()) {</td>
    <td class="lineNumber">4489</td>
    <td class="codeline">    if (LI->hasOneUse()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4490</td>
    <td class="codeline">      assert(*LI->user_begin() == SI && "Single use isn't this store!");</td>
    <td class="lineNumber">4490</td>
    <td class="codeline">      assert(*LI->user_begin() == SI && "Single use isn't this store!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4491</td>
    <td class="codeline">      DeadInsts.push_back(LI);</td>
    <td class="lineNumber">4491</td>
    <td class="codeline">      DeadInsts.push_back(LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4492</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4492</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4493</td>
    <td class="codeline">    DeadInsts.push_back(SI);</td>
    <td class="lineNumber">4493</td>
    <td class="codeline">    DeadInsts.push_back(SI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4494</td>
    <td class="codeline">    Offsets.S->kill();</td>
    <td class="lineNumber">4494</td>
    <td class="codeline">    Offsets.S->kill();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4495</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4495</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4496</td>
    <td class="codeline"></td>
    <td class="lineNumber">4496</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4497</td>
    <td class="codeline">  // Remove the killed slices that have ben pre-split.</td>
    <td class="lineNumber">4497</td>
    <td class="codeline">  // Remove the killed slices that have ben pre-split.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4498</td>
    <td class="codeline">  llvm::erase_if(AS, [](const Slice &S) { return S.isDead(); });</td>
    <td class="lineNumber">4498</td>
    <td class="codeline">  llvm::erase_if(AS, [](const Slice &S) { return S.isDead(); });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4499</td>
    <td class="codeline"></td>
    <td class="lineNumber">4499</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4500</td>
    <td class="codeline">  // Insert our new slices. This will sort and merge them into the sorted</td>
    <td class="lineNumber">4500</td>
    <td class="codeline">  // Insert our new slices. This will sort and merge them into the sorted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4501</td>
    <td class="codeline">  // sequence.</td>
    <td class="lineNumber">4501</td>
    <td class="codeline">  // sequence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4502</td>
    <td class="codeline">  AS.insert(NewSlices);</td>
    <td class="lineNumber">4502</td>
    <td class="codeline">  AS.insert(NewSlices);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4503</td>
    <td class="codeline"></td>
    <td class="lineNumber">4503</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4504</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Pre-split slices:\n");</td>
    <td class="lineNumber">4504</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Pre-split slices:\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4505</td>
    <td class="codeline">#ifndef NDEBUG</td>
    <td class="lineNumber">4505</td>
    <td class="codeline">#ifndef NDEBUG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4506</td>
    <td class="codeline">  for (auto I = AS.begin(), E = AS.end(); I != E; ++I)</td>
    <td class="lineNumber">4506</td>
    <td class="codeline">  for (auto I = AS.begin(), E = AS.end(); I != E; ++I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4507</td>
    <td class="codeline">    LLVM_DEBUG(AS.print(dbgs(), I, "    "));</td>
    <td class="lineNumber">4507</td>
    <td class="codeline">    LLVM_DEBUG(AS.print(dbgs(), I, "    "));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4508</td>
    <td class="codeline">#endif</td>
    <td class="lineNumber">4508</td>
    <td class="codeline">#endif</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4509</td>
    <td class="codeline"></td>
    <td class="lineNumber">4509</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4510</td>
    <td class="codeline">  // Finally, don't try to promote any allocas that new require re-splitting.</td>
    <td class="lineNumber">4510</td>
    <td class="codeline">  // Finally, don't try to promote any allocas that new require re-splitting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4511</td>
    <td class="codeline">  // They have already been added to the worklist above.</td>
    <td class="lineNumber">4511</td>
    <td class="codeline">  // They have already been added to the worklist above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4512</td>
    <td class="codeline">  llvm::erase_if(PromotableAllocas, [&](AllocaInst *AI) {</td>
    <td class="lineNumber">4512</td>
    <td class="codeline">  llvm::erase_if(PromotableAllocas, [&](AllocaInst *AI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4513</td>
    <td class="codeline">    return ResplitPromotableAllocas.count(AI);</td>
    <td class="lineNumber">4513</td>
    <td class="codeline">    return ResplitPromotableAllocas.count(AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4514</td>
    <td class="codeline">  });</td>
    <td class="lineNumber">4514</td>
    <td class="codeline">  });</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4515</td>
    <td class="codeline"></td>
    <td class="lineNumber">4515</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4516</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">4516</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4517</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4517</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4518</td>
    <td class="codeline"></td>
    <td class="lineNumber">4518</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4519</td>
    <td class="codeline">/// Rewrite an alloca partition's users.</td>
    <td class="lineNumber">4519</td>
    <td class="codeline">/// Rewrite an alloca partition's users.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4520</td>
    <td class="codeline">///</td>
    <td class="lineNumber">4520</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4521</td>
    <td class="codeline">/// This routine drives both of the rewriting goals of the SROA pass. It tries</td>
    <td class="lineNumber">4521</td>
    <td class="codeline">/// This routine drives both of the rewriting goals of the SROA pass. It tries</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4522</td>
    <td class="codeline">/// to rewrite uses of an alloca partition to be conducive for SSA value</td>
    <td class="lineNumber">4522</td>
    <td class="codeline">/// to rewrite uses of an alloca partition to be conducive for SSA value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4523</td>
    <td class="codeline">/// promotion. If the partition needs a new, more refined alloca, this will</td>
    <td class="lineNumber">4523</td>
    <td class="codeline">/// promotion. If the partition needs a new, more refined alloca, this will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4524</td>
    <td class="codeline">/// build that new alloca, preserving as much type information as possible, and</td>
    <td class="lineNumber">4524</td>
    <td class="codeline">/// build that new alloca, preserving as much type information as possible, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4525</td>
    <td class="codeline">/// rewrite the uses of the old alloca to point at the new one and have the</td>
    <td class="lineNumber">4525</td>
    <td class="codeline">/// rewrite the uses of the old alloca to point at the new one and have the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4526</td>
    <td class="codeline">/// appropriate new offsets. It also evaluates how successful the rewrite was</td>
    <td class="lineNumber">4526</td>
    <td class="codeline">/// appropriate new offsets. It also evaluates how successful the rewrite was</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4527</td>
    <td class="codeline">/// at enabling promotion and if it was successful queues the alloca to be</td>
    <td class="lineNumber">4527</td>
    <td class="codeline">/// at enabling promotion and if it was successful queues the alloca to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4528</td>
    <td class="codeline">/// promoted.</td>
    <td class="lineNumber">4528</td>
    <td class="codeline">/// promoted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4529</td>
    <td class="codeline">AllocaInst *SROAPass::rewritePartition(AllocaInst &AI, AllocaSlices &AS,</td>
    <td class="lineNumber">4529</td>
    <td class="codeline">AllocaInst *SROAPass::rewritePartition(AllocaInst &AI, AllocaSlices &AS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4530</td>
    <td class="codeline">                                       Partition &P) {</td>
    <td class="lineNumber">4530</td>
    <td class="codeline">                                       Partition &P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4531</td>
    <td class="codeline">  // Try to compute a friendly type for this partition of the alloca. This</td>
    <td class="lineNumber">4531</td>
    <td class="codeline">  // Try to compute a friendly type for this partition of the alloca. This</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4532</td>
    <td class="codeline">  // won't always succeed, in which case we fall back to a legal integer type</td>
    <td class="lineNumber">4532</td>
    <td class="codeline">  // won't always succeed, in which case we fall back to a legal integer type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4533</td>
    <td class="codeline">  // or an i8 array of an appropriate size.</td>
    <td class="lineNumber">4533</td>
    <td class="codeline">  // or an i8 array of an appropriate size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4534</td>
    <td class="codeline">  Type *SliceTy = nullptr;</td>
    <td class="lineNumber">4534</td>
    <td class="codeline">  Type *SliceTy = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4535</td>
    <td class="codeline">  VectorType *SliceVecTy = nullptr;</td>
    <td class="lineNumber">4535</td>
    <td class="codeline">  VectorType *SliceVecTy = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4536</td>
    <td class="codeline">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td class="lineNumber">4536</td>
    <td class="codeline">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4537</td>
    <td class="codeline">  std::pair<Type *, IntegerType *> CommonUseTy =</td>
    <td class="lineNumber">4537</td>
    <td class="codeline">  std::pair<Type *, IntegerType *> CommonUseTy =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4538</td>
    <td class="codeline">      findCommonType(P.begin(), P.end(), P.endOffset());</td>
    <td class="lineNumber">4538</td>
    <td class="codeline">      findCommonType(P.begin(), P.end(), P.endOffset());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4539</td>
    <td class="codeline">  // Do all uses operate on the same type?</td>
    <td class="lineNumber">4539</td>
    <td class="codeline">  // Do all uses operate on the same type?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4540</td>
    <td class="codeline">  if (CommonUseTy.first)</td>
    <td class="lineNumber">4540</td>
    <td class="codeline">  if (CommonUseTy.first)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4541</td>
    <td class="codeline">    if (DL.getTypeAllocSize(CommonUseTy.first).getFixedValue() >= P.size()) {</td>
    <td class="lineNumber">4541</td>
    <td class="codeline">    if (DL.getTypeAllocSize(CommonUseTy.first).getFixedValue() >= P.size()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4542</td>
    <td class="codeline">      SliceTy = CommonUseTy.first;</td>
    <td class="lineNumber">4542</td>
    <td class="codeline">      SliceTy = CommonUseTy.first;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4543</td>
    <td class="codeline">      SliceVecTy = dyn_cast<VectorType>(SliceTy);</td>
    <td class="lineNumber">4543</td>
    <td class="codeline">      SliceVecTy = dyn_cast<VectorType>(SliceTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4544</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4544</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4545</td>
    <td class="codeline">  // If not, can we find an appropriate subtype in the original allocated type?</td>
    <td class="lineNumber">4545</td>
    <td class="codeline">  // If not, can we find an appropriate subtype in the original allocated type?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4546</td>
    <td class="codeline">  if (!SliceTy)</td>
    <td class="lineNumber">4546</td>
    <td class="codeline">  if (!SliceTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4547</td>
    <td class="codeline">    if (Type *TypePartitionTy = getTypePartition(DL, AI.getAllocatedType(),</td>
    <td class="lineNumber">4547</td>
    <td class="codeline">    if (Type *TypePartitionTy = getTypePartition(DL, AI.getAllocatedType(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4548</td>
    <td class="codeline">                                                 P.beginOffset(), P.size()))</td>
    <td class="lineNumber">4548</td>
    <td class="codeline">                                                 P.beginOffset(), P.size()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4549</td>
    <td class="codeline">      SliceTy = TypePartitionTy;</td>
    <td class="lineNumber">4549</td>
    <td class="codeline">      SliceTy = TypePartitionTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4550</td>
    <td class="codeline"></td>
    <td class="lineNumber">4550</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4551</td>
    <td class="codeline">  // If still not, can we use the largest bitwidth integer type used?</td>
    <td class="lineNumber">4551</td>
    <td class="codeline">  // If still not, can we use the largest bitwidth integer type used?</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4552</td>
    <td class="codeline">  if (!SliceTy && CommonUseTy.second)</td>
    <td class="lineNumber">4552</td>
    <td class="codeline">  if (!SliceTy && CommonUseTy.second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4553</td>
    <td class="codeline">    if (DL.getTypeAllocSize(CommonUseTy.second).getFixedValue() >= P.size()) {</td>
    <td class="lineNumber">4553</td>
    <td class="codeline">    if (DL.getTypeAllocSize(CommonUseTy.second).getFixedValue() >= P.size()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4554</td>
    <td class="codeline">      SliceTy = CommonUseTy.second;</td>
    <td class="lineNumber">4554</td>
    <td class="codeline">      SliceTy = CommonUseTy.second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4555</td>
    <td class="codeline">      SliceVecTy = dyn_cast<VectorType>(SliceTy);</td>
    <td class="lineNumber">4555</td>
    <td class="codeline">      SliceVecTy = dyn_cast<VectorType>(SliceTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4556</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4556</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4557</td>
    <td class="codeline">  if ((!SliceTy || (SliceTy->isArrayTy() &&</td>
    <td class="lineNumber">4557</td>
    <td class="codeline">  if ((!SliceTy || (SliceTy->isArrayTy() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4558</td>
    <td class="codeline">                    SliceTy->getArrayElementType()->isIntegerTy())) &&</td>
    <td class="lineNumber">4558</td>
    <td class="codeline">                    SliceTy->getArrayElementType()->isIntegerTy())) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4559</td>
    <td class="codeline">      DL.isLegalInteger(P.size() * 8)) {</td>
    <td class="lineNumber">4559</td>
    <td class="codeline">      DL.isLegalInteger(P.size() * 8)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4560</td>
    <td class="codeline">    SliceTy = Type::getIntNTy(*C, P.size() * 8);</td>
    <td class="lineNumber">4560</td>
    <td class="codeline">    SliceTy = Type::getIntNTy(*C, P.size() * 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4561</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4561</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4562</td>
    <td class="codeline"></td>
    <td class="lineNumber">4562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4563</td>
    <td class="codeline">  // If the common use types are not viable for promotion then attempt to find</td>
    <td class="lineNumber">4563</td>
    <td class="codeline">  // If the common use types are not viable for promotion then attempt to find</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4564</td>
    <td class="codeline">  // another type that is viable.</td>
    <td class="lineNumber">4564</td>
    <td class="codeline">  // another type that is viable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4565</td>
    <td class="codeline">  if (SliceVecTy && !checkVectorTypeForPromotion(P, SliceVecTy, DL))</td>
    <td class="lineNumber">4565</td>
    <td class="codeline">  if (SliceVecTy && !checkVectorTypeForPromotion(P, SliceVecTy, DL))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4566</td>
    <td class="codeline">    if (Type *TypePartitionTy = getTypePartition(DL, AI.getAllocatedType(),</td>
    <td class="lineNumber">4566</td>
    <td class="codeline">    if (Type *TypePartitionTy = getTypePartition(DL, AI.getAllocatedType(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4567</td>
    <td class="codeline">                                                 P.beginOffset(), P.size())) {</td>
    <td class="lineNumber">4567</td>
    <td class="codeline">                                                 P.beginOffset(), P.size())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4568</td>
    <td class="codeline">      VectorType *TypePartitionVecTy = dyn_cast<VectorType>(TypePartitionTy);</td>
    <td class="lineNumber">4568</td>
    <td class="codeline">      VectorType *TypePartitionVecTy = dyn_cast<VectorType>(TypePartitionTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4569</td>
    <td class="codeline">      if (TypePartitionVecTy &&</td>
    <td class="lineNumber">4569</td>
    <td class="codeline">      if (TypePartitionVecTy &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4570</td>
    <td class="codeline">          checkVectorTypeForPromotion(P, TypePartitionVecTy, DL))</td>
    <td class="lineNumber">4570</td>
    <td class="codeline">          checkVectorTypeForPromotion(P, TypePartitionVecTy, DL))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4571</td>
    <td class="codeline">        SliceTy = TypePartitionTy;</td>
    <td class="lineNumber">4571</td>
    <td class="codeline">        SliceTy = TypePartitionTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4572</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4572</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4573</td>
    <td class="codeline"></td>
    <td class="lineNumber">4573</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4574</td>
    <td class="codeline">  if (!SliceTy)</td>
    <td class="lineNumber">4574</td>
    <td class="codeline">  if (!SliceTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4575</td>
    <td class="codeline">    SliceTy = ArrayType::get(Type::getInt8Ty(*C), P.size());</td>
    <td class="lineNumber">4575</td>
    <td class="codeline">    SliceTy = ArrayType::get(Type::getInt8Ty(*C), P.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4576</td>
    <td class="codeline">  assert(DL.getTypeAllocSize(SliceTy).getFixedValue() >= P.size());</td>
    <td class="lineNumber">4576</td>
    <td class="codeline">  assert(DL.getTypeAllocSize(SliceTy).getFixedValue() >= P.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4577</td>
    <td class="codeline"></td>
    <td class="lineNumber">4577</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4578</td>
    <td class="codeline">  bool IsIntegerPromotable = isIntegerWideningViable(P, SliceTy, DL);</td>
    <td class="lineNumber">4578</td>
    <td class="codeline">  bool IsIntegerPromotable = isIntegerWideningViable(P, SliceTy, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4579</td>
    <td class="codeline"></td>
    <td class="lineNumber">4579</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4580</td>
    <td class="codeline">  VectorType *VecTy =</td>
    <td class="lineNumber">4580</td>
    <td class="codeline">  VectorType *VecTy =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4581</td>
    <td class="codeline">      IsIntegerPromotable ? nullptr : isVectorPromotionViable(P, DL);</td>
    <td class="lineNumber">4581</td>
    <td class="codeline">      IsIntegerPromotable ? nullptr : isVectorPromotionViable(P, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4582</td>
    <td class="codeline">  if (VecTy)</td>
    <td class="lineNumber">4582</td>
    <td class="codeline">  if (VecTy)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4583</td>
    <td class="codeline">    SliceTy = VecTy;</td>
    <td class="lineNumber">4583</td>
    <td class="codeline">    SliceTy = VecTy;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4584</td>
    <td class="codeline"></td>
    <td class="lineNumber">4584</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4585</td>
    <td class="codeline">  // Check for the case where we're going to rewrite to a new alloca of the</td>
    <td class="lineNumber">4585</td>
    <td class="codeline">  // Check for the case where we're going to rewrite to a new alloca of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4586</td>
    <td class="codeline">  // exact same type as the original, and with the same access offsets. In that</td>
    <td class="lineNumber">4586</td>
    <td class="codeline">  // exact same type as the original, and with the same access offsets. In that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4587</td>
    <td class="codeline">  // case, re-use the existing alloca, but still run through the rewriter to</td>
    <td class="lineNumber">4587</td>
    <td class="codeline">  // case, re-use the existing alloca, but still run through the rewriter to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4588</td>
    <td class="codeline">  // perform phi and select speculation.</td>
    <td class="lineNumber">4588</td>
    <td class="codeline">  // perform phi and select speculation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4589</td>
    <td class="codeline">  // P.beginOffset() can be non-zero even with the same type in a case with</td>
    <td class="lineNumber">4589</td>
    <td class="codeline">  // P.beginOffset() can be non-zero even with the same type in a case with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4590</td>
    <td class="codeline">  // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).</td>
    <td class="lineNumber">4590</td>
    <td class="codeline">  // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4591</td>
    <td class="codeline">  AllocaInst *NewAI;</td>
    <td class="lineNumber">4591</td>
    <td class="codeline">  AllocaInst *NewAI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4592</td>
    <td class="codeline">  if (SliceTy == AI.getAllocatedType() && P.beginOffset() == 0) {</td>
    <td class="lineNumber">4592</td>
    <td class="codeline">  if (SliceTy == AI.getAllocatedType() && P.beginOffset() == 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4593</td>
    <td class="codeline">    NewAI = &AI;</td>
    <td class="lineNumber">4593</td>
    <td class="codeline">    NewAI = &AI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4594</td>
    <td class="codeline">    // FIXME: We should be able to bail at this point with "nothing changed".</td>
    <td class="lineNumber">4594</td>
    <td class="codeline">    // FIXME: We should be able to bail at this point with "nothing changed".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4595</td>
    <td class="codeline">    // FIXME: We might want to defer PHI speculation until after here.</td>
    <td class="lineNumber">4595</td>
    <td class="codeline">    // FIXME: We might want to defer PHI speculation until after here.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4596</td>
    <td class="codeline">    // FIXME: return nullptr;</td>
    <td class="lineNumber">4596</td>
    <td class="codeline">    // FIXME: return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4597</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">4597</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4598</td>
    <td class="codeline">    // Make sure the alignment is compatible with P.beginOffset().</td>
    <td class="lineNumber">4598</td>
    <td class="codeline">    // Make sure the alignment is compatible with P.beginOffset().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4599</td>
    <td class="codeline">    const Align Alignment = commonAlignment(AI.getAlign(), P.beginOffset());</td>
    <td class="lineNumber">4599</td>
    <td class="codeline">    const Align Alignment = commonAlignment(AI.getAlign(), P.beginOffset());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4600</td>
    <td class="codeline">    // If we will get at least this much alignment from the type alone, leave</td>
    <td class="lineNumber">4600</td>
    <td class="codeline">    // If we will get at least this much alignment from the type alone, leave</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4601</td>
    <td class="codeline">    // the alloca's alignment unconstrained.</td>
    <td class="lineNumber">4601</td>
    <td class="codeline">    // the alloca's alignment unconstrained.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4602</td>
    <td class="codeline">    const bool IsUnconstrained = Alignment <= DL.getABITypeAlign(SliceTy);</td>
    <td class="lineNumber">4602</td>
    <td class="codeline">    const bool IsUnconstrained = Alignment <= DL.getABITypeAlign(SliceTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4603</td>
    <td class="codeline">    NewAI = new AllocaInst(</td>
    <td class="lineNumber">4603</td>
    <td class="codeline">    NewAI = new AllocaInst(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4604</td>
    <td class="codeline">        SliceTy, AI.getAddressSpace(), nullptr,</td>
    <td class="lineNumber">4604</td>
    <td class="codeline">        SliceTy, AI.getAddressSpace(), nullptr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4605</td>
    <td class="codeline">        IsUnconstrained ? DL.getPrefTypeAlign(SliceTy) : Alignment,</td>
    <td class="lineNumber">4605</td>
    <td class="codeline">        IsUnconstrained ? DL.getPrefTypeAlign(SliceTy) : Alignment,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4606</td>
    <td class="codeline">        AI.getName() + ".sroa." + Twine(P.begin() - AS.begin()), &AI);</td>
    <td class="lineNumber">4606</td>
    <td class="codeline">        AI.getName() + ".sroa." + Twine(P.begin() - AS.begin()), &AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4607</td>
    <td class="codeline">    // Copy the old AI debug location over to the new one.</td>
    <td class="lineNumber">4607</td>
    <td class="codeline">    // Copy the old AI debug location over to the new one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4608</td>
    <td class="codeline">    NewAI->setDebugLoc(AI.getDebugLoc());</td>
    <td class="lineNumber">4608</td>
    <td class="codeline">    NewAI->setDebugLoc(AI.getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4609</td>
    <td class="codeline">    ++NumNewAllocas;</td>
    <td class="lineNumber">4609</td>
    <td class="codeline">    ++NumNewAllocas;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4610</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4610</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4611</td>
    <td class="codeline"></td>
    <td class="lineNumber">4611</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4612</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Rewriting alloca partition "</td>
    <td class="lineNumber">4612</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "Rewriting alloca partition "</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4613</td>
    <td class="codeline">                    << "[" << P.beginOffset() << "," << P.endOffset()</td>
    <td class="lineNumber">4613</td>
    <td class="codeline">                    << "[" << P.beginOffset() << "," << P.endOffset()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4614</td>
    <td class="codeline">                    << ") to: " << *NewAI << "\n");</td>
    <td class="lineNumber">4614</td>
    <td class="codeline">                    << ") to: " << *NewAI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4615</td>
    <td class="codeline"></td>
    <td class="lineNumber">4615</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4616</td>
    <td class="codeline">  // Track the high watermark on the worklist as it is only relevant for</td>
    <td class="lineNumber">4616</td>
    <td class="codeline">  // Track the high watermark on the worklist as it is only relevant for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4617</td>
    <td class="codeline">  // promoted allocas. We will reset it to this point if the alloca is not in</td>
    <td class="lineNumber">4617</td>
    <td class="codeline">  // promoted allocas. We will reset it to this point if the alloca is not in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4618</td>
    <td class="codeline">  // fact scheduled for promotion.</td>
    <td class="lineNumber">4618</td>
    <td class="codeline">  // fact scheduled for promotion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4619</td>
    <td class="codeline">  unsigned PPWOldSize = PostPromotionWorklist.size();</td>
    <td class="lineNumber">4619</td>
    <td class="codeline">  unsigned PPWOldSize = PostPromotionWorklist.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4620</td>
    <td class="codeline">  unsigned NumUses = 0;</td>
    <td class="lineNumber">4620</td>
    <td class="codeline">  unsigned NumUses = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4621</td>
    <td class="codeline">  SmallSetVector<PHINode *, 8> PHIUsers;</td>
    <td class="lineNumber">4621</td>
    <td class="codeline">  SmallSetVector<PHINode *, 8> PHIUsers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4622</td>
    <td class="codeline">  SmallSetVector<SelectInst *, 8> SelectUsers;</td>
    <td class="lineNumber">4622</td>
    <td class="codeline">  SmallSetVector<SelectInst *, 8> SelectUsers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4623</td>
    <td class="codeline"></td>
    <td class="lineNumber">4623</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4624</td>
    <td class="codeline">  AllocaSliceRewriter Rewriter(DL, AS, *this, AI, *NewAI, P.beginOffset(),</td>
    <td class="lineNumber">4624</td>
    <td class="codeline">  AllocaSliceRewriter Rewriter(DL, AS, *this, AI, *NewAI, P.beginOffset(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4625</td>
    <td class="codeline">                               P.endOffset(), IsIntegerPromotable, VecTy,</td>
    <td class="lineNumber">4625</td>
    <td class="codeline">                               P.endOffset(), IsIntegerPromotable, VecTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4626</td>
    <td class="codeline">                               PHIUsers, SelectUsers);</td>
    <td class="lineNumber">4626</td>
    <td class="codeline">                               PHIUsers, SelectUsers);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4627</td>
    <td class="codeline">  bool Promotable = true;</td>
    <td class="lineNumber">4627</td>
    <td class="codeline">  bool Promotable = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4628</td>
    <td class="codeline">  for (Slice *S : P.splitSliceTails()) {</td>
    <td class="lineNumber">4628</td>
    <td class="codeline">  for (Slice *S : P.splitSliceTails()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4629</td>
    <td class="codeline">    Promotable &= Rewriter.visit(S);</td>
    <td class="lineNumber">4629</td>
    <td class="codeline">    Promotable &= Rewriter.visit(S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4630</td>
    <td class="codeline">    ++NumUses;</td>
    <td class="lineNumber">4630</td>
    <td class="codeline">    ++NumUses;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4631</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4631</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4632</td>
    <td class="codeline">  for (Slice &S : P) {</td>
    <td class="lineNumber">4632</td>
    <td class="codeline">  for (Slice &S : P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4633</td>
    <td class="codeline">    Promotable &= Rewriter.visit(&S);</td>
    <td class="lineNumber">4633</td>
    <td class="codeline">    Promotable &= Rewriter.visit(&S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4634</td>
    <td class="codeline">    ++NumUses;</td>
    <td class="lineNumber">4634</td>
    <td class="codeline">    ++NumUses;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4635</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4635</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4636</td>
    <td class="codeline"></td>
    <td class="lineNumber">4636</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4637</td>
    <td class="codeline">  NumAllocaPartitionUses += NumUses;</td>
    <td class="lineNumber">4637</td>
    <td class="codeline">  NumAllocaPartitionUses += NumUses;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4638</td>
    <td class="codeline">  MaxUsesPerAllocaPartition.updateMax(NumUses);</td>
    <td class="lineNumber">4638</td>
    <td class="codeline">  MaxUsesPerAllocaPartition.updateMax(NumUses);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4639</td>
    <td class="codeline"></td>
    <td class="lineNumber">4639</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4640</td>
    <td class="codeline">  // Now that we've processed all the slices in the new partition, check if any</td>
    <td class="lineNumber">4640</td>
    <td class="codeline">  // Now that we've processed all the slices in the new partition, check if any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4641</td>
    <td class="codeline">  // PHIs or Selects would block promotion.</td>
    <td class="lineNumber">4641</td>
    <td class="codeline">  // PHIs or Selects would block promotion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4642</td>
    <td class="codeline">  for (PHINode *PHI : PHIUsers)</td>
    <td class="lineNumber">4642</td>
    <td class="codeline">  for (PHINode *PHI : PHIUsers)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4643</td>
    <td class="codeline">    if (!isSafePHIToSpeculate(*PHI)) {</td>
    <td class="lineNumber">4643</td>
    <td class="codeline">    if (!isSafePHIToSpeculate(*PHI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4644</td>
    <td class="codeline">      Promotable = false;</td>
    <td class="lineNumber">4644</td>
    <td class="codeline">      Promotable = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4645</td>
    <td class="codeline">      PHIUsers.clear();</td>
    <td class="lineNumber">4645</td>
    <td class="codeline">      PHIUsers.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4646</td>
    <td class="codeline">      SelectUsers.clear();</td>
    <td class="lineNumber">4646</td>
    <td class="codeline">      SelectUsers.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4647</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">4647</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4648</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4648</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4649</td>
    <td class="codeline"></td>
    <td class="lineNumber">4649</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4650</td>
    <td class="codeline">  SmallVector<std::pair<SelectInst *, RewriteableMemOps>, 2></td>
    <td class="lineNumber">4650</td>
    <td class="codeline">  SmallVector<std::pair<SelectInst *, RewriteableMemOps>, 2></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4651</td>
    <td class="codeline">      NewSelectsToRewrite;</td>
    <td class="lineNumber">4651</td>
    <td class="codeline">      NewSelectsToRewrite;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4652</td>
    <td class="codeline">  NewSelectsToRewrite.reserve(SelectUsers.size());</td>
    <td class="lineNumber">4652</td>
    <td class="codeline">  NewSelectsToRewrite.reserve(SelectUsers.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4653</td>
    <td class="codeline">  for (SelectInst *Sel : SelectUsers) {</td>
    <td class="lineNumber">4653</td>
    <td class="codeline">  for (SelectInst *Sel : SelectUsers) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4654</td>
    <td class="codeline">    std::optional<RewriteableMemOps> Ops =</td>
    <td class="lineNumber">4654</td>
    <td class="codeline">    std::optional<RewriteableMemOps> Ops =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4655</td>
    <td class="codeline">        isSafeSelectToSpeculate(*Sel, PreserveCFG);</td>
    <td class="lineNumber">4655</td>
    <td class="codeline">        isSafeSelectToSpeculate(*Sel, PreserveCFG);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4656</td>
    <td class="codeline">    if (!Ops) {</td>
    <td class="lineNumber">4656</td>
    <td class="codeline">    if (!Ops) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4657</td>
    <td class="codeline">      Promotable = false;</td>
    <td class="lineNumber">4657</td>
    <td class="codeline">      Promotable = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4658</td>
    <td class="codeline">      PHIUsers.clear();</td>
    <td class="lineNumber">4658</td>
    <td class="codeline">      PHIUsers.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4659</td>
    <td class="codeline">      SelectUsers.clear();</td>
    <td class="lineNumber">4659</td>
    <td class="codeline">      SelectUsers.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4660</td>
    <td class="codeline">      NewSelectsToRewrite.clear();</td>
    <td class="lineNumber">4660</td>
    <td class="codeline">      NewSelectsToRewrite.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4661</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">4661</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4662</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4662</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4663</td>
    <td class="codeline">    NewSelectsToRewrite.emplace_back(std::make_pair(Sel, *Ops));</td>
    <td class="lineNumber">4663</td>
    <td class="codeline">    NewSelectsToRewrite.emplace_back(std::make_pair(Sel, *Ops));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4664</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4664</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4665</td>
    <td class="codeline"></td>
    <td class="lineNumber">4665</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4666</td>
    <td class="codeline">  if (Promotable) {</td>
    <td class="lineNumber">4666</td>
    <td class="codeline">  if (Promotable) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4667</td>
    <td class="codeline">    for (Use *U : AS.getDeadUsesIfPromotable()) {</td>
    <td class="lineNumber">4667</td>
    <td class="codeline">    for (Use *U : AS.getDeadUsesIfPromotable()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4668</td>
    <td class="codeline">      auto *OldInst = dyn_cast<Instruction>(U->get());</td>
    <td class="lineNumber">4668</td>
    <td class="codeline">      auto *OldInst = dyn_cast<Instruction>(U->get());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4669</td>
    <td class="codeline">      Value::dropDroppableUse(*U);</td>
    <td class="lineNumber">4669</td>
    <td class="codeline">      Value::dropDroppableUse(*U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4670</td>
    <td class="codeline">      if (OldInst)</td>
    <td class="lineNumber">4670</td>
    <td class="codeline">      if (OldInst)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4671</td>
    <td class="codeline">        if (isInstructionTriviallyDead(OldInst))</td>
    <td class="lineNumber">4671</td>
    <td class="codeline">        if (isInstructionTriviallyDead(OldInst))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4672</td>
    <td class="codeline">          DeadInsts.push_back(OldInst);</td>
    <td class="lineNumber">4672</td>
    <td class="codeline">          DeadInsts.push_back(OldInst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4673</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4673</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4674</td>
    <td class="codeline">    if (PHIUsers.empty() && SelectUsers.empty()) {</td>
    <td class="lineNumber">4674</td>
    <td class="codeline">    if (PHIUsers.empty() && SelectUsers.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4675</td>
    <td class="codeline">      // Promote the alloca.</td>
    <td class="lineNumber">4675</td>
    <td class="codeline">      // Promote the alloca.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4676</td>
    <td class="codeline">      PromotableAllocas.push_back(NewAI);</td>
    <td class="lineNumber">4676</td>
    <td class="codeline">      PromotableAllocas.push_back(NewAI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4677</td>
    <td class="codeline">    } else {</td>
    <td class="lineNumber">4677</td>
    <td class="codeline">    } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4678</td>
    <td class="codeline">      // If we have either PHIs or Selects to speculate, add them to those</td>
    <td class="lineNumber">4678</td>
    <td class="codeline">      // If we have either PHIs or Selects to speculate, add them to those</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4679</td>
    <td class="codeline">      // worklists and re-queue the new alloca so that we promote in on the</td>
    <td class="lineNumber">4679</td>
    <td class="codeline">      // worklists and re-queue the new alloca so that we promote in on the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4680</td>
    <td class="codeline">      // next iteration.</td>
    <td class="lineNumber">4680</td>
    <td class="codeline">      // next iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4681</td>
    <td class="codeline">      for (PHINode *PHIUser : PHIUsers)</td>
    <td class="lineNumber">4681</td>
    <td class="codeline">      for (PHINode *PHIUser : PHIUsers)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4682</td>
    <td class="codeline">        SpeculatablePHIs.insert(PHIUser);</td>
    <td class="lineNumber">4682</td>
    <td class="codeline">        SpeculatablePHIs.insert(PHIUser);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4683</td>
    <td class="codeline">      SelectsToRewrite.reserve(SelectsToRewrite.size() +</td>
    <td class="lineNumber">4683</td>
    <td class="codeline">      SelectsToRewrite.reserve(SelectsToRewrite.size() +</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4684</td>
    <td class="codeline">                               NewSelectsToRewrite.size());</td>
    <td class="lineNumber">4684</td>
    <td class="codeline">                               NewSelectsToRewrite.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4685</td>
    <td class="codeline">      for (auto &&KV : llvm::make_range(</td>
    <td class="lineNumber">4685</td>
    <td class="codeline">      for (auto &&KV : llvm::make_range(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4686</td>
    <td class="codeline">               std::make_move_iterator(NewSelectsToRewrite.begin()),</td>
    <td class="lineNumber">4686</td>
    <td class="codeline">               std::make_move_iterator(NewSelectsToRewrite.begin()),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4687</td>
    <td class="codeline">               std::make_move_iterator(NewSelectsToRewrite.end())))</td>
    <td class="lineNumber">4687</td>
    <td class="codeline">               std::make_move_iterator(NewSelectsToRewrite.end())))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4688</td>
    <td class="codeline">        SelectsToRewrite.insert(std::move(KV));</td>
    <td class="lineNumber">4688</td>
    <td class="codeline">        SelectsToRewrite.insert(std::move(KV));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4689</td>
    <td class="codeline">      Worklist.insert(NewAI);</td>
    <td class="lineNumber">4689</td>
    <td class="codeline">      Worklist.insert(NewAI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4690</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4690</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4691</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">4691</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4692</td>
    <td class="codeline">    // Drop any post-promotion work items if promotion didn't happen.</td>
    <td class="lineNumber">4692</td>
    <td class="codeline">    // Drop any post-promotion work items if promotion didn't happen.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4693</td>
    <td class="codeline">    while (PostPromotionWorklist.size() > PPWOldSize)</td>
    <td class="lineNumber">4693</td>
    <td class="codeline">    while (PostPromotionWorklist.size() > PPWOldSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4694</td>
    <td class="codeline">      PostPromotionWorklist.pop_back();</td>
    <td class="lineNumber">4694</td>
    <td class="codeline">      PostPromotionWorklist.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4695</td>
    <td class="codeline"></td>
    <td class="lineNumber">4695</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4696</td>
    <td class="codeline">    // We couldn't promote and we didn't create a new partition, nothing</td>
    <td class="lineNumber">4696</td>
    <td class="codeline">    // We couldn't promote and we didn't create a new partition, nothing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4697</td>
    <td class="codeline">    // happened.</td>
    <td class="lineNumber">4697</td>
    <td class="codeline">    // happened.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4698</td>
    <td class="codeline">    if (NewAI == &AI)</td>
    <td class="lineNumber">4698</td>
    <td class="codeline">    if (NewAI == &AI)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4699</td>
    <td class="codeline">      return nullptr;</td>
    <td class="lineNumber">4699</td>
    <td class="codeline">      return nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4700</td>
    <td class="codeline"></td>
    <td class="lineNumber">4700</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4701</td>
    <td class="codeline">    // If we can't promote the alloca, iterate on it to check for new</td>
    <td class="lineNumber">4701</td>
    <td class="codeline">    // If we can't promote the alloca, iterate on it to check for new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4702</td>
    <td class="codeline">    // refinements exposed by splitting the current alloca. Don't iterate on an</td>
    <td class="lineNumber">4702</td>
    <td class="codeline">    // refinements exposed by splitting the current alloca. Don't iterate on an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4703</td>
    <td class="codeline">    // alloca which didn't actually change and didn't get promoted.</td>
    <td class="lineNumber">4703</td>
    <td class="codeline">    // alloca which didn't actually change and didn't get promoted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4704</td>
    <td class="codeline">    Worklist.insert(NewAI);</td>
    <td class="lineNumber">4704</td>
    <td class="codeline">    Worklist.insert(NewAI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4705</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4705</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4706</td>
    <td class="codeline"></td>
    <td class="lineNumber">4706</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4707</td>
    <td class="codeline">  return NewAI;</td>
    <td class="lineNumber">4707</td>
    <td class="codeline">  return NewAI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4708</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4708</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4709</td>
    <td class="codeline"></td>
    <td class="lineNumber">4709</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4710</td>
    <td class="codeline">/// Walks the slices of an alloca and form partitions based on them,</td>
    <td class="lineNumber">4710</td>
    <td class="codeline">/// Walks the slices of an alloca and form partitions based on them,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4711</td>
    <td class="codeline">/// rewriting each of their uses.</td>
    <td class="lineNumber">4711</td>
    <td class="codeline">/// rewriting each of their uses.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4712</td>
    <td class="codeline">bool SROAPass::splitAlloca(AllocaInst &AI, AllocaSlices &AS) {</td>
    <td class="lineNumber">4712</td>
    <td class="codeline">bool SROAPass::splitAlloca(AllocaInst &AI, AllocaSlices &AS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4713</td>
    <td class="codeline">  if (AS.begin() == AS.end())</td>
    <td class="lineNumber">4713</td>
    <td class="codeline">  if (AS.begin() == AS.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4714</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">4714</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4715</td>
    <td class="codeline"></td>
    <td class="lineNumber">4715</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4716</td>
    <td class="codeline">  unsigned NumPartitions = 0;</td>
    <td class="lineNumber">4716</td>
    <td class="codeline">  unsigned NumPartitions = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4717</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">4717</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4718</td>
    <td class="codeline">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td class="lineNumber">4718</td>
    <td class="codeline">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4719</td>
    <td class="codeline"></td>
    <td class="lineNumber">4719</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4720</td>
    <td class="codeline">  // First try to pre-split loads and stores.</td>
    <td class="lineNumber">4720</td>
    <td class="codeline">  // First try to pre-split loads and stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4721</td>
    <td class="codeline">  Changed |= presplitLoadsAndStores(AI, AS);</td>
    <td class="lineNumber">4721</td>
    <td class="codeline">  Changed |= presplitLoadsAndStores(AI, AS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4722</td>
    <td class="codeline"></td>
    <td class="lineNumber">4722</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4723</td>
    <td class="codeline">  // Now that we have identified any pre-splitting opportunities,</td>
    <td class="lineNumber">4723</td>
    <td class="codeline">  // Now that we have identified any pre-splitting opportunities,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4724</td>
    <td class="codeline">  // mark loads and stores unsplittable except for the following case.</td>
    <td class="lineNumber">4724</td>
    <td class="codeline">  // mark loads and stores unsplittable except for the following case.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4725</td>
    <td class="codeline">  // We leave a slice splittable if all other slices are disjoint or fully</td>
    <td class="lineNumber">4725</td>
    <td class="codeline">  // We leave a slice splittable if all other slices are disjoint or fully</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4726</td>
    <td class="codeline">  // included in the slice, such as whole-alloca loads and stores.</td>
    <td class="lineNumber">4726</td>
    <td class="codeline">  // included in the slice, such as whole-alloca loads and stores.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4727</td>
    <td class="codeline">  // If we fail to split these during pre-splitting, we want to force them</td>
    <td class="lineNumber">4727</td>
    <td class="codeline">  // If we fail to split these during pre-splitting, we want to force them</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4728</td>
    <td class="codeline">  // to be rewritten into a partition.</td>
    <td class="lineNumber">4728</td>
    <td class="codeline">  // to be rewritten into a partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4729</td>
    <td class="codeline">  bool IsSorted = true;</td>
    <td class="lineNumber">4729</td>
    <td class="codeline">  bool IsSorted = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4730</td>
    <td class="codeline"></td>
    <td class="lineNumber">4730</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4731</td>
    <td class="codeline">  uint64_t AllocaSize =</td>
    <td class="lineNumber">4731</td>
    <td class="codeline">  uint64_t AllocaSize =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4732</td>
    <td class="codeline">      DL.getTypeAllocSize(AI.getAllocatedType()).getFixedValue();</td>
    <td class="lineNumber">4732</td>
    <td class="codeline">      DL.getTypeAllocSize(AI.getAllocatedType()).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4733</td>
    <td class="codeline">  const uint64_t MaxBitVectorSize = 1024;</td>
    <td class="lineNumber">4733</td>
    <td class="codeline">  const uint64_t MaxBitVectorSize = 1024;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4734</td>
    <td class="codeline">  if (AllocaSize <= MaxBitVectorSize) {</td>
    <td class="lineNumber">4734</td>
    <td class="codeline">  if (AllocaSize <= MaxBitVectorSize) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4735</td>
    <td class="codeline">    // If a byte boundary is included in any load or store, a slice starting or</td>
    <td class="lineNumber">4735</td>
    <td class="codeline">    // If a byte boundary is included in any load or store, a slice starting or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4736</td>
    <td class="codeline">    // ending at the boundary is not splittable.</td>
    <td class="lineNumber">4736</td>
    <td class="codeline">    // ending at the boundary is not splittable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4737</td>
    <td class="codeline">    SmallBitVector SplittableOffset(AllocaSize + 1, true);</td>
    <td class="lineNumber">4737</td>
    <td class="codeline">    SmallBitVector SplittableOffset(AllocaSize + 1, true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4738</td>
    <td class="codeline">    for (Slice &S : AS)</td>
    <td class="lineNumber">4738</td>
    <td class="codeline">    for (Slice &S : AS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4739</td>
    <td class="codeline">      for (unsigned O = S.beginOffset() + 1;</td>
    <td class="lineNumber">4739</td>
    <td class="codeline">      for (unsigned O = S.beginOffset() + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4740</td>
    <td class="codeline">           O < S.endOffset() && O < AllocaSize; O++)</td>
    <td class="lineNumber">4740</td>
    <td class="codeline">           O < S.endOffset() && O < AllocaSize; O++)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4741</td>
    <td class="codeline">        SplittableOffset.reset(O);</td>
    <td class="lineNumber">4741</td>
    <td class="codeline">        SplittableOffset.reset(O);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4742</td>
    <td class="codeline"></td>
    <td class="lineNumber">4742</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4743</td>
    <td class="codeline">    for (Slice &S : AS) {</td>
    <td class="lineNumber">4743</td>
    <td class="codeline">    for (Slice &S : AS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4744</td>
    <td class="codeline">      if (!S.isSplittable())</td>
    <td class="lineNumber">4744</td>
    <td class="codeline">      if (!S.isSplittable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4745</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">4745</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4746</td>
    <td class="codeline"></td>
    <td class="lineNumber">4746</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4747</td>
    <td class="codeline">      if ((S.beginOffset() > AllocaSize || SplittableOffset[S.beginOffset()]) &&</td>
    <td class="lineNumber">4747</td>
    <td class="codeline">      if ((S.beginOffset() > AllocaSize || SplittableOffset[S.beginOffset()]) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4748</td>
    <td class="codeline">          (S.endOffset() > AllocaSize || SplittableOffset[S.endOffset()]))</td>
    <td class="lineNumber">4748</td>
    <td class="codeline">          (S.endOffset() > AllocaSize || SplittableOffset[S.endOffset()]))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4749</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">4749</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4750</td>
    <td class="codeline"></td>
    <td class="lineNumber">4750</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4751</td>
    <td class="codeline">      if (isa<LoadInst>(S.getUse()->getUser()) ||</td>
    <td class="lineNumber">4751</td>
    <td class="codeline">      if (isa<LoadInst>(S.getUse()->getUser()) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4752</td>
    <td class="codeline">          isa<StoreInst>(S.getUse()->getUser())) {</td>
    <td class="lineNumber">4752</td>
    <td class="codeline">          isa<StoreInst>(S.getUse()->getUser())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4753</td>
    <td class="codeline">        S.makeUnsplittable();</td>
    <td class="lineNumber">4753</td>
    <td class="codeline">        S.makeUnsplittable();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4754</td>
    <td class="codeline">        IsSorted = false;</td>
    <td class="lineNumber">4754</td>
    <td class="codeline">        IsSorted = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4755</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4755</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4756</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4756</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4757</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4757</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4758</td>
    <td class="codeline">  else {</td>
    <td class="lineNumber">4758</td>
    <td class="codeline">  else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4759</td>
    <td class="codeline">    // We only allow whole-alloca splittable loads and stores</td>
    <td class="lineNumber">4759</td>
    <td class="codeline">    // We only allow whole-alloca splittable loads and stores</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4760</td>
    <td class="codeline">    // for a large alloca to avoid creating too large BitVector.</td>
    <td class="lineNumber">4760</td>
    <td class="codeline">    // for a large alloca to avoid creating too large BitVector.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4761</td>
    <td class="codeline">    for (Slice &S : AS) {</td>
    <td class="lineNumber">4761</td>
    <td class="codeline">    for (Slice &S : AS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4762</td>
    <td class="codeline">      if (!S.isSplittable())</td>
    <td class="lineNumber">4762</td>
    <td class="codeline">      if (!S.isSplittable())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4763</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">4763</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4764</td>
    <td class="codeline"></td>
    <td class="lineNumber">4764</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4765</td>
    <td class="codeline">      if (S.beginOffset() == 0 && S.endOffset() >= AllocaSize)</td>
    <td class="lineNumber">4765</td>
    <td class="codeline">      if (S.beginOffset() == 0 && S.endOffset() >= AllocaSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4766</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">4766</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4767</td>
    <td class="codeline"></td>
    <td class="lineNumber">4767</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4768</td>
    <td class="codeline">      if (isa<LoadInst>(S.getUse()->getUser()) ||</td>
    <td class="lineNumber">4768</td>
    <td class="codeline">      if (isa<LoadInst>(S.getUse()->getUser()) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4769</td>
    <td class="codeline">          isa<StoreInst>(S.getUse()->getUser())) {</td>
    <td class="lineNumber">4769</td>
    <td class="codeline">          isa<StoreInst>(S.getUse()->getUser())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4770</td>
    <td class="codeline">        S.makeUnsplittable();</td>
    <td class="lineNumber">4770</td>
    <td class="codeline">        S.makeUnsplittable();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4771</td>
    <td class="codeline">        IsSorted = false;</td>
    <td class="lineNumber">4771</td>
    <td class="codeline">        IsSorted = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4772</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4772</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4773</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4773</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4774</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4774</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4775</td>
    <td class="codeline"></td>
    <td class="lineNumber">4775</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4776</td>
    <td class="codeline">  if (!IsSorted)</td>
    <td class="lineNumber">4776</td>
    <td class="codeline">  if (!IsSorted)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4777</td>
    <td class="codeline">    llvm::sort(AS);</td>
    <td class="lineNumber">4777</td>
    <td class="codeline">    llvm::sort(AS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4778</td>
    <td class="codeline"></td>
    <td class="lineNumber">4778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4779</td>
    <td class="codeline">  /// Describes the allocas introduced by rewritePartition in order to migrate</td>
    <td class="lineNumber">4779</td>
    <td class="codeline">  /// Describes the allocas introduced by rewritePartition in order to migrate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4780</td>
    <td class="codeline">  /// the debug info.</td>
    <td class="lineNumber">4780</td>
    <td class="codeline">  /// the debug info.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4781</td>
    <td class="codeline">  struct Fragment {</td>
    <td class="lineNumber">4781</td>
    <td class="codeline">  struct Fragment {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4782</td>
    <td class="codeline">    AllocaInst *Alloca;</td>
    <td class="lineNumber">4782</td>
    <td class="codeline">    AllocaInst *Alloca;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4783</td>
    <td class="codeline">    uint64_t Offset;</td>
    <td class="lineNumber">4783</td>
    <td class="codeline">    uint64_t Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4784</td>
    <td class="codeline">    uint64_t Size;</td>
    <td class="lineNumber">4784</td>
    <td class="codeline">    uint64_t Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4785</td>
    <td class="codeline">    Fragment(AllocaInst *AI, uint64_t O, uint64_t S)</td>
    <td class="lineNumber">4785</td>
    <td class="codeline">    Fragment(AllocaInst *AI, uint64_t O, uint64_t S)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4786</td>
    <td class="codeline">      : Alloca(AI), Offset(O), Size(S) {}</td>
    <td class="lineNumber">4786</td>
    <td class="codeline">      : Alloca(AI), Offset(O), Size(S) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4787</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">4787</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4788</td>
    <td class="codeline">  SmallVector<Fragment, 4> Fragments;</td>
    <td class="lineNumber">4788</td>
    <td class="codeline">  SmallVector<Fragment, 4> Fragments;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4789</td>
    <td class="codeline"></td>
    <td class="lineNumber">4789</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4790</td>
    <td class="codeline">  // Rewrite each partition.</td>
    <td class="lineNumber">4790</td>
    <td class="codeline">  // Rewrite each partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4791</td>
    <td class="codeline">  for (auto &P : AS.partitions()) {</td>
    <td class="lineNumber">4791</td>
    <td class="codeline">  for (auto &P : AS.partitions()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4792</td>
    <td class="codeline">    if (AllocaInst *NewAI = rewritePartition(AI, AS, P)) {</td>
    <td class="lineNumber">4792</td>
    <td class="codeline">    if (AllocaInst *NewAI = rewritePartition(AI, AS, P)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4793</td>
    <td class="codeline">      Changed = true;</td>
    <td class="lineNumber">4793</td>
    <td class="codeline">      Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4794</td>
    <td class="codeline">      if (NewAI != &AI) {</td>
    <td class="lineNumber">4794</td>
    <td class="codeline">      if (NewAI != &AI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4795</td>
    <td class="codeline">        uint64_t SizeOfByte = 8;</td>
    <td class="lineNumber">4795</td>
    <td class="codeline">        uint64_t SizeOfByte = 8;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4796</td>
    <td class="codeline">        uint64_t AllocaSize =</td>
    <td class="lineNumber">4796</td>
    <td class="codeline">        uint64_t AllocaSize =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4797</td>
    <td class="codeline">            DL.getTypeSizeInBits(NewAI->getAllocatedType()).getFixedValue();</td>
    <td class="lineNumber">4797</td>
    <td class="codeline">            DL.getTypeSizeInBits(NewAI->getAllocatedType()).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4798</td>
    <td class="codeline">        // Don't include any padding.</td>
    <td class="lineNumber">4798</td>
    <td class="codeline">        // Don't include any padding.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4799</td>
    <td class="codeline">        uint64_t Size = std::min(AllocaSize, P.size() * SizeOfByte);</td>
    <td class="lineNumber">4799</td>
    <td class="codeline">        uint64_t Size = std::min(AllocaSize, P.size() * SizeOfByte);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4800</td>
    <td class="codeline">        Fragments.push_back(Fragment(NewAI, P.beginOffset() * SizeOfByte, Size));</td>
    <td class="lineNumber">4800</td>
    <td class="codeline">        Fragments.push_back(Fragment(NewAI, P.beginOffset() * SizeOfByte, Size));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4801</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4801</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4802</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4802</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4803</td>
    <td class="codeline">    ++NumPartitions;</td>
    <td class="lineNumber">4803</td>
    <td class="codeline">    ++NumPartitions;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4804</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4804</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4805</td>
    <td class="codeline"></td>
    <td class="lineNumber">4805</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4806</td>
    <td class="codeline">  NumAllocaPartitions += NumPartitions;</td>
    <td class="lineNumber">4806</td>
    <td class="codeline">  NumAllocaPartitions += NumPartitions;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4807</td>
    <td class="codeline">  MaxPartitionsPerAlloca.updateMax(NumPartitions);</td>
    <td class="lineNumber">4807</td>
    <td class="codeline">  MaxPartitionsPerAlloca.updateMax(NumPartitions);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4808</td>
    <td class="codeline"></td>
    <td class="lineNumber">4808</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4809</td>
    <td class="codeline">  // Migrate debug information from the old alloca to the new alloca(s)</td>
    <td class="lineNumber">4809</td>
    <td class="codeline">  // Migrate debug information from the old alloca to the new alloca(s)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4810</td>
    <td class="codeline">  // and the individual partitions.</td>
    <td class="lineNumber">4810</td>
    <td class="codeline">  // and the individual partitions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4811</td>
    <td class="codeline">  TinyPtrVector<DbgVariableIntrinsic *> DbgVariables;</td>
    <td class="lineNumber">4811</td>
    <td class="codeline">  TinyPtrVector<DbgVariableIntrinsic *> DbgVariables;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4812</td>
    <td class="codeline">  for (auto *DbgDeclare : FindDbgDeclareUses(&AI))</td>
    <td class="lineNumber">4812</td>
    <td class="codeline">  for (auto *DbgDeclare : FindDbgDeclareUses(&AI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4813</td>
    <td class="codeline">    DbgVariables.push_back(DbgDeclare);</td>
    <td class="lineNumber">4813</td>
    <td class="codeline">    DbgVariables.push_back(DbgDeclare);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4814</td>
    <td class="codeline">  for (auto *DbgAssign : at::getAssignmentMarkers(&AI))</td>
    <td class="lineNumber">4814</td>
    <td class="codeline">  for (auto *DbgAssign : at::getAssignmentMarkers(&AI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4815</td>
    <td class="codeline">    DbgVariables.push_back(DbgAssign);</td>
    <td class="lineNumber">4815</td>
    <td class="codeline">    DbgVariables.push_back(DbgAssign);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4816</td>
    <td class="codeline">  for (DbgVariableIntrinsic *DbgVariable : DbgVariables) {</td>
    <td class="lineNumber">4816</td>
    <td class="codeline">  for (DbgVariableIntrinsic *DbgVariable : DbgVariables) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4817</td>
    <td class="codeline">    auto *Expr = DbgVariable->getExpression();</td>
    <td class="lineNumber">4817</td>
    <td class="codeline">    auto *Expr = DbgVariable->getExpression();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4818</td>
    <td class="codeline">    DIBuilder DIB(*AI.getModule(), /*AllowUnresolved*/ false);</td>
    <td class="lineNumber">4818</td>
    <td class="codeline">    DIBuilder DIB(*AI.getModule(), /*AllowUnresolved*/ false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4819</td>
    <td class="codeline">    uint64_t AllocaSize =</td>
    <td class="lineNumber">4819</td>
    <td class="codeline">    uint64_t AllocaSize =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4820</td>
    <td class="codeline">        DL.getTypeSizeInBits(AI.getAllocatedType()).getFixedValue();</td>
    <td class="lineNumber">4820</td>
    <td class="codeline">        DL.getTypeSizeInBits(AI.getAllocatedType()).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4821</td>
    <td class="codeline">    for (auto Fragment : Fragments) {</td>
    <td class="lineNumber">4821</td>
    <td class="codeline">    for (auto Fragment : Fragments) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4822</td>
    <td class="codeline">      // Create a fragment expression describing the new partition or reuse AI's</td>
    <td class="lineNumber">4822</td>
    <td class="codeline">      // Create a fragment expression describing the new partition or reuse AI's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4823</td>
    <td class="codeline">      // expression if there is only one partition.</td>
    <td class="lineNumber">4823</td>
    <td class="codeline">      // expression if there is only one partition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4824</td>
    <td class="codeline">      auto *FragmentExpr = Expr;</td>
    <td class="lineNumber">4824</td>
    <td class="codeline">      auto *FragmentExpr = Expr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4825</td>
    <td class="codeline">      if (Fragment.Size < AllocaSize || Expr->isFragment()) {</td>
    <td class="lineNumber">4825</td>
    <td class="codeline">      if (Fragment.Size < AllocaSize || Expr->isFragment()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4826</td>
    <td class="codeline">        // If this alloca is already a scalar replacement of a larger aggregate,</td>
    <td class="lineNumber">4826</td>
    <td class="codeline">        // If this alloca is already a scalar replacement of a larger aggregate,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4827</td>
    <td class="codeline">        // Fragment.Offset describes the offset inside the scalar.</td>
    <td class="lineNumber">4827</td>
    <td class="codeline">        // Fragment.Offset describes the offset inside the scalar.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4828</td>
    <td class="codeline">        auto ExprFragment = Expr->getFragmentInfo();</td>
    <td class="lineNumber">4828</td>
    <td class="codeline">        auto ExprFragment = Expr->getFragmentInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4829</td>
    <td class="codeline">        uint64_t Offset = ExprFragment ? ExprFragment->OffsetInBits : 0;</td>
    <td class="lineNumber">4829</td>
    <td class="codeline">        uint64_t Offset = ExprFragment ? ExprFragment->OffsetInBits : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4830</td>
    <td class="codeline">        uint64_t Start = Offset + Fragment.Offset;</td>
    <td class="lineNumber">4830</td>
    <td class="codeline">        uint64_t Start = Offset + Fragment.Offset;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4831</td>
    <td class="codeline">        uint64_t Size = Fragment.Size;</td>
    <td class="lineNumber">4831</td>
    <td class="codeline">        uint64_t Size = Fragment.Size;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4832</td>
    <td class="codeline">        if (ExprFragment) {</td>
    <td class="lineNumber">4832</td>
    <td class="codeline">        if (ExprFragment) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4833</td>
    <td class="codeline">          uint64_t AbsEnd =</td>
    <td class="lineNumber">4833</td>
    <td class="codeline">          uint64_t AbsEnd =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4834</td>
    <td class="codeline">              ExprFragment->OffsetInBits + ExprFragment->SizeInBits;</td>
    <td class="lineNumber">4834</td>
    <td class="codeline">              ExprFragment->OffsetInBits + ExprFragment->SizeInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4835</td>
    <td class="codeline">          if (Start >= AbsEnd) {</td>
    <td class="lineNumber">4835</td>
    <td class="codeline">          if (Start >= AbsEnd) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4836</td>
    <td class="codeline">            // No need to describe a SROAed padding.</td>
    <td class="lineNumber">4836</td>
    <td class="codeline">            // No need to describe a SROAed padding.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4837</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">4837</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4838</td>
    <td class="codeline">          }</td>
    <td class="lineNumber">4838</td>
    <td class="codeline">          }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4839</td>
    <td class="codeline">          Size = std::min(Size, AbsEnd - Start);</td>
    <td class="lineNumber">4839</td>
    <td class="codeline">          Size = std::min(Size, AbsEnd - Start);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4840</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">4840</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4841</td>
    <td class="codeline">        // The new, smaller fragment is stenciled out from the old fragment.</td>
    <td class="lineNumber">4841</td>
    <td class="codeline">        // The new, smaller fragment is stenciled out from the old fragment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4842</td>
    <td class="codeline">        if (auto OrigFragment = FragmentExpr->getFragmentInfo()) {</td>
    <td class="lineNumber">4842</td>
    <td class="codeline">        if (auto OrigFragment = FragmentExpr->getFragmentInfo()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4843</td>
    <td class="codeline">          assert(Start >= OrigFragment->OffsetInBits &&</td>
    <td class="lineNumber">4843</td>
    <td class="codeline">          assert(Start >= OrigFragment->OffsetInBits &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4844</td>
    <td class="codeline">                 "new fragment is outside of original fragment");</td>
    <td class="lineNumber">4844</td>
    <td class="codeline">                 "new fragment is outside of original fragment");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4845</td>
    <td class="codeline">          Start -= OrigFragment->OffsetInBits;</td>
    <td class="lineNumber">4845</td>
    <td class="codeline">          Start -= OrigFragment->OffsetInBits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4846</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">4846</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4847</td>
    <td class="codeline"></td>
    <td class="lineNumber">4847</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4848</td>
    <td class="codeline">        // The alloca may be larger than the variable.</td>
    <td class="lineNumber">4848</td>
    <td class="codeline">        // The alloca may be larger than the variable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4849</td>
    <td class="codeline">        auto VarSize = DbgVariable->getVariable()->getSizeInBits();</td>
    <td class="lineNumber">4849</td>
    <td class="codeline">        auto VarSize = DbgVariable->getVariable()->getSizeInBits();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4850</td>
    <td class="codeline">        if (VarSize) {</td>
    <td class="lineNumber">4850</td>
    <td class="codeline">        if (VarSize) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4851</td>
    <td class="codeline">          if (Size > *VarSize)</td>
    <td class="lineNumber">4851</td>
    <td class="codeline">          if (Size > *VarSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4852</td>
    <td class="codeline">            Size = *VarSize;</td>
    <td class="lineNumber">4852</td>
    <td class="codeline">            Size = *VarSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4853</td>
    <td class="codeline">          if (Size == 0 || Start + Size > *VarSize)</td>
    <td class="lineNumber">4853</td>
    <td class="codeline">          if (Size == 0 || Start + Size > *VarSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4854</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">4854</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4855</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">4855</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4856</td>
    <td class="codeline"></td>
    <td class="lineNumber">4856</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4857</td>
    <td class="codeline">        // Avoid creating a fragment expression that covers the entire variable.</td>
    <td class="lineNumber">4857</td>
    <td class="codeline">        // Avoid creating a fragment expression that covers the entire variable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4858</td>
    <td class="codeline">        if (!VarSize || *VarSize != Size) {</td>
    <td class="lineNumber">4858</td>
    <td class="codeline">        if (!VarSize || *VarSize != Size) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4859</td>
    <td class="codeline">          if (auto E =</td>
    <td class="lineNumber">4859</td>
    <td class="codeline">          if (auto E =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4860</td>
    <td class="codeline">                  DIExpression::createFragmentExpression(Expr, Start, Size))</td>
    <td class="lineNumber">4860</td>
    <td class="codeline">                  DIExpression::createFragmentExpression(Expr, Start, Size))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4861</td>
    <td class="codeline">            FragmentExpr = *E;</td>
    <td class="lineNumber">4861</td>
    <td class="codeline">            FragmentExpr = *E;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4862</td>
    <td class="codeline">          else</td>
    <td class="lineNumber">4862</td>
    <td class="codeline">          else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4863</td>
    <td class="codeline">            continue;</td>
    <td class="lineNumber">4863</td>
    <td class="codeline">            continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4864</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">4864</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4865</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4865</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4866</td>
    <td class="codeline"></td>
    <td class="lineNumber">4866</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4867</td>
    <td class="codeline">      // Remove any existing intrinsics on the new alloca describing</td>
    <td class="lineNumber">4867</td>
    <td class="codeline">      // Remove any existing intrinsics on the new alloca describing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4868</td>
    <td class="codeline">      // the variable fragment.</td>
    <td class="lineNumber">4868</td>
    <td class="codeline">      // the variable fragment.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4869</td>
    <td class="codeline">      for (DbgDeclareInst *OldDII : FindDbgDeclareUses(Fragment.Alloca)) {</td>
    <td class="lineNumber">4869</td>
    <td class="codeline">      for (DbgDeclareInst *OldDII : FindDbgDeclareUses(Fragment.Alloca)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4870</td>
    <td class="codeline">        auto SameVariableFragment = [](const DbgVariableIntrinsic *LHS,</td>
    <td class="lineNumber">4870</td>
    <td class="codeline">        auto SameVariableFragment = [](const DbgVariableIntrinsic *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4871</td>
    <td class="codeline">                                       const DbgVariableIntrinsic *RHS) {</td>
    <td class="lineNumber">4871</td>
    <td class="codeline">                                       const DbgVariableIntrinsic *RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4872</td>
    <td class="codeline">          return LHS->getVariable() == RHS->getVariable() &&</td>
    <td class="lineNumber">4872</td>
    <td class="codeline">          return LHS->getVariable() == RHS->getVariable() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4873</td>
    <td class="codeline">                 LHS->getDebugLoc()->getInlinedAt() ==</td>
    <td class="lineNumber">4873</td>
    <td class="codeline">                 LHS->getDebugLoc()->getInlinedAt() ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4874</td>
    <td class="codeline">                     RHS->getDebugLoc()->getInlinedAt();</td>
    <td class="lineNumber">4874</td>
    <td class="codeline">                     RHS->getDebugLoc()->getInlinedAt();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4875</td>
    <td class="codeline">        };</td>
    <td class="lineNumber">4875</td>
    <td class="codeline">        };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4876</td>
    <td class="codeline">        if (SameVariableFragment(OldDII, DbgVariable))</td>
    <td class="lineNumber">4876</td>
    <td class="codeline">        if (SameVariableFragment(OldDII, DbgVariable))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4877</td>
    <td class="codeline">          OldDII->eraseFromParent();</td>
    <td class="lineNumber">4877</td>
    <td class="codeline">          OldDII->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4878</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4878</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4879</td>
    <td class="codeline"></td>
    <td class="lineNumber">4879</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4880</td>
    <td class="codeline">      if (auto *DbgAssign = dyn_cast<DbgAssignIntrinsic>(DbgVariable)) {</td>
    <td class="lineNumber">4880</td>
    <td class="codeline">      if (auto *DbgAssign = dyn_cast<DbgAssignIntrinsic>(DbgVariable)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4881</td>
    <td class="codeline">        if (!Fragment.Alloca->hasMetadata(LLVMContext::MD_DIAssignID)) {</td>
    <td class="lineNumber">4881</td>
    <td class="codeline">        if (!Fragment.Alloca->hasMetadata(LLVMContext::MD_DIAssignID)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4882</td>
    <td class="codeline">          Fragment.Alloca->setMetadata(</td>
    <td class="lineNumber">4882</td>
    <td class="codeline">          Fragment.Alloca->setMetadata(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4883</td>
    <td class="codeline">              LLVMContext::MD_DIAssignID,</td>
    <td class="lineNumber">4883</td>
    <td class="codeline">              LLVMContext::MD_DIAssignID,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4884</td>
    <td class="codeline">              DIAssignID::getDistinct(AI.getContext()));</td>
    <td class="lineNumber">4884</td>
    <td class="codeline">              DIAssignID::getDistinct(AI.getContext()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4885</td>
    <td class="codeline">        }</td>
    <td class="lineNumber">4885</td>
    <td class="codeline">        }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4886</td>
    <td class="codeline">        auto *NewAssign = DIB.insertDbgAssign(</td>
    <td class="lineNumber">4886</td>
    <td class="codeline">        auto *NewAssign = DIB.insertDbgAssign(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4887</td>
    <td class="codeline">            Fragment.Alloca, DbgAssign->getValue(), DbgAssign->getVariable(),</td>
    <td class="lineNumber">4887</td>
    <td class="codeline">            Fragment.Alloca, DbgAssign->getValue(), DbgAssign->getVariable(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4888</td>
    <td class="codeline">            FragmentExpr, Fragment.Alloca, DbgAssign->getAddressExpression(),</td>
    <td class="lineNumber">4888</td>
    <td class="codeline">            FragmentExpr, Fragment.Alloca, DbgAssign->getAddressExpression(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4889</td>
    <td class="codeline">            DbgAssign->getDebugLoc());</td>
    <td class="lineNumber">4889</td>
    <td class="codeline">            DbgAssign->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4890</td>
    <td class="codeline">        NewAssign->setDebugLoc(DbgAssign->getDebugLoc());</td>
    <td class="lineNumber">4890</td>
    <td class="codeline">        NewAssign->setDebugLoc(DbgAssign->getDebugLoc());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4891</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "Created new assign intrinsic: " << *NewAssign</td>
    <td class="lineNumber">4891</td>
    <td class="codeline">        LLVM_DEBUG(dbgs() << "Created new assign intrinsic: " << *NewAssign</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4892</td>
    <td class="codeline">                          << "\n");</td>
    <td class="lineNumber">4892</td>
    <td class="codeline">                          << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4893</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">4893</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4894</td>
    <td class="codeline">        DIB.insertDeclare(Fragment.Alloca, DbgVariable->getVariable(),</td>
    <td class="lineNumber">4894</td>
    <td class="codeline">        DIB.insertDeclare(Fragment.Alloca, DbgVariable->getVariable(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4895</td>
    <td class="codeline">                          FragmentExpr, DbgVariable->getDebugLoc(), &AI);</td>
    <td class="lineNumber">4895</td>
    <td class="codeline">                          FragmentExpr, DbgVariable->getDebugLoc(), &AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4896</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">4896</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4897</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4897</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4898</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4898</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4899</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">4899</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4900</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4900</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4901</td>
    <td class="codeline"></td>
    <td class="lineNumber">4901</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4902</td>
    <td class="codeline">/// Clobber a use with poison, deleting the used value if it becomes dead.</td>
    <td class="lineNumber">4902</td>
    <td class="codeline">/// Clobber a use with poison, deleting the used value if it becomes dead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4903</td>
    <td class="codeline">void SROAPass::clobberUse(Use &U) {</td>
    <td class="lineNumber">4903</td>
    <td class="codeline">void SROAPass::clobberUse(Use &U) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4904</td>
    <td class="codeline">  Value *OldV = U;</td>
    <td class="lineNumber">4904</td>
    <td class="codeline">  Value *OldV = U;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4905</td>
    <td class="codeline">  // Replace the use with an poison value.</td>
    <td class="lineNumber">4905</td>
    <td class="codeline">  // Replace the use with an poison value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4906</td>
    <td class="codeline">  U = PoisonValue::get(OldV->getType());</td>
    <td class="lineNumber">4906</td>
    <td class="codeline">  U = PoisonValue::get(OldV->getType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4907</td>
    <td class="codeline"></td>
    <td class="lineNumber">4907</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4908</td>
    <td class="codeline">  // Check for this making an instruction dead. We have to garbage collect</td>
    <td class="lineNumber">4908</td>
    <td class="codeline">  // Check for this making an instruction dead. We have to garbage collect</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4909</td>
    <td class="codeline">  // all the dead instructions to ensure the uses of any alloca end up being</td>
    <td class="lineNumber">4909</td>
    <td class="codeline">  // all the dead instructions to ensure the uses of any alloca end up being</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4910</td>
    <td class="codeline">  // minimal.</td>
    <td class="lineNumber">4910</td>
    <td class="codeline">  // minimal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4911</td>
    <td class="codeline">  if (Instruction *OldI = dyn_cast<Instruction>(OldV))</td>
    <td class="lineNumber">4911</td>
    <td class="codeline">  if (Instruction *OldI = dyn_cast<Instruction>(OldV))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4912</td>
    <td class="codeline">    if (isInstructionTriviallyDead(OldI)) {</td>
    <td class="lineNumber">4912</td>
    <td class="codeline">    if (isInstructionTriviallyDead(OldI)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4913</td>
    <td class="codeline">      DeadInsts.push_back(OldI);</td>
    <td class="lineNumber">4913</td>
    <td class="codeline">      DeadInsts.push_back(OldI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4914</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">4914</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4915</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4915</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4916</td>
    <td class="codeline"></td>
    <td class="lineNumber">4916</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4917</td>
    <td class="codeline">/// Analyze an alloca for SROA.</td>
    <td class="lineNumber">4917</td>
    <td class="codeline">/// Analyze an alloca for SROA.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4918</td>
    <td class="codeline">///</td>
    <td class="lineNumber">4918</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4919</td>
    <td class="codeline">/// This analyzes the alloca to ensure we can reason about it, builds</td>
    <td class="lineNumber">4919</td>
    <td class="codeline">/// This analyzes the alloca to ensure we can reason about it, builds</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4920</td>
    <td class="codeline">/// the slices of the alloca, and then hands it off to be split and</td>
    <td class="lineNumber">4920</td>
    <td class="codeline">/// the slices of the alloca, and then hands it off to be split and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4921</td>
    <td class="codeline">/// rewritten as needed.</td>
    <td class="lineNumber">4921</td>
    <td class="codeline">/// rewritten as needed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4922</td>
    <td class="codeline">std::pair<bool /*Changed*/, bool /*CFGChanged*/></td>
    <td class="lineNumber">4922</td>
    <td class="codeline">std::pair<bool /*Changed*/, bool /*CFGChanged*/></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4923</td>
    <td class="codeline">SROAPass::runOnAlloca(AllocaInst &AI) {</td>
    <td class="lineNumber">4923</td>
    <td class="codeline">SROAPass::runOnAlloca(AllocaInst &AI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4924</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">4924</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4925</td>
    <td class="codeline">  bool CFGChanged = false;</td>
    <td class="lineNumber">4925</td>
    <td class="codeline">  bool CFGChanged = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4926</td>
    <td class="codeline"></td>
    <td class="lineNumber">4926</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4927</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "SROA alloca: " << AI << "\n");</td>
    <td class="lineNumber">4927</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "SROA alloca: " << AI << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4928</td>
    <td class="codeline">  ++NumAllocasAnalyzed;</td>
    <td class="lineNumber">4928</td>
    <td class="codeline">  ++NumAllocasAnalyzed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4929</td>
    <td class="codeline"></td>
    <td class="lineNumber">4929</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4930</td>
    <td class="codeline">  // Special case dead allocas, as they're trivial.</td>
    <td class="lineNumber">4930</td>
    <td class="codeline">  // Special case dead allocas, as they're trivial.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4931</td>
    <td class="codeline">  if (AI.use_empty()) {</td>
    <td class="lineNumber">4931</td>
    <td class="codeline">  if (AI.use_empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4932</td>
    <td class="codeline">    AI.eraseFromParent();</td>
    <td class="lineNumber">4932</td>
    <td class="codeline">    AI.eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4933</td>
    <td class="codeline">    Changed = true;</td>
    <td class="lineNumber">4933</td>
    <td class="codeline">    Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4934</td>
    <td class="codeline">    return {Changed, CFGChanged};</td>
    <td class="lineNumber">4934</td>
    <td class="codeline">    return {Changed, CFGChanged};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4935</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4935</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4936</td>
    <td class="codeline">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td class="lineNumber">4936</td>
    <td class="codeline">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4937</td>
    <td class="codeline"></td>
    <td class="lineNumber">4937</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4938</td>
    <td class="codeline">  // Skip alloca forms that this analysis can't handle.</td>
    <td class="lineNumber">4938</td>
    <td class="codeline">  // Skip alloca forms that this analysis can't handle.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4939</td>
    <td class="codeline">  auto *AT = AI.getAllocatedType();</td>
    <td class="lineNumber">4939</td>
    <td class="codeline">  auto *AT = AI.getAllocatedType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4940</td>
    <td class="codeline">  TypeSize Size = DL.getTypeAllocSize(AT);</td>
    <td class="lineNumber">4940</td>
    <td class="codeline">  TypeSize Size = DL.getTypeAllocSize(AT);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4941</td>
    <td class="codeline">  if (AI.isArrayAllocation() || !AT->isSized() || Size.isScalable() ||</td>
    <td class="lineNumber">4941</td>
    <td class="codeline">  if (AI.isArrayAllocation() || !AT->isSized() || Size.isScalable() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4942</td>
    <td class="codeline">      Size.getFixedValue() == 0)</td>
    <td class="lineNumber">4942</td>
    <td class="codeline">      Size.getFixedValue() == 0)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4943</td>
    <td class="codeline">    return {Changed, CFGChanged};</td>
    <td class="lineNumber">4943</td>
    <td class="codeline">    return {Changed, CFGChanged};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4944</td>
    <td class="codeline"></td>
    <td class="lineNumber">4944</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4945</td>
    <td class="codeline">  // First, split any FCA loads and stores touching this alloca to promote</td>
    <td class="lineNumber">4945</td>
    <td class="codeline">  // First, split any FCA loads and stores touching this alloca to promote</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4946</td>
    <td class="codeline">  // better splitting and promotion opportunities.</td>
    <td class="lineNumber">4946</td>
    <td class="codeline">  // better splitting and promotion opportunities.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4947</td>
    <td class="codeline">  IRBuilderTy IRB(&AI);</td>
    <td class="lineNumber">4947</td>
    <td class="codeline">  IRBuilderTy IRB(&AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4948</td>
    <td class="codeline">  AggLoadStoreRewriter AggRewriter(DL, IRB);</td>
    <td class="lineNumber">4948</td>
    <td class="codeline">  AggLoadStoreRewriter AggRewriter(DL, IRB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4949</td>
    <td class="codeline">  Changed |= AggRewriter.rewrite(AI);</td>
    <td class="lineNumber">4949</td>
    <td class="codeline">  Changed |= AggRewriter.rewrite(AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4950</td>
    <td class="codeline"></td>
    <td class="lineNumber">4950</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4951</td>
    <td class="codeline">  // Build the slices using a recursive instruction-visiting builder.</td>
    <td class="lineNumber">4951</td>
    <td class="codeline">  // Build the slices using a recursive instruction-visiting builder.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4952</td>
    <td class="codeline">  AllocaSlices AS(DL, AI);</td>
    <td class="lineNumber">4952</td>
    <td class="codeline">  AllocaSlices AS(DL, AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4953</td>
    <td class="codeline">  LLVM_DEBUG(AS.print(dbgs()));</td>
    <td class="lineNumber">4953</td>
    <td class="codeline">  LLVM_DEBUG(AS.print(dbgs()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4954</td>
    <td class="codeline">  if (AS.isEscaped())</td>
    <td class="lineNumber">4954</td>
    <td class="codeline">  if (AS.isEscaped())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4955</td>
    <td class="codeline">    return {Changed, CFGChanged};</td>
    <td class="lineNumber">4955</td>
    <td class="codeline">    return {Changed, CFGChanged};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4956</td>
    <td class="codeline"></td>
    <td class="lineNumber">4956</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4957</td>
    <td class="codeline">  // Delete all the dead users of this alloca before splitting and rewriting it.</td>
    <td class="lineNumber">4957</td>
    <td class="codeline">  // Delete all the dead users of this alloca before splitting and rewriting it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4958</td>
    <td class="codeline">  for (Instruction *DeadUser : AS.getDeadUsers()) {</td>
    <td class="lineNumber">4958</td>
    <td class="codeline">  for (Instruction *DeadUser : AS.getDeadUsers()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4959</td>
    <td class="codeline">    // Free up everything used by this instruction.</td>
    <td class="lineNumber">4959</td>
    <td class="codeline">    // Free up everything used by this instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4960</td>
    <td class="codeline">    for (Use &DeadOp : DeadUser->operands())</td>
    <td class="lineNumber">4960</td>
    <td class="codeline">    for (Use &DeadOp : DeadUser->operands())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4961</td>
    <td class="codeline">      clobberUse(DeadOp);</td>
    <td class="lineNumber">4961</td>
    <td class="codeline">      clobberUse(DeadOp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4962</td>
    <td class="codeline"></td>
    <td class="lineNumber">4962</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4963</td>
    <td class="codeline">    // Now replace the uses of this instruction.</td>
    <td class="lineNumber">4963</td>
    <td class="codeline">    // Now replace the uses of this instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4964</td>
    <td class="codeline">    DeadUser->replaceAllUsesWith(PoisonValue::get(DeadUser->getType()));</td>
    <td class="lineNumber">4964</td>
    <td class="codeline">    DeadUser->replaceAllUsesWith(PoisonValue::get(DeadUser->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4965</td>
    <td class="codeline"></td>
    <td class="lineNumber">4965</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4966</td>
    <td class="codeline">    // And mark it for deletion.</td>
    <td class="lineNumber">4966</td>
    <td class="codeline">    // And mark it for deletion.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4967</td>
    <td class="codeline">    DeadInsts.push_back(DeadUser);</td>
    <td class="lineNumber">4967</td>
    <td class="codeline">    DeadInsts.push_back(DeadUser);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4968</td>
    <td class="codeline">    Changed = true;</td>
    <td class="lineNumber">4968</td>
    <td class="codeline">    Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4969</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4969</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4970</td>
    <td class="codeline">  for (Use *DeadOp : AS.getDeadOperands()) {</td>
    <td class="lineNumber">4970</td>
    <td class="codeline">  for (Use *DeadOp : AS.getDeadOperands()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4971</td>
    <td class="codeline">    clobberUse(*DeadOp);</td>
    <td class="lineNumber">4971</td>
    <td class="codeline">    clobberUse(*DeadOp);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4972</td>
    <td class="codeline">    Changed = true;</td>
    <td class="lineNumber">4972</td>
    <td class="codeline">    Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4973</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4973</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4974</td>
    <td class="codeline"></td>
    <td class="lineNumber">4974</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4975</td>
    <td class="codeline">  // No slices to split. Leave the dead alloca for a later pass to clean up.</td>
    <td class="lineNumber">4975</td>
    <td class="codeline">  // No slices to split. Leave the dead alloca for a later pass to clean up.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4976</td>
    <td class="codeline">  if (AS.begin() == AS.end())</td>
    <td class="lineNumber">4976</td>
    <td class="codeline">  if (AS.begin() == AS.end())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4977</td>
    <td class="codeline">    return {Changed, CFGChanged};</td>
    <td class="lineNumber">4977</td>
    <td class="codeline">    return {Changed, CFGChanged};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4978</td>
    <td class="codeline"></td>
    <td class="lineNumber">4978</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4979</td>
    <td class="codeline">  Changed |= splitAlloca(AI, AS);</td>
    <td class="lineNumber">4979</td>
    <td class="codeline">  Changed |= splitAlloca(AI, AS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4980</td>
    <td class="codeline"></td>
    <td class="lineNumber">4980</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4981</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Speculating PHIs\n");</td>
    <td class="lineNumber">4981</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Speculating PHIs\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4982</td>
    <td class="codeline">  while (!SpeculatablePHIs.empty())</td>
    <td class="lineNumber">4982</td>
    <td class="codeline">  while (!SpeculatablePHIs.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4983</td>
    <td class="codeline">    speculatePHINodeLoads(IRB, *SpeculatablePHIs.pop_back_val());</td>
    <td class="lineNumber">4983</td>
    <td class="codeline">    speculatePHINodeLoads(IRB, *SpeculatablePHIs.pop_back_val());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4984</td>
    <td class="codeline"></td>
    <td class="lineNumber">4984</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4985</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Rewriting Selects\n");</td>
    <td class="lineNumber">4985</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "  Rewriting Selects\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4986</td>
    <td class="codeline">  auto RemainingSelectsToRewrite = SelectsToRewrite.takeVector();</td>
    <td class="lineNumber">4986</td>
    <td class="codeline">  auto RemainingSelectsToRewrite = SelectsToRewrite.takeVector();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4987</td>
    <td class="codeline">  while (!RemainingSelectsToRewrite.empty()) {</td>
    <td class="lineNumber">4987</td>
    <td class="codeline">  while (!RemainingSelectsToRewrite.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4988</td>
    <td class="codeline">    const auto [K, V] = RemainingSelectsToRewrite.pop_back_val();</td>
    <td class="lineNumber">4988</td>
    <td class="codeline">    const auto [K, V] = RemainingSelectsToRewrite.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4989</td>
    <td class="codeline">    CFGChanged |=</td>
    <td class="lineNumber">4989</td>
    <td class="codeline">    CFGChanged |=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4990</td>
    <td class="codeline">        rewriteSelectInstMemOps(*K, V, IRB, PreserveCFG ? nullptr : DTU);</td>
    <td class="lineNumber">4990</td>
    <td class="codeline">        rewriteSelectInstMemOps(*K, V, IRB, PreserveCFG ? nullptr : DTU);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4991</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">4991</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4992</td>
    <td class="codeline"></td>
    <td class="lineNumber">4992</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4993</td>
    <td class="codeline">  return {Changed, CFGChanged};</td>
    <td class="lineNumber">4993</td>
    <td class="codeline">  return {Changed, CFGChanged};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4994</td>
    <td class="codeline">}</td>
    <td class="lineNumber">4994</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4995</td>
    <td class="codeline"></td>
    <td class="lineNumber">4995</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4996</td>
    <td class="codeline">/// Delete the dead instructions accumulated in this run.</td>
    <td class="lineNumber">4996</td>
    <td class="codeline">/// Delete the dead instructions accumulated in this run.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4997</td>
    <td class="codeline">///</td>
    <td class="lineNumber">4997</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4998</td>
    <td class="codeline">/// Recursively deletes the dead instructions we've accumulated. This is done</td>
    <td class="lineNumber">4998</td>
    <td class="codeline">/// Recursively deletes the dead instructions we've accumulated. This is done</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4999</td>
    <td class="codeline">/// at the very end to maximize locality of the recursive delete and to</td>
    <td class="lineNumber">4999</td>
    <td class="codeline">/// at the very end to maximize locality of the recursive delete and to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5000</td>
    <td class="codeline">/// minimize the problems of invalidated instruction pointers as such pointers</td>
    <td class="lineNumber">5000</td>
    <td class="codeline">/// minimize the problems of invalidated instruction pointers as such pointers</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5001</td>
    <td class="codeline">/// are used heavily in the intermediate stages of the algorithm.</td>
    <td class="lineNumber">5001</td>
    <td class="codeline">/// are used heavily in the intermediate stages of the algorithm.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5002</td>
    <td class="codeline">///</td>
    <td class="lineNumber">5002</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5003</td>
    <td class="codeline">/// We also record the alloca instructions deleted here so that they aren't</td>
    <td class="lineNumber">5003</td>
    <td class="codeline">/// We also record the alloca instructions deleted here so that they aren't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5004</td>
    <td class="codeline">/// subsequently handed to mem2reg to promote.</td>
    <td class="lineNumber">5004</td>
    <td class="codeline">/// subsequently handed to mem2reg to promote.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5005</td>
    <td class="codeline">bool SROAPass::deleteDeadInstructions(</td>
    <td class="lineNumber">5005</td>
    <td class="codeline">bool SROAPass::deleteDeadInstructions(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5006</td>
    <td class="codeline">    SmallPtrSetImpl<AllocaInst *> &DeletedAllocas) {</td>
    <td class="lineNumber">5006</td>
    <td class="codeline">    SmallPtrSetImpl<AllocaInst *> &DeletedAllocas) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5007</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">5007</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5008</td>
    <td class="codeline">  while (!DeadInsts.empty()) {</td>
    <td class="lineNumber">5008</td>
    <td class="codeline">  while (!DeadInsts.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5009</td>
    <td class="codeline">    Instruction *I = dyn_cast_or_null<Instruction>(DeadInsts.pop_back_val());</td>
    <td class="lineNumber">5009</td>
    <td class="codeline">    Instruction *I = dyn_cast_or_null<Instruction>(DeadInsts.pop_back_val());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5010</td>
    <td class="codeline">    if (!I)</td>
    <td class="lineNumber">5010</td>
    <td class="codeline">    if (!I)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5011</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">5011</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5012</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Deleting dead instruction: " << *I << "\n");</td>
    <td class="lineNumber">5012</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Deleting dead instruction: " << *I << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5013</td>
    <td class="codeline"></td>
    <td class="lineNumber">5013</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5014</td>
    <td class="codeline">    // If the instruction is an alloca, find the possible dbg.declare connected</td>
    <td class="lineNumber">5014</td>
    <td class="codeline">    // If the instruction is an alloca, find the possible dbg.declare connected</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5015</td>
    <td class="codeline">    // to it, and remove it too. We must do this before calling RAUW or we will</td>
    <td class="lineNumber">5015</td>
    <td class="codeline">    // to it, and remove it too. We must do this before calling RAUW or we will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5016</td>
    <td class="codeline">    // not be able to find it.</td>
    <td class="lineNumber">5016</td>
    <td class="codeline">    // not be able to find it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5017</td>
    <td class="codeline">    if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {</td>
    <td class="lineNumber">5017</td>
    <td class="codeline">    if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5018</td>
    <td class="codeline">      DeletedAllocas.insert(AI);</td>
    <td class="lineNumber">5018</td>
    <td class="codeline">      DeletedAllocas.insert(AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5019</td>
    <td class="codeline">      for (DbgDeclareInst *OldDII : FindDbgDeclareUses(AI))</td>
    <td class="lineNumber">5019</td>
    <td class="codeline">      for (DbgDeclareInst *OldDII : FindDbgDeclareUses(AI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5020</td>
    <td class="codeline">        OldDII->eraseFromParent();</td>
    <td class="lineNumber">5020</td>
    <td class="codeline">        OldDII->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5021</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">5021</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5022</td>
    <td class="codeline"></td>
    <td class="lineNumber">5022</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5023</td>
    <td class="codeline">    at::deleteAssignmentMarkers(I);</td>
    <td class="lineNumber">5023</td>
    <td class="codeline">    at::deleteAssignmentMarkers(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5024</td>
    <td class="codeline">    I->replaceAllUsesWith(UndefValue::get(I->getType()));</td>
    <td class="lineNumber">5024</td>
    <td class="codeline">    I->replaceAllUsesWith(UndefValue::get(I->getType()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5025</td>
    <td class="codeline"></td>
    <td class="lineNumber">5025</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5026</td>
    <td class="codeline">    for (Use &Operand : I->operands())</td>
    <td class="lineNumber">5026</td>
    <td class="codeline">    for (Use &Operand : I->operands())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5027</td>
    <td class="codeline">      if (Instruction *U = dyn_cast<Instruction>(Operand)) {</td>
    <td class="lineNumber">5027</td>
    <td class="codeline">      if (Instruction *U = dyn_cast<Instruction>(Operand)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5028</td>
    <td class="codeline">        // Zero out the operand and see if it becomes trivially dead.</td>
    <td class="lineNumber">5028</td>
    <td class="codeline">        // Zero out the operand and see if it becomes trivially dead.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5029</td>
    <td class="codeline">        Operand = nullptr;</td>
    <td class="lineNumber">5029</td>
    <td class="codeline">        Operand = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5030</td>
    <td class="codeline">        if (isInstructionTriviallyDead(U))</td>
    <td class="lineNumber">5030</td>
    <td class="codeline">        if (isInstructionTriviallyDead(U))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5031</td>
    <td class="codeline">          DeadInsts.push_back(U);</td>
    <td class="lineNumber">5031</td>
    <td class="codeline">          DeadInsts.push_back(U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5032</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">5032</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5033</td>
    <td class="codeline"></td>
    <td class="lineNumber">5033</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5034</td>
    <td class="codeline">    ++NumDeleted;</td>
    <td class="lineNumber">5034</td>
    <td class="codeline">    ++NumDeleted;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5035</td>
    <td class="codeline">    I->eraseFromParent();</td>
    <td class="lineNumber">5035</td>
    <td class="codeline">    I->eraseFromParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5036</td>
    <td class="codeline">    Changed = true;</td>
    <td class="lineNumber">5036</td>
    <td class="codeline">    Changed = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5037</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5037</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5038</td>
    <td class="codeline">  return Changed;</td>
    <td class="lineNumber">5038</td>
    <td class="codeline">  return Changed;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5039</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5039</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5040</td>
    <td class="codeline"></td>
    <td class="lineNumber">5040</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5041</td>
    <td class="codeline">/// Promote the allocas, using the best available technique.</td>
    <td class="lineNumber">5041</td>
    <td class="codeline">/// Promote the allocas, using the best available technique.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5042</td>
    <td class="codeline">///</td>
    <td class="lineNumber">5042</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5043</td>
    <td class="codeline">/// This attempts to promote whatever allocas have been identified as viable in</td>
    <td class="lineNumber">5043</td>
    <td class="codeline">/// This attempts to promote whatever allocas have been identified as viable in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5044</td>
    <td class="codeline">/// the PromotableAllocas list. If that list is empty, there is nothing to do.</td>
    <td class="lineNumber">5044</td>
    <td class="codeline">/// the PromotableAllocas list. If that list is empty, there is nothing to do.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5045</td>
    <td class="codeline">/// This function returns whether any promotion occurred.</td>
    <td class="lineNumber">5045</td>
    <td class="codeline">/// This function returns whether any promotion occurred.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5046</td>
    <td class="codeline">bool SROAPass::promoteAllocas(Function &F) {</td>
    <td class="lineNumber">5046</td>
    <td class="codeline">bool SROAPass::promoteAllocas(Function &F) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5047</td>
    <td class="codeline">  if (PromotableAllocas.empty())</td>
    <td class="lineNumber">5047</td>
    <td class="codeline">  if (PromotableAllocas.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5048</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">5048</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5049</td>
    <td class="codeline"></td>
    <td class="lineNumber">5049</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5050</td>
    <td class="codeline">  NumPromoted += PromotableAllocas.size();</td>
    <td class="lineNumber">5050</td>
    <td class="codeline">  NumPromoted += PromotableAllocas.size();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5051</td>
    <td class="codeline"></td>
    <td class="lineNumber">5051</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5052</td>
    <td class="codeline">  if (SROASkipMem2Reg) {</td>
    <td class="lineNumber">5052</td>
    <td class="codeline">  if (SROASkipMem2Reg) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5053</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Not promoting allocas with mem2reg!\n");</td>
    <td class="lineNumber">5053</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Not promoting allocas with mem2reg!\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5054</td>
    <td class="codeline">  } else {</td>
    <td class="lineNumber">5054</td>
    <td class="codeline">  } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5055</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Promoting allocas with mem2reg...\n");</td>
    <td class="lineNumber">5055</td>
    <td class="codeline">    LLVM_DEBUG(dbgs() << "Promoting allocas with mem2reg...\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5056</td>
    <td class="codeline">    PromoteMemToReg(PromotableAllocas, DTU->getDomTree(), AC);</td>
    <td class="lineNumber">5056</td>
    <td class="codeline">    PromoteMemToReg(PromotableAllocas, DTU->getDomTree(), AC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5057</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5057</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5058</td>
    <td class="codeline"></td>
    <td class="lineNumber">5058</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5059</td>
    <td class="codeline">  PromotableAllocas.clear();</td>
    <td class="lineNumber">5059</td>
    <td class="codeline">  PromotableAllocas.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5060</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">5060</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5061</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5061</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5062</td>
    <td class="codeline"></td>
    <td class="lineNumber">5062</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5063</td>
    <td class="codeline">PreservedAnalyses SROAPass::runImpl(Function &F, DomTreeUpdater &RunDTU,</td>
    <td class="lineNumber">5063</td>
    <td class="codeline">PreservedAnalyses SROAPass::runImpl(Function &F, DomTreeUpdater &RunDTU,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5064</td>
    <td class="codeline">                                    AssumptionCache &RunAC) {</td>
    <td class="lineNumber">5064</td>
    <td class="codeline">                                    AssumptionCache &RunAC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5065</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "SROA function: " << F.getName() << "\n");</td>
    <td class="lineNumber">5065</td>
    <td class="codeline">  LLVM_DEBUG(dbgs() << "SROA function: " << F.getName() << "\n");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5066</td>
    <td class="codeline">  C = &F.getContext();</td>
    <td class="lineNumber">5066</td>
    <td class="codeline">  C = &F.getContext();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5067</td>
    <td class="codeline">  DTU = &RunDTU;</td>
    <td class="lineNumber">5067</td>
    <td class="codeline">  DTU = &RunDTU;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5068</td>
    <td class="codeline">  AC = &RunAC;</td>
    <td class="lineNumber">5068</td>
    <td class="codeline">  AC = &RunAC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5069</td>
    <td class="codeline"></td>
    <td class="lineNumber">5069</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5070</td>
    <td class="codeline">  const DataLayout &DL = F.getParent()->getDataLayout();</td>
    <td class="lineNumber">5070</td>
    <td class="codeline">  const DataLayout &DL = F.getParent()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5071</td>
    <td class="codeline">  BasicBlock &EntryBB = F.getEntryBlock();</td>
    <td class="lineNumber">5071</td>
    <td class="codeline">  BasicBlock &EntryBB = F.getEntryBlock();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5072</td>
    <td class="codeline">  for (BasicBlock::iterator I = EntryBB.begin(), E = std::prev(EntryBB.end());</td>
    <td class="lineNumber">5072</td>
    <td class="codeline">  for (BasicBlock::iterator I = EntryBB.begin(), E = std::prev(EntryBB.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5073</td>
    <td class="codeline">       I != E; ++I) {</td>
    <td class="lineNumber">5073</td>
    <td class="codeline">       I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5074</td>
    <td class="codeline">    if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {</td>
    <td class="lineNumber">5074</td>
    <td class="codeline">    if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5075</td>
    <td class="codeline">      if (DL.getTypeAllocSize(AI->getAllocatedType()).isScalable() &&</td>
    <td class="lineNumber">5075</td>
    <td class="codeline">      if (DL.getTypeAllocSize(AI->getAllocatedType()).isScalable() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5076</td>
    <td class="codeline">          isAllocaPromotable(AI))</td>
    <td class="lineNumber">5076</td>
    <td class="codeline">          isAllocaPromotable(AI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5077</td>
    <td class="codeline">        PromotableAllocas.push_back(AI);</td>
    <td class="lineNumber">5077</td>
    <td class="codeline">        PromotableAllocas.push_back(AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5078</td>
    <td class="codeline">      else</td>
    <td class="lineNumber">5078</td>
    <td class="codeline">      else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5079</td>
    <td class="codeline">        Worklist.insert(AI);</td>
    <td class="lineNumber">5079</td>
    <td class="codeline">        Worklist.insert(AI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5080</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">5080</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5081</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5081</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5082</td>
    <td class="codeline"></td>
    <td class="lineNumber">5082</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5083</td>
    <td class="codeline">  bool Changed = false;</td>
    <td class="lineNumber">5083</td>
    <td class="codeline">  bool Changed = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5084</td>
    <td class="codeline">  bool CFGChanged = false;</td>
    <td class="lineNumber">5084</td>
    <td class="codeline">  bool CFGChanged = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5085</td>
    <td class="codeline">  // A set of deleted alloca instruction pointers which should be removed from</td>
    <td class="lineNumber">5085</td>
    <td class="codeline">  // A set of deleted alloca instruction pointers which should be removed from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5086</td>
    <td class="codeline">  // the list of promotable allocas.</td>
    <td class="lineNumber">5086</td>
    <td class="codeline">  // the list of promotable allocas.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5087</td>
    <td class="codeline">  SmallPtrSet<AllocaInst *, 4> DeletedAllocas;</td>
    <td class="lineNumber">5087</td>
    <td class="codeline">  SmallPtrSet<AllocaInst *, 4> DeletedAllocas;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5088</td>
    <td class="codeline"></td>
    <td class="lineNumber">5088</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5089</td>
    <td class="codeline">  do {</td>
    <td class="lineNumber">5089</td>
    <td class="codeline">  do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5090</td>
    <td class="codeline">    while (!Worklist.empty()) {</td>
    <td class="lineNumber">5090</td>
    <td class="codeline">    while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5091</td>
    <td class="codeline">      auto [IterationChanged, IterationCFGChanged] =</td>
    <td class="lineNumber">5091</td>
    <td class="codeline">      auto [IterationChanged, IterationCFGChanged] =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5092</td>
    <td class="codeline">          runOnAlloca(*Worklist.pop_back_val());</td>
    <td class="lineNumber">5092</td>
    <td class="codeline">          runOnAlloca(*Worklist.pop_back_val());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5093</td>
    <td class="codeline">      Changed |= IterationChanged;</td>
    <td class="lineNumber">5093</td>
    <td class="codeline">      Changed |= IterationChanged;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5094</td>
    <td class="codeline">      CFGChanged |= IterationCFGChanged;</td>
    <td class="lineNumber">5094</td>
    <td class="codeline">      CFGChanged |= IterationCFGChanged;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5095</td>
    <td class="codeline"></td>
    <td class="lineNumber">5095</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5096</td>
    <td class="codeline">      Changed |= deleteDeadInstructions(DeletedAllocas);</td>
    <td class="lineNumber">5096</td>
    <td class="codeline">      Changed |= deleteDeadInstructions(DeletedAllocas);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5097</td>
    <td class="codeline"></td>
    <td class="lineNumber">5097</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5098</td>
    <td class="codeline">      // Remove the deleted allocas from various lists so that we don't try to</td>
    <td class="lineNumber">5098</td>
    <td class="codeline">      // Remove the deleted allocas from various lists so that we don't try to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5099</td>
    <td class="codeline">      // continue processing them.</td>
    <td class="lineNumber">5099</td>
    <td class="codeline">      // continue processing them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5100</td>
    <td class="codeline">      if (!DeletedAllocas.empty()) {</td>
    <td class="lineNumber">5100</td>
    <td class="codeline">      if (!DeletedAllocas.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5101</td>
    <td class="codeline">        auto IsInSet = [&](AllocaInst *AI) { return DeletedAllocas.count(AI); };</td>
    <td class="lineNumber">5101</td>
    <td class="codeline">        auto IsInSet = [&](AllocaInst *AI) { return DeletedAllocas.count(AI); };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5102</td>
    <td class="codeline">        Worklist.remove_if(IsInSet);</td>
    <td class="lineNumber">5102</td>
    <td class="codeline">        Worklist.remove_if(IsInSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5103</td>
    <td class="codeline">        PostPromotionWorklist.remove_if(IsInSet);</td>
    <td class="lineNumber">5103</td>
    <td class="codeline">        PostPromotionWorklist.remove_if(IsInSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5104</td>
    <td class="codeline">        llvm::erase_if(PromotableAllocas, IsInSet);</td>
    <td class="lineNumber">5104</td>
    <td class="codeline">        llvm::erase_if(PromotableAllocas, IsInSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5105</td>
    <td class="codeline">        DeletedAllocas.clear();</td>
    <td class="lineNumber">5105</td>
    <td class="codeline">        DeletedAllocas.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5106</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">5106</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5107</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">5107</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5108</td>
    <td class="codeline"></td>
    <td class="lineNumber">5108</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5109</td>
    <td class="codeline">    Changed |= promoteAllocas(F);</td>
    <td class="lineNumber">5109</td>
    <td class="codeline">    Changed |= promoteAllocas(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5110</td>
    <td class="codeline"></td>
    <td class="lineNumber">5110</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5111</td>
    <td class="codeline">    Worklist = PostPromotionWorklist;</td>
    <td class="lineNumber">5111</td>
    <td class="codeline">    Worklist = PostPromotionWorklist;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5112</td>
    <td class="codeline">    PostPromotionWorklist.clear();</td>
    <td class="lineNumber">5112</td>
    <td class="codeline">    PostPromotionWorklist.clear();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5113</td>
    <td class="codeline">  } while (!Worklist.empty());</td>
    <td class="lineNumber">5113</td>
    <td class="codeline">  } while (!Worklist.empty());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5114</td>
    <td class="codeline"></td>
    <td class="lineNumber">5114</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5115</td>
    <td class="codeline">  assert((!CFGChanged || Changed) && "Can not only modify the CFG.");</td>
    <td class="lineNumber">5115</td>
    <td class="codeline">  assert((!CFGChanged || Changed) && "Can not only modify the CFG.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5116</td>
    <td class="codeline">  assert((!CFGChanged || !PreserveCFG) &&</td>
    <td class="lineNumber">5116</td>
    <td class="codeline">  assert((!CFGChanged || !PreserveCFG) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5117</td>
    <td class="codeline">         "Should not have modified the CFG when told to preserve it.");</td>
    <td class="lineNumber">5117</td>
    <td class="codeline">         "Should not have modified the CFG when told to preserve it.");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5118</td>
    <td class="codeline"></td>
    <td class="lineNumber">5118</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5119</td>
    <td class="codeline">  if (!Changed)</td>
    <td class="lineNumber">5119</td>
    <td class="codeline">  if (!Changed)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5120</td>
    <td class="codeline">    return PreservedAnalyses::all();</td>
    <td class="lineNumber">5120</td>
    <td class="codeline">    return PreservedAnalyses::all();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5121</td>
    <td class="codeline"></td>
    <td class="lineNumber">5121</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5122</td>
    <td class="codeline">  if (isAssignmentTrackingEnabled(*F.getParent())) {</td>
    <td class="lineNumber">5122</td>
    <td class="codeline">  if (isAssignmentTrackingEnabled(*F.getParent())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5123</td>
    <td class="codeline">    for (auto &BB : F)</td>
    <td class="lineNumber">5123</td>
    <td class="codeline">    for (auto &BB : F)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5124</td>
    <td class="codeline">      RemoveRedundantDbgInstrs(&BB);</td>
    <td class="lineNumber">5124</td>
    <td class="codeline">      RemoveRedundantDbgInstrs(&BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5125</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5125</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5126</td>
    <td class="codeline"></td>
    <td class="lineNumber">5126</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5127</td>
    <td class="codeline">  PreservedAnalyses PA;</td>
    <td class="lineNumber">5127</td>
    <td class="codeline">  PreservedAnalyses PA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5128</td>
    <td class="codeline">  if (!CFGChanged)</td>
    <td class="lineNumber">5128</td>
    <td class="codeline">  if (!CFGChanged)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5129</td>
    <td class="codeline">    PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">5129</td>
    <td class="codeline">    PA.preserveSet<CFGAnalyses>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5130</td>
    <td class="codeline">  PA.preserve<DominatorTreeAnalysis>();</td>
    <td class="lineNumber">5130</td>
    <td class="codeline">  PA.preserve<DominatorTreeAnalysis>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5131</td>
    <td class="codeline">  return PA;</td>
    <td class="lineNumber">5131</td>
    <td class="codeline">  return PA;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5132</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5132</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5133</td>
    <td class="codeline"></td>
    <td class="lineNumber">5133</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5134</td>
    <td class="codeline">PreservedAnalyses SROAPass::runImpl(Function &F, DominatorTree &RunDT,</td>
    <td class="lineNumber">5134</td>
    <td class="codeline">PreservedAnalyses SROAPass::runImpl(Function &F, DominatorTree &RunDT,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5135</td>
    <td class="codeline">                                    AssumptionCache &RunAC) {</td>
    <td class="lineNumber">5135</td>
    <td class="codeline">                                    AssumptionCache &RunAC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5136</td>
    <td class="codeline">  DomTreeUpdater DTU(RunDT, DomTreeUpdater::UpdateStrategy::Lazy);</td>
    <td class="lineNumber">5136</td>
    <td class="codeline">  DomTreeUpdater DTU(RunDT, DomTreeUpdater::UpdateStrategy::Lazy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5137</td>
    <td class="codeline">  return runImpl(F, DTU, RunAC);</td>
    <td class="lineNumber">5137</td>
    <td class="codeline">  return runImpl(F, DTU, RunAC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5138</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5138</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5139</td>
    <td class="codeline"></td>
    <td class="lineNumber">5139</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5140</td>
    <td class="codeline">PreservedAnalyses SROAPass::run(Function &F, FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">5140</td>
    <td class="codeline">PreservedAnalyses SROAPass::run(Function &F, FunctionAnalysisManager &AM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5141</td>
    <td class="codeline">  DominatorTree &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">5141</td>
    <td class="codeline">  DominatorTree &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5142</td>
    <td class="codeline">  AssumptionCache &AC = AM.getResult<AssumptionAnalysis>(F);</td>
    <td class="lineNumber">5142</td>
    <td class="codeline">  AssumptionCache &AC = AM.getResult<AssumptionAnalysis>(F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5143</td>
    <td class="codeline">  return runImpl(F, DT, AC);</td>
    <td class="lineNumber">5143</td>
    <td class="codeline">  return runImpl(F, DT, AC);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5144</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5144</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5145</td>
    <td class="codeline"></td>
    <td class="lineNumber">5145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5146</td>
    <td class="codeline">void SROAPass::printPipeline(</td>
    <td class="lineNumber">5146</td>
    <td class="codeline">void SROAPass::printPipeline(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5147</td>
    <td class="codeline">    raw_ostream &OS, function_ref<StringRef(StringRef)> MapClassName2PassName) {</td>
    <td class="lineNumber">5147</td>
    <td class="codeline">    raw_ostream &OS, function_ref<StringRef(StringRef)> MapClassName2PassName) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5148</td>
    <td class="codeline">  static_cast<PassInfoMixin<SROAPass> *>(this)->printPipeline(</td>
    <td class="lineNumber">5148</td>
    <td class="codeline">  static_cast<PassInfoMixin<SROAPass> *>(this)->printPipeline(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5149</td>
    <td class="codeline">      OS, MapClassName2PassName);</td>
    <td class="lineNumber">5149</td>
    <td class="codeline">      OS, MapClassName2PassName);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5150</td>
    <td class="codeline">  OS << (PreserveCFG ? "<preserve-cfg>" : "<modify-cfg>");</td>
    <td class="lineNumber">5150</td>
    <td class="codeline">  OS << (PreserveCFG ? "<preserve-cfg>" : "<modify-cfg>");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5151</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5151</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5152</td>
    <td class="codeline"></td>
    <td class="lineNumber">5152</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5153</td>
    <td class="codeline">SROAPass::SROAPass(SROAOptions PreserveCFG_)</td>
    <td class="lineNumber">5153</td>
    <td class="codeline">SROAPass::SROAPass(SROAOptions PreserveCFG_)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5154</td>
    <td class="codeline">    : PreserveCFG(PreserveCFG_ == SROAOptions::PreserveCFG) {}</td>
    <td class="lineNumber">5154</td>
    <td class="codeline">    : PreserveCFG(PreserveCFG_ == SROAOptions::PreserveCFG) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5155</td>
    <td class="codeline"></td>
    <td class="lineNumber">5155</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5156</td>
    <td class="codeline">/// A legacy pass for the legacy pass manager that wraps the \c SROA pass.</td>
    <td class="lineNumber">5156</td>
    <td class="codeline">/// A legacy pass for the legacy pass manager that wraps the \c SROA pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5157</td>
    <td class="codeline">///</td>
    <td class="lineNumber">5157</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5158</td>
    <td class="codeline">/// This is in the llvm namespace purely to allow it to be a friend of the \c</td>
    <td class="lineNumber">5158</td>
    <td class="codeline">/// This is in the llvm namespace purely to allow it to be a friend of the \c</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5159</td>
    <td class="codeline">/// SROA pass.</td>
    <td class="lineNumber">5159</td>
    <td class="codeline">/// SROA pass.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5160</td>
    <td class="codeline">class llvm::sroa::SROALegacyPass : public FunctionPass {</td>
    <td class="lineNumber">5160</td>
    <td class="codeline">class llvm::sroa::SROALegacyPass : public FunctionPass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5161</td>
    <td class="codeline">  /// The SROA implementation.</td>
    <td class="lineNumber">5161</td>
    <td class="codeline">  /// The SROA implementation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5162</td>
    <td class="codeline">  SROAPass Impl;</td>
    <td class="lineNumber">5162</td>
    <td class="codeline">  SROAPass Impl;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5163</td>
    <td class="codeline"></td>
    <td class="lineNumber">5163</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5164</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">5164</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5165</td>
    <td class="codeline">  static char ID;</td>
    <td class="lineNumber">5165</td>
    <td class="codeline">  static char ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5166</td>
    <td class="codeline"></td>
    <td class="lineNumber">5166</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5167</td>
    <td class="codeline">  SROALegacyPass(SROAOptions PreserveCFG = SROAOptions::PreserveCFG)</td>
    <td class="lineNumber">5167</td>
    <td class="codeline">  SROALegacyPass(SROAOptions PreserveCFG = SROAOptions::PreserveCFG)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5168</td>
    <td class="codeline">      : FunctionPass(ID), Impl(PreserveCFG) {</td>
    <td class="lineNumber">5168</td>
    <td class="codeline">      : FunctionPass(ID), Impl(PreserveCFG) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5169</td>
    <td class="codeline">    initializeSROALegacyPassPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">5169</td>
    <td class="codeline">    initializeSROALegacyPassPass(*PassRegistry::getPassRegistry());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5170</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5170</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5171</td>
    <td class="codeline"></td>
    <td class="lineNumber">5171</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5172</td>
    <td class="codeline">  bool runOnFunction(Function &F) override {</td>
    <td class="lineNumber">5172</td>
    <td class="codeline">  bool runOnFunction(Function &F) override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5173</td>
    <td class="codeline">    if (skipFunction(F))</td>
    <td class="lineNumber">5173</td>
    <td class="codeline">    if (skipFunction(F))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5174</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">5174</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5175</td>
    <td class="codeline"></td>
    <td class="lineNumber">5175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5176</td>
    <td class="codeline">    auto PA = Impl.runImpl(</td>
    <td class="lineNumber">5176</td>
    <td class="codeline">    auto PA = Impl.runImpl(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5177</td>
    <td class="codeline">        F, getAnalysis<DominatorTreeWrapperPass>().getDomTree(),</td>
    <td class="lineNumber">5177</td>
    <td class="codeline">        F, getAnalysis<DominatorTreeWrapperPass>().getDomTree(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5178</td>
    <td class="codeline">        getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F));</td>
    <td class="lineNumber">5178</td>
    <td class="codeline">        getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5179</td>
    <td class="codeline">    return !PA.areAllPreserved();</td>
    <td class="lineNumber">5179</td>
    <td class="codeline">    return !PA.areAllPreserved();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5180</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5180</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5181</td>
    <td class="codeline"></td>
    <td class="lineNumber">5181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5182</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">5182</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5183</td>
    <td class="codeline">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">5183</td>
    <td class="codeline">    AU.addRequired<AssumptionCacheTracker>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5184</td>
    <td class="codeline">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">5184</td>
    <td class="codeline">    AU.addRequired<DominatorTreeWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5185</td>
    <td class="codeline">    AU.addPreserved<GlobalsAAWrapperPass>();</td>
    <td class="lineNumber">5185</td>
    <td class="codeline">    AU.addPreserved<GlobalsAAWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5186</td>
    <td class="codeline">    AU.addPreserved<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">5186</td>
    <td class="codeline">    AU.addPreserved<DominatorTreeWrapperPass>();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5187</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">5187</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5188</td>
    <td class="codeline"></td>
    <td class="lineNumber">5188</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5189</td>
    <td class="codeline">  StringRef getPassName() const override { return "SROA"; }</td>
    <td class="lineNumber">5189</td>
    <td class="codeline">  StringRef getPassName() const override { return "SROA"; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5190</td>
    <td class="codeline">};</td>
    <td class="lineNumber">5190</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5191</td>
    <td class="codeline"></td>
    <td class="lineNumber">5191</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5192</td>
    <td class="codeline">char SROALegacyPass::ID = 0;</td>
    <td class="lineNumber">5192</td>
    <td class="codeline">char SROALegacyPass::ID = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5193</td>
    <td class="codeline"></td>
    <td class="lineNumber">5193</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5194</td>
    <td class="codeline">FunctionPass *llvm::createSROAPass(bool PreserveCFG) {</td>
    <td class="lineNumber">5194</td>
    <td class="codeline">FunctionPass *llvm::createSROAPass(bool PreserveCFG) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5195</td>
    <td class="codeline">  return new SROALegacyPass(PreserveCFG ? SROAOptions::PreserveCFG</td>
    <td class="lineNumber">5195</td>
    <td class="codeline">  return new SROALegacyPass(PreserveCFG ? SROAOptions::PreserveCFG</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5196</td>
    <td class="codeline">                                        : SROAOptions::ModifyCFG);</td>
    <td class="lineNumber">5196</td>
    <td class="codeline">                                        : SROAOptions::ModifyCFG);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5197</td>
    <td class="codeline">}</td>
    <td class="lineNumber">5197</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5198</td>
    <td class="codeline"></td>
    <td class="lineNumber">5198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5199</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(SROALegacyPass, "sroa",</td>
    <td class="lineNumber">5199</td>
    <td class="codeline">INITIALIZE_PASS_BEGIN(SROALegacyPass, "sroa",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5200</td>
    <td class="codeline">                      "Scalar Replacement Of Aggregates", false, false)</td>
    <td class="lineNumber">5200</td>
    <td class="codeline">                      "Scalar Replacement Of Aggregates", false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5201</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td class="lineNumber">5201</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5202</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">5202</td>
    <td class="codeline">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5203</td>
    <td class="codeline">INITIALIZE_PASS_END(SROALegacyPass, "sroa", "Scalar Replacement Of Aggregates",</td>
    <td class="lineNumber">5203</td>
    <td class="codeline">INITIALIZE_PASS_END(SROALegacyPass, "sroa", "Scalar Replacement Of Aggregates",</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5204</td>
    <td class="codeline">                    false, false)</td>
    <td class="lineNumber">5204</td>
    <td class="codeline">                    false, false)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5205</td>
    <td class="codeline"></td>
    <td class="lineNumber">5205</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- SROA.cpp - Scalar Replacement Of Aggregates ------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- SROA.cpp - Scalar Replacement Of Aggregates ------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">/// \file</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">/// This transformation implements the well known scalar replacement of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">/// This transformation implements the well known scalar replacement of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">/// aggregates transformation. It tries to identify promotable elements of an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">/// aggregates transformation. It tries to identify promotable elements of an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">/// aggregate alloca, and promote them to registers. It will also try to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">/// aggregate alloca, and promote them to registers. It will also try to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">/// convert uses of an element (or set of elements) of an alloca into a vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">/// convert uses of an element (or set of elements) of an alloca into a vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">/// or bitfield-style integer scalar if appropriate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">/// or bitfield-style integer scalar if appropriate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">/// It works to do this with minimal slicing of the alloca so that regions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">/// It works to do this with minimal slicing of the alloca so that regions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">/// which are merely transferred in and out of external memory remain unchanged</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">/// which are merely transferred in and out of external memory remain unchanged</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">/// and are not decomposed to scalar code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">/// and are not decomposed to scalar code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">/// Because this also performs alloca promotion, it can be thought of as also</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">/// Because this also performs alloca promotion, it can be thought of as also</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">/// serving the purpose of SSA formation. The algorithm iterates on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">/// serving the purpose of SSA formation. The algorithm iterates on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">/// function until all opportunities for promotion have been realized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">/// function until all opportunities for promotion have been realized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar/SROA.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar/SROA.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/ADT/PointerIntPair.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/ADT/PointerIntPair.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/ADT/STLExtras.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/ADT/SmallBitVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/ADT/SmallBitVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/ADT/Statistic.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/ADT/StringRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/ADT/Twine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/ADT/Twine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/ADT/iterator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/ADT/iterator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include "llvm/ADT/iterator_range.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include "llvm/Analysis/AssumptionCache.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/Analysis/DomTreeUpdater.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include "llvm/Analysis/DomTreeUpdater.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/Analysis/GlobalsModRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include "llvm/Analysis/GlobalsModRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/Analysis/Loads.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">#include "llvm/Analysis/Loads.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/Analysis/PtrUseVisitor.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">#include "llvm/Analysis/PtrUseVisitor.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">#include "llvm/Config/llvm-config.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">#include "llvm/IR/BasicBlock.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">#include "llvm/IR/Constant.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/IR/ConstantFolder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">#include "llvm/IR/ConstantFolder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">#include "llvm/IR/Constants.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/IR/DIBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">#include "llvm/IR/DIBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/IR/DebugInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">#include "llvm/IR/DebugInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/IR/DebugInfoMetadata.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">#include "llvm/IR/DebugInfoMetadata.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">#include "llvm/IR/Dominators.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">#include "llvm/IR/GetElementPtrTypeIterator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">#include "llvm/IR/GlobalAlias.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">#include "llvm/IR/GlobalAlias.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">#include "llvm/IR/IRBuilder.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">#include "llvm/IR/InstVisitor.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">#include "llvm/IR/InstVisitor.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">#include "llvm/IR/Instruction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">#include "llvm/IR/LLVMContext.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">#include "llvm/IR/Metadata.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">#include "llvm/IR/Metadata.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">#include "llvm/IR/Operator.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">#include "llvm/IR/Type.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">#include "llvm/IR/Use.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">#include "llvm/IR/Use.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine">#include "llvm/IR/User.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine">#include "llvm/IR/User.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">#include "llvm/IR/Value.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">#include "llvm/InitializePasses.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">#include "llvm/Support/Casting.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">#include "llvm/Support/CommandLine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">#include "llvm/Support/Compiler.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">#include "llvm/Support/Debug.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">#include "llvm/Support/raw_ostream.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">#include "llvm/Transforms/Scalar.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/BasicBlockUtils.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/Local.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/PromoteMemToReg.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">#include "llvm/Transforms/Utils/PromoteMemToReg.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">#include <algorithm></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">#include <cstddef></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">#include <cstddef></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">#include <cstring></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">#include <cstring></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">#include <iterator></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">#include <string></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">#include <string></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">#include <tuple></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">#include <vector></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">using namespace llvm::sroa;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">using namespace llvm::sroa;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">#define DEBUG_TYPE "sroa"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">#define DEBUG_TYPE "sroa"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">STATISTIC(NumAllocasAnalyzed, "Number of allocas analyzed for replacement");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">STATISTIC(NumAllocasAnalyzed, "Number of allocas analyzed for replacement");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">STATISTIC(NumAllocaPartitions, "Number of alloca partitions formed");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">STATISTIC(NumAllocaPartitions, "Number of alloca partitions formed");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">STATISTIC(MaxPartitionsPerAlloca, "Maximum number of partitions per alloca");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">STATISTIC(MaxPartitionsPerAlloca, "Maximum number of partitions per alloca");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">STATISTIC(NumAllocaPartitionUses, "Number of alloca partition uses rewritten");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">STATISTIC(NumAllocaPartitionUses, "Number of alloca partition uses rewritten");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">STATISTIC(MaxUsesPerAllocaPartition, "Maximum number of uses of a partition");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">STATISTIC(MaxUsesPerAllocaPartition, "Maximum number of uses of a partition");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">STATISTIC(NumNewAllocas, "Number of new, smaller allocas introduced");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">STATISTIC(NumNewAllocas, "Number of new, smaller allocas introduced");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">STATISTIC(NumPromoted, "Number of allocas promoted to SSA values");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">STATISTIC(NumPromoted, "Number of allocas promoted to SSA values");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">STATISTIC(NumLoadsSpeculated, "Number of loads speculated to allow promotion");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">STATISTIC(NumLoadsSpeculated, "Number of loads speculated to allow promotion");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">STATISTIC(NumLoadsPredicated,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">STATISTIC(NumLoadsPredicated,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">          "Number of loads rewritten into predicated loads to allow promotion");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">          "Number of loads rewritten into predicated loads to allow promotion");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">STATISTIC(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">STATISTIC(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">    NumStoresPredicated,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">    NumStoresPredicated,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">    "Number of stores rewritten into predicated loads to allow promotion");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">    "Number of stores rewritten into predicated loads to allow promotion");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">STATISTIC(NumDeleted, "Number of instructions deleted");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">STATISTIC(NumDeleted, "Number of instructions deleted");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">STATISTIC(NumVectorized, "Number of vectorized aggregates");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">STATISTIC(NumVectorized, "Number of vectorized aggregates");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">/// Hidden option to experiment with completely strict handling of inbounds</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">/// Hidden option to experiment with completely strict handling of inbounds</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">/// GEPs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">/// GEPs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">static cl::opt<bool> SROAStrictInbounds("sroa-strict-inbounds", cl::init(false),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">static cl::opt<bool> SROAStrictInbounds("sroa-strict-inbounds", cl::init(false),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">                                        cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">                                        cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">/// Disable running mem2reg during SROA in order to test or debug SROA.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">/// Disable running mem2reg during SROA in order to test or debug SROA.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">static cl::opt<bool> SROASkipMem2Reg("sroa-skip-mem2reg", cl::init(false),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">static cl::opt<bool> SROASkipMem2Reg("sroa-skip-mem2reg", cl::init(false),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">                                     cl::Hidden);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">                                     cl::Hidden);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">/// Calculate the fragment of a variable to use when slicing a store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">/// Calculate the fragment of a variable to use when slicing a store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">/// based on the slice dimensions, existing fragment, and base storage</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">/// based on the slice dimensions, existing fragment, and base storage</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">/// fragment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">/// fragment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">/// Results:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">/// Results:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">/// UseFrag - Use Target as the new fragment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">/// UseFrag - Use Target as the new fragment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">/// UseNoFrag - The new slice already covers the whole variable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">/// UseNoFrag - The new slice already covers the whole variable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">/// Skip - The new alloca slice doesn't include this variable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">/// Skip - The new alloca slice doesn't include this variable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">/// FIXME: Can we use calculateFragmentIntersect instead?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">/// FIXME: Can we use calculateFragmentIntersect instead?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">enum FragCalcResult { UseFrag, UseNoFrag, Skip };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">enum FragCalcResult { UseFrag, UseNoFrag, Skip };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">static FragCalcResult</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">static FragCalcResult</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">calculateFragment(DILocalVariable *Variable,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">calculateFragment(DILocalVariable *Variable,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine">                  uint64_t NewStorageSliceOffsetInBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine">                  uint64_t NewStorageSliceOffsetInBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">                  uint64_t NewStorageSliceSizeInBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">                  uint64_t NewStorageSliceSizeInBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">                  std::optional<DIExpression::FragmentInfo> StorageFragment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">                  std::optional<DIExpression::FragmentInfo> StorageFragment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">                  std::optional<DIExpression::FragmentInfo> CurrentFragment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">                  std::optional<DIExpression::FragmentInfo> CurrentFragment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">                  DIExpression::FragmentInfo &Target) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">                  DIExpression::FragmentInfo &Target) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">  // If the base storage describes part of the variable apply the offset and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">  // If the base storage describes part of the variable apply the offset and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">  // the size constraint.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">  // the size constraint.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  if (StorageFragment) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  if (StorageFragment) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">    Target.SizeInBits =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">    Target.SizeInBits =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">        std::min(NewStorageSliceSizeInBits, StorageFragment->SizeInBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">        std::min(NewStorageSliceSizeInBits, StorageFragment->SizeInBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">    Target.OffsetInBits =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">    Target.OffsetInBits =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine">        NewStorageSliceOffsetInBits + StorageFragment->OffsetInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">148</td>
    <td class="codeLine">        NewStorageSliceOffsetInBits + StorageFragment->OffsetInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">    Target.SizeInBits = NewStorageSliceSizeInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">    Target.SizeInBits = NewStorageSliceSizeInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">    Target.OffsetInBits = NewStorageSliceOffsetInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">    Target.OffsetInBits = NewStorageSliceOffsetInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">  // If this slice extracts the entirety of an independent variable from a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">  // If this slice extracts the entirety of an independent variable from a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">  // larger alloca, do not produce a fragment expression, as the variable is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">  // larger alloca, do not produce a fragment expression, as the variable is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">  // not fragmented.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">  // not fragmented.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">  if (!CurrentFragment) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">  if (!CurrentFragment) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">    if (auto Size = Variable->getSizeInBits()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">    if (auto Size = Variable->getSizeInBits()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">      // Treat the current fragment as covering the whole variable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">      // Treat the current fragment as covering the whole variable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">      CurrentFragment =  DIExpression::FragmentInfo(*Size, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">      CurrentFragment =  DIExpression::FragmentInfo(*Size, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">      if (Target == CurrentFragment)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">      if (Target == CurrentFragment)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">        return UseNoFrag;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">        return UseNoFrag;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">  // No additional work to do if there isn't a fragment already, or there is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">  // No additional work to do if there isn't a fragment already, or there is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">  // but it already exactly describes the new assignment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">  // but it already exactly describes the new assignment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">  if (!CurrentFragment || *CurrentFragment == Target)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">  if (!CurrentFragment || *CurrentFragment == Target)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">    return UseFrag;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">    return UseFrag;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">  // Reject the target fragment if it doesn't fit wholly within the current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">  // Reject the target fragment if it doesn't fit wholly within the current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  // fragment. TODO: We could instead chop up the target to fit in the case of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  // fragment. TODO: We could instead chop up the target to fit in the case of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">  // a partial overlap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">  // a partial overlap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">  if (Target.startInBits() < CurrentFragment->startInBits() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">  if (Target.startInBits() < CurrentFragment->startInBits() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">      Target.endInBits() > CurrentFragment->endInBits())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">      Target.endInBits() > CurrentFragment->endInBits())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine">    return Skip;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">176</td>
    <td class="codeLine">    return Skip;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  // Target fits within the current fragment, return it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  // Target fits within the current fragment, return it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  return UseFrag;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  return UseFrag;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">static DebugVariable getAggregateVariable(DbgVariableIntrinsic *DVI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">static DebugVariable getAggregateVariable(DbgVariableIntrinsic *DVI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">  return DebugVariable(DVI->getVariable(), std::nullopt,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">  return DebugVariable(DVI->getVariable(), std::nullopt,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">                       DVI->getDebugLoc().getInlinedAt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">                       DVI->getDebugLoc().getInlinedAt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">/// Find linked dbg.assign and generate a new one with the correct</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">/// Find linked dbg.assign and generate a new one with the correct</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">/// FragmentInfo. Link Inst to the new dbg.assign.  If Value is nullptr the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">/// FragmentInfo. Link Inst to the new dbg.assign.  If Value is nullptr the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">/// value component is copied from the old dbg.assign to the new.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">/// value component is copied from the old dbg.assign to the new.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">/// \param OldAlloca             Alloca for the variable before splitting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">/// \param OldAlloca             Alloca for the variable before splitting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">/// \param IsSplit               True if the store (not necessarily alloca)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">/// \param IsSplit               True if the store (not necessarily alloca)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">///                              is being split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">///                              is being split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">/// \param OldAllocaOffsetInBits Offset of the slice taken from OldAlloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">/// \param OldAllocaOffsetInBits Offset of the slice taken from OldAlloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">/// \param SliceSizeInBits       New number of bits being written to.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">/// \param SliceSizeInBits       New number of bits being written to.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">/// \param OldInst               Instruction that is being split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">/// \param OldInst               Instruction that is being split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">/// \param Inst                  New instruction performing this part of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">/// \param Inst                  New instruction performing this part of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">///                              split store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">///                              split store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">/// \param Dest                  Store destination.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">/// \param Dest                  Store destination.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">/// \param Value                 Stored value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">/// \param Value                 Stored value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">/// \param DL                    Datalayout.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">/// \param DL                    Datalayout.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">static void migrateDebugInfo(AllocaInst *OldAlloca, bool IsSplit,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">static void migrateDebugInfo(AllocaInst *OldAlloca, bool IsSplit,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">                             uint64_t OldAllocaOffsetInBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">                             uint64_t OldAllocaOffsetInBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">                             uint64_t SliceSizeInBits, Instruction *OldInst,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">                             uint64_t SliceSizeInBits, Instruction *OldInst,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">                             Instruction *Inst, Value *Dest, Value *Value,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">                             Instruction *Inst, Value *Dest, Value *Value,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">                             const DataLayout &DL) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">                             const DataLayout &DL) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">  auto MarkerRange = at::getAssignmentMarkers(OldInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">  auto MarkerRange = at::getAssignmentMarkers(OldInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">  // Nothing to do if OldInst has no linked dbg.assign intrinsics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">  // Nothing to do if OldInst has no linked dbg.assign intrinsics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">  if (MarkerRange.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">  if (MarkerRange.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  migrateDebugInfo\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  migrateDebugInfo\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    OldAlloca: " << *OldAlloca << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    OldAlloca: " << *OldAlloca << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    IsSplit: " << IsSplit << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    IsSplit: " << IsSplit << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    OldAllocaOffsetInBits: " << OldAllocaOffsetInBits</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    OldAllocaOffsetInBits: " << OldAllocaOffsetInBits</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">                    << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    SliceSizeInBits: " << SliceSizeInBits << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    SliceSizeInBits: " << SliceSizeInBits << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    OldInst: " << *OldInst << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    OldInst: " << *OldInst << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    Inst: " << *Inst << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    Inst: " << *Inst << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    Dest: " << *Dest << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    Dest: " << *Dest << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine">  if (Value)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">220</td>
    <td class="codeLine">  if (Value)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    Value: " << *Value << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    Value: " << *Value << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  /// Map of aggregate variables to their fragment associated with OldAlloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  /// Map of aggregate variables to their fragment associated with OldAlloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">  DenseMap<DebugVariable, std::optional<DIExpression::FragmentInfo>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">  DenseMap<DebugVariable, std::optional<DIExpression::FragmentInfo>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">      BaseFragments;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">      BaseFragments;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">  for (auto *DAI : at::getAssignmentMarkers(OldAlloca))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">  for (auto *DAI : at::getAssignmentMarkers(OldAlloca))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">    BaseFragments[getAggregateVariable(DAI)] =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">    BaseFragments[getAggregateVariable(DAI)] =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">        DAI->getExpression()->getFragmentInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">        DAI->getExpression()->getFragmentInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">  // The new inst needs a DIAssignID unique metadata tag (if OldInst has</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">  // The new inst needs a DIAssignID unique metadata tag (if OldInst has</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  // one). It shouldn't already have one: assert this assumption.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  // one). It shouldn't already have one: assert this assumption.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">  assert(!Inst->getMetadata(LLVMContext::MD_DIAssignID));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">  assert(!Inst->getMetadata(LLVMContext::MD_DIAssignID));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine">  DIAssignID *NewID = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">233</td>
    <td class="codeLine">  DIAssignID *NewID = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">  auto &Ctx = Inst->getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">  auto &Ctx = Inst->getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  DIBuilder DIB(*OldInst->getModule(), /*AllowUnresolved*/ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  DIBuilder DIB(*OldInst->getModule(), /*AllowUnresolved*/ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">  assert(OldAlloca->isStaticAlloca());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">  assert(OldAlloca->isStaticAlloca());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">  for (DbgAssignIntrinsic *DbgAssign : MarkerRange) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">  for (DbgAssignIntrinsic *DbgAssign : MarkerRange) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "      existing dbg.assign is: " << *DbgAssign</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "      existing dbg.assign is: " << *DbgAssign</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">    auto *Expr = DbgAssign->getExpression();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">    auto *Expr = DbgAssign->getExpression();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">    bool SetKillLocation = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">    bool SetKillLocation = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">    if (IsSplit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">    if (IsSplit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">      std::optional<DIExpression::FragmentInfo> BaseFragment;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">      std::optional<DIExpression::FragmentInfo> BaseFragment;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">      {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">      {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">        auto R = BaseFragments.find(getAggregateVariable(DbgAssign));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">        auto R = BaseFragments.find(getAggregateVariable(DbgAssign));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">        if (R == BaseFragments.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">        if (R == BaseFragments.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">        BaseFragment = R->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">        BaseFragment = R->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">      std::optional<DIExpression::FragmentInfo> CurrentFragment =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">      std::optional<DIExpression::FragmentInfo> CurrentFragment =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">          Expr->getFragmentInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">          Expr->getFragmentInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">      DIExpression::FragmentInfo NewFragment;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">      DIExpression::FragmentInfo NewFragment;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">      FragCalcResult Result = calculateFragment(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">      FragCalcResult Result = calculateFragment(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">          DbgAssign->getVariable(), OldAllocaOffsetInBits, SliceSizeInBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">          DbgAssign->getVariable(), OldAllocaOffsetInBits, SliceSizeInBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">          BaseFragment, CurrentFragment, NewFragment);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">          BaseFragment, CurrentFragment, NewFragment);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine">      if (Result == Skip)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">259</td>
    <td class="codeLine">      if (Result == Skip)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">      if (Result == UseFrag && !(NewFragment == CurrentFragment)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">      if (Result == UseFrag && !(NewFragment == CurrentFragment)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">        if (CurrentFragment) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">        if (CurrentFragment) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">          // Rewrite NewFragment to be relative to the existing one (this is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">          // Rewrite NewFragment to be relative to the existing one (this is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">          // what createFragmentExpression wants).  CalculateFragment has</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">          // what createFragmentExpression wants).  CalculateFragment has</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">          // already resolved the size for us. FIXME: Should it return the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">          // already resolved the size for us. FIXME: Should it return the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">          // relative fragment too?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">          // relative fragment too?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">          NewFragment.OffsetInBits -= CurrentFragment->OffsetInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">          NewFragment.OffsetInBits -= CurrentFragment->OffsetInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">        // Add the new fragment info to the existing expression if possible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">        // Add the new fragment info to the existing expression if possible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">        if (auto E = DIExpression::createFragmentExpression(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">        if (auto E = DIExpression::createFragmentExpression(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">                Expr, NewFragment.OffsetInBits, NewFragment.SizeInBits)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">                Expr, NewFragment.OffsetInBits, NewFragment.SizeInBits)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine">          Expr = *E;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">272</td>
    <td class="codeLine">          Expr = *E;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">          // Otherwise, add the new fragment info to an empty expression and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">          // Otherwise, add the new fragment info to an empty expression and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">          // discard the value component of this dbg.assign as the value cannot</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">          // discard the value component of this dbg.assign as the value cannot</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">          // be computed with the new fragment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">          // be computed with the new fragment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">          Expr = *DIExpression::createFragmentExpression(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">          Expr = *DIExpression::createFragmentExpression(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">              DIExpression::get(Expr->getContext(), std::nullopt),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">              DIExpression::get(Expr->getContext(), std::nullopt),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">              NewFragment.OffsetInBits, NewFragment.SizeInBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">              NewFragment.OffsetInBits, NewFragment.SizeInBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">          SetKillLocation = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">          SetKillLocation = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">    // If we haven't created a DIAssignID ID do that now and attach it to Inst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">    // If we haven't created a DIAssignID ID do that now and attach it to Inst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">    if (!NewID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">    if (!NewID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">      NewID = DIAssignID::getDistinct(Ctx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">      NewID = DIAssignID::getDistinct(Ctx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">      Inst->setMetadata(LLVMContext::MD_DIAssignID, NewID);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">      Inst->setMetadata(LLVMContext::MD_DIAssignID, NewID);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">    ::Value *NewValue = Value ? Value : DbgAssign->getValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">    ::Value *NewValue = Value ? Value : DbgAssign->getValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">    auto *NewAssign = DIB.insertDbgAssign(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">    auto *NewAssign = DIB.insertDbgAssign(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">        Inst, NewValue, DbgAssign->getVariable(), Expr, Dest,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">        Inst, NewValue, DbgAssign->getVariable(), Expr, Dest,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">        DIExpression::get(Ctx, std::nullopt), DbgAssign->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">        DIExpression::get(Ctx, std::nullopt), DbgAssign->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">    // If we've updated the value but the original dbg.assign has an arglist</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">    // If we've updated the value but the original dbg.assign has an arglist</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">    // then kill it now - we can't use the requested new value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">    // then kill it now - we can't use the requested new value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">    // We can't replace the DIArgList with the new value as it'd leave</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">    // We can't replace the DIArgList with the new value as it'd leave</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">    // the DIExpression in an invalid state (DW_OP_LLVM_arg operands without</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">    // the DIExpression in an invalid state (DW_OP_LLVM_arg operands without</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">    // an arglist). And we can't keep the DIArgList in case the linked store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">    // an arglist). And we can't keep the DIArgList in case the linked store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">    // is being split - in which case the DIArgList + expression may no longer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">    // is being split - in which case the DIArgList + expression may no longer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">    // be computing the correct value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">    // be computing the correct value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">    // This should be a very rare situation as it requires the value being</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">    // This should be a very rare situation as it requires the value being</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">    // stored to differ from the dbg.assign (i.e., the value has been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">    // stored to differ from the dbg.assign (i.e., the value has been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">    // represented differently in the debug intrinsic for some reason).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">    // represented differently in the debug intrinsic for some reason).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">    SetKillLocation |=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">    SetKillLocation |=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">        Value && (DbgAssign->hasArgList() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">        Value && (DbgAssign->hasArgList() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">                  !DbgAssign->getExpression()->isSingleLocationExpression());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">                  !DbgAssign->getExpression()->isSingleLocationExpression());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">    if (SetKillLocation)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">    if (SetKillLocation)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">      NewAssign->setKillLocation();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">      NewAssign->setKillLocation();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">    // We could use more precision here at the cost of some additional (code)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">    // We could use more precision here at the cost of some additional (code)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">    // complexity - if the original dbg.assign was adjacent to its store, we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">    // complexity - if the original dbg.assign was adjacent to its store, we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">    // could position this new dbg.assign adjacent to its store rather than the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">    // could position this new dbg.assign adjacent to its store rather than the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">    // old dbg.assgn. That would result in interleaved dbg.assigns rather than</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">    // old dbg.assgn. That would result in interleaved dbg.assigns rather than</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">    // what we get now:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">    // what we get now:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">    //    split store !1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">    //    split store !1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">    //    split store !2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">    //    split store !2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">    //    dbg.assign !1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">    //    dbg.assign !1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">    //    dbg.assign !2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">    //    dbg.assign !2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">    // This (current behaviour) results results in debug assignments being</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">    // This (current behaviour) results results in debug assignments being</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">    // noted as slightly offset (in code) from the store. In practice this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">    // noted as slightly offset (in code) from the store. In practice this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">    // should have little effect on the debugging experience due to the fact</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">    // should have little effect on the debugging experience due to the fact</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">    // that all the split stores should get the same line number.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">    // that all the split stores should get the same line number.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">    NewAssign->moveBefore(DbgAssign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">    NewAssign->moveBefore(DbgAssign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">    NewAssign->setDebugLoc(DbgAssign->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">    NewAssign->setDebugLoc(DbgAssign->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Created new assign intrinsic: " << *NewAssign</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Created new assign intrinsic: " << *NewAssign</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">                      << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">/// A custom IRBuilder inserter which prefixes all names, but only in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">/// A custom IRBuilder inserter which prefixes all names, but only in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">/// Assert builds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">/// Assert builds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">class IRBuilderPrefixedInserter final : public IRBuilderDefaultInserter {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">class IRBuilderPrefixedInserter final : public IRBuilderDefaultInserter {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">  std::string Prefix;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">  std::string Prefix;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">  Twine getNameWithPrefix(const Twine &Name) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">  Twine getNameWithPrefix(const Twine &Name) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">    return Name.isTriviallyEmpty() ? Name : Prefix + Name;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">    return Name.isTriviallyEmpty() ? Name : Prefix + Name;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">  void SetNamePrefix(const Twine &P) { Prefix = P.str(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">  void SetNamePrefix(const Twine &P) { Prefix = P.str(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  void InsertHelper(Instruction *I, const Twine &Name, BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  void InsertHelper(Instruction *I, const Twine &Name, BasicBlock *BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">                    BasicBlock::iterator InsertPt) const override {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">                    BasicBlock::iterator InsertPt) const override {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">    IRBuilderDefaultInserter::InsertHelper(I, getNameWithPrefix(Name), BB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">    IRBuilderDefaultInserter::InsertHelper(I, getNameWithPrefix(Name), BB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">                                           InsertPt);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">                                           InsertPt);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">/// Provide a type for IRBuilder that drops names in release builds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">/// Provide a type for IRBuilder that drops names in release builds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">using IRBuilderTy = IRBuilder<ConstantFolder, IRBuilderPrefixedInserter>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">using IRBuilderTy = IRBuilder<ConstantFolder, IRBuilderPrefixedInserter>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">/// A used slice of an alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">/// A used slice of an alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">/// This structure represents a slice of an alloca used by some instruction. It</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">/// This structure represents a slice of an alloca used by some instruction. It</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">/// stores both the begin and end offsets of this use, a pointer to the use</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">/// stores both the begin and end offsets of this use, a pointer to the use</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">/// itself, and a flag indicating whether we can classify the use as splittable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">/// itself, and a flag indicating whether we can classify the use as splittable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">/// or not when forming partitions of the alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">/// or not when forming partitions of the alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">class Slice {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">class Slice {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">  /// The beginning offset of the range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">  /// The beginning offset of the range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">  uint64_t BeginOffset = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">  uint64_t BeginOffset = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">  /// The ending offset, not included in the range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">  /// The ending offset, not included in the range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">  uint64_t EndOffset = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">  uint64_t EndOffset = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">  /// Storage for both the use of this slice and whether it can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">  /// Storage for both the use of this slice and whether it can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">  /// split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">  /// split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">  PointerIntPair<Use *, 1, bool> UseAndIsSplittable;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">  PointerIntPair<Use *, 1, bool> UseAndIsSplittable;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">  Slice() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">  Slice() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">  Slice(uint64_t BeginOffset, uint64_t EndOffset, Use *U, bool IsSplittable)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">  Slice(uint64_t BeginOffset, uint64_t EndOffset, Use *U, bool IsSplittable)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">      : BeginOffset(BeginOffset), EndOffset(EndOffset),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">      : BeginOffset(BeginOffset), EndOffset(EndOffset),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">        UseAndIsSplittable(U, IsSplittable) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">        UseAndIsSplittable(U, IsSplittable) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">  uint64_t beginOffset() const { return BeginOffset; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">  uint64_t beginOffset() const { return BeginOffset; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">  uint64_t endOffset() const { return EndOffset; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">  uint64_t endOffset() const { return EndOffset; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">  bool isSplittable() const { return UseAndIsSplittable.getInt(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">  bool isSplittable() const { return UseAndIsSplittable.getInt(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  void makeUnsplittable() { UseAndIsSplittable.setInt(false); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  void makeUnsplittable() { UseAndIsSplittable.setInt(false); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">  Use *getUse() const { return UseAndIsSplittable.getPointer(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">  Use *getUse() const { return UseAndIsSplittable.getPointer(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">  bool isDead() const { return getUse() == nullptr; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">  bool isDead() const { return getUse() == nullptr; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">  void kill() { UseAndIsSplittable.setPointer(nullptr); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">  void kill() { UseAndIsSplittable.setPointer(nullptr); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">  /// Support for ordering ranges.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">  /// Support for ordering ranges.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">  /// This provides an ordering over ranges such that start offsets are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">  /// This provides an ordering over ranges such that start offsets are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">  /// always increasing, and within equal start offsets, the end offsets are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">  /// always increasing, and within equal start offsets, the end offsets are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">  /// decreasing. Thus the spanning range comes first in a cluster with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">  /// decreasing. Thus the spanning range comes first in a cluster with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">  /// same start position.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">  /// same start position.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  bool operator<(const Slice &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  bool operator<(const Slice &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">    if (beginOffset() < RHS.beginOffset())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">    if (beginOffset() < RHS.beginOffset())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">    if (beginOffset() > RHS.beginOffset())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">    if (beginOffset() > RHS.beginOffset())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">    if (isSplittable() != RHS.isSplittable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">    if (isSplittable() != RHS.isSplittable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">      return !isSplittable();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">      return !isSplittable();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">    if (endOffset() > RHS.endOffset())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">    if (endOffset() > RHS.endOffset())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">  /// Support comparison with a single offset to allow binary searches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">  /// Support comparison with a single offset to allow binary searches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">  friend LLVM_ATTRIBUTE_UNUSED bool operator<(const Slice &LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">  friend LLVM_ATTRIBUTE_UNUSED bool operator<(const Slice &LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">                                              uint64_t RHSOffset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">                                              uint64_t RHSOffset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">    return LHS.beginOffset() < RHSOffset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">    return LHS.beginOffset() < RHSOffset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">  friend LLVM_ATTRIBUTE_UNUSED bool operator<(uint64_t LHSOffset,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">  friend LLVM_ATTRIBUTE_UNUSED bool operator<(uint64_t LHSOffset,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">                                              const Slice &RHS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">                                              const Slice &RHS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">    return LHSOffset < RHS.beginOffset();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">    return LHSOffset < RHS.beginOffset();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">  bool operator==(const Slice &RHS) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">  bool operator==(const Slice &RHS) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">    return isSplittable() == RHS.isSplittable() &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">    return isSplittable() == RHS.isSplittable() &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">           beginOffset() == RHS.beginOffset() && endOffset() == RHS.endOffset();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">           beginOffset() == RHS.beginOffset() && endOffset() == RHS.endOffset();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">  bool operator!=(const Slice &RHS) const { return !operator==(RHS); }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  bool operator!=(const Slice &RHS) const { return !operator==(RHS); }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">/// Representation of the alloca slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">/// Representation of the alloca slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine">/// This class represents the slices of an alloca which are formed by its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine">/// This class represents the slices of an alloca which are formed by its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">/// various uses. If a pointer escapes, we can't fully build a representation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">/// various uses. If a pointer escapes, we can't fully build a representation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">/// for the slices used and we reflect that in this structure. The uses are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">/// for the slices used and we reflect that in this structure. The uses are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">/// stored, sorted by increasing beginning offset and with unsplittable slices</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">/// stored, sorted by increasing beginning offset and with unsplittable slices</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">/// starting at a particular offset before splittable slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">/// starting at a particular offset before splittable slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">class llvm::sroa::AllocaSlices {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">class llvm::sroa::AllocaSlices {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">  /// Construct the slices of a particular alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">  /// Construct the slices of a particular alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">  AllocaSlices(const DataLayout &DL, AllocaInst &AI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">  AllocaSlices(const DataLayout &DL, AllocaInst &AI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">  /// Test whether a pointer to the allocation escapes our analysis.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">  /// Test whether a pointer to the allocation escapes our analysis.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">  /// If this is true, the slices are never fully built and should be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">  /// If this is true, the slices are never fully built and should be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">  /// ignored.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">  /// ignored.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">  bool isEscaped() const { return PointerEscapingInstr; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">  bool isEscaped() const { return PointerEscapingInstr; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">  /// Support for iterating over the slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">  /// Support for iterating over the slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">  using iterator = SmallVectorImpl<Slice>::iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">  using iterator = SmallVectorImpl<Slice>::iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">  using range = iterator_range<iterator>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">  using range = iterator_range<iterator>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">  iterator begin() { return Slices.begin(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">  iterator begin() { return Slices.begin(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">  iterator end() { return Slices.end(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">  iterator end() { return Slices.end(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  using const_iterator = SmallVectorImpl<Slice>::const_iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  using const_iterator = SmallVectorImpl<Slice>::const_iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine">  using const_range = iterator_range<const_iterator>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine">  using const_range = iterator_range<const_iterator>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">  const_iterator begin() const { return Slices.begin(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">  const_iterator begin() const { return Slices.begin(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">  const_iterator end() const { return Slices.end(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">  const_iterator end() const { return Slices.end(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">  /// Erase a range of slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">  /// Erase a range of slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">  void erase(iterator Start, iterator Stop) { Slices.erase(Start, Stop); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">  void erase(iterator Start, iterator Stop) { Slices.erase(Start, Stop); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">  /// Insert new slices for this alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">  /// Insert new slices for this alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">  /// This moves the slices into the alloca's slices collection, and re-sorts</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">  /// This moves the slices into the alloca's slices collection, and re-sorts</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">  /// everything so that the usual ordering properties of the alloca's slices</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">  /// everything so that the usual ordering properties of the alloca's slices</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">  /// hold.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">  /// hold.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">  void insert(ArrayRef<Slice> NewSlices) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">  void insert(ArrayRef<Slice> NewSlices) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">    int OldSize = Slices.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">    int OldSize = Slices.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">    Slices.append(NewSlices.begin(), NewSlices.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">    Slices.append(NewSlices.begin(), NewSlices.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">    auto SliceI = Slices.begin() + OldSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">    auto SliceI = Slices.begin() + OldSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">    llvm::sort(SliceI, Slices.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">    llvm::sort(SliceI, Slices.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">    std::inplace_merge(Slices.begin(), SliceI, Slices.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">    std::inplace_merge(Slices.begin(), SliceI, Slices.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">  // Forward declare the iterator and range accessor for walking the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">  // Forward declare the iterator and range accessor for walking the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">  // partitions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">  // partitions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">  class partition_iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">  class partition_iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  iterator_range<partition_iterator> partitions();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  iterator_range<partition_iterator> partitions();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">  /// Access the dead users for this alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">  /// Access the dead users for this alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">  ArrayRef<Instruction *> getDeadUsers() const { return DeadUsers; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">  ArrayRef<Instruction *> getDeadUsers() const { return DeadUsers; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">  /// Access Uses that should be dropped if the alloca is promotable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">  /// Access Uses that should be dropped if the alloca is promotable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">  ArrayRef<Use *> getDeadUsesIfPromotable() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">  ArrayRef<Use *> getDeadUsesIfPromotable() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">    return DeadUseIfPromotable;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">    return DeadUseIfPromotable;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">  /// Access the dead operands referring to this alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">  /// Access the dead operands referring to this alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  /// These are operands which have cannot actually be used to refer to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  /// These are operands which have cannot actually be used to refer to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">  /// alloca as they are outside its range and the user doesn't correct for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">  /// alloca as they are outside its range and the user doesn't correct for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  /// that. These mostly consist of PHI node inputs and the like which we just</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  /// that. These mostly consist of PHI node inputs and the like which we just</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">  /// need to replace with undef.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">  /// need to replace with undef.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">  ArrayRef<Use *> getDeadOperands() const { return DeadOperands; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">  ArrayRef<Use *> getDeadOperands() const { return DeadOperands; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">  void print(raw_ostream &OS, const_iterator I, StringRef Indent = "  ") const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">  void print(raw_ostream &OS, const_iterator I, StringRef Indent = "  ") const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">  void printSlice(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">  void printSlice(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">                  StringRef Indent = "  ") const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">                  StringRef Indent = "  ") const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">  void printUse(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">  void printUse(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">                StringRef Indent = "  ") const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">                StringRef Indent = "  ") const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">  void print(raw_ostream &OS) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">  void print(raw_ostream &OS) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">  void dump(const_iterator I) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">  void dump(const_iterator I) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine">  void dump() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine">  void dump() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  template <typename DerivedT, typename RetT = void> class BuilderBase;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  template <typename DerivedT, typename RetT = void> class BuilderBase;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">  class SliceBuilder;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">  class SliceBuilder;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  friend class AllocaSlices::SliceBuilder;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  friend class AllocaSlices::SliceBuilder;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">  /// Handle to alloca instruction to simplify method interfaces.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">  /// Handle to alloca instruction to simplify method interfaces.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">  AllocaInst &AI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">  AllocaInst &AI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  /// The instruction responsible for this alloca not having a known set</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  /// The instruction responsible for this alloca not having a known set</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">  /// of slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">  /// of slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">  /// When an instruction (potentially) escapes the pointer to the alloca, we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">  /// When an instruction (potentially) escapes the pointer to the alloca, we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">  /// store a pointer to that here and abort trying to form slices of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">  /// store a pointer to that here and abort trying to form slices of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">  /// alloca. This will be null if the alloca slices are analyzed successfully.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">  /// alloca. This will be null if the alloca slices are analyzed successfully.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  Instruction *PointerEscapingInstr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  Instruction *PointerEscapingInstr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  /// The slices of the alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  /// The slices of the alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">  /// We store a vector of the slices formed by uses of the alloca here. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">  /// We store a vector of the slices formed by uses of the alloca here. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">  /// vector is sorted by increasing begin offset, and then the unsplittable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">  /// vector is sorted by increasing begin offset, and then the unsplittable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">  /// slices before the splittable ones. See the Slice inner class for more</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">  /// slices before the splittable ones. See the Slice inner class for more</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">  /// details.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">  /// details.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">  SmallVector<Slice, 8> Slices;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">  SmallVector<Slice, 8> Slices;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">  /// Instructions which will become dead if we rewrite the alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">  /// Instructions which will become dead if we rewrite the alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  /// Note that these are not separated by slice. This is because we expect an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  /// Note that these are not separated by slice. This is because we expect an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">  /// alloca to be completely rewritten or not rewritten at all. If rewritten,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">  /// alloca to be completely rewritten or not rewritten at all. If rewritten,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">  /// all these instructions can simply be removed and replaced with poison as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">  /// all these instructions can simply be removed and replaced with poison as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine">  /// they come from outside of the allocated space.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine">  /// they come from outside of the allocated space.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  SmallVector<Instruction *, 8> DeadUsers;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  SmallVector<Instruction *, 8> DeadUsers;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">  /// Uses which will become dead if can promote the alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">  /// Uses which will become dead if can promote the alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">  SmallVector<Use *, 8> DeadUseIfPromotable;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">  SmallVector<Use *, 8> DeadUseIfPromotable;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">  /// Operands which will become dead if we rewrite the alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">  /// Operands which will become dead if we rewrite the alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine">  /// These are operands that in their particular use can be replaced with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine">  /// These are operands that in their particular use can be replaced with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">  /// poison when we rewrite the alloca. These show up in out-of-bounds inputs</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">  /// poison when we rewrite the alloca. These show up in out-of-bounds inputs</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">  /// to PHI nodes and the like. They aren't entirely dead (there might be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">  /// to PHI nodes and the like. They aren't entirely dead (there might be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine">  /// a GEP back into the bounds using it elsewhere) and nor is the PHI, but we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine">  /// a GEP back into the bounds using it elsewhere) and nor is the PHI, but we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">  /// want to swap this particular input for poison to simplify the use lists of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">  /// want to swap this particular input for poison to simplify the use lists of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">  /// the alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">  /// the alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">  SmallVector<Use *, 8> DeadOperands;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">  SmallVector<Use *, 8> DeadOperands;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">/// A partition of the slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">/// A partition of the slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">/// An ephemeral representation for a range of slices which can be viewed as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">/// An ephemeral representation for a range of slices which can be viewed as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">/// a partition of the alloca. This range represents a span of the alloca's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">/// a partition of the alloca. This range represents a span of the alloca's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">/// memory which cannot be split, and provides access to all of the slices</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">/// memory which cannot be split, and provides access to all of the slices</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">/// overlapping some part of the partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">/// overlapping some part of the partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">/// Objects of this type are produced by traversing the alloca's slices, but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">/// Objects of this type are produced by traversing the alloca's slices, but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">/// are only ephemeral and not persistent.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">/// are only ephemeral and not persistent.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">class llvm::sroa::Partition {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">class llvm::sroa::Partition {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">  friend class AllocaSlices;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">  friend class AllocaSlices;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">  friend class AllocaSlices::partition_iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">  friend class AllocaSlices::partition_iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">  using iterator = AllocaSlices::iterator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">  using iterator = AllocaSlices::iterator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">  /// The beginning and ending offsets of the alloca for this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">  /// The beginning and ending offsets of the alloca for this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">  /// partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">  /// partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">  uint64_t BeginOffset = 0, EndOffset = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">  uint64_t BeginOffset = 0, EndOffset = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  /// The start and end iterators of this partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  /// The start and end iterators of this partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">  iterator SI, SJ;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">  iterator SI, SJ;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">  /// A collection of split slice tails overlapping the partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">  /// A collection of split slice tails overlapping the partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">  SmallVector<Slice *, 4> SplitTails;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">  SmallVector<Slice *, 4> SplitTails;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">  /// Raw constructor builds an empty partition starting and ending at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">  /// Raw constructor builds an empty partition starting and ending at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">  /// the given iterator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">  /// the given iterator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">  Partition(iterator SI) : SI(SI), SJ(SI) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  Partition(iterator SI) : SI(SI), SJ(SI) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">  /// The start offset of this partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">  /// The start offset of this partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">  /// All of the contained slices start at or after this offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">  /// All of the contained slices start at or after this offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">  uint64_t beginOffset() const { return BeginOffset; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">  uint64_t beginOffset() const { return BeginOffset; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">  /// The end offset of this partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">  /// The end offset of this partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">  /// All of the contained slices end at or before this offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">  /// All of the contained slices end at or before this offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  uint64_t endOffset() const { return EndOffset; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  uint64_t endOffset() const { return EndOffset; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">  /// The size of the partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">  /// The size of the partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">  /// Note that this can never be zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">  /// Note that this can never be zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">  uint64_t size() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">  uint64_t size() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">    assert(BeginOffset < EndOffset && "Partitions must span some bytes!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">    assert(BeginOffset < EndOffset && "Partitions must span some bytes!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">    return EndOffset - BeginOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">    return EndOffset - BeginOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">605</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">  /// Test whether this partition contains no slices, and merely spans</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">  /// Test whether this partition contains no slices, and merely spans</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">  /// a region occupied by split slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">  /// a region occupied by split slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">  bool empty() const { return SI == SJ; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">  bool empty() const { return SI == SJ; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">609</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">  /// \name Iterate slices that start within the partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">  /// \name Iterate slices that start within the partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">  /// These may be splittable or unsplittable. They have a begin offset >= the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">  /// These may be splittable or unsplittable. They have a begin offset >= the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">  /// partition begin offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">  /// partition begin offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">  /// @{</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">  // FIXME: We should probably define a "concat_iterator" helper and use that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">  // FIXME: We should probably define a "concat_iterator" helper and use that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">  // to stitch together pointee_iterators over the split tails and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">  // to stitch together pointee_iterators over the split tails and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">  // contiguous iterators of the partition. That would give a much nicer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">  // contiguous iterators of the partition. That would give a much nicer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">  // interface here. We could then additionally expose filtered iterators for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">  // interface here. We could then additionally expose filtered iterators for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">  // split, unsplit, and unsplittable splices based on the usage patterns.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">  // split, unsplit, and unsplittable splices based on the usage patterns.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">  iterator begin() const { return SI; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">  iterator begin() const { return SI; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">  iterator end() const { return SJ; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">  iterator end() const { return SJ; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">  /// @}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">  /// Get the sequence of split slice tails.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">  /// Get the sequence of split slice tails.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">  /// These tails are of slices which start before this partition but are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">  /// These tails are of slices which start before this partition but are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  /// split and overlap into the partition. We accumulate these while forming</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  /// split and overlap into the partition. We accumulate these while forming</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">  /// partitions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">  /// partitions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">  ArrayRef<Slice *> splitSliceTails() const { return SplitTails; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">  ArrayRef<Slice *> splitSliceTails() const { return SplitTails; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">/// An iterator over partitions of the alloca's slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">/// An iterator over partitions of the alloca's slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">/// This iterator implements the core algorithm for partitioning the alloca's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">/// This iterator implements the core algorithm for partitioning the alloca's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">/// slices. It is a forward iterator as we don't support backtracking for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">/// slices. It is a forward iterator as we don't support backtracking for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">/// efficiency reasons, and re-use a single storage area to maintain the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">/// efficiency reasons, and re-use a single storage area to maintain the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">/// current set of split slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">/// current set of split slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">/// It is templated on the slice iterator type to use so that it can operate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">/// It is templated on the slice iterator type to use so that it can operate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">/// with either const or non-const slice iterators.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">/// with either const or non-const slice iterators.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">class AllocaSlices::partition_iterator</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">class AllocaSlices::partition_iterator</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">    : public iterator_facade_base<partition_iterator, std::forward_iterator_tag,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">    : public iterator_facade_base<partition_iterator, std::forward_iterator_tag,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">                                  Partition> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">                                  Partition> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  friend class AllocaSlices;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  friend class AllocaSlices;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">  /// Most of the state for walking the partitions is held in a class</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">  /// Most of the state for walking the partitions is held in a class</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">  /// with a nice interface for examining them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">  /// with a nice interface for examining them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">  Partition P;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">  Partition P;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  /// We need to keep the end of the slices to know when to stop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  /// We need to keep the end of the slices to know when to stop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">  AllocaSlices::iterator SE;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">  AllocaSlices::iterator SE;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">  /// We also need to keep track of the maximum split end offset seen.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">  /// We also need to keep track of the maximum split end offset seen.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">  /// FIXME: Do we really?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">  /// FIXME: Do we really?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">  uint64_t MaxSplitSliceEndOffset = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">  uint64_t MaxSplitSliceEndOffset = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  /// Sets the partition to be empty at given iterator, and sets the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  /// Sets the partition to be empty at given iterator, and sets the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">  /// end iterator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">  /// end iterator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">  partition_iterator(AllocaSlices::iterator SI, AllocaSlices::iterator SE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">  partition_iterator(AllocaSlices::iterator SI, AllocaSlices::iterator SE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">      : P(SI), SE(SE) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">      : P(SI), SE(SE) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">    // If not already at the end, advance our state to form the initial</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">    // If not already at the end, advance our state to form the initial</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">    // partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">    // partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">    if (SI != SE)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">    if (SI != SE)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">      advance();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">      advance();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">  /// Advance the iterator to the next partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">  /// Advance the iterator to the next partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">  /// Requires that the iterator not be at the end of the slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">  /// Requires that the iterator not be at the end of the slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">  void advance() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">  void advance() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">    assert((P.SI != SE || !P.SplitTails.empty()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">    assert((P.SI != SE || !P.SplitTails.empty()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">           "Cannot advance past the end of the slices!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">           "Cannot advance past the end of the slices!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">    // Clear out any split uses which have ended.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">    // Clear out any split uses which have ended.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">    if (!P.SplitTails.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">    if (!P.SplitTails.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">      if (P.EndOffset >= MaxSplitSliceEndOffset) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">      if (P.EndOffset >= MaxSplitSliceEndOffset) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">        // If we've finished all splits, this is easy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">        // If we've finished all splits, this is easy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">        P.SplitTails.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">        P.SplitTails.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine">        MaxSplitSliceEndOffset = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">678</td>
    <td class="codeLine">        MaxSplitSliceEndOffset = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">        // Remove the uses which have ended in the prior partition. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">        // Remove the uses which have ended in the prior partition. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">        // cannot change the max split slice end because we just checked that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">        // cannot change the max split slice end because we just checked that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">        // the prior partition ended prior to that max.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">        // the prior partition ended prior to that max.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">        llvm::erase_if(P.SplitTails,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">        llvm::erase_if(P.SplitTails,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">                       [&](Slice *S) { return S->endOffset() <= P.EndOffset; });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">                       [&](Slice *S) { return S->endOffset() <= P.EndOffset; });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">        assert(llvm::any_of(P.SplitTails,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">        assert(llvm::any_of(P.SplitTails,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">                            [&](Slice *S) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">                            [&](Slice *S) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">                              return S->endOffset() == MaxSplitSliceEndOffset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">                              return S->endOffset() == MaxSplitSliceEndOffset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine">                            }) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine">                            }) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">               "Could not find the current max split slice offset!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">               "Could not find the current max split slice offset!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">        assert(llvm::all_of(P.SplitTails,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">        assert(llvm::all_of(P.SplitTails,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine">                            [&](Slice *S) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine">                            [&](Slice *S) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">                              return S->endOffset() <= MaxSplitSliceEndOffset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">                              return S->endOffset() <= MaxSplitSliceEndOffset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">                            }) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">                            }) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">               "Max split slice end offset is not actually the max!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">               "Max split slice end offset is not actually the max!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">    // If P.SI is already at the end, then we've cleared the split tail and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">    // If P.SI is already at the end, then we've cleared the split tail and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">    // now have an end iterator.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">    // now have an end iterator.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">    if (P.SI == SE) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">    if (P.SI == SE) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">      assert(P.SplitTails.empty() && "Failed to clear the split slices!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">      assert(P.SplitTails.empty() && "Failed to clear the split slices!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">702</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">    // If we had a non-empty partition previously, set up the state for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">    // If we had a non-empty partition previously, set up the state for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">    // subsequent partitions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">    // subsequent partitions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">    if (P.SI != P.SJ) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">    if (P.SI != P.SJ) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">      // Accumulate all the splittable slices which started in the old</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">      // Accumulate all the splittable slices which started in the old</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">      // partition into the split list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">      // partition into the split list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">      for (Slice &S : P)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">      for (Slice &S : P)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">        if (S.isSplittable() && S.endOffset() > P.EndOffset) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">        if (S.isSplittable() && S.endOffset() > P.EndOffset) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">          P.SplitTails.push_back(&S);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">          P.SplitTails.push_back(&S);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">          MaxSplitSliceEndOffset =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">          MaxSplitSliceEndOffset =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">              std::max(S.endOffset(), MaxSplitSliceEndOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">              std::max(S.endOffset(), MaxSplitSliceEndOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">      // Start from the end of the previous partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">      // Start from the end of the previous partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">      P.SI = P.SJ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">      P.SI = P.SJ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">      // If P.SI is now at the end, we at most have a tail of split slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">      // If P.SI is now at the end, we at most have a tail of split slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">      if (P.SI == SE) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">      if (P.SI == SE) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">        P.BeginOffset = P.EndOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">        P.BeginOffset = P.EndOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">        P.EndOffset = MaxSplitSliceEndOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">        P.EndOffset = MaxSplitSliceEndOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">        return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">        return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">      // If the we have split slices and the next slice is after a gap and is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">      // If the we have split slices and the next slice is after a gap and is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">      // not splittable immediately form an empty partition for the split</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">      // not splittable immediately form an empty partition for the split</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">      // slices up until the next slice begins.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">      // slices up until the next slice begins.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">      if (!P.SplitTails.empty() && P.SI->beginOffset() != P.EndOffset &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">      if (!P.SplitTails.empty() && P.SI->beginOffset() != P.EndOffset &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">          !P.SI->isSplittable()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">          !P.SI->isSplittable()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">        P.BeginOffset = P.EndOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">        P.BeginOffset = P.EndOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">        P.EndOffset = P.SI->beginOffset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">        P.EndOffset = P.SI->beginOffset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">        return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">        return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">    // OK, we need to consume new slices. Set the end offset based on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">    // OK, we need to consume new slices. Set the end offset based on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">    // current slice, and step SJ past it. The beginning offset of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">    // current slice, and step SJ past it. The beginning offset of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">    // partition is the beginning offset of the next slice unless we have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">    // partition is the beginning offset of the next slice unless we have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">    // pre-existing split slices that are continuing, in which case we begin</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">    // pre-existing split slices that are continuing, in which case we begin</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">    // at the prior end offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">    // at the prior end offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">    P.BeginOffset = P.SplitTails.empty() ? P.SI->beginOffset() : P.EndOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">    P.BeginOffset = P.SplitTails.empty() ? P.SI->beginOffset() : P.EndOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">    P.EndOffset = P.SI->endOffset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">    P.EndOffset = P.SI->endOffset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">    ++P.SJ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">    ++P.SJ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">    // There are two strategies to form a partition based on whether the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">    // There are two strategies to form a partition based on whether the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">    // partition starts with an unsplittable slice or a splittable slice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">    // partition starts with an unsplittable slice or a splittable slice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">    if (!P.SI->isSplittable()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">    if (!P.SI->isSplittable()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">      // When we're forming an unsplittable region, it must always start at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">      // When we're forming an unsplittable region, it must always start at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">      // the first slice and will extend through its end.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">      // the first slice and will extend through its end.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">      assert(P.BeginOffset == P.SI->beginOffset());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">      assert(P.BeginOffset == P.SI->beginOffset());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">      // Form a partition including all of the overlapping slices with this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">      // Form a partition including all of the overlapping slices with this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">      // unsplittable slice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">      // unsplittable slice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">      while (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">      while (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">        if (!P.SJ->isSplittable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">        if (!P.SJ->isSplittable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">          P.EndOffset = std::max(P.EndOffset, P.SJ->endOffset());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">          P.EndOffset = std::max(P.EndOffset, P.SJ->endOffset());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">        ++P.SJ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">        ++P.SJ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">      // We have a partition across a set of overlapping unsplittable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">      // We have a partition across a set of overlapping unsplittable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">      // partitions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">      // partitions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">    // If we're starting with a splittable slice, then we need to form</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">    // If we're starting with a splittable slice, then we need to form</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">    // a synthetic partition spanning it and any other overlapping splittable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">    // a synthetic partition spanning it and any other overlapping splittable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">    // splices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">    // splices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">    assert(P.SI->isSplittable() && "Forming a splittable partition!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">    assert(P.SI->isSplittable() && "Forming a splittable partition!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">    // Collect all of the overlapping splittable slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">    // Collect all of the overlapping splittable slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">    while (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">    while (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">           P.SJ->isSplittable()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">           P.SJ->isSplittable()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">      P.EndOffset = std::max(P.EndOffset, P.SJ->endOffset());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">      P.EndOffset = std::max(P.EndOffset, P.SJ->endOffset());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine">      ++P.SJ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">776</td>
    <td class="codeLine">      ++P.SJ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine">    // Back upiP.EndOffset if we ended the span early when encountering an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine">    // Back upiP.EndOffset if we ended the span early when encountering an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">    // unsplittable slice. This synthesizes the early end offset of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">    // unsplittable slice. This synthesizes the early end offset of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">    // a partition spanning only splittable slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">    // a partition spanning only splittable slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">    if (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">    if (P.SJ != SE && P.SJ->beginOffset() < P.EndOffset) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">      assert(!P.SJ->isSplittable());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">      assert(!P.SJ->isSplittable());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">      P.EndOffset = P.SJ->beginOffset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">      P.EndOffset = P.SJ->beginOffset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">  bool operator==(const partition_iterator &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">  bool operator==(const partition_iterator &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">    assert(SE == RHS.SE &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">    assert(SE == RHS.SE &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">           "End iterators don't match between compared partition iterators!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">           "End iterators don't match between compared partition iterators!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">    // The observed positions of partitions is marked by the P.SI iterator and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">    // The observed positions of partitions is marked by the P.SI iterator and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">    // the emptiness of the split slices. The latter is only relevant when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">    // the emptiness of the split slices. The latter is only relevant when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">    // P.SI == SE, as the end iterator will additionally have an empty split</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">    // P.SI == SE, as the end iterator will additionally have an empty split</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">    // slices list, but the prior may have the same P.SI and a tail of split</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">    // slices list, but the prior may have the same P.SI and a tail of split</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">    // slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">    // slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">    if (P.SI == RHS.P.SI && P.SplitTails.empty() == RHS.P.SplitTails.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">    if (P.SI == RHS.P.SI && P.SplitTails.empty() == RHS.P.SplitTails.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">      assert(P.SJ == RHS.P.SJ &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">      assert(P.SJ == RHS.P.SJ &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">             "Same set of slices formed two different sized partitions!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">             "Same set of slices formed two different sized partitions!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">      assert(P.SplitTails.size() == RHS.P.SplitTails.size() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">      assert(P.SplitTails.size() == RHS.P.SplitTails.size() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">             "Same slice position with differently sized non-empty split "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">             "Same slice position with differently sized non-empty split "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">             "slice tails!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">             "slice tails!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">  partition_iterator &operator++() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">  partition_iterator &operator++() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine">    advance();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">810</td>
    <td class="codeLine">    advance();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">    return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">  Partition &operator*() { return P; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">  Partition &operator*() { return P; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">/// A forward range over the partitions of the alloca's slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">/// A forward range over the partitions of the alloca's slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">/// This accesses an iterator range over the partitions of the alloca's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">/// This accesses an iterator range over the partitions of the alloca's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">/// slices. It computes these partitions on the fly based on the overlapping</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">/// slices. It computes these partitions on the fly based on the overlapping</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">/// offsets of the slices and the ability to split them. It will visit "empty"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">/// offsets of the slices and the ability to split them. It will visit "empty"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">/// partitions to cover regions of the alloca only accessed via split</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">/// partitions to cover regions of the alloca only accessed via split</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">/// slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">/// slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">iterator_range<AllocaSlices::partition_iterator> AllocaSlices::partitions() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">iterator_range<AllocaSlices::partition_iterator> AllocaSlices::partitions() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">  return make_range(partition_iterator(begin(), end()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">  return make_range(partition_iterator(begin(), end()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">                    partition_iterator(end(), end()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">                    partition_iterator(end(), end()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">static Value *foldSelectInst(SelectInst &SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">static Value *foldSelectInst(SelectInst &SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">  // If the condition being selected on is a constant or the same value is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">  // If the condition being selected on is a constant or the same value is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">  // being selected between, fold the select. Yes this does (rarely) happen</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">  // being selected between, fold the select. Yes this does (rarely) happen</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">  // early on.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">  // early on.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine">  if (ConstantInt *CI = dyn_cast<ConstantInt>(SI.getCondition()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">833</td>
    <td class="codeLine">  if (ConstantInt *CI = dyn_cast<ConstantInt>(SI.getCondition()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">    return SI.getOperand(1 + CI->isZero());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">    return SI.getOperand(1 + CI->isZero());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">  if (SI.getOperand(1) == SI.getOperand(2))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">  if (SI.getOperand(1) == SI.getOperand(2))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">    return SI.getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">    return SI.getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">/// A helper that folds a PHI node or a select.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">/// A helper that folds a PHI node or a select.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">static Value *foldPHINodeOrSelectInst(Instruction &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">static Value *foldPHINodeOrSelectInst(Instruction &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">  if (PHINode *PN = dyn_cast<PHINode>(&I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">  if (PHINode *PN = dyn_cast<PHINode>(&I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">    // If PN merges together the same value, return that value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">    // If PN merges together the same value, return that value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">    return PN->hasConstantValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">    return PN->hasConstantValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  return foldSelectInst(cast<SelectInst>(I));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  return foldSelectInst(cast<SelectInst>(I));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">/// Builder for the alloca slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">/// Builder for the alloca slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">/// This class builds a set of alloca slices by recursively visiting the uses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">/// This class builds a set of alloca slices by recursively visiting the uses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">/// of an alloca and making a slice for each load and store at each offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">/// of an alloca and making a slice for each load and store at each offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">class AllocaSlices::SliceBuilder : public PtrUseVisitor<SliceBuilder> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">class AllocaSlices::SliceBuilder : public PtrUseVisitor<SliceBuilder> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">  friend class PtrUseVisitor<SliceBuilder>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">  friend class PtrUseVisitor<SliceBuilder>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">  friend class InstVisitor<SliceBuilder>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">  friend class InstVisitor<SliceBuilder>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">  using Base = PtrUseVisitor<SliceBuilder>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">  using Base = PtrUseVisitor<SliceBuilder>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">  const uint64_t AllocSize;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">  const uint64_t AllocSize;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">  AllocaSlices &AS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">  AllocaSlices &AS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">  SmallDenseMap<Instruction *, unsigned> MemTransferSliceMap;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">  SmallDenseMap<Instruction *, unsigned> MemTransferSliceMap;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">  SmallDenseMap<Instruction *, uint64_t> PHIOrSelectSizes;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">  SmallDenseMap<Instruction *, uint64_t> PHIOrSelectSizes;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">  /// Set to de-duplicate dead instructions found in the use walk.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">  /// Set to de-duplicate dead instructions found in the use walk.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">  SmallPtrSet<Instruction *, 4> VisitedDeadInsts;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">  SmallPtrSet<Instruction *, 4> VisitedDeadInsts;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  SliceBuilder(const DataLayout &DL, AllocaInst &AI, AllocaSlices &AS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  SliceBuilder(const DataLayout &DL, AllocaInst &AI, AllocaSlices &AS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">      : PtrUseVisitor<SliceBuilder>(DL),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">      : PtrUseVisitor<SliceBuilder>(DL),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">        AllocSize(DL.getTypeAllocSize(AI.getAllocatedType()).getFixedValue()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">        AllocSize(DL.getTypeAllocSize(AI.getAllocatedType()).getFixedValue()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">        AS(AS) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">        AS(AS) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  void markAsDead(Instruction &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  void markAsDead(Instruction &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">    if (VisitedDeadInsts.insert(&I).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">    if (VisitedDeadInsts.insert(&I).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine">      AS.DeadUsers.push_back(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">878</td>
    <td class="codeLine">      AS.DeadUsers.push_back(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">  void insertUse(Instruction &I, const APInt &Offset, uint64_t Size,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">  void insertUse(Instruction &I, const APInt &Offset, uint64_t Size,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">                 bool IsSplittable = false) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">                 bool IsSplittable = false) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">    // Completely skip uses which have a zero size or start either before or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">    // Completely skip uses which have a zero size or start either before or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">    // past the end of the allocation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">    // past the end of the allocation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">    if (Size == 0 || Offset.uge(AllocSize)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">    if (Size == 0 || Offset.uge(AllocSize)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "WARNING: Ignoring " << Size << " byte use @"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "WARNING: Ignoring " << Size << " byte use @"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">                        << Offset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">                        << Offset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">                        << " which has zero size or starts outside of the "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">                        << " which has zero size or starts outside of the "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">                        << AllocSize << " byte alloca:\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">                        << AllocSize << " byte alloca:\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine">                        << "    alloca: " << AS.AI << "\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine">                        << "    alloca: " << AS.AI << "\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">                        << "       use: " << I << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">                        << "       use: " << I << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">      return markAsDead(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">      return markAsDead(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">    uint64_t BeginOffset = Offset.getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">    uint64_t BeginOffset = Offset.getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">    uint64_t EndOffset = BeginOffset + Size;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">    uint64_t EndOffset = BeginOffset + Size;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">    // Clamp the end offset to the end of the allocation. Note that this is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">    // Clamp the end offset to the end of the allocation. Note that this is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">    // formulated to handle even the case where "BeginOffset + Size" overflows.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">    // formulated to handle even the case where "BeginOffset + Size" overflows.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">    // This may appear superficially to be something we could ignore entirely,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">    // This may appear superficially to be something we could ignore entirely,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">    // but that is not so! There may be widened loads or PHI-node uses where</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">    // but that is not so! There may be widened loads or PHI-node uses where</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">    // some instructions are dead but not others. We can't completely ignore</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">    // some instructions are dead but not others. We can't completely ignore</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">    // them, and so have to record at least the information here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">    // them, and so have to record at least the information here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">    assert(AllocSize >= BeginOffset); // Established above.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">    assert(AllocSize >= BeginOffset); // Established above.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine">    if (Size > AllocSize - BeginOffset) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">905</td>
    <td class="codeLine">    if (Size > AllocSize - BeginOffset) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "WARNING: Clamping a " << Size << " byte use @"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "WARNING: Clamping a " << Size << " byte use @"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">                        << Offset << " to remain within the " << AllocSize</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">                        << Offset << " to remain within the " << AllocSize</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">                        << " byte alloca:\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">                        << " byte alloca:\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">                        << "    alloca: " << AS.AI << "\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">                        << "    alloca: " << AS.AI << "\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">                        << "       use: " << I << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">                        << "       use: " << I << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">      EndOffset = AllocSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">      EndOffset = AllocSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">    AS.Slices.push_back(Slice(BeginOffset, EndOffset, U, IsSplittable));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">    AS.Slices.push_back(Slice(BeginOffset, EndOffset, U, IsSplittable));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine">  void visitBitCastInst(BitCastInst &BC) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">917</td>
    <td class="codeLine">  void visitBitCastInst(BitCastInst &BC) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">    if (BC.use_empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">    if (BC.use_empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">      return markAsDead(BC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">      return markAsDead(BC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">920</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine">    return Base::visitBitCastInst(BC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">921</td>
    <td class="codeLine">    return Base::visitBitCastInst(BC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">  void visitAddrSpaceCastInst(AddrSpaceCastInst &ASC) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">  void visitAddrSpaceCastInst(AddrSpaceCastInst &ASC) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">    if (ASC.use_empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">    if (ASC.use_empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">      return markAsDead(ASC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">      return markAsDead(ASC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine">    return Base::visitAddrSpaceCastInst(ASC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">928</td>
    <td class="codeLine">    return Base::visitAddrSpaceCastInst(ASC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">  void visitGetElementPtrInst(GetElementPtrInst &GEPI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">  void visitGetElementPtrInst(GetElementPtrInst &GEPI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">    if (GEPI.use_empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">    if (GEPI.use_empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">      return markAsDead(GEPI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">      return markAsDead(GEPI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">    if (SROAStrictInbounds && GEPI.isInBounds()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">    if (SROAStrictInbounds && GEPI.isInBounds()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">      // FIXME: This is a manually un-factored variant of the basic code inside</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">      // FIXME: This is a manually un-factored variant of the basic code inside</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">      // of GEPs with checking of the inbounds invariant specified in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">      // of GEPs with checking of the inbounds invariant specified in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">      // langref in a very strict sense. If we ever want to enable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">      // langref in a very strict sense. If we ever want to enable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">      // SROAStrictInbounds, this code should be factored cleanly into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">      // SROAStrictInbounds, this code should be factored cleanly into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine">      // PtrUseVisitor, but it is easier to experiment with SROAStrictInbounds</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine">      // PtrUseVisitor, but it is easier to experiment with SROAStrictInbounds</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">      // by writing out the code here where we have the underlying allocation</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">      // by writing out the code here where we have the underlying allocation</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">      // size readily available.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">      // size readily available.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">      APInt GEPOffset = Offset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">      APInt GEPOffset = Offset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">      const DataLayout &DL = GEPI.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">      const DataLayout &DL = GEPI.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine">      for (gep_type_iterator GTI = gep_type_begin(GEPI),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">945</td>
    <td class="codeLine">      for (gep_type_iterator GTI = gep_type_begin(GEPI),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">                             GTE = gep_type_end(GEPI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">                             GTE = gep_type_end(GEPI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">           GTI != GTE; ++GTI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">           GTI != GTE; ++GTI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">        ConstantInt *OpC = dyn_cast<ConstantInt>(GTI.getOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">        ConstantInt *OpC = dyn_cast<ConstantInt>(GTI.getOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">        if (!OpC)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">        if (!OpC)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">          break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine">        // Handle a struct index, which adds its field offset to the pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine">        // Handle a struct index, which adds its field offset to the pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">        if (StructType *STy = GTI.getStructTypeOrNull()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">        if (StructType *STy = GTI.getStructTypeOrNull()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">          unsigned ElementIdx = OpC->getZExtValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">          unsigned ElementIdx = OpC->getZExtValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">          const StructLayout *SL = DL.getStructLayout(STy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">          const StructLayout *SL = DL.getStructLayout(STy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">          GEPOffset +=</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">          GEPOffset +=</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">              APInt(Offset.getBitWidth(), SL->getElementOffset(ElementIdx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">              APInt(Offset.getBitWidth(), SL->getElementOffset(ElementIdx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">        } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine">          // For array or vector indices, scale the index by the size of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine">          // For array or vector indices, scale the index by the size of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">          // type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">          // type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">          APInt Index = OpC->getValue().sextOrTrunc(Offset.getBitWidth());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">          APInt Index = OpC->getValue().sextOrTrunc(Offset.getBitWidth());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">          GEPOffset +=</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">          GEPOffset +=</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">              Index *</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">              Index *</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">              APInt(Offset.getBitWidth(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">              APInt(Offset.getBitWidth(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine">                    DL.getTypeAllocSize(GTI.getIndexedType()).getFixedValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">965</td>
    <td class="codeLine">                    DL.getTypeAllocSize(GTI.getIndexedType()).getFixedValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine">        // If this index has computed an intermediate pointer which is not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine">        // If this index has computed an intermediate pointer which is not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">        // inbounds, then the result of the GEP is a poison value and we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">        // inbounds, then the result of the GEP is a poison value and we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">        // delete it and all uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">        // delete it and all uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine">        if (GEPOffset.ugt(AllocSize))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">971</td>
    <td class="codeLine">        if (GEPOffset.ugt(AllocSize))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">          return markAsDead(GEPI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">          return markAsDead(GEPI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">975</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">    return Base::visitGetElementPtrInst(GEPI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">    return Base::visitGetElementPtrInst(GEPI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">  void handleLoadOrStore(Type *Ty, Instruction &I, const APInt &Offset,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">  void handleLoadOrStore(Type *Ty, Instruction &I, const APInt &Offset,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">                         uint64_t Size, bool IsVolatile) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">                         uint64_t Size, bool IsVolatile) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">    // We allow splitting of non-volatile loads and stores where the type is an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">    // We allow splitting of non-volatile loads and stores where the type is an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine">    // integer type. These may be used to implement 'memcpy' or other "transfer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine">    // integer type. These may be used to implement 'memcpy' or other "transfer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">    // of bits" patterns.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">    // of bits" patterns.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">    bool IsSplittable =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">    bool IsSplittable =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">        Ty->isIntegerTy() && !IsVolatile && DL.typeSizeEqualsStoreSize(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">        Ty->isIntegerTy() && !IsVolatile && DL.typeSizeEqualsStoreSize(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine">    insertUse(I, Offset, Size, IsSplittable);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">987</td>
    <td class="codeLine">    insertUse(I, Offset, Size, IsSplittable);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">  void visitLoadInst(LoadInst &LI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">  void visitLoadInst(LoadInst &LI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">    assert((!LI.isSimple() || LI.getType()->isSingleValueType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">    assert((!LI.isSimple() || LI.getType()->isSingleValueType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">           "All simple FCA loads should have been pre-split");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">           "All simple FCA loads should have been pre-split");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">      return PI.setAborted(&LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">      return PI.setAborted(&LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">    TypeSize Size = DL.getTypeStoreSize(LI.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">    TypeSize Size = DL.getTypeStoreSize(LI.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine">    if (Size.isScalable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">998</td>
    <td class="codeLine">    if (Size.isScalable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">      return PI.setAborted(&LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">      return PI.setAborted(&LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">    return handleLoadOrStore(LI.getType(), LI, Offset, Size.getFixedValue(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">    return handleLoadOrStore(LI.getType(), LI, Offset, Size.getFixedValue(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">                             LI.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">                             LI.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">  void visitStoreInst(StoreInst &SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">  void visitStoreInst(StoreInst &SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine">    Value *ValOp = SI.getValueOperand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine">    Value *ValOp = SI.getValueOperand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">    if (ValOp == *U)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">    if (ValOp == *U)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">      return PI.setEscapedAndAborted(&SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">      return PI.setEscapedAndAborted(&SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">      return PI.setAborted(&SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">      return PI.setAborted(&SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine">    TypeSize StoreSize = DL.getTypeStoreSize(ValOp->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine">    TypeSize StoreSize = DL.getTypeStoreSize(ValOp->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">    if (StoreSize.isScalable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">    if (StoreSize.isScalable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">      return PI.setAborted(&SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">      return PI.setAborted(&SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">    uint64_t Size = StoreSize.getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">    uint64_t Size = StoreSize.getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine">    // If this memory access can be shown to *statically* extend outside the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine">    // If this memory access can be shown to *statically* extend outside the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">    // bounds of the allocation, it's behavior is undefined, so simply</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">    // bounds of the allocation, it's behavior is undefined, so simply</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">    // ignore it. Note that this is more strict than the generic clamping</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">    // ignore it. Note that this is more strict than the generic clamping</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">    // behavior of insertUse. We also try to handle cases which might run the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">    // behavior of insertUse. We also try to handle cases which might run the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">    // risk of overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">    // risk of overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">    // FIXME: We should instead consider the pointer to have escaped if this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">    // FIXME: We should instead consider the pointer to have escaped if this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">    // function is being instrumented for addressing bugs or race conditions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">    // function is being instrumented for addressing bugs or race conditions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">    if (Size > AllocSize || Offset.ugt(AllocSize - Size)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">    if (Size > AllocSize || Offset.ugt(AllocSize - Size)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "WARNING: Ignoring " << Size << " byte store @"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "WARNING: Ignoring " << Size << " byte store @"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">                        << Offset << " which extends past the end of the "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">                        << Offset << " which extends past the end of the "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">                        << AllocSize << " byte alloca:\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">                        << AllocSize << " byte alloca:\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">                        << "    alloca: " << AS.AI << "\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">                        << "    alloca: " << AS.AI << "\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">                        << "       use: " << SI << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">                        << "       use: " << SI << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">      return markAsDead(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">      return markAsDead(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">    assert((!SI.isSimple() || ValOp->getType()->isSingleValueType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">    assert((!SI.isSimple() || ValOp->getType()->isSingleValueType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">           "All simple FCA stores should have been pre-split");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">           "All simple FCA stores should have been pre-split");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">    handleLoadOrStore(ValOp->getType(), SI, Offset, Size, SI.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">    handleLoadOrStore(ValOp->getType(), SI, Offset, Size, SI.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">  void visitMemSetInst(MemSetInst &II) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">  void visitMemSetInst(MemSetInst &II) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">    assert(II.getRawDest() == *U && "Pointer use is not the destination?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">    assert(II.getRawDest() == *U && "Pointer use is not the destination?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">    ConstantInt *Length = dyn_cast<ConstantInt>(II.getLength());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">    ConstantInt *Length = dyn_cast<ConstantInt>(II.getLength());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">    if ((Length && Length->getValue() == 0) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">    if ((Length && Length->getValue() == 0) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">        (IsOffsetKnown && Offset.uge(AllocSize)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">        (IsOffsetKnown && Offset.uge(AllocSize)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">      // Zero-length mem transfer intrinsics can be ignored entirely.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">      // Zero-length mem transfer intrinsics can be ignored entirely.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">      return markAsDead(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">      return markAsDead(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">      return PI.setAborted(&II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">      return PI.setAborted(&II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">    insertUse(II, Offset, Length ? Length->getLimitedValue()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">    insertUse(II, Offset, Length ? Length->getLimitedValue()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">                                 : AllocSize - Offset.getLimitedValue(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">                                 : AllocSize - Offset.getLimitedValue(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">              (bool)Length);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">              (bool)Length);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">  void visitMemTransferInst(MemTransferInst &II) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">  void visitMemTransferInst(MemTransferInst &II) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">    ConstantInt *Length = dyn_cast<ConstantInt>(II.getLength());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">    ConstantInt *Length = dyn_cast<ConstantInt>(II.getLength());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">    if (Length && Length->getValue() == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">    if (Length && Length->getValue() == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine">      // Zero-length mem transfer intrinsics can be ignored entirely.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine">      // Zero-length mem transfer intrinsics can be ignored entirely.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">      return markAsDead(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">      return markAsDead(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">    // Because we can visit these intrinsics twice, also check to see if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">    // Because we can visit these intrinsics twice, also check to see if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">    // first time marked this instruction as dead. If so, skip it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">    // first time marked this instruction as dead. If so, skip it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine">    if (VisitedDeadInsts.count(&II))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine">    if (VisitedDeadInsts.count(&II))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">      return PI.setAborted(&II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">      return PI.setAborted(&II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine">    // This side of the transfer is completely out-of-bounds, and so we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine">    // This side of the transfer is completely out-of-bounds, and so we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">    // nuke the entire transfer. However, we also need to nuke the other side</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">    // nuke the entire transfer. However, we also need to nuke the other side</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">    // if already added to our partitions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">    // if already added to our partitions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">    // FIXME: Yet another place we really should bypass this when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">    // FIXME: Yet another place we really should bypass this when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">    // instrumenting for ASan.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">    // instrumenting for ASan.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine">    if (Offset.uge(AllocSize)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine">    if (Offset.uge(AllocSize)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">      SmallDenseMap<Instruction *, unsigned>::iterator MTPI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">      SmallDenseMap<Instruction *, unsigned>::iterator MTPI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">          MemTransferSliceMap.find(&II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">          MemTransferSliceMap.find(&II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">      if (MTPI != MemTransferSliceMap.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">      if (MTPI != MemTransferSliceMap.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">        AS.Slices[MTPI->second].kill();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">        AS.Slices[MTPI->second].kill();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">      return markAsDead(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">      return markAsDead(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">    uint64_t RawOffset = Offset.getLimitedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">    uint64_t RawOffset = Offset.getLimitedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">    uint64_t Size = Length ? Length->getLimitedValue() : AllocSize - RawOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">    uint64_t Size = Length ? Length->getLimitedValue() : AllocSize - RawOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">    // Check for the special case where the same exact value is used for both</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">    // Check for the special case where the same exact value is used for both</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine">    // source and dest.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine">    // source and dest.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">    if (*U == II.getRawDest() && *U == II.getRawSource()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">    if (*U == II.getRawDest() && *U == II.getRawSource()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">      // For non-volatile transfers this is a no-op.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">      // For non-volatile transfers this is a no-op.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">      if (!II.isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">      if (!II.isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">        return markAsDead(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">        return markAsDead(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">      return insertUse(II, Offset, Size, /*IsSplittable=*/false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">      return insertUse(II, Offset, Size, /*IsSplittable=*/false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">    // If we have seen both source and destination for a mem transfer, then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">    // If we have seen both source and destination for a mem transfer, then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine">    // they both point to the same alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine">    // they both point to the same alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">    bool Inserted;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">    bool Inserted;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">    SmallDenseMap<Instruction *, unsigned>::iterator MTPI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">    SmallDenseMap<Instruction *, unsigned>::iterator MTPI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine">    std::tie(MTPI, Inserted) =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine">    std::tie(MTPI, Inserted) =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">        MemTransferSliceMap.insert(std::make_pair(&II, AS.Slices.size()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">        MemTransferSliceMap.insert(std::make_pair(&II, AS.Slices.size()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">    unsigned PrevIdx = MTPI->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">    unsigned PrevIdx = MTPI->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">    if (!Inserted) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">    if (!Inserted) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">      Slice &PrevP = AS.Slices[PrevIdx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">      Slice &PrevP = AS.Slices[PrevIdx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">      // Check if the begin offsets match and this is a non-volatile transfer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">      // Check if the begin offsets match and this is a non-volatile transfer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">      // In that case, we can completely elide the transfer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">      // In that case, we can completely elide the transfer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">      if (!II.isVolatile() && PrevP.beginOffset() == RawOffset) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">      if (!II.isVolatile() && PrevP.beginOffset() == RawOffset) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">        PrevP.kill();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">        PrevP.kill();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine">        return markAsDead(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine">        return markAsDead(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">      // Otherwise we have an offset transfer within the same alloca. We can't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">      // Otherwise we have an offset transfer within the same alloca. We can't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">      // split those.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">      // split those.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine">      PrevP.makeUnsplittable();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine">      PrevP.makeUnsplittable();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">    // Insert the use now that we've fixed up the splittable nature.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">    // Insert the use now that we've fixed up the splittable nature.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">    insertUse(II, Offset, Size, /*IsSplittable=*/Inserted && Length);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">    insertUse(II, Offset, Size, /*IsSplittable=*/Inserted && Length);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine">    // Check that we ended up with a valid index in the map.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine">    // Check that we ended up with a valid index in the map.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">    assert(AS.Slices[PrevIdx].getUse()->getUser() == &II &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">    assert(AS.Slices[PrevIdx].getUse()->getUser() == &II &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">           "Map index doesn't point back to a slice with this user.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">           "Map index doesn't point back to a slice with this user.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">  // Disable SRoA for any intrinsics except for lifetime invariants and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">  // Disable SRoA for any intrinsics except for lifetime invariants and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">  // invariant group.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">  // invariant group.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">  // FIXME: What about debug intrinsics? This matches old behavior, but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">  // FIXME: What about debug intrinsics? This matches old behavior, but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">  // doesn't make sense.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">  // doesn't make sense.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">  void visitIntrinsicInst(IntrinsicInst &II) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">  void visitIntrinsicInst(IntrinsicInst &II) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">    if (II.isDroppable()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">    if (II.isDroppable()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine">      AS.DeadUseIfPromotable.push_back(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine">      AS.DeadUseIfPromotable.push_back(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">      return PI.setAborted(&II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">      return PI.setAborted(&II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">    if (II.isLifetimeStartOrEnd()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">    if (II.isLifetimeStartOrEnd()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">      ConstantInt *Length = cast<ConstantInt>(II.getArgOperand(0));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">      ConstantInt *Length = cast<ConstantInt>(II.getArgOperand(0));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">      uint64_t Size = std::min(AllocSize - Offset.getLimitedValue(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">      uint64_t Size = std::min(AllocSize - Offset.getLimitedValue(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">                               Length->getLimitedValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">                               Length->getLimitedValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">      insertUse(II, Offset, Size, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">      insertUse(II, Offset, Size, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">    if (II.isLaunderOrStripInvariantGroup()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">    if (II.isLaunderOrStripInvariantGroup()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">      enqueueUsers(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">      enqueueUsers(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine">    Base::visitIntrinsicInst(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine">    Base::visitIntrinsicInst(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">  Instruction *hasUnsafePHIOrSelectUse(Instruction *Root, uint64_t &Size) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">  Instruction *hasUnsafePHIOrSelectUse(Instruction *Root, uint64_t &Size) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">    // We consider any PHI or select that results in a direct load or store of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">    // We consider any PHI or select that results in a direct load or store of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">    // the same offset to be a viable use for slicing purposes. These uses</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">    // the same offset to be a viable use for slicing purposes. These uses</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">    // are considered unsplittable and the size is the maximum loaded or stored</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">    // are considered unsplittable and the size is the maximum loaded or stored</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">    // size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">    // size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">    SmallPtrSet<Instruction *, 4> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">    SmallPtrSet<Instruction *, 4> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">    SmallVector<std::pair<Instruction *, Instruction *>, 4> Uses;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">    SmallVector<std::pair<Instruction *, Instruction *>, 4> Uses;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine">    Visited.insert(Root);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine">    Visited.insert(Root);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">    Uses.push_back(std::make_pair(cast<Instruction>(*U), Root));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">    Uses.push_back(std::make_pair(cast<Instruction>(*U), Root));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">    const DataLayout &DL = Root->getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">    const DataLayout &DL = Root->getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">    // If there are no loads or stores, the access is dead. We mark that as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">    // If there are no loads or stores, the access is dead. We mark that as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">    // a size zero access.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">    // a size zero access.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">    Size = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">    Size = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">      Instruction *I, *UsedI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">      Instruction *I, *UsedI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">      std::tie(UsedI, I) = Uses.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">      std::tie(UsedI, I) = Uses.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">      if (LoadInst *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">      if (LoadInst *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">        Size =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">        Size =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">            std::max(Size, DL.getTypeStoreSize(LI->getType()).getFixedValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">            std::max(Size, DL.getTypeStoreSize(LI->getType()).getFixedValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">      if (StoreInst *SI = dyn_cast<StoreInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">      if (StoreInst *SI = dyn_cast<StoreInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">        Value *Op = SI->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">        Value *Op = SI->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">        if (Op == UsedI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">        if (Op == UsedI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">          return SI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">          return SI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">        Size =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">        Size =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">            std::max(Size, DL.getTypeStoreSize(Op->getType()).getFixedValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">            std::max(Size, DL.getTypeStoreSize(Op->getType()).getFixedValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">      if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">      if (GetElementPtrInst *GEP = dyn_cast<GetElementPtrInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">        if (!GEP->hasAllZeroIndices())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">        if (!GEP->hasAllZeroIndices())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine">          return GEP;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine">          return GEP;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">      } else if (!isa<BitCastInst>(I) && !isa<PHINode>(I) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">      } else if (!isa<BitCastInst>(I) && !isa<PHINode>(I) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">                 !isa<SelectInst>(I) && !isa<AddrSpaceCastInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">                 !isa<SelectInst>(I) && !isa<AddrSpaceCastInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">        return I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">        return I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">      for (User *U : I->users())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">      for (User *U : I->users())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">        if (Visited.insert(cast<Instruction>(U)).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">        if (Visited.insert(cast<Instruction>(U)).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">          Uses.push_back(std::make_pair(I, cast<Instruction>(U)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">          Uses.push_back(std::make_pair(I, cast<Instruction>(U)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">    } while (!Uses.empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">    } while (!Uses.empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">  void visitPHINodeOrSelectInst(Instruction &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">  void visitPHINodeOrSelectInst(Instruction &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">    assert(isa<PHINode>(I) || isa<SelectInst>(I));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">    assert(isa<PHINode>(I) || isa<SelectInst>(I));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">    if (I.use_empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">    if (I.use_empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine">      return markAsDead(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine">      return markAsDead(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">    // If this is a PHI node before a catchswitch, we cannot insert any non-PHI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">    // If this is a PHI node before a catchswitch, we cannot insert any non-PHI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">    // instructions in this BB, which may be required during rewriting. Bail out</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">    // instructions in this BB, which may be required during rewriting. Bail out</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">    // on these cases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">    // on these cases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">    if (isa<PHINode>(I) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">    if (isa<PHINode>(I) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">        I.getParent()->getFirstInsertionPt() == I.getParent()->end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">        I.getParent()->getFirstInsertionPt() == I.getParent()->end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine">      return PI.setAborted(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine">      return PI.setAborted(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">    // TODO: We could use simplifyInstruction here to fold PHINodes and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">    // TODO: We could use simplifyInstruction here to fold PHINodes and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">    // SelectInsts. However, doing so requires to change the current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">    // SelectInsts. However, doing so requires to change the current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine">    // dead-operand-tracking mechanism. For instance, suppose neither loading</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine">    // dead-operand-tracking mechanism. For instance, suppose neither loading</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">    // from %U nor %other traps. Then "load (select undef, %U, %other)" does not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">    // from %U nor %other traps. Then "load (select undef, %U, %other)" does not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">    // trap either.  However, if we simply replace %U with undef using the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">    // trap either.  However, if we simply replace %U with undef using the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">    // current dead-operand-tracking mechanism, "load (select undef, undef,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">    // current dead-operand-tracking mechanism, "load (select undef, undef,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine">    // %other)" may trap because the select may return the first operand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine">    // %other)" may trap because the select may return the first operand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">    // "undef".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">    // "undef".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">    if (Value *Result = foldPHINodeOrSelectInst(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">    if (Value *Result = foldPHINodeOrSelectInst(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">      if (Result == *U)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">      if (Result == *U)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">        // If the result of the constant fold will be the pointer, recurse</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">        // If the result of the constant fold will be the pointer, recurse</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine">        // through the PHI/select as if we had RAUW'ed it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine">        // through the PHI/select as if we had RAUW'ed it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">        enqueueUsers(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">        enqueueUsers(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">        // Otherwise the operand to the PHI/select is dead, and we can replace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">        // Otherwise the operand to the PHI/select is dead, and we can replace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">        // it with poison.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">        // it with poison.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">        AS.DeadOperands.push_back(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">        AS.DeadOperands.push_back(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine">    if (!IsOffsetKnown)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">      return PI.setAborted(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">      return PI.setAborted(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">    // See if we already have computed info on this node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">    // See if we already have computed info on this node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine">    uint64_t &Size = PHIOrSelectSizes[&I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine">    uint64_t &Size = PHIOrSelectSizes[&I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">    if (!Size) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">    if (!Size) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">      // This is a new PHI/Select, check for an unsafe use of it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">      // This is a new PHI/Select, check for an unsafe use of it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">      if (Instruction *UnsafeI = hasUnsafePHIOrSelectUse(&I, Size))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">      if (Instruction *UnsafeI = hasUnsafePHIOrSelectUse(&I, Size))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine">        return PI.setAborted(UnsafeI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine">        return PI.setAborted(UnsafeI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine">    // For PHI and select operands outside the alloca, we can't nuke the entire</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine">    // For PHI and select operands outside the alloca, we can't nuke the entire</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">    // phi or select -- the other side might still be relevant, so we special</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">    // phi or select -- the other side might still be relevant, so we special</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">    // case them here and use a separate structure to track the operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">    // case them here and use a separate structure to track the operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine">    // themselves which should be replaced with poison.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine">    // themselves which should be replaced with poison.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">    // FIXME: This should instead be escaped in the event we're instrumenting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">    // FIXME: This should instead be escaped in the event we're instrumenting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">    // for address sanitization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">    // for address sanitization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">    if (Offset.uge(AllocSize)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">    if (Offset.uge(AllocSize)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">      AS.DeadOperands.push_back(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">      AS.DeadOperands.push_back(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine">      return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">    insertUse(I, Offset, Size);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">    insertUse(I, Offset, Size);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine">  void visitPHINode(PHINode &PN) { visitPHINodeOrSelectInst(PN); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine">  void visitPHINode(PHINode &PN) { visitPHINodeOrSelectInst(PN); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">  void visitSelectInst(SelectInst &SI) { visitPHINodeOrSelectInst(SI); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">  void visitSelectInst(SelectInst &SI) { visitPHINodeOrSelectInst(SI); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine">  /// Disable SROA entirely if there are unhandled users of the alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine">  /// Disable SROA entirely if there are unhandled users of the alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">  void visitInstruction(Instruction &I) { PI.setAborted(&I); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">  void visitInstruction(Instruction &I) { PI.setAborted(&I); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine">AllocaSlices::AllocaSlices(const DataLayout &DL, AllocaInst &AI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine">AllocaSlices::AllocaSlices(const DataLayout &DL, AllocaInst &AI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">    :</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">    :</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">      AI(AI),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">      AI(AI),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">      PointerEscapingInstr(nullptr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">      PointerEscapingInstr(nullptr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">  SliceBuilder PB(DL, AI, *this);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">  SliceBuilder PB(DL, AI, *this);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">  SliceBuilder::PtrInfo PtrI = PB.visitPtr(AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">  SliceBuilder::PtrInfo PtrI = PB.visitPtr(AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">  if (PtrI.isEscaped() || PtrI.isAborted()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">  if (PtrI.isEscaped() || PtrI.isAborted()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine">    // FIXME: We should sink the escape vs. abort info into the caller nicely,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine">    // FIXME: We should sink the escape vs. abort info into the caller nicely,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">    // possibly by just storing the PtrInfo in the AllocaSlices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">    // possibly by just storing the PtrInfo in the AllocaSlices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">    PointerEscapingInstr = PtrI.getEscapingInst() ? PtrI.getEscapingInst()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">    PointerEscapingInstr = PtrI.getEscapingInst() ? PtrI.getEscapingInst()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">                                                  : PtrI.getAbortingInst();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">                                                  : PtrI.getAbortingInst();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">    assert(PointerEscapingInstr && "Did not track a bad instruction");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">    assert(PointerEscapingInstr && "Did not track a bad instruction");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">  llvm::erase_if(Slices, [](const Slice &S) { return S.isDead(); });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">  llvm::erase_if(Slices, [](const Slice &S) { return S.isDead(); });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine">  // Sort the uses. This arranges for the offsets to be in ascending order,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine">  // Sort the uses. This arranges for the offsets to be in ascending order,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">  // and the sizes to be in descending order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">  // and the sizes to be in descending order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">  llvm::stable_sort(Slices);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">  llvm::stable_sort(Slices);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine">#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">void AllocaSlices::print(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">void AllocaSlices::print(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine">                         StringRef Indent) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine">                         StringRef Indent) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">  printSlice(OS, I, Indent);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">  printSlice(OS, I, Indent);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">  OS << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">  OS << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">  printUse(OS, I, Indent);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">  printUse(OS, I, Indent);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">void AllocaSlices::printSlice(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">void AllocaSlices::printSlice(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">                              StringRef Indent) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">                              StringRef Indent) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine">  OS << Indent << "[" << I->beginOffset() << "," << I->endOffset() << ")"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine">  OS << Indent << "[" << I->beginOffset() << "," << I->endOffset() << ")"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">     << " slice #" << (I - begin())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">     << " slice #" << (I - begin())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">     << (I->isSplittable() ? " (splittable)" : "");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">     << (I->isSplittable() ? " (splittable)" : "");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">void AllocaSlices::printUse(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">void AllocaSlices::printUse(raw_ostream &OS, const_iterator I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">                            StringRef Indent) const {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">                            StringRef Indent) const {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">  OS << Indent << "  used by: " << *I->getUse()->getUser() << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">  OS << Indent << "  used by: " << *I->getUse()->getUser() << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">void AllocaSlices::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">void AllocaSlices::print(raw_ostream &OS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">  if (PointerEscapingInstr) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">  if (PointerEscapingInstr) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">    OS << "Can't analyze slices for alloca: " << AI << "\n"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">    OS << "Can't analyze slices for alloca: " << AI << "\n"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">       << "  A pointer to this alloca escaped by:\n"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">       << "  A pointer to this alloca escaped by:\n"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">       << "  " << *PointerEscapingInstr << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">       << "  " << *PointerEscapingInstr << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">  OS << "Slices of alloca: " << AI << "\n";</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">  OS << "Slices of alloca: " << AI << "\n";</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">  for (const_iterator I = begin(), E = end(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">  for (const_iterator I = begin(), E = end(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">    print(OS, I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">    print(OS, I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine">LLVM_DUMP_METHOD void AllocaSlices::dump(const_iterator I) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine">LLVM_DUMP_METHOD void AllocaSlices::dump(const_iterator I) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">  print(dbgs(), I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">  print(dbgs(), I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">LLVM_DUMP_METHOD void AllocaSlices::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">LLVM_DUMP_METHOD void AllocaSlices::dump() const { print(dbgs()); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine">#endif // !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine">#endif // !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">/// Walk the range of a partitioning looking for a common type to cover this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">/// Walk the range of a partitioning looking for a common type to cover this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">/// sequence of slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">/// sequence of slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">static std::pair<Type *, IntegerType *></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">static std::pair<Type *, IntegerType *></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">findCommonType(AllocaSlices::const_iterator B, AllocaSlices::const_iterator E,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">findCommonType(AllocaSlices::const_iterator B, AllocaSlices::const_iterator E,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine">               uint64_t EndOffset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine">               uint64_t EndOffset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">  Type *Ty = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">  Type *Ty = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">  bool TyIsCommon = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">  bool TyIsCommon = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine">  IntegerType *ITy = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine">  IntegerType *ITy = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">  // Note that we need to look at *every* alloca slice's Use to ensure we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">  // Note that we need to look at *every* alloca slice's Use to ensure we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">  // always get consistent results regardless of the order of slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">  // always get consistent results regardless of the order of slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine">  for (AllocaSlices::const_iterator I = B; I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine">  for (AllocaSlices::const_iterator I = B; I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">    Use *U = I->getUse();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">    Use *U = I->getUse();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">    if (isa<IntrinsicInst>(*U->getUser()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">    if (isa<IntrinsicInst>(*U->getUser()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine">    if (I->beginOffset() != B->beginOffset() || I->endOffset() != EndOffset)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine">    if (I->beginOffset() != B->beginOffset() || I->endOffset() != EndOffset)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine">    Type *UserTy = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine">    Type *UserTy = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">    if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">    if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">      UserTy = LI->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">      UserTy = LI->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">    } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">    } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">      UserTy = SI->getValueOperand()->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">      UserTy = SI->getValueOperand()->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">    if (IntegerType *UserITy = dyn_cast_or_null<IntegerType>(UserTy)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">    if (IntegerType *UserITy = dyn_cast_or_null<IntegerType>(UserTy)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine">      // If the type is larger than the partition, skip it. We only encounter</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine">      // If the type is larger than the partition, skip it. We only encounter</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">      // this for split integer operations where we want to use the type of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">      // this for split integer operations where we want to use the type of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">      // entity causing the split. Also skip if the type is not a byte width</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">      // entity causing the split. Also skip if the type is not a byte width</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine">      // multiple.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine">      // multiple.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">      if (UserITy->getBitWidth() % 8 != 0 ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">      if (UserITy->getBitWidth() % 8 != 0 ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">          UserITy->getBitWidth() / 8 > (EndOffset - B->beginOffset()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">          UserITy->getBitWidth() / 8 > (EndOffset - B->beginOffset()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">      // Track the largest bitwidth integer type used in this way in case there</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">      // Track the largest bitwidth integer type used in this way in case there</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine">      // is no common type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine">      // is no common type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">      if (!ITy || ITy->getBitWidth() < UserITy->getBitWidth())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">      if (!ITy || ITy->getBitWidth() < UserITy->getBitWidth())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">        ITy = UserITy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">        ITy = UserITy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">    // To avoid depending on the order of slices, Ty and TyIsCommon must not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">    // To avoid depending on the order of slices, Ty and TyIsCommon must not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine">    // depend on types skipped above.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine">    // depend on types skipped above.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">    if (!UserTy || (Ty && Ty != UserTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">    if (!UserTy || (Ty && Ty != UserTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">      TyIsCommon = false; // Give up on anything but an iN type.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">      TyIsCommon = false; // Give up on anything but an iN type.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">      Ty = UserTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">      Ty = UserTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine">  return {TyIsCommon ? Ty : nullptr, ITy};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine">  return {TyIsCommon ? Ty : nullptr, ITy};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">/// PHI instructions that use an alloca and are subsequently loaded can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">/// PHI instructions that use an alloca and are subsequently loaded can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine">/// rewritten to load both input pointers in the pred blocks and then PHI the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine">/// rewritten to load both input pointers in the pred blocks and then PHI the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">/// results, allowing the load of the alloca to be promoted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">/// results, allowing the load of the alloca to be promoted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">/// From this:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">/// From this:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">///   %P2 = phi [i32* %Alloca, i32* %Other]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">///   %P2 = phi [i32* %Alloca, i32* %Other]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine">///   %V = load i32* %P2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine">///   %V = load i32* %P2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">/// to:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">/// to:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">///   %V1 = load i32* %Alloca      -> will be mem2reg'd</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">///   %V1 = load i32* %Alloca      -> will be mem2reg'd</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine">///   ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine">///   ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">///   %V2 = load i32* %Other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">///   %V2 = load i32* %Other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">///   ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">///   ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">///   %V = phi [i32 %V1, i32 %V2]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">///   %V = phi [i32 %V1, i32 %V2]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine">/// We can do this to a select if its only uses are loads and if the operands</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine">/// We can do this to a select if its only uses are loads and if the operands</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">/// to the select can be loaded unconditionally.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">/// to the select can be loaded unconditionally.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine">/// FIXME: This should be hoisted into a generic utility, likely in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine">/// FIXME: This should be hoisted into a generic utility, likely in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">/// Transforms/Util/Local.h</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">/// Transforms/Util/Local.h</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">static bool isSafePHIToSpeculate(PHINode &PN) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">static bool isSafePHIToSpeculate(PHINode &PN) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine">  const DataLayout &DL = PN.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine">  const DataLayout &DL = PN.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">  // For now, we can only do this promotion if the load is in the same block</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">  // For now, we can only do this promotion if the load is in the same block</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine">  // as the PHI, and if there are no stores between the phi and load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine">  // as the PHI, and if there are no stores between the phi and load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">  // TODO: Allow recursive phi users.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">  // TODO: Allow recursive phi users.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">  // TODO: Allow stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">  // TODO: Allow stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine">  BasicBlock *BB = PN.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine">  BasicBlock *BB = PN.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">  Align MaxAlign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">  Align MaxAlign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">  uint64_t APWidth = DL.getIndexTypeSizeInBits(PN.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">  uint64_t APWidth = DL.getIndexTypeSizeInBits(PN.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">  Type *LoadType = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">  Type *LoadType = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine">  for (User *U : PN.users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine">  for (User *U : PN.users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">    LoadInst *LI = dyn_cast<LoadInst>(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">    LoadInst *LI = dyn_cast<LoadInst>(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">    if (!LI || !LI->isSimple())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">    if (!LI || !LI->isSimple())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">    // For now we only allow loads in the same block as the PHI.  This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">    // For now we only allow loads in the same block as the PHI.  This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">    // a common case that happens when instcombine merges two loads through</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">    // a common case that happens when instcombine merges two loads through</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine">    // a PHI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine">    // a PHI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">    if (LI->getParent() != BB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">    if (LI->getParent() != BB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">    if (LoadType) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">    if (LoadType) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">      if (LoadType != LI->getType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">      if (LoadType != LI->getType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">      LoadType = LI->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">      LoadType = LI->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">    // Ensure that there are no instructions between the PHI and the load that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">    // Ensure that there are no instructions between the PHI and the load that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">    // could store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">    // could store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">    for (BasicBlock::iterator BBI(PN); &*BBI != LI; ++BBI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">    for (BasicBlock::iterator BBI(PN); &*BBI != LI; ++BBI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">      if (BBI->mayWriteToMemory())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">      if (BBI->mayWriteToMemory())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">    MaxAlign = std::max(MaxAlign, LI->getAlign());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">    MaxAlign = std::max(MaxAlign, LI->getAlign());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">  if (!LoadType)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">  if (!LoadType)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine">  APInt LoadSize =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine">  APInt LoadSize =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">      APInt(APWidth, DL.getTypeStoreSize(LoadType).getFixedValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">      APInt(APWidth, DL.getTypeStoreSize(LoadType).getFixedValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">  // We can only transform this if it is safe to push the loads into the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">  // We can only transform this if it is safe to push the loads into the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">  // predecessor blocks. The only thing to watch out for is that we can't put</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">  // predecessor blocks. The only thing to watch out for is that we can't put</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine">  // a possibly trapping load in the predecessor if it is a critical edge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine">  // a possibly trapping load in the predecessor if it is a critical edge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">  for (unsigned Idx = 0, Num = PN.getNumIncomingValues(); Idx != Num; ++Idx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">  for (unsigned Idx = 0, Num = PN.getNumIncomingValues(); Idx != Num; ++Idx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">    Instruction *TI = PN.getIncomingBlock(Idx)->getTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">    Instruction *TI = PN.getIncomingBlock(Idx)->getTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">    Value *InVal = PN.getIncomingValue(Idx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">    Value *InVal = PN.getIncomingValue(Idx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">    // If the value is produced by the terminator of the predecessor (an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">    // If the value is produced by the terminator of the predecessor (an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine">    // invoke) or it has side-effects, there is no valid place to put a load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine">    // invoke) or it has side-effects, there is no valid place to put a load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">    // in the predecessor.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">    // in the predecessor.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">    if (TI == InVal || TI->mayHaveSideEffects())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">    if (TI == InVal || TI->mayHaveSideEffects())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">    // If the predecessor has a single successor, then the edge isn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">    // If the predecessor has a single successor, then the edge isn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">    // critical.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">    // critical.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">    if (TI->getNumSuccessors() == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">    if (TI->getNumSuccessors() == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">    // If this pointer is always safe to load, or if we can prove that there</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">    // If this pointer is always safe to load, or if we can prove that there</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">    // is already a load in the block, then we can move the load to the pred</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">    // is already a load in the block, then we can move the load to the pred</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">    // block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">    // block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine">    if (isSafeToLoadUnconditionally(InVal, MaxAlign, LoadSize, DL, TI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine">    if (isSafeToLoadUnconditionally(InVal, MaxAlign, LoadSize, DL, TI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">static void speculatePHINodeLoads(IRBuilderTy &IRB, PHINode &PN) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">static void speculatePHINodeLoads(IRBuilderTy &IRB, PHINode &PN) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    original: " << PN << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    original: " << PN << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">  LoadInst *SomeLoad = cast<LoadInst>(PN.user_back());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">  LoadInst *SomeLoad = cast<LoadInst>(PN.user_back());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">  Type *LoadTy = SomeLoad->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">  Type *LoadTy = SomeLoad->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">  IRB.SetInsertPoint(&PN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">  IRB.SetInsertPoint(&PN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine">  PHINode *NewPN = IRB.CreatePHI(LoadTy, PN.getNumIncomingValues(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine">  PHINode *NewPN = IRB.CreatePHI(LoadTy, PN.getNumIncomingValues(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">                                 PN.getName() + ".sroa.speculated");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">                                 PN.getName() + ".sroa.speculated");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">  // Get the AA tags and alignment to use from one of the loads. It does not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">  // Get the AA tags and alignment to use from one of the loads. It does not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">  // matter which one we get and if any differ.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">  // matter which one we get and if any differ.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">  AAMDNodes AATags = SomeLoad->getAAMetadata();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">  AAMDNodes AATags = SomeLoad->getAAMetadata();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine">  Align Alignment = SomeLoad->getAlign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine">  Align Alignment = SomeLoad->getAlign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">  // Rewrite all loads of the PN to use the new PHI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">  // Rewrite all loads of the PN to use the new PHI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">  while (!PN.use_empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">  while (!PN.use_empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">    LoadInst *LI = cast<LoadInst>(PN.user_back());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">    LoadInst *LI = cast<LoadInst>(PN.user_back());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">    LI->replaceAllUsesWith(NewPN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">    LI->replaceAllUsesWith(NewPN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">    LI->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">    LI->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">  // Inject loads into all of the pred blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">  // Inject loads into all of the pred blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine">  DenseMap<BasicBlock*, Value*> InjectedLoads;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine">  DenseMap<BasicBlock*, Value*> InjectedLoads;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">  for (unsigned Idx = 0, Num = PN.getNumIncomingValues(); Idx != Num; ++Idx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">  for (unsigned Idx = 0, Num = PN.getNumIncomingValues(); Idx != Num; ++Idx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">    BasicBlock *Pred = PN.getIncomingBlock(Idx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">    BasicBlock *Pred = PN.getIncomingBlock(Idx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">    Value *InVal = PN.getIncomingValue(Idx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">    Value *InVal = PN.getIncomingValue(Idx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">    // A PHI node is allowed to have multiple (duplicated) entries for the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">    // A PHI node is allowed to have multiple (duplicated) entries for the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">    // basic block, as long as the value is the same. So if we already injected</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">    // basic block, as long as the value is the same. So if we already injected</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">    // a load in the predecessor, then we should reuse the same load for all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">    // a load in the predecessor, then we should reuse the same load for all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">    // duplicated entries.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">    // duplicated entries.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">    if (Value* V = InjectedLoads.lookup(Pred)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">    if (Value* V = InjectedLoads.lookup(Pred)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">      NewPN->addIncoming(V, Pred);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">      NewPN->addIncoming(V, Pred);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">    Instruction *TI = Pred->getTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">    Instruction *TI = Pred->getTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">    IRB.SetInsertPoint(TI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">    IRB.SetInsertPoint(TI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">    LoadInst *Load = IRB.CreateAlignedLoad(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">    LoadInst *Load = IRB.CreateAlignedLoad(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">        LoadTy, InVal, Alignment,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">        LoadTy, InVal, Alignment,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">        (PN.getName() + ".sroa.speculate.load." + Pred->getName()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">        (PN.getName() + ".sroa.speculate.load." + Pred->getName()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">    ++NumLoadsSpeculated;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">    ++NumLoadsSpeculated;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine">    if (AATags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine">    if (AATags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">      Load->setAAMetadata(AATags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">      Load->setAAMetadata(AATags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">    NewPN->addIncoming(Load, Pred);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">    NewPN->addIncoming(Load, Pred);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">    InjectedLoads[Pred] = Load;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">    InjectedLoads[Pred] = Load;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "          speculated to: " << *NewPN << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "          speculated to: " << *NewPN << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine">  PN.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine">  PN.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine">sroa::SelectHandSpeculativity &</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine">sroa::SelectHandSpeculativity &</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">sroa::SelectHandSpeculativity::setAsSpeculatable(bool isTrueVal) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">sroa::SelectHandSpeculativity::setAsSpeculatable(bool isTrueVal) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">  if (isTrueVal)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">  if (isTrueVal)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">    Bitfield::set<sroa::SelectHandSpeculativity::TrueVal>(Storage, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">    Bitfield::set<sroa::SelectHandSpeculativity::TrueVal>(Storage, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">    Bitfield::set<sroa::SelectHandSpeculativity::FalseVal>(Storage, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">    Bitfield::set<sroa::SelectHandSpeculativity::FalseVal>(Storage, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">  return *this;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">bool sroa::SelectHandSpeculativity::isSpeculatable(bool isTrueVal) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">bool sroa::SelectHandSpeculativity::isSpeculatable(bool isTrueVal) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">  return isTrueVal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">  return isTrueVal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine">             ? Bitfield::get<sroa::SelectHandSpeculativity::TrueVal>(Storage)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine">             ? Bitfield::get<sroa::SelectHandSpeculativity::TrueVal>(Storage)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">             : Bitfield::get<sroa::SelectHandSpeculativity::FalseVal>(Storage);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">             : Bitfield::get<sroa::SelectHandSpeculativity::FalseVal>(Storage);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">bool sroa::SelectHandSpeculativity::areAllSpeculatable() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">bool sroa::SelectHandSpeculativity::areAllSpeculatable() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine">  return isSpeculatable(/*isTrueVal=*/true) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine">  return isSpeculatable(/*isTrueVal=*/true) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">         isSpeculatable(/*isTrueVal=*/false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">         isSpeculatable(/*isTrueVal=*/false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine">bool sroa::SelectHandSpeculativity::areAnySpeculatable() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine">bool sroa::SelectHandSpeculativity::areAnySpeculatable() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">  return isSpeculatable(/*isTrueVal=*/true) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">  return isSpeculatable(/*isTrueVal=*/true) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">         isSpeculatable(/*isTrueVal=*/false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">         isSpeculatable(/*isTrueVal=*/false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine">bool sroa::SelectHandSpeculativity::areNoneSpeculatable() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine">bool sroa::SelectHandSpeculativity::areNoneSpeculatable() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">  return !areAnySpeculatable();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">  return !areAnySpeculatable();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine">static sroa::SelectHandSpeculativity</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine">static sroa::SelectHandSpeculativity</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">isSafeLoadOfSelectToSpeculate(LoadInst &LI, SelectInst &SI, bool PreserveCFG) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">isSafeLoadOfSelectToSpeculate(LoadInst &LI, SelectInst &SI, bool PreserveCFG) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">  assert(LI.isSimple() && "Only for simple loads");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">  assert(LI.isSimple() && "Only for simple loads");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">  sroa::SelectHandSpeculativity Spec;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">  sroa::SelectHandSpeculativity Spec;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">  const DataLayout &DL = SI.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">  const DataLayout &DL = SI.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine">  for (Value *Value : {SI.getTrueValue(), SI.getFalseValue()})</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine">  for (Value *Value : {SI.getTrueValue(), SI.getFalseValue()})</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">    if (isSafeToLoadUnconditionally(Value, LI.getType(), LI.getAlign(), DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">    if (isSafeToLoadUnconditionally(Value, LI.getType(), LI.getAlign(), DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">                                    &LI))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">                                    &LI))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">      Spec.setAsSpeculatable(/*isTrueVal=*/Value == SI.getTrueValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">      Spec.setAsSpeculatable(/*isTrueVal=*/Value == SI.getTrueValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">    else if (PreserveCFG)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">    else if (PreserveCFG)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">      return Spec;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">      return Spec;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">  return Spec;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">  return Spec;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">std::optional<sroa::RewriteableMemOps></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">std::optional<sroa::RewriteableMemOps></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine">SROAPass::isSafeSelectToSpeculate(SelectInst &SI, bool PreserveCFG) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine">SROAPass::isSafeSelectToSpeculate(SelectInst &SI, bool PreserveCFG) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">  RewriteableMemOps Ops;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">  RewriteableMemOps Ops;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">  for (User *U : SI.users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">  for (User *U : SI.users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">    if (auto *BC = dyn_cast<BitCastInst>(U); BC && BC->hasOneUse())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">    if (auto *BC = dyn_cast<BitCastInst>(U); BC && BC->hasOneUse())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine">      U = *BC->user_begin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine">      U = *BC->user_begin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">    if (auto *Store = dyn_cast<StoreInst>(U)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">    if (auto *Store = dyn_cast<StoreInst>(U)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">      // Note that atomic stores can be transformed; atomic semantics do not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">      // Note that atomic stores can be transformed; atomic semantics do not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">      // have any meaning for a local alloca. Stores are not speculatable,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">      // have any meaning for a local alloca. Stores are not speculatable,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">      // however, so if we can't turn it into a predicated store, we are done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">      // however, so if we can't turn it into a predicated store, we are done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">      if (Store->isVolatile() || PreserveCFG)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">      if (Store->isVolatile() || PreserveCFG)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">        return {}; // Give up on this `select`.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">        return {}; // Give up on this `select`.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine">      Ops.emplace_back(Store);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine">      Ops.emplace_back(Store);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">    auto *LI = dyn_cast<LoadInst>(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">    auto *LI = dyn_cast<LoadInst>(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">    // Note that atomic loads can be transformed;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">    // Note that atomic loads can be transformed;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">    // atomic semantics do not have any meaning for a local alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">    // atomic semantics do not have any meaning for a local alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine">    if (!LI || LI->isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine">    if (!LI || LI->isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">      return {}; // Give up on this `select`.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">      return {}; // Give up on this `select`.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine">    PossiblySpeculatableLoad Load(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine">    PossiblySpeculatableLoad Load(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">    if (!LI->isSimple()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">    if (!LI->isSimple()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">      // If the `load` is not simple, we can't speculatively execute it,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">      // If the `load` is not simple, we can't speculatively execute it,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">      // but we could handle this via a CFG modification. But can we?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">      // but we could handle this via a CFG modification. But can we?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine">      if (PreserveCFG)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine">      if (PreserveCFG)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">        return {}; // Give up on this `select`.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">        return {}; // Give up on this `select`.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">      Ops.emplace_back(Load);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">      Ops.emplace_back(Load);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">    sroa::SelectHandSpeculativity Spec =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">    sroa::SelectHandSpeculativity Spec =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">        isSafeLoadOfSelectToSpeculate(*LI, SI, PreserveCFG);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">        isSafeLoadOfSelectToSpeculate(*LI, SI, PreserveCFG);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">    if (PreserveCFG && !Spec.areAllSpeculatable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">    if (PreserveCFG && !Spec.areAllSpeculatable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine">      return {}; // Give up on this `select`.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine">      return {}; // Give up on this `select`.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">    Load.setInt(Spec);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">    Load.setInt(Spec);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine">    Ops.emplace_back(Load);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine">    Ops.emplace_back(Load);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine">  return Ops;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine">  return Ops;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine">static void speculateSelectInstLoads(SelectInst &SI, LoadInst &LI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine">static void speculateSelectInstLoads(SelectInst &SI, LoadInst &LI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">                                     IRBuilderTy &IRB) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">                                     IRBuilderTy &IRB) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    original load: " << SI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    original load: " << SI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">  Value *TV = SI.getTrueValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">  Value *TV = SI.getTrueValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">  Value *FV = SI.getFalseValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">  Value *FV = SI.getFalseValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine">  // Replace the given load of the select with a select of two loads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine">  // Replace the given load of the select with a select of two loads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">  assert(LI.isSimple() && "We only speculate simple loads");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">  assert(LI.isSimple() && "We only speculate simple loads");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">  IRB.SetInsertPoint(&LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">  IRB.SetInsertPoint(&LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine">  LoadInst *TL =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine">  LoadInst *TL =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">      IRB.CreateAlignedLoad(LI.getType(), TV, LI.getAlign(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">      IRB.CreateAlignedLoad(LI.getType(), TV, LI.getAlign(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">                            LI.getName() + ".sroa.speculate.load.true");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">                            LI.getName() + ".sroa.speculate.load.true");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">  LoadInst *FL =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">  LoadInst *FL =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">      IRB.CreateAlignedLoad(LI.getType(), FV, LI.getAlign(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">      IRB.CreateAlignedLoad(LI.getType(), FV, LI.getAlign(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">                            LI.getName() + ".sroa.speculate.load.false");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">                            LI.getName() + ".sroa.speculate.load.false");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine">  NumLoadsSpeculated += 2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine">  NumLoadsSpeculated += 2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">  // Transfer alignment and AA info if present.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">  // Transfer alignment and AA info if present.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">  TL->setAlignment(LI.getAlign());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">  TL->setAlignment(LI.getAlign());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">  FL->setAlignment(LI.getAlign());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">  FL->setAlignment(LI.getAlign());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine">  AAMDNodes Tags = LI.getAAMetadata();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine">  AAMDNodes Tags = LI.getAAMetadata();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">  if (Tags) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">  if (Tags) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">    TL->setAAMetadata(Tags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">    TL->setAAMetadata(Tags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">    FL->setAAMetadata(Tags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">    FL->setAAMetadata(Tags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">  Value *V = IRB.CreateSelect(SI.getCondition(), TL, FL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">  Value *V = IRB.CreateSelect(SI.getCondition(), TL, FL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">                              LI.getName() + ".sroa.speculated");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">                              LI.getName() + ".sroa.speculated");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "          speculated to: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "          speculated to: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">  LI.replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">  LI.replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">template <typename T></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">static void rewriteMemOpOfSelect(SelectInst &SI, T &I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">static void rewriteMemOpOfSelect(SelectInst &SI, T &I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">                                 sroa::SelectHandSpeculativity Spec,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">                                 sroa::SelectHandSpeculativity Spec,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine">                                 DomTreeUpdater &DTU) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine">                                 DomTreeUpdater &DTU) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">  assert((isa<LoadInst>(I) || isa<StoreInst>(I)) && "Only for load and store!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">  assert((isa<LoadInst>(I) || isa<StoreInst>(I)) && "Only for load and store!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    original mem op: " << I << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    original mem op: " << I << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">  BasicBlock *Head = I.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">  BasicBlock *Head = I.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">  Instruction *ThenTerm = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">  Instruction *ThenTerm = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">  Instruction *ElseTerm = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">  Instruction *ElseTerm = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine">  if (Spec.areNoneSpeculatable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine">  if (Spec.areNoneSpeculatable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">    SplitBlockAndInsertIfThenElse(SI.getCondition(), &I, &ThenTerm, &ElseTerm,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">    SplitBlockAndInsertIfThenElse(SI.getCondition(), &I, &ThenTerm, &ElseTerm,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">                                  SI.getMetadata(LLVMContext::MD_prof), &DTU);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">                                  SI.getMetadata(LLVMContext::MD_prof), &DTU);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">    SplitBlockAndInsertIfThen(SI.getCondition(), &I, /*Unreachable=*/false,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">    SplitBlockAndInsertIfThen(SI.getCondition(), &I, /*Unreachable=*/false,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">                              SI.getMetadata(LLVMContext::MD_prof), &DTU,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">                              SI.getMetadata(LLVMContext::MD_prof), &DTU,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine">                              /*LI=*/nullptr, /*ThenBlock=*/nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine">                              /*LI=*/nullptr, /*ThenBlock=*/nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">    if (Spec.isSpeculatable(/*isTrueVal=*/true))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">    if (Spec.isSpeculatable(/*isTrueVal=*/true))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">      cast<BranchInst>(Head->getTerminator())->swapSuccessors();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">      cast<BranchInst>(Head->getTerminator())->swapSuccessors();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine">  auto *HeadBI = cast<BranchInst>(Head->getTerminator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine">  auto *HeadBI = cast<BranchInst>(Head->getTerminator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">  Spec = {}; // Do not use `Spec` beyond this point.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">  Spec = {}; // Do not use `Spec` beyond this point.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">  BasicBlock *Tail = I.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">  BasicBlock *Tail = I.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine">  Tail->setName(Head->getName() + ".cont");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine">  Tail->setName(Head->getName() + ".cont");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">  PHINode *PN;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">  PHINode *PN;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">  if (isa<LoadInst>(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">  if (isa<LoadInst>(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">    PN = PHINode::Create(I.getType(), 2, "", &I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">    PN = PHINode::Create(I.getType(), 2, "", &I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">  for (BasicBlock *SuccBB : successors(Head)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">  for (BasicBlock *SuccBB : successors(Head)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine">    bool IsThen = SuccBB == HeadBI->getSuccessor(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine">    bool IsThen = SuccBB == HeadBI->getSuccessor(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">    int SuccIdx = IsThen ? 0 : 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">    int SuccIdx = IsThen ? 0 : 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">    auto *NewMemOpBB = SuccBB == Tail ? Head : SuccBB;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">    auto *NewMemOpBB = SuccBB == Tail ? Head : SuccBB;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine">    auto &CondMemOp = cast<T>(*I.clone());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine">    auto &CondMemOp = cast<T>(*I.clone());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">    if (NewMemOpBB != Head) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">    if (NewMemOpBB != Head) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">      NewMemOpBB->setName(Head->getName() + (IsThen ? ".then" : ".else"));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">      NewMemOpBB->setName(Head->getName() + (IsThen ? ".then" : ".else"));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine">      if (isa<LoadInst>(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine">      if (isa<LoadInst>(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">        ++NumLoadsPredicated;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">        ++NumLoadsPredicated;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">        ++NumStoresPredicated;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">        ++NumStoresPredicated;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">      CondMemOp.dropUBImplyingAttrsAndMetadata();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">      CondMemOp.dropUBImplyingAttrsAndMetadata();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">      ++NumLoadsSpeculated;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">      ++NumLoadsSpeculated;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">    CondMemOp.insertBefore(NewMemOpBB->getTerminator());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">    CondMemOp.insertBefore(NewMemOpBB->getTerminator());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">    Value *Ptr = SI.getOperand(1 + SuccIdx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">    Value *Ptr = SI.getOperand(1 + SuccIdx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">    CondMemOp.setOperand(I.getPointerOperandIndex(), Ptr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">    CondMemOp.setOperand(I.getPointerOperandIndex(), Ptr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">    if (isa<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">    if (isa<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">      CondMemOp.setName(I.getName() + (IsThen ? ".then" : ".else") + ".val");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">      CondMemOp.setName(I.getName() + (IsThen ? ".then" : ".else") + ".val");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">      PN->addIncoming(&CondMemOp, NewMemOpBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">      PN->addIncoming(&CondMemOp, NewMemOpBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">    } else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "                 to: " << CondMemOp << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "                 to: " << CondMemOp << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">  if (isa<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">  if (isa<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">    PN->takeName(&I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">    PN->takeName(&I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *PN << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *PN << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine">    I.replaceAllUsesWith(PN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine">    I.replaceAllUsesWith(PN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">static void rewriteMemOpOfSelect(SelectInst &SelInst, Instruction &I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">static void rewriteMemOpOfSelect(SelectInst &SelInst, Instruction &I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">                                 sroa::SelectHandSpeculativity Spec,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">                                 sroa::SelectHandSpeculativity Spec,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">                                 DomTreeUpdater &DTU) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">                                 DomTreeUpdater &DTU) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine">  if (auto *LI = dyn_cast<LoadInst>(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine">  if (auto *LI = dyn_cast<LoadInst>(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">    rewriteMemOpOfSelect(SelInst, *LI, Spec, DTU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">    rewriteMemOpOfSelect(SelInst, *LI, Spec, DTU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">  else if (auto *SI = dyn_cast<StoreInst>(&I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">  else if (auto *SI = dyn_cast<StoreInst>(&I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine">    rewriteMemOpOfSelect(SelInst, *SI, Spec, DTU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine">    rewriteMemOpOfSelect(SelInst, *SI, Spec, DTU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">    llvm_unreachable_internal("Only for load and store.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">    llvm_unreachable_internal("Only for load and store.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">static bool rewriteSelectInstMemOps(SelectInst &SI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">static bool rewriteSelectInstMemOps(SelectInst &SI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">                                    const sroa::RewriteableMemOps &Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">                                    const sroa::RewriteableMemOps &Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">                                    IRBuilderTy &IRB, DomTreeUpdater *DTU) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">                                    IRBuilderTy &IRB, DomTreeUpdater *DTU) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">  bool CFGChanged = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">  bool CFGChanged = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    original select: " << SI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    original select: " << SI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">  for (const RewriteableMemOp &Op : Ops) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">  for (const RewriteableMemOp &Op : Ops) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">    sroa::SelectHandSpeculativity Spec;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">    sroa::SelectHandSpeculativity Spec;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine">    Instruction *I;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine">    Instruction *I;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">    if (auto *const *US = std::get_if<UnspeculatableStore>(&Op)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">    if (auto *const *US = std::get_if<UnspeculatableStore>(&Op)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">      I = *US;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">      I = *US;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">      auto PSL = std::get<PossiblySpeculatableLoad>(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">      auto PSL = std::get<PossiblySpeculatableLoad>(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">      I = PSL.getPointer();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">      I = PSL.getPointer();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine">      Spec = PSL.getInt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine">      Spec = PSL.getInt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">    if (Spec.areAllSpeculatable()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">    if (Spec.areAllSpeculatable()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">      speculateSelectInstLoads(SI, cast<LoadInst>(*I), IRB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">      speculateSelectInstLoads(SI, cast<LoadInst>(*I), IRB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">      assert(DTU && "Should not get here when not allowed to modify the CFG!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">      assert(DTU && "Should not get here when not allowed to modify the CFG!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">      rewriteMemOpOfSelect(SI, *I, Spec, *DTU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">      rewriteMemOpOfSelect(SI, *I, Spec, *DTU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine">      CFGChanged = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine">      CFGChanged = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">    I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">    I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine">  for (User *U : make_early_inc_range(SI.users()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine">  for (User *U : make_early_inc_range(SI.users()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">    cast<BitCastInst>(U)->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">    cast<BitCastInst>(U)->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">  SI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">  SI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine">  return CFGChanged;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine">  return CFGChanged;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">/// Compute an adjusted pointer from Ptr by Offset bytes where the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">/// Compute an adjusted pointer from Ptr by Offset bytes where the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">/// resulting pointer has PointerTy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">/// resulting pointer has PointerTy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">static Value *getAdjustedPtr(IRBuilderTy &IRB, const DataLayout &DL, Value *Ptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">static Value *getAdjustedPtr(IRBuilderTy &IRB, const DataLayout &DL, Value *Ptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">                             APInt Offset, Type *PointerTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">                             APInt Offset, Type *PointerTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">                             const Twine &NamePrefix) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">                             const Twine &NamePrefix) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine">  if (Offset != 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine">  if (Offset != 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">    Ptr = IRB.CreateInBoundsGEP(IRB.getInt8Ty(), Ptr, IRB.getInt(Offset),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">    Ptr = IRB.CreateInBoundsGEP(IRB.getInt8Ty(), Ptr, IRB.getInt(Offset),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">                                NamePrefix + "sroa_idx");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">                                NamePrefix + "sroa_idx");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">  return IRB.CreatePointerBitCastOrAddrSpaceCast(Ptr, PointerTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">  return IRB.CreatePointerBitCastOrAddrSpaceCast(Ptr, PointerTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine">                                                 NamePrefix + "sroa_cast");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine">                                                 NamePrefix + "sroa_cast");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">/// Compute the adjusted alignment for a load or store from an offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">/// Compute the adjusted alignment for a load or store from an offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine">static Align getAdjustedAlignment(Instruction *I, uint64_t Offset) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine">static Align getAdjustedAlignment(Instruction *I, uint64_t Offset) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">  return commonAlignment(getLoadStoreAlignment(I), Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">  return commonAlignment(getLoadStoreAlignment(I), Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine">/// Test whether we can convert a value from the old to the new type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine">/// Test whether we can convert a value from the old to the new type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">/// This predicate should be used to guard calls to convertValue in order to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">/// This predicate should be used to guard calls to convertValue in order to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">/// ensure that we only try to convert viable values. The strategy is that we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">/// ensure that we only try to convert viable values. The strategy is that we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">/// will peel off single element struct and array wrappings to get to an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">/// will peel off single element struct and array wrappings to get to an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine">/// underlying value, and convert that value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine">/// underlying value, and convert that value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">static bool canConvertValue(const DataLayout &DL, Type *OldTy, Type *NewTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">static bool canConvertValue(const DataLayout &DL, Type *OldTy, Type *NewTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine">  if (OldTy == NewTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine">  if (OldTy == NewTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">  // For integer types, we can't handle any bit-width differences. This would</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">  // For integer types, we can't handle any bit-width differences. This would</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">  // break both vector conversions with extension and introduce endianness</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">  // break both vector conversions with extension and introduce endianness</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">  // issues when in conjunction with loads and stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">  // issues when in conjunction with loads and stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">  if (isa<IntegerType>(OldTy) && isa<IntegerType>(NewTy)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">  if (isa<IntegerType>(OldTy) && isa<IntegerType>(NewTy)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">    assert(cast<IntegerType>(OldTy)->getBitWidth() !=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">    assert(cast<IntegerType>(OldTy)->getBitWidth() !=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">               cast<IntegerType>(NewTy)->getBitWidth() &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">               cast<IntegerType>(NewTy)->getBitWidth() &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">           "We can't have the same bitwidth for different int types");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">           "We can't have the same bitwidth for different int types");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine">  if (DL.getTypeSizeInBits(NewTy).getFixedValue() !=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine">  if (DL.getTypeSizeInBits(NewTy).getFixedValue() !=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">      DL.getTypeSizeInBits(OldTy).getFixedValue())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">      DL.getTypeSizeInBits(OldTy).getFixedValue())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">  if (!NewTy->isSingleValueType() || !OldTy->isSingleValueType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">  if (!NewTy->isSingleValueType() || !OldTy->isSingleValueType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">  // We can convert pointers to integers and vice-versa. Same for vectors</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">  // We can convert pointers to integers and vice-versa. Same for vectors</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">  // of pointers and integers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">  // of pointers and integers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">  OldTy = OldTy->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">  OldTy = OldTy->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">  NewTy = NewTy->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">  NewTy = NewTy->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine">  if (NewTy->isPointerTy() || OldTy->isPointerTy()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine">  if (NewTy->isPointerTy() || OldTy->isPointerTy()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">    if (NewTy->isPointerTy() && OldTy->isPointerTy()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">    if (NewTy->isPointerTy() && OldTy->isPointerTy()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">      unsigned OldAS = OldTy->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">      unsigned OldAS = OldTy->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">      unsigned NewAS = NewTy->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">      unsigned NewAS = NewTy->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">      // Convert pointers if they are pointers from the same address space or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">      // Convert pointers if they are pointers from the same address space or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">      // different integral (not non-integral) address spaces with the same</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">      // different integral (not non-integral) address spaces with the same</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">      // pointer size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">      // pointer size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">      return OldAS == NewAS ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">      return OldAS == NewAS ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">             (!DL.isNonIntegralAddressSpace(OldAS) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">             (!DL.isNonIntegralAddressSpace(OldAS) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine">              !DL.isNonIntegralAddressSpace(NewAS) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine">              !DL.isNonIntegralAddressSpace(NewAS) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">              DL.getPointerSize(OldAS) == DL.getPointerSize(NewAS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">              DL.getPointerSize(OldAS) == DL.getPointerSize(NewAS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">    // We can convert integers to integral pointers, but not to non-integral</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">    // We can convert integers to integral pointers, but not to non-integral</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">    // pointers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">    // pointers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">    if (OldTy->isIntegerTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">    if (OldTy->isIntegerTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">      return !DL.isNonIntegralPointerType(NewTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">      return !DL.isNonIntegralPointerType(NewTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">    // We can convert integral pointers to integers, but non-integral pointers</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">    // We can convert integral pointers to integers, but non-integral pointers</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">    // need to remain pointers.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">    // need to remain pointers.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">    if (!DL.isNonIntegralPointerType(OldTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">    if (!DL.isNonIntegralPointerType(OldTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">      return NewTy->isIntegerTy();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">      return NewTy->isIntegerTy();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">  if (OldTy->isTargetExtTy() || NewTy->isTargetExtTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">  if (OldTy->isTargetExtTy() || NewTy->isTargetExtTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">/// Generic routine to convert an SSA value to a value of a different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">/// Generic routine to convert an SSA value to a value of a different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">/// type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">/// type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine">/// This will try various different casting techniques, such as bitcasts,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine">/// This will try various different casting techniques, such as bitcasts,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">/// inttoptr, and ptrtoint casts. Use the \c canConvertValue predicate to test</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">/// inttoptr, and ptrtoint casts. Use the \c canConvertValue predicate to test</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">/// two types for viability with this routine.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">/// two types for viability with this routine.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">static Value *convertValue(const DataLayout &DL, IRBuilderTy &IRB, Value *V,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">static Value *convertValue(const DataLayout &DL, IRBuilderTy &IRB, Value *V,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">                           Type *NewTy) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">                           Type *NewTy) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">  Type *OldTy = V->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">  Type *OldTy = V->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">  assert(canConvertValue(DL, OldTy, NewTy) && "Value not convertable to type");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">  assert(canConvertValue(DL, OldTy, NewTy) && "Value not convertable to type");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">  if (OldTy == NewTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">  if (OldTy == NewTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">  assert(!(isa<IntegerType>(OldTy) && isa<IntegerType>(NewTy)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">  assert(!(isa<IntegerType>(OldTy) && isa<IntegerType>(NewTy)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine">         "Integer types must be the exact same to convert.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine">         "Integer types must be the exact same to convert.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">  // See if we need inttoptr for this type pair. May require additional bitcast.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">  // See if we need inttoptr for this type pair. May require additional bitcast.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">  if (OldTy->isIntOrIntVectorTy() && NewTy->isPtrOrPtrVectorTy()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">  if (OldTy->isIntOrIntVectorTy() && NewTy->isPtrOrPtrVectorTy()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">    // Expand <2 x i32> to i8* --> <2 x i32> to i64 to i8*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">    // Expand <2 x i32> to i8* --> <2 x i32> to i64 to i8*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">    // Expand i128 to <2 x i8*> --> i128 to <2 x i64> to <2 x i8*></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">    // Expand i128 to <2 x i8*> --> i128 to <2 x i64> to <2 x i8*></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">    // Expand <4 x i32> to <2 x i8*> --> <4 x i32> to <2 x i64> to <2 x i8*></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">    // Expand <4 x i32> to <2 x i8*> --> <4 x i32> to <2 x i64> to <2 x i8*></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">    // Directly handle i64 to i8*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">    // Directly handle i64 to i8*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">    return IRB.CreateIntToPtr(IRB.CreateBitCast(V, DL.getIntPtrType(NewTy)),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">    return IRB.CreateIntToPtr(IRB.CreateBitCast(V, DL.getIntPtrType(NewTy)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">                              NewTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">                              NewTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">  // See if we need ptrtoint for this type pair. May require additional bitcast.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">  // See if we need ptrtoint for this type pair. May require additional bitcast.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">  if (OldTy->isPtrOrPtrVectorTy() && NewTy->isIntOrIntVectorTy()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">  if (OldTy->isPtrOrPtrVectorTy() && NewTy->isIntOrIntVectorTy()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">    // Expand <2 x i8*> to i128 --> <2 x i8*> to <2 x i64> to i128</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">    // Expand <2 x i8*> to i128 --> <2 x i8*> to <2 x i64> to i128</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">    // Expand i8* to <2 x i32> --> i8* to i64 to <2 x i32></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">    // Expand i8* to <2 x i32> --> i8* to i64 to <2 x i32></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine">    // Expand <2 x i8*> to <4 x i32> --> <2 x i8*> to <2 x i64> to <4 x i32></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine">    // Expand <2 x i8*> to <4 x i32> --> <2 x i8*> to <2 x i64> to <4 x i32></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">    // Expand i8* to i64 --> i8* to i64 to i64</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">    // Expand i8* to i64 --> i8* to i64 to i64</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">    return IRB.CreateBitCast(IRB.CreatePtrToInt(V, DL.getIntPtrType(OldTy)),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">    return IRB.CreateBitCast(IRB.CreatePtrToInt(V, DL.getIntPtrType(OldTy)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">                             NewTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">                             NewTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">  if (OldTy->isPtrOrPtrVectorTy() && NewTy->isPtrOrPtrVectorTy()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">  if (OldTy->isPtrOrPtrVectorTy() && NewTy->isPtrOrPtrVectorTy()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">    unsigned OldAS = OldTy->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">    unsigned OldAS = OldTy->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">    unsigned NewAS = NewTy->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">    unsigned NewAS = NewTy->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">    // To convert pointers with different address spaces (they are already</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">    // To convert pointers with different address spaces (they are already</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine">    // checked convertible, i.e. they have the same pointer size), so far we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine">    // checked convertible, i.e. they have the same pointer size), so far we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">    // cannot use `bitcast` (which has restrict on the same address space) or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">    // cannot use `bitcast` (which has restrict on the same address space) or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">    // `addrspacecast` (which is not always no-op casting). Instead, use a pair</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">    // `addrspacecast` (which is not always no-op casting). Instead, use a pair</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">    // of no-op `ptrtoint`/`inttoptr` casts through an integer with the same bit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">    // of no-op `ptrtoint`/`inttoptr` casts through an integer with the same bit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">    // size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">    // size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">    if (OldAS != NewAS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">    if (OldAS != NewAS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">      assert(DL.getPointerSize(OldAS) == DL.getPointerSize(NewAS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">      assert(DL.getPointerSize(OldAS) == DL.getPointerSize(NewAS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">      return IRB.CreateIntToPtr(IRB.CreatePtrToInt(V, DL.getIntPtrType(OldTy)),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">      return IRB.CreateIntToPtr(IRB.CreatePtrToInt(V, DL.getIntPtrType(OldTy)),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine">                                NewTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine">                                NewTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">  return IRB.CreateBitCast(V, NewTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">  return IRB.CreateBitCast(V, NewTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">/// Test whether the given slice use can be promoted to a vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">/// Test whether the given slice use can be promoted to a vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">/// This function is called to test each entry in a partition which is slated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">/// This function is called to test each entry in a partition which is slated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine">/// for a single slice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine">/// for a single slice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">static bool isVectorPromotionViableForSlice(Partition &P, const Slice &S,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">static bool isVectorPromotionViableForSlice(Partition &P, const Slice &S,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">                                            VectorType *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">                                            VectorType *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">                                            uint64_t ElementSize,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">                                            uint64_t ElementSize,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">                                            const DataLayout &DL) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">                                            const DataLayout &DL) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">  // First validate the slice offsets.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">  // First validate the slice offsets.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">  uint64_t BeginOffset =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">  uint64_t BeginOffset =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">      std::max(S.beginOffset(), P.beginOffset()) - P.beginOffset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">      std::max(S.beginOffset(), P.beginOffset()) - P.beginOffset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">  uint64_t BeginIndex = BeginOffset / ElementSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">  uint64_t BeginIndex = BeginOffset / ElementSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine">  if (BeginIndex * ElementSize != BeginOffset ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine">  if (BeginIndex * ElementSize != BeginOffset ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">      BeginIndex >= cast<FixedVectorType>(Ty)->getNumElements())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">      BeginIndex >= cast<FixedVectorType>(Ty)->getNumElements())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">  uint64_t EndOffset =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">  uint64_t EndOffset =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">      std::min(S.endOffset(), P.endOffset()) - P.beginOffset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">      std::min(S.endOffset(), P.endOffset()) - P.beginOffset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">  uint64_t EndIndex = EndOffset / ElementSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">  uint64_t EndIndex = EndOffset / ElementSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">  if (EndIndex * ElementSize != EndOffset ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">  if (EndIndex * ElementSize != EndOffset ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">      EndIndex > cast<FixedVectorType>(Ty)->getNumElements())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">      EndIndex > cast<FixedVectorType>(Ty)->getNumElements())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">  assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">  assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">  uint64_t NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">  uint64_t NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">  Type *SliceTy = (NumElements == 1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">  Type *SliceTy = (NumElements == 1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">                      ? Ty->getElementType()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">                      ? Ty->getElementType()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">                      : FixedVectorType::get(Ty->getElementType(), NumElements);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">                      : FixedVectorType::get(Ty->getElementType(), NumElements);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">  Type *SplitIntTy =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">  Type *SplitIntTy =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">      Type::getIntNTy(Ty->getContext(), NumElements * ElementSize * 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">      Type::getIntNTy(Ty->getContext(), NumElements * ElementSize * 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">  Use *U = S.getUse();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">  Use *U = S.getUse();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">  if (MemIntrinsic *MI = dyn_cast<MemIntrinsic>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">  if (MemIntrinsic *MI = dyn_cast<MemIntrinsic>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">    if (MI->isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">    if (MI->isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">    if (!S.isSplittable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">    if (!S.isSplittable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">      return false; // Skip any unsplittable intrinsics.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">      return false; // Skip any unsplittable intrinsics.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">  } else if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">  } else if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">    if (!II->isLifetimeStartOrEnd() && !II->isDroppable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">    if (!II->isLifetimeStartOrEnd() && !II->isDroppable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine">  } else if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine">  } else if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine">    if (LI->isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine">    if (LI->isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">    Type *LTy = LI->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">    Type *LTy = LI->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">    // Disable vector promotion when there are loads or stores of an FCA.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">    // Disable vector promotion when there are loads or stores of an FCA.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">    if (LTy->isStructTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">    if (LTy->isStructTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">    if (P.beginOffset() > S.beginOffset() || P.endOffset() < S.endOffset()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">    if (P.beginOffset() > S.beginOffset() || P.endOffset() < S.endOffset()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">      assert(LTy->isIntegerTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">      assert(LTy->isIntegerTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine">      LTy = SplitIntTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine">      LTy = SplitIntTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">    if (!canConvertValue(DL, SliceTy, LTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">    if (!canConvertValue(DL, SliceTy, LTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">  } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">  } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine">    if (SI->isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine">    if (SI->isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">    Type *STy = SI->getValueOperand()->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">    Type *STy = SI->getValueOperand()->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">    // Disable vector promotion when there are loads or stores of an FCA.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">    // Disable vector promotion when there are loads or stores of an FCA.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">    if (STy->isStructTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">    if (STy->isStructTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">    if (P.beginOffset() > S.beginOffset() || P.endOffset() < S.endOffset()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">    if (P.beginOffset() > S.beginOffset() || P.endOffset() < S.endOffset()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">      assert(STy->isIntegerTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">      assert(STy->isIntegerTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">      STy = SplitIntTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">      STy = SplitIntTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">    if (!canConvertValue(DL, STy, SliceTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">    if (!canConvertValue(DL, STy, SliceTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">/// Test whether a vector type is viable for promotion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">/// Test whether a vector type is viable for promotion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">/// This implements the necessary checking for \c isVectorPromotionViable over</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">/// This implements the necessary checking for \c isVectorPromotionViable over</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">/// all slices of the alloca for the given VectorType.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">/// all slices of the alloca for the given VectorType.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine">static bool checkVectorTypeForPromotion(Partition &P, VectorType *VTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine">static bool checkVectorTypeForPromotion(Partition &P, VectorType *VTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">                                        const DataLayout &DL) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">                                        const DataLayout &DL) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">  uint64_t ElementSize =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">  uint64_t ElementSize =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">      DL.getTypeSizeInBits(VTy->getElementType()).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">      DL.getTypeSizeInBits(VTy->getElementType()).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">  // While the definition of LLVM vectors is bitpacked, we don't support sizes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">  // While the definition of LLVM vectors is bitpacked, we don't support sizes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">  // that aren't byte sized.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">  // that aren't byte sized.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">  if (ElementSize % 8)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">  if (ElementSize % 8)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">  assert((DL.getTypeSizeInBits(VTy).getFixedValue() % 8) == 0 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">  assert((DL.getTypeSizeInBits(VTy).getFixedValue() % 8) == 0 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">         "vector size not a multiple of element size?");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">         "vector size not a multiple of element size?");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">  ElementSize /= 8;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">  ElementSize /= 8;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">  for (const Slice &S : P)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">  for (const Slice &S : P)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">    if (!isVectorPromotionViableForSlice(P, S, VTy, ElementSize, DL))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">    if (!isVectorPromotionViableForSlice(P, S, VTy, ElementSize, DL))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">  for (const Slice *S : P.splitSliceTails())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">  for (const Slice *S : P.splitSliceTails())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">    if (!isVectorPromotionViableForSlice(P, *S, VTy, ElementSize, DL))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">    if (!isVectorPromotionViableForSlice(P, *S, VTy, ElementSize, DL))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">/// Test whether the given alloca partitioning and range of slices can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">/// Test whether the given alloca partitioning and range of slices can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">/// promoted to a vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">/// promoted to a vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine">/// This is a quick test to check whether we can rewrite a particular alloca</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine">/// This is a quick test to check whether we can rewrite a particular alloca</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine">/// partition (and its newly formed alloca) into a vector alloca with only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine">/// partition (and its newly formed alloca) into a vector alloca with only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">/// whole-vector loads and stores such that it could be promoted to a vector</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">/// whole-vector loads and stores such that it could be promoted to a vector</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">/// SSA value. We only can ensure this for a limited set of operations, and we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">/// SSA value. We only can ensure this for a limited set of operations, and we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">/// don't want to do the rewrites unless we are confident that the result will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">/// don't want to do the rewrites unless we are confident that the result will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine">/// be promotable, so we have an early test here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine">/// be promotable, so we have an early test here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">static VectorType *isVectorPromotionViable(Partition &P, const DataLayout &DL) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">static VectorType *isVectorPromotionViable(Partition &P, const DataLayout &DL) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">  // Collect the candidate types for vector-based promotion. Also track whether</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">  // Collect the candidate types for vector-based promotion. Also track whether</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">  // we have different element types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">  // we have different element types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">  SmallVector<VectorType *, 4> CandidateTys;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">  SmallVector<VectorType *, 4> CandidateTys;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">  SetVector<Type *> LoadStoreTys;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">  SetVector<Type *> LoadStoreTys;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">  Type *CommonEltTy = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">  Type *CommonEltTy = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">  VectorType *CommonVecPtrTy = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">  VectorType *CommonVecPtrTy = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine">  bool HaveVecPtrTy = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine">  bool HaveVecPtrTy = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">  bool HaveCommonEltTy = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">  bool HaveCommonEltTy = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">  bool HaveCommonVecPtrTy = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">  bool HaveCommonVecPtrTy = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">  auto CheckCandidateType = [&](Type *Ty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">  auto CheckCandidateType = [&](Type *Ty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">    if (auto *VTy = dyn_cast<VectorType>(Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine">      // Return if bitcast to vectors is different for total size in bits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine">      // Return if bitcast to vectors is different for total size in bits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">      if (!CandidateTys.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">      if (!CandidateTys.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">        VectorType *V = CandidateTys[0];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">        VectorType *V = CandidateTys[0];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">        if (DL.getTypeSizeInBits(VTy).getFixedValue() !=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">        if (DL.getTypeSizeInBits(VTy).getFixedValue() !=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine">            DL.getTypeSizeInBits(V).getFixedValue()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine">            DL.getTypeSizeInBits(V).getFixedValue()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">          CandidateTys.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">          CandidateTys.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">          return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">          return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">      CandidateTys.push_back(VTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">      CandidateTys.push_back(VTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine">      Type *EltTy = VTy->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine">      Type *EltTy = VTy->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine">      if (!CommonEltTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine">      if (!CommonEltTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine">        CommonEltTy = EltTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine">        CommonEltTy = EltTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">      else if (CommonEltTy != EltTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">      else if (CommonEltTy != EltTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">        HaveCommonEltTy = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">        HaveCommonEltTy = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">      if (EltTy->isPointerTy()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">      if (EltTy->isPointerTy()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">        HaveVecPtrTy = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">        HaveVecPtrTy = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine">        if (!CommonVecPtrTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine">        if (!CommonVecPtrTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">          CommonVecPtrTy = VTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">          CommonVecPtrTy = VTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">        else if (CommonVecPtrTy != VTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">        else if (CommonVecPtrTy != VTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine">          HaveCommonVecPtrTy = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine">          HaveCommonVecPtrTy = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">  // Put load and store types into a set for de-duplication.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">  // Put load and store types into a set for de-duplication.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">  for (const Slice &S : P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">  for (const Slice &S : P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">    Type *Ty;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">    Type *Ty;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine">    if (auto *LI = dyn_cast<LoadInst>(S.getUse()->getUser()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine">    if (auto *LI = dyn_cast<LoadInst>(S.getUse()->getUser()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">      Ty = LI->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">      Ty = LI->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">    else if (auto *SI = dyn_cast<StoreInst>(S.getUse()->getUser()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">    else if (auto *SI = dyn_cast<StoreInst>(S.getUse()->getUser()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">      Ty = SI->getValueOperand()->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">      Ty = SI->getValueOperand()->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine">    LoadStoreTys.insert(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine">    LoadStoreTys.insert(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">    // Consider any loads or stores that are the exact size of the slice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">    // Consider any loads or stores that are the exact size of the slice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">    if (S.beginOffset() == P.beginOffset() && S.endOffset() == P.endOffset())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">    if (S.beginOffset() == P.beginOffset() && S.endOffset() == P.endOffset())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine">      CheckCandidateType(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine">      CheckCandidateType(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">  // Consider additional vector types where the element type size is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">  // Consider additional vector types where the element type size is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine">  // multiple of load/store element size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine">  // multiple of load/store element size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">  for (Type *Ty : LoadStoreTys) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">  for (Type *Ty : LoadStoreTys) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">    if (!VectorType::isValidElementType(Ty))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">    if (!VectorType::isValidElementType(Ty))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine">    unsigned TypeSize = DL.getTypeSizeInBits(Ty).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine">    unsigned TypeSize = DL.getTypeSizeInBits(Ty).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">    // Make a copy of CandidateTys and iterate through it, because we might</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">    // Make a copy of CandidateTys and iterate through it, because we might</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">    // append to CandidateTys in the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">    // append to CandidateTys in the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">    SmallVector<VectorType *, 4> CandidateTysCopy = CandidateTys;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">    SmallVector<VectorType *, 4> CandidateTysCopy = CandidateTys;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine">    for (VectorType *&VTy : CandidateTysCopy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine">    for (VectorType *&VTy : CandidateTysCopy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">      unsigned VectorSize = DL.getTypeSizeInBits(VTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">      unsigned VectorSize = DL.getTypeSizeInBits(VTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">      unsigned ElementSize =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">      unsigned ElementSize =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">          DL.getTypeSizeInBits(VTy->getElementType()).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">          DL.getTypeSizeInBits(VTy->getElementType()).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine">      if (TypeSize != VectorSize && TypeSize != ElementSize &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine">      if (TypeSize != VectorSize && TypeSize != ElementSize &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">          VectorSize % TypeSize == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">          VectorSize % TypeSize == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">        VectorType *NewVTy = VectorType::get(Ty, VectorSize / TypeSize, false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">        VectorType *NewVTy = VectorType::get(Ty, VectorSize / TypeSize, false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">        CheckCandidateType(NewVTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">        CheckCandidateType(NewVTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine">  // If we didn't find a vector type, nothing to do here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine">  // If we didn't find a vector type, nothing to do here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">  if (CandidateTys.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">  if (CandidateTys.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">  // Pointer-ness is sticky, if we had a vector-of-pointers candidate type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">  // Pointer-ness is sticky, if we had a vector-of-pointers candidate type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">  // then we should choose it, not some other alternative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">  // then we should choose it, not some other alternative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">  // But, we can't perform a no-op pointer address space change via bitcast,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">  // But, we can't perform a no-op pointer address space change via bitcast,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">  // so if we didn't have a common pointer element type, bail.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">  // so if we didn't have a common pointer element type, bail.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">  if (HaveVecPtrTy && !HaveCommonVecPtrTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">  if (HaveVecPtrTy && !HaveCommonVecPtrTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">  // Try to pick the "best" element type out of the choices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">  // Try to pick the "best" element type out of the choices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">  if (!HaveCommonEltTy && HaveVecPtrTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">  if (!HaveCommonEltTy && HaveVecPtrTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine">    // If there was a pointer element type, there's really only one choice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine">    // If there was a pointer element type, there's really only one choice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">    CandidateTys.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">    CandidateTys.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">    CandidateTys.push_back(CommonVecPtrTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">    CandidateTys.push_back(CommonVecPtrTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">  } else if (!HaveCommonEltTy && !HaveVecPtrTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">  } else if (!HaveCommonEltTy && !HaveVecPtrTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">    // Integer-ify vector types.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">    // Integer-ify vector types.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine">    for (VectorType *&VTy : CandidateTys) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine">    for (VectorType *&VTy : CandidateTys) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">      if (!VTy->getElementType()->isIntegerTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">      if (!VTy->getElementType()->isIntegerTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">        VTy = cast<VectorType>(VTy->getWithNewType(IntegerType::getIntNTy(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">        VTy = cast<VectorType>(VTy->getWithNewType(IntegerType::getIntNTy(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">            VTy->getContext(), VTy->getScalarSizeInBits())));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">            VTy->getContext(), VTy->getScalarSizeInBits())));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">    // Rank the remaining candidate vector types. This is easy because we know</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">    // Rank the remaining candidate vector types. This is easy because we know</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">    // they're all integer vectors. We sort by ascending number of elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">    // they're all integer vectors. We sort by ascending number of elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">    auto RankVectorTypesComp = [&DL](VectorType *RHSTy, VectorType *LHSTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">    auto RankVectorTypesComp = [&DL](VectorType *RHSTy, VectorType *LHSTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">      (void)DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">      (void)DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">      assert(DL.getTypeSizeInBits(RHSTy).getFixedValue() ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">      assert(DL.getTypeSizeInBits(RHSTy).getFixedValue() ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">                 DL.getTypeSizeInBits(LHSTy).getFixedValue() &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">                 DL.getTypeSizeInBits(LHSTy).getFixedValue() &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">             "Cannot have vector types of different sizes!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">             "Cannot have vector types of different sizes!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">      assert(RHSTy->getElementType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">      assert(RHSTy->getElementType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">             "All non-integer types eliminated!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">             "All non-integer types eliminated!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">      assert(LHSTy->getElementType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">      assert(LHSTy->getElementType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">             "All non-integer types eliminated!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">             "All non-integer types eliminated!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">      return cast<FixedVectorType>(RHSTy)->getNumElements() <</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">      return cast<FixedVectorType>(RHSTy)->getNumElements() <</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine">             cast<FixedVectorType>(LHSTy)->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine">             cast<FixedVectorType>(LHSTy)->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">    auto RankVectorTypesEq = [&DL](VectorType *RHSTy, VectorType *LHSTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">    auto RankVectorTypesEq = [&DL](VectorType *RHSTy, VectorType *LHSTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">      (void)DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">      (void)DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">      assert(DL.getTypeSizeInBits(RHSTy).getFixedValue() ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">      assert(DL.getTypeSizeInBits(RHSTy).getFixedValue() ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">                 DL.getTypeSizeInBits(LHSTy).getFixedValue() &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">                 DL.getTypeSizeInBits(LHSTy).getFixedValue() &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine">             "Cannot have vector types of different sizes!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine">             "Cannot have vector types of different sizes!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">      assert(RHSTy->getElementType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">      assert(RHSTy->getElementType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">             "All non-integer types eliminated!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">             "All non-integer types eliminated!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">      assert(LHSTy->getElementType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">      assert(LHSTy->getElementType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">             "All non-integer types eliminated!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">             "All non-integer types eliminated!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">      return cast<FixedVectorType>(RHSTy)->getNumElements() ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">      return cast<FixedVectorType>(RHSTy)->getNumElements() ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">             cast<FixedVectorType>(LHSTy)->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">             cast<FixedVectorType>(LHSTy)->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">    };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">    llvm::sort(CandidateTys, RankVectorTypesComp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">    llvm::sort(CandidateTys, RankVectorTypesComp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">    CandidateTys.erase(std::unique(CandidateTys.begin(), CandidateTys.end(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">    CandidateTys.erase(std::unique(CandidateTys.begin(), CandidateTys.end(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">                                   RankVectorTypesEq),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">                                   RankVectorTypesEq),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">                       CandidateTys.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">                       CandidateTys.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine">// The only way to have the same element type in every vector type is to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine">// The only way to have the same element type in every vector type is to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">// have the same vector type. Check that and remove all but one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">// have the same vector type. Check that and remove all but one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">    for (VectorType *VTy : CandidateTys) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">    for (VectorType *VTy : CandidateTys) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">      assert(VTy->getElementType() == CommonEltTy &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">      assert(VTy->getElementType() == CommonEltTy &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">             "Unaccounted for element type!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">             "Unaccounted for element type!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">      assert(VTy == CandidateTys[0] &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">      assert(VTy == CandidateTys[0] &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">             "Different vector types with the same element type!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">             "Different vector types with the same element type!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine">    CandidateTys.resize(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine">    CandidateTys.resize(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine">  // FIXME: hack. Do we have a named constant for this?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine">  // FIXME: hack. Do we have a named constant for this?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">  // SDAG SDNode can't have more than 65535 operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">  // SDAG SDNode can't have more than 65535 operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">  llvm::erase_if(CandidateTys, [](VectorType *VTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">  llvm::erase_if(CandidateTys, [](VectorType *VTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">    return cast<FixedVectorType>(VTy)->getNumElements() ></td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">    return cast<FixedVectorType>(VTy)->getNumElements() ></td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">           std::numeric_limits<unsigned short>::max();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">           std::numeric_limits<unsigned short>::max();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">  for (VectorType *VTy : CandidateTys)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">  for (VectorType *VTy : CandidateTys)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">    if (checkVectorTypeForPromotion(P, VTy, DL))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">    if (checkVectorTypeForPromotion(P, VTy, DL))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">      return VTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">      return VTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">  return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine">/// Test whether a slice of an alloca is valid for integer widening.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine">/// Test whether a slice of an alloca is valid for integer widening.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine">/// This implements the necessary checking for the \c isIntegerWideningViable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine">/// This implements the necessary checking for the \c isIntegerWideningViable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">/// test below on a single slice of the alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">/// test below on a single slice of the alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine">static bool isIntegerWideningViableForSlice(const Slice &S,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine">static bool isIntegerWideningViableForSlice(const Slice &S,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">                                            uint64_t AllocBeginOffset,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">                                            uint64_t AllocBeginOffset,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">                                            Type *AllocaTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">                                            Type *AllocaTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">                                            const DataLayout &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">                                            const DataLayout &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine">                                            bool &WholeAllocaOp) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine">                                            bool &WholeAllocaOp) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">  uint64_t Size = DL.getTypeStoreSize(AllocaTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">  uint64_t Size = DL.getTypeStoreSize(AllocaTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine">  uint64_t RelBegin = S.beginOffset() - AllocBeginOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine">  uint64_t RelBegin = S.beginOffset() - AllocBeginOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">  uint64_t RelEnd = S.endOffset() - AllocBeginOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">  uint64_t RelEnd = S.endOffset() - AllocBeginOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">  Use *U = S.getUse();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">  Use *U = S.getUse();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine">  // Lifetime intrinsics operate over the whole alloca whose sizes are usually</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine">  // Lifetime intrinsics operate over the whole alloca whose sizes are usually</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">  // larger than other load/store slices (RelEnd > Size). But lifetime are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">  // larger than other load/store slices (RelEnd > Size). But lifetime are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">  // always promotable and should not impact other slices' promotability of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">  // always promotable and should not impact other slices' promotability of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">  // partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">  // partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine">  if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine">  if (IntrinsicInst *II = dyn_cast<IntrinsicInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">    if (II->isLifetimeStartOrEnd() || II->isDroppable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">    if (II->isLifetimeStartOrEnd() || II->isDroppable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">  // We can't reasonably handle cases where the load or store extends past</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">  // We can't reasonably handle cases where the load or store extends past</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">  // the end of the alloca's type and into its padding.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">  // the end of the alloca's type and into its padding.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">  if (RelEnd > Size)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">  if (RelEnd > Size)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">  if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">  if (LoadInst *LI = dyn_cast<LoadInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">    if (LI->isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">    if (LI->isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">    // We can't handle loads that extend past the allocated memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">    // We can't handle loads that extend past the allocated memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine">    if (DL.getTypeStoreSize(LI->getType()).getFixedValue() > Size)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine">    if (DL.getTypeStoreSize(LI->getType()).getFixedValue() > Size)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">    // So far, AllocaSliceRewriter does not support widening split slice tails</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">    // So far, AllocaSliceRewriter does not support widening split slice tails</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">    // in rewriteIntegerLoad.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">    // in rewriteIntegerLoad.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine">    if (S.beginOffset() < AllocBeginOffset)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine">    if (S.beginOffset() < AllocBeginOffset)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">    // Note that we don't count vector loads or stores as whole-alloca</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">    // Note that we don't count vector loads or stores as whole-alloca</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine">    // operations which enable integer widening because we would prefer to use</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine">    // operations which enable integer widening because we would prefer to use</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">    // vector widening instead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">    // vector widening instead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine">    if (!isa<VectorType>(LI->getType()) && RelBegin == 0 && RelEnd == Size)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine">    if (!isa<VectorType>(LI->getType()) && RelBegin == 0 && RelEnd == Size)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">      WholeAllocaOp = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">      WholeAllocaOp = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">    if (IntegerType *ITy = dyn_cast<IntegerType>(LI->getType())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">    if (IntegerType *ITy = dyn_cast<IntegerType>(LI->getType())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">      if (ITy->getBitWidth() < DL.getTypeStoreSizeInBits(ITy).getFixedValue())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">      if (ITy->getBitWidth() < DL.getTypeStoreSizeInBits(ITy).getFixedValue())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">    } else if (RelBegin != 0 || RelEnd != Size ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">    } else if (RelBegin != 0 || RelEnd != Size ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">               !canConvertValue(DL, AllocaTy, LI->getType())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">               !canConvertValue(DL, AllocaTy, LI->getType())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">      // Non-integer loads need to be convertible from the alloca type so that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">      // Non-integer loads need to be convertible from the alloca type so that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine">      // they are promotable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine">      // they are promotable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">  } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">  } else if (StoreInst *SI = dyn_cast<StoreInst>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine">    Type *ValueTy = SI->getValueOperand()->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine">    Type *ValueTy = SI->getValueOperand()->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">    if (SI->isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">    if (SI->isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">    // We can't handle stores that extend past the allocated memory.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">    // We can't handle stores that extend past the allocated memory.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine">    if (DL.getTypeStoreSize(ValueTy).getFixedValue() > Size)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine">    if (DL.getTypeStoreSize(ValueTy).getFixedValue() > Size)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine">    // So far, AllocaSliceRewriter does not support widening split slice tails</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine">    // So far, AllocaSliceRewriter does not support widening split slice tails</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">    // in rewriteIntegerStore.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">    // in rewriteIntegerStore.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">    if (S.beginOffset() < AllocBeginOffset)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">    if (S.beginOffset() < AllocBeginOffset)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">    // Note that we don't count vector loads or stores as whole-alloca</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">    // Note that we don't count vector loads or stores as whole-alloca</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine">    // operations which enable integer widening because we would prefer to use</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine">    // operations which enable integer widening because we would prefer to use</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">    // vector widening instead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">    // vector widening instead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine">    if (!isa<VectorType>(ValueTy) && RelBegin == 0 && RelEnd == Size)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine">    if (!isa<VectorType>(ValueTy) && RelBegin == 0 && RelEnd == Size)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">      WholeAllocaOp = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">      WholeAllocaOp = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">    if (IntegerType *ITy = dyn_cast<IntegerType>(ValueTy)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">    if (IntegerType *ITy = dyn_cast<IntegerType>(ValueTy)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine">      if (ITy->getBitWidth() < DL.getTypeStoreSizeInBits(ITy).getFixedValue())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine">      if (ITy->getBitWidth() < DL.getTypeStoreSizeInBits(ITy).getFixedValue())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">    } else if (RelBegin != 0 || RelEnd != Size ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">    } else if (RelBegin != 0 || RelEnd != Size ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine">               !canConvertValue(DL, ValueTy, AllocaTy)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine">               !canConvertValue(DL, ValueTy, AllocaTy)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">      // Non-integer stores need to be convertible to the alloca type so that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">      // Non-integer stores need to be convertible to the alloca type so that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">      // they are promotable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">      // they are promotable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">  } else if (MemIntrinsic *MI = dyn_cast<MemIntrinsic>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">  } else if (MemIntrinsic *MI = dyn_cast<MemIntrinsic>(U->getUser())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">    if (MI->isVolatile() || !isa<Constant>(MI->getLength()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">    if (MI->isVolatile() || !isa<Constant>(MI->getLength()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">    if (!S.isSplittable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">    if (!S.isSplittable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">      return false; // Skip any unsplittable intrinsics.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">      return false; // Skip any unsplittable intrinsics.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine">/// Test whether the given alloca partition's integer operations can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine">/// Test whether the given alloca partition's integer operations can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine">/// widened to promotable ones.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine">/// widened to promotable ones.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">/// This is a quick test to check whether we can rewrite the integer loads and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">/// This is a quick test to check whether we can rewrite the integer loads and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine">/// stores to a particular alloca into wider loads and stores and be able to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine">/// stores to a particular alloca into wider loads and stores and be able to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">/// promote the resulting alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">/// promote the resulting alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">static bool isIntegerWideningViable(Partition &P, Type *AllocaTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">static bool isIntegerWideningViable(Partition &P, Type *AllocaTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine">                                    const DataLayout &DL) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine">                                    const DataLayout &DL) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">  uint64_t SizeInBits = DL.getTypeSizeInBits(AllocaTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">  uint64_t SizeInBits = DL.getTypeSizeInBits(AllocaTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine">  // Don't create integer types larger than the maximum bitwidth.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine">  // Don't create integer types larger than the maximum bitwidth.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">  if (SizeInBits > IntegerType::MAX_INT_BITS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">  if (SizeInBits > IntegerType::MAX_INT_BITS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">  // Don't try to handle allocas with bit-padding.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">  // Don't try to handle allocas with bit-padding.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">  if (SizeInBits != DL.getTypeStoreSizeInBits(AllocaTy).getFixedValue())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">  if (SizeInBits != DL.getTypeStoreSizeInBits(AllocaTy).getFixedValue())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">  // We need to ensure that an integer type with the appropriate bitwidth can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">  // We need to ensure that an integer type with the appropriate bitwidth can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">  // be converted to the alloca type, whatever that is. We don't want to force</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">  // be converted to the alloca type, whatever that is. We don't want to force</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine">  // the alloca itself to have an integer type if there is a more suitable one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine">  // the alloca itself to have an integer type if there is a more suitable one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">  Type *IntTy = Type::getIntNTy(AllocaTy->getContext(), SizeInBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">  Type *IntTy = Type::getIntNTy(AllocaTy->getContext(), SizeInBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">  if (!canConvertValue(DL, AllocaTy, IntTy) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">  if (!canConvertValue(DL, AllocaTy, IntTy) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">      !canConvertValue(DL, IntTy, AllocaTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">      !canConvertValue(DL, IntTy, AllocaTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine">  // While examining uses, we ensure that the alloca has a covering load or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine">  // While examining uses, we ensure that the alloca has a covering load or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">  // store. We don't want to widen the integer operations only to fail to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">  // store. We don't want to widen the integer operations only to fail to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">  // promote due to some other unsplittable entry (which we may make splittable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">  // promote due to some other unsplittable entry (which we may make splittable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">  // later). However, if there are only splittable uses, go ahead and assume</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">  // later). However, if there are only splittable uses, go ahead and assume</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">  // that we cover the alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">  // that we cover the alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">  // FIXME: We shouldn't consider split slices that happen to start in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">  // FIXME: We shouldn't consider split slices that happen to start in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine">  // partition here...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine">  // partition here...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">  bool WholeAllocaOp = P.empty() && DL.isLegalInteger(SizeInBits);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">  bool WholeAllocaOp = P.empty() && DL.isLegalInteger(SizeInBits);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">  for (const Slice &S : P)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">  for (const Slice &S : P)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">    if (!isIntegerWideningViableForSlice(S, P.beginOffset(), AllocaTy, DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">    if (!isIntegerWideningViableForSlice(S, P.beginOffset(), AllocaTy, DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine">                                         WholeAllocaOp))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine">                                         WholeAllocaOp))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">  for (const Slice *S : P.splitSliceTails())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">  for (const Slice *S : P.splitSliceTails())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">    if (!isIntegerWideningViableForSlice(*S, P.beginOffset(), AllocaTy, DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">    if (!isIntegerWideningViableForSlice(*S, P.beginOffset(), AllocaTy, DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">                                         WholeAllocaOp))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">                                         WholeAllocaOp))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine">  return WholeAllocaOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine">  return WholeAllocaOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine">static Value *extractInteger(const DataLayout &DL, IRBuilderTy &IRB, Value *V,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine">static Value *extractInteger(const DataLayout &DL, IRBuilderTy &IRB, Value *V,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">                             IntegerType *Ty, uint64_t Offset,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">                             IntegerType *Ty, uint64_t Offset,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">                             const Twine &Name) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">                             const Twine &Name) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "       start: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "       start: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">  IntegerType *IntTy = cast<IntegerType>(V->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">  IntegerType *IntTy = cast<IntegerType>(V->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine">  assert(DL.getTypeStoreSize(Ty).getFixedValue() + Offset <=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine">  assert(DL.getTypeStoreSize(Ty).getFixedValue() + Offset <=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine">             DL.getTypeStoreSize(IntTy).getFixedValue() &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine">             DL.getTypeStoreSize(IntTy).getFixedValue() &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">         "Element extends past full value");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">         "Element extends past full value");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine">  uint64_t ShAmt = 8 * Offset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine">  uint64_t ShAmt = 8 * Offset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine">  if (DL.isBigEndian())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine">  if (DL.isBigEndian())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine">    ShAmt = 8 * (DL.getTypeStoreSize(IntTy).getFixedValue() -</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine">    ShAmt = 8 * (DL.getTypeStoreSize(IntTy).getFixedValue() -</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">                 DL.getTypeStoreSize(Ty).getFixedValue() - Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">                 DL.getTypeStoreSize(Ty).getFixedValue() - Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine">  if (ShAmt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine">  if (ShAmt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine">    V = IRB.CreateLShr(V, ShAmt, Name + ".shift");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine">    V = IRB.CreateLShr(V, ShAmt, Name + ".shift");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "     shifted: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "     shifted: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine">  assert(Ty->getBitWidth() <= IntTy->getBitWidth() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine">  assert(Ty->getBitWidth() <= IntTy->getBitWidth() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">         "Cannot extract to a larger integer!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">         "Cannot extract to a larger integer!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine">  if (Ty != IntTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine">  if (Ty != IntTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine">    V = IRB.CreateTrunc(V, Ty, Name + ".trunc");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine">    V = IRB.CreateTrunc(V, Ty, Name + ".trunc");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "     trunced: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "     trunced: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">static Value *insertInteger(const DataLayout &DL, IRBuilderTy &IRB, Value *Old,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">static Value *insertInteger(const DataLayout &DL, IRBuilderTy &IRB, Value *Old,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine">                            Value *V, uint64_t Offset, const Twine &Name) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine">                            Value *V, uint64_t Offset, const Twine &Name) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine">  IntegerType *IntTy = cast<IntegerType>(Old->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine">  IntegerType *IntTy = cast<IntegerType>(Old->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine">  IntegerType *Ty = cast<IntegerType>(V->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine">  IntegerType *Ty = cast<IntegerType>(V->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">  assert(Ty->getBitWidth() <= IntTy->getBitWidth() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">  assert(Ty->getBitWidth() <= IntTy->getBitWidth() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">         "Cannot insert a larger integer!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">         "Cannot insert a larger integer!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "       start: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "       start: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">  if (Ty != IntTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">  if (Ty != IntTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine">    V = IRB.CreateZExt(V, IntTy, Name + ".ext");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine">    V = IRB.CreateZExt(V, IntTy, Name + ".ext");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    extended: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    extended: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine">  assert(DL.getTypeStoreSize(Ty).getFixedValue() + Offset <=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine">  assert(DL.getTypeStoreSize(Ty).getFixedValue() + Offset <=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">             DL.getTypeStoreSize(IntTy).getFixedValue() &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">             DL.getTypeStoreSize(IntTy).getFixedValue() &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">         "Element store outside of alloca store");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">         "Element store outside of alloca store");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine">  uint64_t ShAmt = 8 * Offset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine">  uint64_t ShAmt = 8 * Offset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine">  if (DL.isBigEndian())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine">  if (DL.isBigEndian())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">    ShAmt = 8 * (DL.getTypeStoreSize(IntTy).getFixedValue() -</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">    ShAmt = 8 * (DL.getTypeStoreSize(IntTy).getFixedValue() -</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">                 DL.getTypeStoreSize(Ty).getFixedValue() - Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">                 DL.getTypeStoreSize(Ty).getFixedValue() - Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">  if (ShAmt) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">  if (ShAmt) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">    V = IRB.CreateShl(V, ShAmt, Name + ".shift");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">    V = IRB.CreateShl(V, ShAmt, Name + ".shift");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "     shifted: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "     shifted: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">  if (ShAmt || Ty->getBitWidth() < IntTy->getBitWidth()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">  if (ShAmt || Ty->getBitWidth() < IntTy->getBitWidth()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine">    APInt Mask = ~Ty->getMask().zext(IntTy->getBitWidth()).shl(ShAmt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine">    APInt Mask = ~Ty->getMask().zext(IntTy->getBitWidth()).shl(ShAmt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine">    Old = IRB.CreateAnd(Old, Mask, Name + ".mask");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine">    Old = IRB.CreateAnd(Old, Mask, Name + ".mask");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "      masked: " << *Old << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "      masked: " << *Old << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine">    V = IRB.CreateOr(Old, V, Name + ".insert");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine">    V = IRB.CreateOr(Old, V, Name + ".insert");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    inserted: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    inserted: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">static Value *extractVector(IRBuilderTy &IRB, Value *V, unsigned BeginIndex,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">static Value *extractVector(IRBuilderTy &IRB, Value *V, unsigned BeginIndex,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">                            unsigned EndIndex, const Twine &Name) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">                            unsigned EndIndex, const Twine &Name) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine">  auto *VecTy = cast<FixedVectorType>(V->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine">  auto *VecTy = cast<FixedVectorType>(V->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">  unsigned NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">  unsigned NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine">  assert(NumElements <= VecTy->getNumElements() && "Too many elements!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine">  assert(NumElements <= VecTy->getNumElements() && "Too many elements!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine">  if (NumElements == VecTy->getNumElements())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine">  if (NumElements == VecTy->getNumElements())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine">  if (NumElements == 1) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine">  if (NumElements == 1) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">    V = IRB.CreateExtractElement(V, IRB.getInt32(BeginIndex),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">    V = IRB.CreateExtractElement(V, IRB.getInt32(BeginIndex),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine">                                 Name + ".extract");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine">                                 Name + ".extract");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "     extract: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "     extract: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">  auto Mask = llvm::to_vector<8>(llvm::seq<int>(BeginIndex, EndIndex));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">  auto Mask = llvm::to_vector<8>(llvm::seq<int>(BeginIndex, EndIndex));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine">  V = IRB.CreateShuffleVector(V, Mask, Name + ".extract");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine">  V = IRB.CreateShuffleVector(V, Mask, Name + ".extract");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "     shuffle: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "     shuffle: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine">static Value *insertVector(IRBuilderTy &IRB, Value *Old, Value *V,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine">static Value *insertVector(IRBuilderTy &IRB, Value *Old, Value *V,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine">                           unsigned BeginIndex, const Twine &Name) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine">                           unsigned BeginIndex, const Twine &Name) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine">  VectorType *VecTy = cast<VectorType>(Old->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine">  VectorType *VecTy = cast<VectorType>(Old->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">  assert(VecTy && "Can only insert a vector into a vector");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">  assert(VecTy && "Can only insert a vector into a vector");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">  VectorType *Ty = dyn_cast<VectorType>(V->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">  VectorType *Ty = dyn_cast<VectorType>(V->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">  if (!Ty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">  if (!Ty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">    // Single element to insert.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">    // Single element to insert.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">    V = IRB.CreateInsertElement(Old, V, IRB.getInt32(BeginIndex),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">    V = IRB.CreateInsertElement(Old, V, IRB.getInt32(BeginIndex),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">                                Name + ".insert");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">                                Name + ".insert");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "     insert: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "     insert: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine">  assert(cast<FixedVectorType>(Ty)->getNumElements() <=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine">  assert(cast<FixedVectorType>(Ty)->getNumElements() <=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2390</td>
    <td class="codeLine">             cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2390</td>
    <td class="codeLine">             cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2391</td>
    <td class="codeLine">         "Too many elements!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2391</td>
    <td class="codeLine">         "Too many elements!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2392</td>
    <td class="codeLine">  if (cast<FixedVectorType>(Ty)->getNumElements() ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2392</td>
    <td class="codeLine">  if (cast<FixedVectorType>(Ty)->getNumElements() ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2393</td>
    <td class="codeLine">      cast<FixedVectorType>(VecTy)->getNumElements()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2393</td>
    <td class="codeLine">      cast<FixedVectorType>(VecTy)->getNumElements()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2394</td>
    <td class="codeLine">    assert(V->getType() == VecTy && "Vector type mismatch");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2394</td>
    <td class="codeLine">    assert(V->getType() == VecTy && "Vector type mismatch");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2395</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2395</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2396</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2396</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2397</td>
    <td class="codeLine">  unsigned EndIndex = BeginIndex + cast<FixedVectorType>(Ty)->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2397</td>
    <td class="codeLine">  unsigned EndIndex = BeginIndex + cast<FixedVectorType>(Ty)->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2398</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2399</td>
    <td class="codeLine">  // When inserting a smaller vector into the larger to store, we first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2399</td>
    <td class="codeLine">  // When inserting a smaller vector into the larger to store, we first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2400</td>
    <td class="codeLine">  // use a shuffle vector to widen it with undef elements, and then</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2400</td>
    <td class="codeLine">  // use a shuffle vector to widen it with undef elements, and then</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2401</td>
    <td class="codeLine">  // a second shuffle vector to select between the loaded vector and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2401</td>
    <td class="codeLine">  // a second shuffle vector to select between the loaded vector and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2402</td>
    <td class="codeLine">  // incoming vector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2402</td>
    <td class="codeLine">  // incoming vector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2403</td>
    <td class="codeLine">  SmallVector<int, 8> Mask;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2403</td>
    <td class="codeLine">  SmallVector<int, 8> Mask;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2404</td>
    <td class="codeLine">  Mask.reserve(cast<FixedVectorType>(VecTy)->getNumElements());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2404</td>
    <td class="codeLine">  Mask.reserve(cast<FixedVectorType>(VecTy)->getNumElements());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2405</td>
    <td class="codeLine">  for (unsigned i = 0; i != cast<FixedVectorType>(VecTy)->getNumElements(); ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2405</td>
    <td class="codeLine">  for (unsigned i = 0; i != cast<FixedVectorType>(VecTy)->getNumElements(); ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2406</td>
    <td class="codeLine">    if (i >= BeginIndex && i < EndIndex)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2406</td>
    <td class="codeLine">    if (i >= BeginIndex && i < EndIndex)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2407</td>
    <td class="codeLine">      Mask.push_back(i - BeginIndex);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2407</td>
    <td class="codeLine">      Mask.push_back(i - BeginIndex);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2408</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2408</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2409</td>
    <td class="codeLine">      Mask.push_back(-1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2409</td>
    <td class="codeLine">      Mask.push_back(-1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2410</td>
    <td class="codeLine">  V = IRB.CreateShuffleVector(V, Mask, Name + ".expand");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2410</td>
    <td class="codeLine">  V = IRB.CreateShuffleVector(V, Mask, Name + ".expand");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2411</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    shuffle: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2411</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    shuffle: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2413</td>
    <td class="codeLine">  SmallVector<Constant *, 8> Mask2;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2413</td>
    <td class="codeLine">  SmallVector<Constant *, 8> Mask2;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2414</td>
    <td class="codeLine">  Mask2.reserve(cast<FixedVectorType>(VecTy)->getNumElements());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2414</td>
    <td class="codeLine">  Mask2.reserve(cast<FixedVectorType>(VecTy)->getNumElements());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2415</td>
    <td class="codeLine">  for (unsigned i = 0; i != cast<FixedVectorType>(VecTy)->getNumElements(); ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2415</td>
    <td class="codeLine">  for (unsigned i = 0; i != cast<FixedVectorType>(VecTy)->getNumElements(); ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2416</td>
    <td class="codeLine">    Mask2.push_back(IRB.getInt1(i >= BeginIndex && i < EndIndex));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2416</td>
    <td class="codeLine">    Mask2.push_back(IRB.getInt1(i >= BeginIndex && i < EndIndex));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2417</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2418</td>
    <td class="codeLine">  V = IRB.CreateSelect(ConstantVector::get(Mask2), V, Old, Name + "blend");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2418</td>
    <td class="codeLine">  V = IRB.CreateSelect(ConstantVector::get(Mask2), V, Old, Name + "blend");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2420</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    blend: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2420</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "    blend: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2421</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2421</td>
    <td class="codeLine">  return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2422</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2422</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2424</td>
    <td class="codeLine">/// Visitor to rewrite instructions using p particular slice of an alloca</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2424</td>
    <td class="codeLine">/// Visitor to rewrite instructions using p particular slice of an alloca</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2425</td>
    <td class="codeLine">/// to use a new alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2425</td>
    <td class="codeLine">/// to use a new alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2426</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2426</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2427</td>
    <td class="codeLine">/// Also implements the rewriting to vector-based accesses when the partition</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2427</td>
    <td class="codeLine">/// Also implements the rewriting to vector-based accesses when the partition</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2428</td>
    <td class="codeLine">/// passes the isVectorPromotionViable predicate. Most of the rewriting logic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2428</td>
    <td class="codeLine">/// passes the isVectorPromotionViable predicate. Most of the rewriting logic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2429</td>
    <td class="codeLine">/// lives here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2429</td>
    <td class="codeLine">/// lives here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2430</td>
    <td class="codeLine">class llvm::sroa::AllocaSliceRewriter</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2430</td>
    <td class="codeLine">class llvm::sroa::AllocaSliceRewriter</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2431</td>
    <td class="codeLine">    : public InstVisitor<AllocaSliceRewriter, bool> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2431</td>
    <td class="codeLine">    : public InstVisitor<AllocaSliceRewriter, bool> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2432</td>
    <td class="codeLine">  // Befriend the base class so it can delegate to private visit methods.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2432</td>
    <td class="codeLine">  // Befriend the base class so it can delegate to private visit methods.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2433</td>
    <td class="codeLine">  friend class InstVisitor<AllocaSliceRewriter, bool>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2433</td>
    <td class="codeLine">  friend class InstVisitor<AllocaSliceRewriter, bool>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2435</td>
    <td class="codeLine">  using Base = InstVisitor<AllocaSliceRewriter, bool>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2435</td>
    <td class="codeLine">  using Base = InstVisitor<AllocaSliceRewriter, bool>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2437</td>
    <td class="codeLine">  const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2437</td>
    <td class="codeLine">  const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2438</td>
    <td class="codeLine">  AllocaSlices &AS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2438</td>
    <td class="codeLine">  AllocaSlices &AS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2439</td>
    <td class="codeLine">  SROAPass &Pass;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2439</td>
    <td class="codeLine">  SROAPass &Pass;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2440</td>
    <td class="codeLine">  AllocaInst &OldAI, &NewAI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2440</td>
    <td class="codeLine">  AllocaInst &OldAI, &NewAI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2441</td>
    <td class="codeLine">  const uint64_t NewAllocaBeginOffset, NewAllocaEndOffset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2441</td>
    <td class="codeLine">  const uint64_t NewAllocaBeginOffset, NewAllocaEndOffset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2442</td>
    <td class="codeLine">  Type *NewAllocaTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2442</td>
    <td class="codeLine">  Type *NewAllocaTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2443</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2444</td>
    <td class="codeLine">  // This is a convenience and flag variable that will be null unless the new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2444</td>
    <td class="codeLine">  // This is a convenience and flag variable that will be null unless the new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2445</td>
    <td class="codeLine">  // alloca's integer operations should be widened to this integer type due to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2445</td>
    <td class="codeLine">  // alloca's integer operations should be widened to this integer type due to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2446</td>
    <td class="codeLine">  // passing isIntegerWideningViable above. If it is non-null, the desired</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2446</td>
    <td class="codeLine">  // passing isIntegerWideningViable above. If it is non-null, the desired</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2447</td>
    <td class="codeLine">  // integer type will be stored here for easy access during rewriting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2447</td>
    <td class="codeLine">  // integer type will be stored here for easy access during rewriting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2448</td>
    <td class="codeLine">  IntegerType *IntTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2448</td>
    <td class="codeLine">  IntegerType *IntTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2449</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2450</td>
    <td class="codeLine">  // If we are rewriting an alloca partition which can be written as pure</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2450</td>
    <td class="codeLine">  // If we are rewriting an alloca partition which can be written as pure</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2451</td>
    <td class="codeLine">  // vector operations, we stash extra information here. When VecTy is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2451</td>
    <td class="codeLine">  // vector operations, we stash extra information here. When VecTy is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2452</td>
    <td class="codeLine">  // non-null, we have some strict guarantees about the rewritten alloca:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2452</td>
    <td class="codeLine">  // non-null, we have some strict guarantees about the rewritten alloca:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2453</td>
    <td class="codeLine">  //   - The new alloca is exactly the size of the vector type here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2453</td>
    <td class="codeLine">  //   - The new alloca is exactly the size of the vector type here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2454</td>
    <td class="codeLine">  //   - The accesses all either map to the entire vector or to a single</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2454</td>
    <td class="codeLine">  //   - The accesses all either map to the entire vector or to a single</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2455</td>
    <td class="codeLine">  //     element.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2455</td>
    <td class="codeLine">  //     element.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2456</td>
    <td class="codeLine">  //   - The set of accessing instructions is only one of those handled above</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2456</td>
    <td class="codeLine">  //   - The set of accessing instructions is only one of those handled above</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2457</td>
    <td class="codeLine">  //     in isVectorPromotionViable. Generally these are the same access kinds</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2457</td>
    <td class="codeLine">  //     in isVectorPromotionViable. Generally these are the same access kinds</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2458</td>
    <td class="codeLine">  //     which are promotable via mem2reg.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2458</td>
    <td class="codeLine">  //     which are promotable via mem2reg.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2459</td>
    <td class="codeLine">  VectorType *VecTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2459</td>
    <td class="codeLine">  VectorType *VecTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2460</td>
    <td class="codeLine">  Type *ElementTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2460</td>
    <td class="codeLine">  Type *ElementTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2461</td>
    <td class="codeLine">  uint64_t ElementSize;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2461</td>
    <td class="codeLine">  uint64_t ElementSize;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2463</td>
    <td class="codeLine">  // The original offset of the slice currently being rewritten relative to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2463</td>
    <td class="codeLine">  // The original offset of the slice currently being rewritten relative to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2464</td>
    <td class="codeLine">  // the original alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2464</td>
    <td class="codeLine">  // the original alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2465</td>
    <td class="codeLine">  uint64_t BeginOffset = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2465</td>
    <td class="codeLine">  uint64_t BeginOffset = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2466</td>
    <td class="codeLine">  uint64_t EndOffset = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2466</td>
    <td class="codeLine">  uint64_t EndOffset = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2467</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2468</td>
    <td class="codeLine">  // The new offsets of the slice currently being rewritten relative to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2468</td>
    <td class="codeLine">  // The new offsets of the slice currently being rewritten relative to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2469</td>
    <td class="codeLine">  // original alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2469</td>
    <td class="codeLine">  // original alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2470</td>
    <td class="codeLine">  uint64_t NewBeginOffset = 0, NewEndOffset = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2470</td>
    <td class="codeLine">  uint64_t NewBeginOffset = 0, NewEndOffset = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2471</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2472</td>
    <td class="codeLine">  uint64_t SliceSize = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2472</td>
    <td class="codeLine">  uint64_t SliceSize = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2473</td>
    <td class="codeLine">  bool IsSplittable = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2473</td>
    <td class="codeLine">  bool IsSplittable = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2474</td>
    <td class="codeLine">  bool IsSplit = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2474</td>
    <td class="codeLine">  bool IsSplit = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2475</td>
    <td class="codeLine">  Use *OldUse = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2475</td>
    <td class="codeLine">  Use *OldUse = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2476</td>
    <td class="codeLine">  Instruction *OldPtr = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2476</td>
    <td class="codeLine">  Instruction *OldPtr = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2477</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2478</td>
    <td class="codeLine">  // Track post-rewrite users which are PHI nodes and Selects.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2478</td>
    <td class="codeLine">  // Track post-rewrite users which are PHI nodes and Selects.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2479</td>
    <td class="codeLine">  SmallSetVector<PHINode *, 8> &PHIUsers;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2479</td>
    <td class="codeLine">  SmallSetVector<PHINode *, 8> &PHIUsers;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2480</td>
    <td class="codeLine">  SmallSetVector<SelectInst *, 8> &SelectUsers;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2480</td>
    <td class="codeLine">  SmallSetVector<SelectInst *, 8> &SelectUsers;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2482</td>
    <td class="codeLine">  // Utility IR builder, whose name prefix is setup for each visited use, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2482</td>
    <td class="codeLine">  // Utility IR builder, whose name prefix is setup for each visited use, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2483</td>
    <td class="codeLine">  // the insertion point is set to point to the user.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2483</td>
    <td class="codeLine">  // the insertion point is set to point to the user.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2484</td>
    <td class="codeLine">  IRBuilderTy IRB;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2484</td>
    <td class="codeLine">  IRBuilderTy IRB;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2486</td>
    <td class="codeLine">  // Return the new alloca, addrspacecasted if required to avoid changing the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2486</td>
    <td class="codeLine">  // Return the new alloca, addrspacecasted if required to avoid changing the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2487</td>
    <td class="codeLine">  // addrspace of a volatile access.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2487</td>
    <td class="codeLine">  // addrspace of a volatile access.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2488</td>
    <td class="codeLine">  Value *getPtrToNewAI(unsigned AddrSpace, bool IsVolatile) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2488</td>
    <td class="codeLine">  Value *getPtrToNewAI(unsigned AddrSpace, bool IsVolatile) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2489</td>
    <td class="codeLine">    if (!IsVolatile || AddrSpace == NewAI.getType()->getPointerAddressSpace())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2489</td>
    <td class="codeLine">    if (!IsVolatile || AddrSpace == NewAI.getType()->getPointerAddressSpace())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2490</td>
    <td class="codeLine">      return &NewAI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2490</td>
    <td class="codeLine">      return &NewAI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2492</td>
    <td class="codeLine">    Type *AccessTy = NewAI.getAllocatedType()->getPointerTo(AddrSpace);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2492</td>
    <td class="codeLine">    Type *AccessTy = NewAI.getAllocatedType()->getPointerTo(AddrSpace);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2493</td>
    <td class="codeLine">    return IRB.CreateAddrSpaceCast(&NewAI, AccessTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2493</td>
    <td class="codeLine">    return IRB.CreateAddrSpaceCast(&NewAI, AccessTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2494</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2494</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2496</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2496</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2497</td>
    <td class="codeLine">  AllocaSliceRewriter(const DataLayout &DL, AllocaSlices &AS, SROAPass &Pass,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2497</td>
    <td class="codeLine">  AllocaSliceRewriter(const DataLayout &DL, AllocaSlices &AS, SROAPass &Pass,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2498</td>
    <td class="codeLine">                      AllocaInst &OldAI, AllocaInst &NewAI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2498</td>
    <td class="codeLine">                      AllocaInst &OldAI, AllocaInst &NewAI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2499</td>
    <td class="codeLine">                      uint64_t NewAllocaBeginOffset,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2499</td>
    <td class="codeLine">                      uint64_t NewAllocaBeginOffset,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2500</td>
    <td class="codeLine">                      uint64_t NewAllocaEndOffset, bool IsIntegerPromotable,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2500</td>
    <td class="codeLine">                      uint64_t NewAllocaEndOffset, bool IsIntegerPromotable,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2501</td>
    <td class="codeLine">                      VectorType *PromotableVecTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2501</td>
    <td class="codeLine">                      VectorType *PromotableVecTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2502</td>
    <td class="codeLine">                      SmallSetVector<PHINode *, 8> &PHIUsers,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2502</td>
    <td class="codeLine">                      SmallSetVector<PHINode *, 8> &PHIUsers,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2503</td>
    <td class="codeLine">                      SmallSetVector<SelectInst *, 8> &SelectUsers)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2503</td>
    <td class="codeLine">                      SmallSetVector<SelectInst *, 8> &SelectUsers)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2504</td>
    <td class="codeLine">      : DL(DL), AS(AS), Pass(Pass), OldAI(OldAI), NewAI(NewAI),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2504</td>
    <td class="codeLine">      : DL(DL), AS(AS), Pass(Pass), OldAI(OldAI), NewAI(NewAI),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2505</td>
    <td class="codeLine">        NewAllocaBeginOffset(NewAllocaBeginOffset),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2505</td>
    <td class="codeLine">        NewAllocaBeginOffset(NewAllocaBeginOffset),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2506</td>
    <td class="codeLine">        NewAllocaEndOffset(NewAllocaEndOffset),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2506</td>
    <td class="codeLine">        NewAllocaEndOffset(NewAllocaEndOffset),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2507</td>
    <td class="codeLine">        NewAllocaTy(NewAI.getAllocatedType()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2507</td>
    <td class="codeLine">        NewAllocaTy(NewAI.getAllocatedType()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2508</td>
    <td class="codeLine">        IntTy(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2508</td>
    <td class="codeLine">        IntTy(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2509</td>
    <td class="codeLine">            IsIntegerPromotable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2509</td>
    <td class="codeLine">            IsIntegerPromotable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2510</td>
    <td class="codeLine">                ? Type::getIntNTy(NewAI.getContext(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2510</td>
    <td class="codeLine">                ? Type::getIntNTy(NewAI.getContext(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2511</td>
    <td class="codeLine">                                  DL.getTypeSizeInBits(NewAI.getAllocatedType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2511</td>
    <td class="codeLine">                                  DL.getTypeSizeInBits(NewAI.getAllocatedType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2512</td>
    <td class="codeLine">                                      .getFixedValue())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2512</td>
    <td class="codeLine">                                      .getFixedValue())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2513</td>
    <td class="codeLine">                : nullptr),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2513</td>
    <td class="codeLine">                : nullptr),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2514</td>
    <td class="codeLine">        VecTy(PromotableVecTy),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2514</td>
    <td class="codeLine">        VecTy(PromotableVecTy),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2515</td>
    <td class="codeLine">        ElementTy(VecTy ? VecTy->getElementType() : nullptr),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2515</td>
    <td class="codeLine">        ElementTy(VecTy ? VecTy->getElementType() : nullptr),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2516</td>
    <td class="codeLine">        ElementSize(VecTy ? DL.getTypeSizeInBits(ElementTy).getFixedValue() / 8</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2516</td>
    <td class="codeLine">        ElementSize(VecTy ? DL.getTypeSizeInBits(ElementTy).getFixedValue() / 8</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2517</td>
    <td class="codeLine">                          : 0),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2517</td>
    <td class="codeLine">                          : 0),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2518</td>
    <td class="codeLine">        PHIUsers(PHIUsers), SelectUsers(SelectUsers),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2518</td>
    <td class="codeLine">        PHIUsers(PHIUsers), SelectUsers(SelectUsers),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2519</td>
    <td class="codeLine">        IRB(NewAI.getContext(), ConstantFolder()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2519</td>
    <td class="codeLine">        IRB(NewAI.getContext(), ConstantFolder()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2520</td>
    <td class="codeLine">    if (VecTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2520</td>
    <td class="codeLine">    if (VecTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2521</td>
    <td class="codeLine">      assert((DL.getTypeSizeInBits(ElementTy).getFixedValue() % 8) == 0 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2521</td>
    <td class="codeLine">      assert((DL.getTypeSizeInBits(ElementTy).getFixedValue() % 8) == 0 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2522</td>
    <td class="codeLine">             "Only multiple-of-8 sized vector elements are viable");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2522</td>
    <td class="codeLine">             "Only multiple-of-8 sized vector elements are viable");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2523</td>
    <td class="codeLine">      ++NumVectorized;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2523</td>
    <td class="codeLine">      ++NumVectorized;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2524</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2524</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2525</td>
    <td class="codeLine">    assert((!IntTy && !VecTy) || (IntTy && !VecTy) || (!IntTy && VecTy));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2525</td>
    <td class="codeLine">    assert((!IntTy && !VecTy) || (IntTy && !VecTy) || (!IntTy && VecTy));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2526</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2526</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2527</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2528</td>
    <td class="codeLine">  bool visit(AllocaSlices::const_iterator I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2528</td>
    <td class="codeLine">  bool visit(AllocaSlices::const_iterator I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2529</td>
    <td class="codeLine">    bool CanSROA = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2529</td>
    <td class="codeLine">    bool CanSROA = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2530</td>
    <td class="codeLine">    BeginOffset = I->beginOffset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2530</td>
    <td class="codeLine">    BeginOffset = I->beginOffset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2531</td>
    <td class="codeLine">    EndOffset = I->endOffset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2531</td>
    <td class="codeLine">    EndOffset = I->endOffset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2532</td>
    <td class="codeLine">    IsSplittable = I->isSplittable();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2532</td>
    <td class="codeLine">    IsSplittable = I->isSplittable();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2533</td>
    <td class="codeLine">    IsSplit =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2533</td>
    <td class="codeLine">    IsSplit =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2534</td>
    <td class="codeLine">        BeginOffset < NewAllocaBeginOffset || EndOffset > NewAllocaEndOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2534</td>
    <td class="codeLine">        BeginOffset < NewAllocaBeginOffset || EndOffset > NewAllocaEndOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2535</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  rewriting " << (IsSplit ? "split " : ""));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2535</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  rewriting " << (IsSplit ? "split " : ""));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2536</td>
    <td class="codeLine">    LLVM_DEBUG(AS.printSlice(dbgs(), I, ""));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2536</td>
    <td class="codeLine">    LLVM_DEBUG(AS.printSlice(dbgs(), I, ""));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2537</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2537</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2538</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2539</td>
    <td class="codeLine">    // Compute the intersecting offset range.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2539</td>
    <td class="codeLine">    // Compute the intersecting offset range.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2540</td>
    <td class="codeLine">    assert(BeginOffset < NewAllocaEndOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2540</td>
    <td class="codeLine">    assert(BeginOffset < NewAllocaEndOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2541</td>
    <td class="codeLine">    assert(EndOffset > NewAllocaBeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2541</td>
    <td class="codeLine">    assert(EndOffset > NewAllocaBeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2542</td>
    <td class="codeLine">    NewBeginOffset = std::max(BeginOffset, NewAllocaBeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2542</td>
    <td class="codeLine">    NewBeginOffset = std::max(BeginOffset, NewAllocaBeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2543</td>
    <td class="codeLine">    NewEndOffset = std::min(EndOffset, NewAllocaEndOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2543</td>
    <td class="codeLine">    NewEndOffset = std::min(EndOffset, NewAllocaEndOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2545</td>
    <td class="codeLine">    SliceSize = NewEndOffset - NewBeginOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2545</td>
    <td class="codeLine">    SliceSize = NewEndOffset - NewBeginOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2546</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "   Begin:(" << BeginOffset << ", " << EndOffset</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2546</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "   Begin:(" << BeginOffset << ", " << EndOffset</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2547</td>
    <td class="codeLine">                      << ") NewBegin:(" << NewBeginOffset << ", "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2547</td>
    <td class="codeLine">                      << ") NewBegin:(" << NewBeginOffset << ", "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2548</td>
    <td class="codeLine">                      << NewEndOffset << ") NewAllocaBegin:("</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2548</td>
    <td class="codeLine">                      << NewEndOffset << ") NewAllocaBegin:("</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2549</td>
    <td class="codeLine">                      << NewAllocaBeginOffset << ", " << NewAllocaEndOffset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2549</td>
    <td class="codeLine">                      << NewAllocaBeginOffset << ", " << NewAllocaEndOffset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2550</td>
    <td class="codeLine">                      << ")\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2550</td>
    <td class="codeLine">                      << ")\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2551</td>
    <td class="codeLine">    assert(IsSplit || NewBeginOffset == BeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2551</td>
    <td class="codeLine">    assert(IsSplit || NewBeginOffset == BeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2552</td>
    <td class="codeLine">    OldUse = I->getUse();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2552</td>
    <td class="codeLine">    OldUse = I->getUse();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2553</td>
    <td class="codeLine">    OldPtr = cast<Instruction>(OldUse->get());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2553</td>
    <td class="codeLine">    OldPtr = cast<Instruction>(OldUse->get());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2555</td>
    <td class="codeLine">    Instruction *OldUserI = cast<Instruction>(OldUse->getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2555</td>
    <td class="codeLine">    Instruction *OldUserI = cast<Instruction>(OldUse->getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2556</td>
    <td class="codeLine">    IRB.SetInsertPoint(OldUserI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2556</td>
    <td class="codeLine">    IRB.SetInsertPoint(OldUserI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2557</td>
    <td class="codeLine">    IRB.SetCurrentDebugLocation(OldUserI->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2557</td>
    <td class="codeLine">    IRB.SetCurrentDebugLocation(OldUserI->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2558</td>
    <td class="codeLine">    IRB.getInserter().SetNamePrefix(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2558</td>
    <td class="codeLine">    IRB.getInserter().SetNamePrefix(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2559</td>
    <td class="codeLine">        Twine(NewAI.getName()) + "." + Twine(BeginOffset) + ".");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2559</td>
    <td class="codeLine">        Twine(NewAI.getName()) + "." + Twine(BeginOffset) + ".");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2560</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2561</td>
    <td class="codeLine">    CanSROA &= visit(cast<Instruction>(OldUse->getUser()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2561</td>
    <td class="codeLine">    CanSROA &= visit(cast<Instruction>(OldUse->getUser()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2562</td>
    <td class="codeLine">    if (VecTy || IntTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2562</td>
    <td class="codeLine">    if (VecTy || IntTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2563</td>
    <td class="codeLine">      assert(CanSROA);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2563</td>
    <td class="codeLine">      assert(CanSROA);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2564</td>
    <td class="codeLine">    return CanSROA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2564</td>
    <td class="codeLine">    return CanSROA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2565</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2565</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2567</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2567</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2568</td>
    <td class="codeLine">  // Make sure the other visit overloads are visible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2568</td>
    <td class="codeLine">  // Make sure the other visit overloads are visible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2569</td>
    <td class="codeLine">  using Base::visit;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2569</td>
    <td class="codeLine">  using Base::visit;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2570</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2571</td>
    <td class="codeLine">  // Every instruction which can end up as a user must have a rewrite rule.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2571</td>
    <td class="codeLine">  // Every instruction which can end up as a user must have a rewrite rule.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2572</td>
    <td class="codeLine">  bool visitInstruction(Instruction &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2572</td>
    <td class="codeLine">  bool visitInstruction(Instruction &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2573</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    !!!! Cannot rewrite: " << I << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2573</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    !!!! Cannot rewrite: " << I << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2574</td>
    <td class="codeLine">    llvm_unreachable("No rewrite rule for this instruction!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2574</td>
    <td class="codeLine">    llvm_unreachable("No rewrite rule for this instruction!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2575</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2575</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2576</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2577</td>
    <td class="codeLine">  Value *getNewAllocaSlicePtr(IRBuilderTy &IRB, Type *PointerTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2577</td>
    <td class="codeLine">  Value *getNewAllocaSlicePtr(IRBuilderTy &IRB, Type *PointerTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2578</td>
    <td class="codeLine">    // Note that the offset computation can use BeginOffset or NewBeginOffset</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2578</td>
    <td class="codeLine">    // Note that the offset computation can use BeginOffset or NewBeginOffset</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2579</td>
    <td class="codeLine">    // interchangeably for unsplit slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2579</td>
    <td class="codeLine">    // interchangeably for unsplit slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2580</td>
    <td class="codeLine">    assert(IsSplit || BeginOffset == NewBeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2580</td>
    <td class="codeLine">    assert(IsSplit || BeginOffset == NewBeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2581</td>
    <td class="codeLine">    uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2581</td>
    <td class="codeLine">    uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2582</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2583</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2583</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2584</td>
    <td class="codeLine">    StringRef OldName = OldPtr->getName();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2584</td>
    <td class="codeLine">    StringRef OldName = OldPtr->getName();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2585</td>
    <td class="codeLine">    // Skip through the last '.sroa.' component of the name.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2585</td>
    <td class="codeLine">    // Skip through the last '.sroa.' component of the name.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2586</td>
    <td class="codeLine">    size_t LastSROAPrefix = OldName.rfind(".sroa.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2586</td>
    <td class="codeLine">    size_t LastSROAPrefix = OldName.rfind(".sroa.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2587</td>
    <td class="codeLine">    if (LastSROAPrefix != StringRef::npos) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2587</td>
    <td class="codeLine">    if (LastSROAPrefix != StringRef::npos) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2588</td>
    <td class="codeLine">      OldName = OldName.substr(LastSROAPrefix + strlen(".sroa."));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2588</td>
    <td class="codeLine">      OldName = OldName.substr(LastSROAPrefix + strlen(".sroa."));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2589</td>
    <td class="codeLine">      // Look for an SROA slice index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2589</td>
    <td class="codeLine">      // Look for an SROA slice index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2590</td>
    <td class="codeLine">      size_t IndexEnd = OldName.find_first_not_of("0123456789");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2590</td>
    <td class="codeLine">      size_t IndexEnd = OldName.find_first_not_of("0123456789");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2591</td>
    <td class="codeLine">      if (IndexEnd != StringRef::npos && OldName[IndexEnd] == '.') {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2591</td>
    <td class="codeLine">      if (IndexEnd != StringRef::npos && OldName[IndexEnd] == '.') {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2592</td>
    <td class="codeLine">        // Strip the index and look for the offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2592</td>
    <td class="codeLine">        // Strip the index and look for the offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2593</td>
    <td class="codeLine">        OldName = OldName.substr(IndexEnd + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2593</td>
    <td class="codeLine">        OldName = OldName.substr(IndexEnd + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2594</td>
    <td class="codeLine">        size_t OffsetEnd = OldName.find_first_not_of("0123456789");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2594</td>
    <td class="codeLine">        size_t OffsetEnd = OldName.find_first_not_of("0123456789");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2595</td>
    <td class="codeLine">        if (OffsetEnd != StringRef::npos && OldName[OffsetEnd] == '.')</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2595</td>
    <td class="codeLine">        if (OffsetEnd != StringRef::npos && OldName[OffsetEnd] == '.')</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2596</td>
    <td class="codeLine">          // Strip the offset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2596</td>
    <td class="codeLine">          // Strip the offset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2597</td>
    <td class="codeLine">          OldName = OldName.substr(OffsetEnd + 1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2597</td>
    <td class="codeLine">          OldName = OldName.substr(OffsetEnd + 1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2598</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2598</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2599</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2599</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2600</td>
    <td class="codeLine">    // Strip any SROA suffixes as well.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2600</td>
    <td class="codeLine">    // Strip any SROA suffixes as well.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2601</td>
    <td class="codeLine">    OldName = OldName.substr(0, OldName.find(".sroa_"));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2601</td>
    <td class="codeLine">    OldName = OldName.substr(0, OldName.find(".sroa_"));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2602</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2602</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2603</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2604</td>
    <td class="codeLine">    return getAdjustedPtr(IRB, DL, &NewAI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2604</td>
    <td class="codeLine">    return getAdjustedPtr(IRB, DL, &NewAI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2605</td>
    <td class="codeLine">                          APInt(DL.getIndexTypeSizeInBits(PointerTy), Offset),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2605</td>
    <td class="codeLine">                          APInt(DL.getIndexTypeSizeInBits(PointerTy), Offset),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2606</td>
    <td class="codeLine">                          PointerTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2606</td>
    <td class="codeLine">                          PointerTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2607</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2607</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2608</td>
    <td class="codeLine">                          Twine(OldName) + "."</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2608</td>
    <td class="codeLine">                          Twine(OldName) + "."</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2609</td>
    <td class="codeLine">#else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2609</td>
    <td class="codeLine">#else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2610</td>
    <td class="codeLine">                          Twine()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2610</td>
    <td class="codeLine">                          Twine()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2611</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2611</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2612</td>
    <td class="codeLine">                          );</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2612</td>
    <td class="codeLine">                          );</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2615</td>
    <td class="codeLine">  /// Compute suitable alignment to access this slice of the *new*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2615</td>
    <td class="codeLine">  /// Compute suitable alignment to access this slice of the *new*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2616</td>
    <td class="codeLine">  /// alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2616</td>
    <td class="codeLine">  /// alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2617</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2617</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2618</td>
    <td class="codeLine">  /// You can optionally pass a type to this routine and if that type's ABI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2618</td>
    <td class="codeLine">  /// You can optionally pass a type to this routine and if that type's ABI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2619</td>
    <td class="codeLine">  /// alignment is itself suitable, this will return zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2619</td>
    <td class="codeLine">  /// alignment is itself suitable, this will return zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2620</td>
    <td class="codeLine">  Align getSliceAlign() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2620</td>
    <td class="codeLine">  Align getSliceAlign() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2621</td>
    <td class="codeLine">    return commonAlignment(NewAI.getAlign(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2621</td>
    <td class="codeLine">    return commonAlignment(NewAI.getAlign(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2622</td>
    <td class="codeLine">                           NewBeginOffset - NewAllocaBeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2622</td>
    <td class="codeLine">                           NewBeginOffset - NewAllocaBeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2623</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2623</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2625</td>
    <td class="codeLine">  unsigned getIndex(uint64_t Offset) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2625</td>
    <td class="codeLine">  unsigned getIndex(uint64_t Offset) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2626</td>
    <td class="codeLine">    assert(VecTy && "Can only call getIndex when rewriting a vector");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2626</td>
    <td class="codeLine">    assert(VecTy && "Can only call getIndex when rewriting a vector");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2627</td>
    <td class="codeLine">    uint64_t RelOffset = Offset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2627</td>
    <td class="codeLine">    uint64_t RelOffset = Offset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2628</td>
    <td class="codeLine">    assert(RelOffset / ElementSize < UINT32_MAX && "Index out of bounds");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2628</td>
    <td class="codeLine">    assert(RelOffset / ElementSize < UINT32_MAX && "Index out of bounds");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2629</td>
    <td class="codeLine">    uint32_t Index = RelOffset / ElementSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2629</td>
    <td class="codeLine">    uint32_t Index = RelOffset / ElementSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2630</td>
    <td class="codeLine">    assert(Index * ElementSize == RelOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2630</td>
    <td class="codeLine">    assert(Index * ElementSize == RelOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2631</td>
    <td class="codeLine">    return Index;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2631</td>
    <td class="codeLine">    return Index;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2632</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2632</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2633</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2634</td>
    <td class="codeLine">  void deleteIfTriviallyDead(Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2634</td>
    <td class="codeLine">  void deleteIfTriviallyDead(Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2635</td>
    <td class="codeLine">    Instruction *I = cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2635</td>
    <td class="codeLine">    Instruction *I = cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2636</td>
    <td class="codeLine">    if (isInstructionTriviallyDead(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2636</td>
    <td class="codeLine">    if (isInstructionTriviallyDead(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2637</td>
    <td class="codeLine">      Pass.DeadInsts.push_back(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2637</td>
    <td class="codeLine">      Pass.DeadInsts.push_back(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2638</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2638</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2639</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2639</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2640</td>
    <td class="codeLine">  Value *rewriteVectorizedLoadInst(LoadInst &LI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2640</td>
    <td class="codeLine">  Value *rewriteVectorizedLoadInst(LoadInst &LI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2641</td>
    <td class="codeLine">    unsigned BeginIndex = getIndex(NewBeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2641</td>
    <td class="codeLine">    unsigned BeginIndex = getIndex(NewBeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2642</td>
    <td class="codeLine">    unsigned EndIndex = getIndex(NewEndOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2642</td>
    <td class="codeLine">    unsigned EndIndex = getIndex(NewEndOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2643</td>
    <td class="codeLine">    assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2643</td>
    <td class="codeLine">    assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2644</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2645</td>
    <td class="codeLine">    LoadInst *Load = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2645</td>
    <td class="codeLine">    LoadInst *Load = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2646</td>
    <td class="codeLine">                                           NewAI.getAlign(), "load");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2646</td>
    <td class="codeLine">                                           NewAI.getAlign(), "load");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2648</td>
    <td class="codeLine">    Load->copyMetadata(LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2648</td>
    <td class="codeLine">    Load->copyMetadata(LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2649</td>
    <td class="codeLine">                            LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2649</td>
    <td class="codeLine">                            LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2650</td>
    <td class="codeLine">    return extractVector(IRB, Load, BeginIndex, EndIndex, "vec");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2650</td>
    <td class="codeLine">    return extractVector(IRB, Load, BeginIndex, EndIndex, "vec");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2651</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2651</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2653</td>
    <td class="codeLine">  Value *rewriteIntegerLoad(LoadInst &LI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2653</td>
    <td class="codeLine">  Value *rewriteIntegerLoad(LoadInst &LI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2654</td>
    <td class="codeLine">    assert(IntTy && "We cannot insert an integer to the alloca");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2654</td>
    <td class="codeLine">    assert(IntTy && "We cannot insert an integer to the alloca");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2655</td>
    <td class="codeLine">    assert(!LI.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2655</td>
    <td class="codeLine">    assert(!LI.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2656</td>
    <td class="codeLine">    Value *V = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2656</td>
    <td class="codeLine">    Value *V = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2657</td>
    <td class="codeLine">                                     NewAI.getAlign(), "load");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2657</td>
    <td class="codeLine">                                     NewAI.getAlign(), "load");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2658</td>
    <td class="codeLine">    V = convertValue(DL, IRB, V, IntTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2658</td>
    <td class="codeLine">    V = convertValue(DL, IRB, V, IntTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2659</td>
    <td class="codeLine">    assert(NewBeginOffset >= NewAllocaBeginOffset && "Out of bounds offset");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2659</td>
    <td class="codeLine">    assert(NewBeginOffset >= NewAllocaBeginOffset && "Out of bounds offset");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2660</td>
    <td class="codeLine">    uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2660</td>
    <td class="codeLine">    uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2661</td>
    <td class="codeLine">    if (Offset > 0 || NewEndOffset < NewAllocaEndOffset) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2661</td>
    <td class="codeLine">    if (Offset > 0 || NewEndOffset < NewAllocaEndOffset) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2662</td>
    <td class="codeLine">      IntegerType *ExtractTy = Type::getIntNTy(LI.getContext(), SliceSize * 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2662</td>
    <td class="codeLine">      IntegerType *ExtractTy = Type::getIntNTy(LI.getContext(), SliceSize * 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2663</td>
    <td class="codeLine">      V = extractInteger(DL, IRB, V, ExtractTy, Offset, "extract");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2663</td>
    <td class="codeLine">      V = extractInteger(DL, IRB, V, ExtractTy, Offset, "extract");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2664</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2664</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2665</td>
    <td class="codeLine">    // It is possible that the extracted type is not the load type. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2665</td>
    <td class="codeLine">    // It is possible that the extracted type is not the load type. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2666</td>
    <td class="codeLine">    // happens if there is a load past the end of the alloca, and as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2666</td>
    <td class="codeLine">    // happens if there is a load past the end of the alloca, and as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2667</td>
    <td class="codeLine">    // a consequence the slice is narrower but still a candidate for integer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2667</td>
    <td class="codeLine">    // a consequence the slice is narrower but still a candidate for integer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2668</td>
    <td class="codeLine">    // lowering. To handle this case, we just zero extend the extracted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2668</td>
    <td class="codeLine">    // lowering. To handle this case, we just zero extend the extracted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2669</td>
    <td class="codeLine">    // integer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2669</td>
    <td class="codeLine">    // integer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2670</td>
    <td class="codeLine">    assert(cast<IntegerType>(LI.getType())->getBitWidth() >= SliceSize * 8 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2670</td>
    <td class="codeLine">    assert(cast<IntegerType>(LI.getType())->getBitWidth() >= SliceSize * 8 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2671</td>
    <td class="codeLine">           "Can only handle an extract for an overly wide load");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2671</td>
    <td class="codeLine">           "Can only handle an extract for an overly wide load");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2672</td>
    <td class="codeLine">    if (cast<IntegerType>(LI.getType())->getBitWidth() > SliceSize * 8)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2672</td>
    <td class="codeLine">    if (cast<IntegerType>(LI.getType())->getBitWidth() > SliceSize * 8)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2673</td>
    <td class="codeLine">      V = IRB.CreateZExt(V, LI.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2673</td>
    <td class="codeLine">      V = IRB.CreateZExt(V, LI.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2674</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2674</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2675</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2675</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2676</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2677</td>
    <td class="codeLine">  bool visitLoadInst(LoadInst &LI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2677</td>
    <td class="codeLine">  bool visitLoadInst(LoadInst &LI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2678</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << LI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2678</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << LI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2679</td>
    <td class="codeLine">    Value *OldOp = LI.getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2679</td>
    <td class="codeLine">    Value *OldOp = LI.getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2680</td>
    <td class="codeLine">    assert(OldOp == OldPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2680</td>
    <td class="codeLine">    assert(OldOp == OldPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2682</td>
    <td class="codeLine">    AAMDNodes AATags = LI.getAAMetadata();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2682</td>
    <td class="codeLine">    AAMDNodes AATags = LI.getAAMetadata();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2684</td>
    <td class="codeLine">    unsigned AS = LI.getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2684</td>
    <td class="codeLine">    unsigned AS = LI.getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2686</td>
    <td class="codeLine">    Type *TargetTy = IsSplit ? Type::getIntNTy(LI.getContext(), SliceSize * 8)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2686</td>
    <td class="codeLine">    Type *TargetTy = IsSplit ? Type::getIntNTy(LI.getContext(), SliceSize * 8)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2687</td>
    <td class="codeLine">                             : LI.getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2687</td>
    <td class="codeLine">                             : LI.getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2688</td>
    <td class="codeLine">    const bool IsLoadPastEnd =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2688</td>
    <td class="codeLine">    const bool IsLoadPastEnd =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2689</td>
    <td class="codeLine">        DL.getTypeStoreSize(TargetTy).getFixedValue() > SliceSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2689</td>
    <td class="codeLine">        DL.getTypeStoreSize(TargetTy).getFixedValue() > SliceSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2690</td>
    <td class="codeLine">    bool IsPtrAdjusted = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2690</td>
    <td class="codeLine">    bool IsPtrAdjusted = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2691</td>
    <td class="codeLine">    Value *V;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2691</td>
    <td class="codeLine">    Value *V;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2692</td>
    <td class="codeLine">    if (VecTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2692</td>
    <td class="codeLine">    if (VecTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2693</td>
    <td class="codeLine">      V = rewriteVectorizedLoadInst(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2693</td>
    <td class="codeLine">      V = rewriteVectorizedLoadInst(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2694</td>
    <td class="codeLine">    } else if (IntTy && LI.getType()->isIntegerTy()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2694</td>
    <td class="codeLine">    } else if (IntTy && LI.getType()->isIntegerTy()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2695</td>
    <td class="codeLine">      V = rewriteIntegerLoad(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2695</td>
    <td class="codeLine">      V = rewriteIntegerLoad(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2696</td>
    <td class="codeLine">    } else if (NewBeginOffset == NewAllocaBeginOffset &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2696</td>
    <td class="codeLine">    } else if (NewBeginOffset == NewAllocaBeginOffset &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2697</td>
    <td class="codeLine">               NewEndOffset == NewAllocaEndOffset &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2697</td>
    <td class="codeLine">               NewEndOffset == NewAllocaEndOffset &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2698</td>
    <td class="codeLine">               (canConvertValue(DL, NewAllocaTy, TargetTy) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2698</td>
    <td class="codeLine">               (canConvertValue(DL, NewAllocaTy, TargetTy) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2699</td>
    <td class="codeLine">                (IsLoadPastEnd && NewAllocaTy->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2699</td>
    <td class="codeLine">                (IsLoadPastEnd && NewAllocaTy->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2700</td>
    <td class="codeLine">                 TargetTy->isIntegerTy()))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2700</td>
    <td class="codeLine">                 TargetTy->isIntegerTy()))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2701</td>
    <td class="codeLine">      Value *NewPtr =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2701</td>
    <td class="codeLine">      Value *NewPtr =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2702</td>
    <td class="codeLine">          getPtrToNewAI(LI.getPointerAddressSpace(), LI.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2702</td>
    <td class="codeLine">          getPtrToNewAI(LI.getPointerAddressSpace(), LI.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2703</td>
    <td class="codeLine">      LoadInst *NewLI = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), NewPtr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2703</td>
    <td class="codeLine">      LoadInst *NewLI = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), NewPtr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2704</td>
    <td class="codeLine">                                              NewAI.getAlign(), LI.isVolatile(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2704</td>
    <td class="codeLine">                                              NewAI.getAlign(), LI.isVolatile(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2705</td>
    <td class="codeLine">                                              LI.getName());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2705</td>
    <td class="codeLine">                                              LI.getName());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2706</td>
    <td class="codeLine">      if (LI.isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2706</td>
    <td class="codeLine">      if (LI.isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2707</td>
    <td class="codeLine">        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2707</td>
    <td class="codeLine">        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2708</td>
    <td class="codeLine">      if (NewLI->isAtomic())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2708</td>
    <td class="codeLine">      if (NewLI->isAtomic())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2709</td>
    <td class="codeLine">        NewLI->setAlignment(LI.getAlign());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2709</td>
    <td class="codeLine">        NewLI->setAlignment(LI.getAlign());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2710</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2711</td>
    <td class="codeLine">      // Copy any metadata that is valid for the new load. This may require</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2711</td>
    <td class="codeLine">      // Copy any metadata that is valid for the new load. This may require</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2712</td>
    <td class="codeLine">      // conversion to a different kind of metadata, e.g. !nonnull might change</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2712</td>
    <td class="codeLine">      // conversion to a different kind of metadata, e.g. !nonnull might change</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2713</td>
    <td class="codeLine">      // to !range or vice versa.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2713</td>
    <td class="codeLine">      // to !range or vice versa.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2714</td>
    <td class="codeLine">      copyMetadataForLoad(*NewLI, LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2714</td>
    <td class="codeLine">      copyMetadataForLoad(*NewLI, LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2716</td>
    <td class="codeLine">      // Do this after copyMetadataForLoad() to preserve the TBAA shift.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2716</td>
    <td class="codeLine">      // Do this after copyMetadataForLoad() to preserve the TBAA shift.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2717</td>
    <td class="codeLine">      if (AATags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2717</td>
    <td class="codeLine">      if (AATags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2718</td>
    <td class="codeLine">        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2718</td>
    <td class="codeLine">        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2720</td>
    <td class="codeLine">      // Try to preserve nonnull metadata</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2720</td>
    <td class="codeLine">      // Try to preserve nonnull metadata</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2721</td>
    <td class="codeLine">      V = NewLI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2721</td>
    <td class="codeLine">      V = NewLI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2723</td>
    <td class="codeLine">      // If this is an integer load past the end of the slice (which means the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2723</td>
    <td class="codeLine">      // If this is an integer load past the end of the slice (which means the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2724</td>
    <td class="codeLine">      // bytes outside the slice are undef or this load is dead) just forcibly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2724</td>
    <td class="codeLine">      // bytes outside the slice are undef or this load is dead) just forcibly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2725</td>
    <td class="codeLine">      // fix the integer size with correct handling of endianness.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2725</td>
    <td class="codeLine">      // fix the integer size with correct handling of endianness.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2726</td>
    <td class="codeLine">      if (auto *AITy = dyn_cast<IntegerType>(NewAllocaTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2726</td>
    <td class="codeLine">      if (auto *AITy = dyn_cast<IntegerType>(NewAllocaTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2727</td>
    <td class="codeLine">        if (auto *TITy = dyn_cast<IntegerType>(TargetTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2727</td>
    <td class="codeLine">        if (auto *TITy = dyn_cast<IntegerType>(TargetTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2728</td>
    <td class="codeLine">          if (AITy->getBitWidth() < TITy->getBitWidth()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2728</td>
    <td class="codeLine">          if (AITy->getBitWidth() < TITy->getBitWidth()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2729</td>
    <td class="codeLine">            V = IRB.CreateZExt(V, TITy, "load.ext");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2729</td>
    <td class="codeLine">            V = IRB.CreateZExt(V, TITy, "load.ext");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2730</td>
    <td class="codeLine">            if (DL.isBigEndian())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2730</td>
    <td class="codeLine">            if (DL.isBigEndian())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2731</td>
    <td class="codeLine">              V = IRB.CreateShl(V, TITy->getBitWidth() - AITy->getBitWidth(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2731</td>
    <td class="codeLine">              V = IRB.CreateShl(V, TITy->getBitWidth() - AITy->getBitWidth(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2732</td>
    <td class="codeLine">                                "endian_shift");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2732</td>
    <td class="codeLine">                                "endian_shift");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2733</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2733</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2734</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2734</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2735</td>
    <td class="codeLine">      Type *LTy = TargetTy->getPointerTo(AS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2735</td>
    <td class="codeLine">      Type *LTy = TargetTy->getPointerTo(AS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2736</td>
    <td class="codeLine">      LoadInst *NewLI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2736</td>
    <td class="codeLine">      LoadInst *NewLI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2737</td>
    <td class="codeLine">          IRB.CreateAlignedLoad(TargetTy, getNewAllocaSlicePtr(IRB, LTy),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2737</td>
    <td class="codeLine">          IRB.CreateAlignedLoad(TargetTy, getNewAllocaSlicePtr(IRB, LTy),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2738</td>
    <td class="codeLine">                                getSliceAlign(), LI.isVolatile(), LI.getName());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2738</td>
    <td class="codeLine">                                getSliceAlign(), LI.isVolatile(), LI.getName());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2739</td>
    <td class="codeLine">      if (AATags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2739</td>
    <td class="codeLine">      if (AATags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2740</td>
    <td class="codeLine">        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2740</td>
    <td class="codeLine">        NewLI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2741</td>
    <td class="codeLine">      if (LI.isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2741</td>
    <td class="codeLine">      if (LI.isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2742</td>
    <td class="codeLine">        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2742</td>
    <td class="codeLine">        NewLI->setAtomic(LI.getOrdering(), LI.getSyncScopeID());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2743</td>
    <td class="codeLine">      NewLI->copyMetadata(LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2743</td>
    <td class="codeLine">      NewLI->copyMetadata(LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2744</td>
    <td class="codeLine">                               LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2744</td>
    <td class="codeLine">                               LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2746</td>
    <td class="codeLine">      V = NewLI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2746</td>
    <td class="codeLine">      V = NewLI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2747</td>
    <td class="codeLine">      IsPtrAdjusted = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2747</td>
    <td class="codeLine">      IsPtrAdjusted = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2748</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2748</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2749</td>
    <td class="codeLine">    V = convertValue(DL, IRB, V, TargetTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2749</td>
    <td class="codeLine">    V = convertValue(DL, IRB, V, TargetTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2751</td>
    <td class="codeLine">    if (IsSplit) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2751</td>
    <td class="codeLine">    if (IsSplit) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2752</td>
    <td class="codeLine">      assert(!LI.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2752</td>
    <td class="codeLine">      assert(!LI.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2753</td>
    <td class="codeLine">      assert(LI.getType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2753</td>
    <td class="codeLine">      assert(LI.getType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2754</td>
    <td class="codeLine">             "Only integer type loads and stores are split");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2754</td>
    <td class="codeLine">             "Only integer type loads and stores are split");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2755</td>
    <td class="codeLine">      assert(SliceSize < DL.getTypeStoreSize(LI.getType()).getFixedValue() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2755</td>
    <td class="codeLine">      assert(SliceSize < DL.getTypeStoreSize(LI.getType()).getFixedValue() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2756</td>
    <td class="codeLine">             "Split load isn't smaller than original load");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2756</td>
    <td class="codeLine">             "Split load isn't smaller than original load");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2757</td>
    <td class="codeLine">      assert(DL.typeSizeEqualsStoreSize(LI.getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2757</td>
    <td class="codeLine">      assert(DL.typeSizeEqualsStoreSize(LI.getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2758</td>
    <td class="codeLine">             "Non-byte-multiple bit width");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2758</td>
    <td class="codeLine">             "Non-byte-multiple bit width");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2759</td>
    <td class="codeLine">      // Move the insertion point just past the load so that we can refer to it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2759</td>
    <td class="codeLine">      // Move the insertion point just past the load so that we can refer to it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2760</td>
    <td class="codeLine">      IRB.SetInsertPoint(&*std::next(BasicBlock::iterator(&LI)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2760</td>
    <td class="codeLine">      IRB.SetInsertPoint(&*std::next(BasicBlock::iterator(&LI)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2761</td>
    <td class="codeLine">      // Create a placeholder value with the same type as LI to use as the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2761</td>
    <td class="codeLine">      // Create a placeholder value with the same type as LI to use as the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2762</td>
    <td class="codeLine">      // basis for the new value. This allows us to replace the uses of LI with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2762</td>
    <td class="codeLine">      // basis for the new value. This allows us to replace the uses of LI with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2763</td>
    <td class="codeLine">      // the computed value, and then replace the placeholder with LI, leaving</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2763</td>
    <td class="codeLine">      // the computed value, and then replace the placeholder with LI, leaving</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2764</td>
    <td class="codeLine">      // LI only used for this computation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2764</td>
    <td class="codeLine">      // LI only used for this computation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2765</td>
    <td class="codeLine">      Value *Placeholder = new LoadInst(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2765</td>
    <td class="codeLine">      Value *Placeholder = new LoadInst(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2766</td>
    <td class="codeLine">          LI.getType(), PoisonValue::get(LI.getType()->getPointerTo(AS)), "",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2766</td>
    <td class="codeLine">          LI.getType(), PoisonValue::get(LI.getType()->getPointerTo(AS)), "",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2767</td>
    <td class="codeLine">          false, Align(1));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2767</td>
    <td class="codeLine">          false, Align(1));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2768</td>
    <td class="codeLine">      V = insertInteger(DL, IRB, Placeholder, V, NewBeginOffset - BeginOffset,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2768</td>
    <td class="codeLine">      V = insertInteger(DL, IRB, Placeholder, V, NewBeginOffset - BeginOffset,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2769</td>
    <td class="codeLine">                        "insert");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2769</td>
    <td class="codeLine">                        "insert");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2770</td>
    <td class="codeLine">      LI.replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2770</td>
    <td class="codeLine">      LI.replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2771</td>
    <td class="codeLine">      Placeholder->replaceAllUsesWith(&LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2771</td>
    <td class="codeLine">      Placeholder->replaceAllUsesWith(&LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2772</td>
    <td class="codeLine">      Placeholder->deleteValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2772</td>
    <td class="codeLine">      Placeholder->deleteValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2773</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2773</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2774</td>
    <td class="codeLine">      LI.replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2774</td>
    <td class="codeLine">      LI.replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2775</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2775</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2777</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2777</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2778</td>
    <td class="codeLine">    deleteIfTriviallyDead(OldOp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2778</td>
    <td class="codeLine">    deleteIfTriviallyDead(OldOp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2779</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2779</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2780</td>
    <td class="codeLine">    return !LI.isVolatile() && !IsPtrAdjusted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2780</td>
    <td class="codeLine">    return !LI.isVolatile() && !IsPtrAdjusted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2781</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2781</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2782</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2782</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2783</td>
    <td class="codeLine">  bool rewriteVectorizedStoreInst(Value *V, StoreInst &SI, Value *OldOp,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2783</td>
    <td class="codeLine">  bool rewriteVectorizedStoreInst(Value *V, StoreInst &SI, Value *OldOp,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2784</td>
    <td class="codeLine">                                  AAMDNodes AATags) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2784</td>
    <td class="codeLine">                                  AAMDNodes AATags) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2785</td>
    <td class="codeLine">    // Capture V for the purpose of debug-info accounting once it's converted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2785</td>
    <td class="codeLine">    // Capture V for the purpose of debug-info accounting once it's converted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2786</td>
    <td class="codeLine">    // to a vector store.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2786</td>
    <td class="codeLine">    // to a vector store.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2787</td>
    <td class="codeLine">    Value *OrigV = V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2787</td>
    <td class="codeLine">    Value *OrigV = V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2788</td>
    <td class="codeLine">    if (V->getType() != VecTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2788</td>
    <td class="codeLine">    if (V->getType() != VecTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2789</td>
    <td class="codeLine">      unsigned BeginIndex = getIndex(NewBeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2789</td>
    <td class="codeLine">      unsigned BeginIndex = getIndex(NewBeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2790</td>
    <td class="codeLine">      unsigned EndIndex = getIndex(NewEndOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2790</td>
    <td class="codeLine">      unsigned EndIndex = getIndex(NewEndOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2791</td>
    <td class="codeLine">      assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2791</td>
    <td class="codeLine">      assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2792</td>
    <td class="codeLine">      unsigned NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2792</td>
    <td class="codeLine">      unsigned NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2793</td>
    <td class="codeLine">      assert(NumElements <= cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2793</td>
    <td class="codeLine">      assert(NumElements <= cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2794</td>
    <td class="codeLine">             "Too many elements!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2794</td>
    <td class="codeLine">             "Too many elements!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2795</td>
    <td class="codeLine">      Type *SliceTy = (NumElements == 1)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2795</td>
    <td class="codeLine">      Type *SliceTy = (NumElements == 1)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2796</td>
    <td class="codeLine">                          ? ElementTy</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2796</td>
    <td class="codeLine">                          ? ElementTy</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2797</td>
    <td class="codeLine">                          : FixedVectorType::get(ElementTy, NumElements);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2797</td>
    <td class="codeLine">                          : FixedVectorType::get(ElementTy, NumElements);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2798</td>
    <td class="codeLine">      if (V->getType() != SliceTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2798</td>
    <td class="codeLine">      if (V->getType() != SliceTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2799</td>
    <td class="codeLine">        V = convertValue(DL, IRB, V, SliceTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2799</td>
    <td class="codeLine">        V = convertValue(DL, IRB, V, SliceTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2801</td>
    <td class="codeLine">      // Mix in the existing elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2801</td>
    <td class="codeLine">      // Mix in the existing elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2802</td>
    <td class="codeLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2802</td>
    <td class="codeLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2803</td>
    <td class="codeLine">                                         NewAI.getAlign(), "load");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2803</td>
    <td class="codeLine">                                         NewAI.getAlign(), "load");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2804</td>
    <td class="codeLine">      V = insertVector(IRB, Old, V, BeginIndex, "vec");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2804</td>
    <td class="codeLine">      V = insertVector(IRB, Old, V, BeginIndex, "vec");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2805</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2805</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2806</td>
    <td class="codeLine">    StoreInst *Store = IRB.CreateAlignedStore(V, &NewAI, NewAI.getAlign());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2806</td>
    <td class="codeLine">    StoreInst *Store = IRB.CreateAlignedStore(V, &NewAI, NewAI.getAlign());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2807</td>
    <td class="codeLine">    Store->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2807</td>
    <td class="codeLine">    Store->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2808</td>
    <td class="codeLine">                             LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2808</td>
    <td class="codeLine">                             LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2809</td>
    <td class="codeLine">    if (AATags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2809</td>
    <td class="codeLine">    if (AATags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2810</td>
    <td class="codeLine">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2810</td>
    <td class="codeLine">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2811</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2811</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2813</td>
    <td class="codeLine">    // NOTE: Careful to use OrigV rather than V.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2813</td>
    <td class="codeLine">    // NOTE: Careful to use OrigV rather than V.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2814</td>
    <td class="codeLine">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2814</td>
    <td class="codeLine">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2815</td>
    <td class="codeLine">                     Store, Store->getPointerOperand(), OrigV, DL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2815</td>
    <td class="codeLine">                     Store, Store->getPointerOperand(), OrigV, DL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2816</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2816</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2817</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2817</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2818</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2818</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2819</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2819</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2820</td>
    <td class="codeLine">  bool rewriteIntegerStore(Value *V, StoreInst &SI, AAMDNodes AATags) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2820</td>
    <td class="codeLine">  bool rewriteIntegerStore(Value *V, StoreInst &SI, AAMDNodes AATags) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2821</td>
    <td class="codeLine">    assert(IntTy && "We cannot extract an integer from the alloca");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2821</td>
    <td class="codeLine">    assert(IntTy && "We cannot extract an integer from the alloca");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2822</td>
    <td class="codeLine">    assert(!SI.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2822</td>
    <td class="codeLine">    assert(!SI.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2823</td>
    <td class="codeLine">    if (DL.getTypeSizeInBits(V->getType()).getFixedValue() !=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2823</td>
    <td class="codeLine">    if (DL.getTypeSizeInBits(V->getType()).getFixedValue() !=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2824</td>
    <td class="codeLine">        IntTy->getBitWidth()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2824</td>
    <td class="codeLine">        IntTy->getBitWidth()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2825</td>
    <td class="codeLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2825</td>
    <td class="codeLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2826</td>
    <td class="codeLine">                                         NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2826</td>
    <td class="codeLine">                                         NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2827</td>
    <td class="codeLine">      Old = convertValue(DL, IRB, Old, IntTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2827</td>
    <td class="codeLine">      Old = convertValue(DL, IRB, Old, IntTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2828</td>
    <td class="codeLine">      assert(BeginOffset >= NewAllocaBeginOffset && "Out of bounds offset");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2828</td>
    <td class="codeLine">      assert(BeginOffset >= NewAllocaBeginOffset && "Out of bounds offset");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2829</td>
    <td class="codeLine">      uint64_t Offset = BeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2829</td>
    <td class="codeLine">      uint64_t Offset = BeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2830</td>
    <td class="codeLine">      V = insertInteger(DL, IRB, Old, SI.getValueOperand(), Offset, "insert");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2830</td>
    <td class="codeLine">      V = insertInteger(DL, IRB, Old, SI.getValueOperand(), Offset, "insert");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2831</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2831</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2832</td>
    <td class="codeLine">    V = convertValue(DL, IRB, V, NewAllocaTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2832</td>
    <td class="codeLine">    V = convertValue(DL, IRB, V, NewAllocaTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2833</td>
    <td class="codeLine">    StoreInst *Store = IRB.CreateAlignedStore(V, &NewAI, NewAI.getAlign());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2833</td>
    <td class="codeLine">    StoreInst *Store = IRB.CreateAlignedStore(V, &NewAI, NewAI.getAlign());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2834</td>
    <td class="codeLine">    Store->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2834</td>
    <td class="codeLine">    Store->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2835</td>
    <td class="codeLine">                             LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2835</td>
    <td class="codeLine">                             LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2836</td>
    <td class="codeLine">    if (AATags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2836</td>
    <td class="codeLine">    if (AATags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2837</td>
    <td class="codeLine">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2837</td>
    <td class="codeLine">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2838</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2838</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2839</td>
    <td class="codeLine">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2839</td>
    <td class="codeLine">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2840</td>
    <td class="codeLine">                     Store, Store->getPointerOperand(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2840</td>
    <td class="codeLine">                     Store, Store->getPointerOperand(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2841</td>
    <td class="codeLine">                     Store->getValueOperand(), DL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2841</td>
    <td class="codeLine">                     Store->getValueOperand(), DL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2842</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2842</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2843</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2843</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2844</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2844</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2845</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2845</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2846</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2846</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2848</td>
    <td class="codeLine">  bool visitStoreInst(StoreInst &SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2848</td>
    <td class="codeLine">  bool visitStoreInst(StoreInst &SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2849</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2849</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2850</td>
    <td class="codeLine">    Value *OldOp = SI.getOperand(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2850</td>
    <td class="codeLine">    Value *OldOp = SI.getOperand(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2851</td>
    <td class="codeLine">    assert(OldOp == OldPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2851</td>
    <td class="codeLine">    assert(OldOp == OldPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2852</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2852</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2853</td>
    <td class="codeLine">    AAMDNodes AATags = SI.getAAMetadata();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2853</td>
    <td class="codeLine">    AAMDNodes AATags = SI.getAAMetadata();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2854</td>
    <td class="codeLine">    Value *V = SI.getValueOperand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2854</td>
    <td class="codeLine">    Value *V = SI.getValueOperand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2856</td>
    <td class="codeLine">    // Strip all inbounds GEPs and pointer casts to try to dig out any root</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2856</td>
    <td class="codeLine">    // Strip all inbounds GEPs and pointer casts to try to dig out any root</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2857</td>
    <td class="codeLine">    // alloca that should be re-examined after promoting this alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2857</td>
    <td class="codeLine">    // alloca that should be re-examined after promoting this alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2858</td>
    <td class="codeLine">    if (V->getType()->isPointerTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2858</td>
    <td class="codeLine">    if (V->getType()->isPointerTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2859</td>
    <td class="codeLine">      if (AllocaInst *AI = dyn_cast<AllocaInst>(V->stripInBoundsOffsets()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2859</td>
    <td class="codeLine">      if (AllocaInst *AI = dyn_cast<AllocaInst>(V->stripInBoundsOffsets()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2860</td>
    <td class="codeLine">        Pass.PostPromotionWorklist.insert(AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2860</td>
    <td class="codeLine">        Pass.PostPromotionWorklist.insert(AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2861</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2862</td>
    <td class="codeLine">    if (SliceSize < DL.getTypeStoreSize(V->getType()).getFixedValue()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2862</td>
    <td class="codeLine">    if (SliceSize < DL.getTypeStoreSize(V->getType()).getFixedValue()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2863</td>
    <td class="codeLine">      assert(!SI.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2863</td>
    <td class="codeLine">      assert(!SI.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2864</td>
    <td class="codeLine">      assert(V->getType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2864</td>
    <td class="codeLine">      assert(V->getType()->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2865</td>
    <td class="codeLine">             "Only integer type loads and stores are split");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2865</td>
    <td class="codeLine">             "Only integer type loads and stores are split");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2866</td>
    <td class="codeLine">      assert(DL.typeSizeEqualsStoreSize(V->getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2866</td>
    <td class="codeLine">      assert(DL.typeSizeEqualsStoreSize(V->getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2867</td>
    <td class="codeLine">             "Non-byte-multiple bit width");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2867</td>
    <td class="codeLine">             "Non-byte-multiple bit width");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2868</td>
    <td class="codeLine">      IntegerType *NarrowTy = Type::getIntNTy(SI.getContext(), SliceSize * 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2868</td>
    <td class="codeLine">      IntegerType *NarrowTy = Type::getIntNTy(SI.getContext(), SliceSize * 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2869</td>
    <td class="codeLine">      V = extractInteger(DL, IRB, V, NarrowTy, NewBeginOffset - BeginOffset,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2869</td>
    <td class="codeLine">      V = extractInteger(DL, IRB, V, NarrowTy, NewBeginOffset - BeginOffset,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2870</td>
    <td class="codeLine">                         "extract");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2870</td>
    <td class="codeLine">                         "extract");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2871</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2871</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2873</td>
    <td class="codeLine">    if (VecTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2873</td>
    <td class="codeLine">    if (VecTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2874</td>
    <td class="codeLine">      return rewriteVectorizedStoreInst(V, SI, OldOp, AATags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2874</td>
    <td class="codeLine">      return rewriteVectorizedStoreInst(V, SI, OldOp, AATags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2875</td>
    <td class="codeLine">    if (IntTy && V->getType()->isIntegerTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2875</td>
    <td class="codeLine">    if (IntTy && V->getType()->isIntegerTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2876</td>
    <td class="codeLine">      return rewriteIntegerStore(V, SI, AATags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2876</td>
    <td class="codeLine">      return rewriteIntegerStore(V, SI, AATags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2877</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2878</td>
    <td class="codeLine">    const bool IsStorePastEnd =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2878</td>
    <td class="codeLine">    const bool IsStorePastEnd =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2879</td>
    <td class="codeLine">        DL.getTypeStoreSize(V->getType()).getFixedValue() > SliceSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2879</td>
    <td class="codeLine">        DL.getTypeStoreSize(V->getType()).getFixedValue() > SliceSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2880</td>
    <td class="codeLine">    StoreInst *NewSI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2880</td>
    <td class="codeLine">    StoreInst *NewSI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2881</td>
    <td class="codeLine">    if (NewBeginOffset == NewAllocaBeginOffset &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2881</td>
    <td class="codeLine">    if (NewBeginOffset == NewAllocaBeginOffset &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2882</td>
    <td class="codeLine">        NewEndOffset == NewAllocaEndOffset &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2882</td>
    <td class="codeLine">        NewEndOffset == NewAllocaEndOffset &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2883</td>
    <td class="codeLine">        (canConvertValue(DL, V->getType(), NewAllocaTy) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2883</td>
    <td class="codeLine">        (canConvertValue(DL, V->getType(), NewAllocaTy) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2884</td>
    <td class="codeLine">         (IsStorePastEnd && NewAllocaTy->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2884</td>
    <td class="codeLine">         (IsStorePastEnd && NewAllocaTy->isIntegerTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2885</td>
    <td class="codeLine">          V->getType()->isIntegerTy()))) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2885</td>
    <td class="codeLine">          V->getType()->isIntegerTy()))) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2886</td>
    <td class="codeLine">      // If this is an integer store past the end of slice (and thus the bytes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2886</td>
    <td class="codeLine">      // If this is an integer store past the end of slice (and thus the bytes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2887</td>
    <td class="codeLine">      // past that point are irrelevant or this is unreachable), truncate the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2887</td>
    <td class="codeLine">      // past that point are irrelevant or this is unreachable), truncate the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2888</td>
    <td class="codeLine">      // value prior to storing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2888</td>
    <td class="codeLine">      // value prior to storing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2889</td>
    <td class="codeLine">      if (auto *VITy = dyn_cast<IntegerType>(V->getType()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2889</td>
    <td class="codeLine">      if (auto *VITy = dyn_cast<IntegerType>(V->getType()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2890</td>
    <td class="codeLine">        if (auto *AITy = dyn_cast<IntegerType>(NewAllocaTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2890</td>
    <td class="codeLine">        if (auto *AITy = dyn_cast<IntegerType>(NewAllocaTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2891</td>
    <td class="codeLine">          if (VITy->getBitWidth() > AITy->getBitWidth()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2891</td>
    <td class="codeLine">          if (VITy->getBitWidth() > AITy->getBitWidth()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2892</td>
    <td class="codeLine">            if (DL.isBigEndian())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2892</td>
    <td class="codeLine">            if (DL.isBigEndian())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2893</td>
    <td class="codeLine">              V = IRB.CreateLShr(V, VITy->getBitWidth() - AITy->getBitWidth(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2893</td>
    <td class="codeLine">              V = IRB.CreateLShr(V, VITy->getBitWidth() - AITy->getBitWidth(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2894</td>
    <td class="codeLine">                                 "endian_shift");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2894</td>
    <td class="codeLine">                                 "endian_shift");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2895</td>
    <td class="codeLine">            V = IRB.CreateTrunc(V, AITy, "load.trunc");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2895</td>
    <td class="codeLine">            V = IRB.CreateTrunc(V, AITy, "load.trunc");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2896</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2896</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2898</td>
    <td class="codeLine">      V = convertValue(DL, IRB, V, NewAllocaTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2898</td>
    <td class="codeLine">      V = convertValue(DL, IRB, V, NewAllocaTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2899</td>
    <td class="codeLine">      Value *NewPtr =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2899</td>
    <td class="codeLine">      Value *NewPtr =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2900</td>
    <td class="codeLine">          getPtrToNewAI(SI.getPointerAddressSpace(), SI.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2900</td>
    <td class="codeLine">          getPtrToNewAI(SI.getPointerAddressSpace(), SI.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2901</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2901</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2902</td>
    <td class="codeLine">      NewSI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2902</td>
    <td class="codeLine">      NewSI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2903</td>
    <td class="codeLine">          IRB.CreateAlignedStore(V, NewPtr, NewAI.getAlign(), SI.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2903</td>
    <td class="codeLine">          IRB.CreateAlignedStore(V, NewPtr, NewAI.getAlign(), SI.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2904</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2904</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2905</td>
    <td class="codeLine">      unsigned AS = SI.getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2905</td>
    <td class="codeLine">      unsigned AS = SI.getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2906</td>
    <td class="codeLine">      Value *NewPtr = getNewAllocaSlicePtr(IRB, V->getType()->getPointerTo(AS));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2906</td>
    <td class="codeLine">      Value *NewPtr = getNewAllocaSlicePtr(IRB, V->getType()->getPointerTo(AS));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2907</td>
    <td class="codeLine">      NewSI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2907</td>
    <td class="codeLine">      NewSI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2908</td>
    <td class="codeLine">          IRB.CreateAlignedStore(V, NewPtr, getSliceAlign(), SI.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2908</td>
    <td class="codeLine">          IRB.CreateAlignedStore(V, NewPtr, getSliceAlign(), SI.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2909</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2909</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2910</td>
    <td class="codeLine">    NewSI->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2910</td>
    <td class="codeLine">    NewSI->copyMetadata(SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2911</td>
    <td class="codeLine">                             LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2911</td>
    <td class="codeLine">                             LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2912</td>
    <td class="codeLine">    if (AATags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2912</td>
    <td class="codeLine">    if (AATags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2913</td>
    <td class="codeLine">      NewSI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2913</td>
    <td class="codeLine">      NewSI->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2914</td>
    <td class="codeLine">    if (SI.isVolatile())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2914</td>
    <td class="codeLine">    if (SI.isVolatile())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2915</td>
    <td class="codeLine">      NewSI->setAtomic(SI.getOrdering(), SI.getSyncScopeID());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2915</td>
    <td class="codeLine">      NewSI->setAtomic(SI.getOrdering(), SI.getSyncScopeID());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2916</td>
    <td class="codeLine">    if (NewSI->isAtomic())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2916</td>
    <td class="codeLine">    if (NewSI->isAtomic())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2917</td>
    <td class="codeLine">      NewSI->setAlignment(SI.getAlign());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2917</td>
    <td class="codeLine">      NewSI->setAlignment(SI.getAlign());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2918</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2918</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2919</td>
    <td class="codeLine">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2919</td>
    <td class="codeLine">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &SI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2920</td>
    <td class="codeLine">                     NewSI, NewSI->getPointerOperand(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2920</td>
    <td class="codeLine">                     NewSI, NewSI->getPointerOperand(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2921</td>
    <td class="codeLine">                     NewSI->getValueOperand(), DL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2921</td>
    <td class="codeLine">                     NewSI->getValueOperand(), DL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2922</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2923</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2923</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2924</td>
    <td class="codeLine">    deleteIfTriviallyDead(OldOp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2924</td>
    <td class="codeLine">    deleteIfTriviallyDead(OldOp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2925</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2925</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2926</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *NewSI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2926</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *NewSI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2927</td>
    <td class="codeLine">    return NewSI->getPointerOperand() == &NewAI &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2927</td>
    <td class="codeLine">    return NewSI->getPointerOperand() == &NewAI &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2928</td>
    <td class="codeLine">           NewSI->getValueOperand()->getType() == NewAllocaTy &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2928</td>
    <td class="codeLine">           NewSI->getValueOperand()->getType() == NewAllocaTy &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2929</td>
    <td class="codeLine">           !SI.isVolatile();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2929</td>
    <td class="codeLine">           !SI.isVolatile();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2930</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2930</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2931</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2932</td>
    <td class="codeLine">  /// Compute an integer value from splatting an i8 across the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2932</td>
    <td class="codeLine">  /// Compute an integer value from splatting an i8 across the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2933</td>
    <td class="codeLine">  /// number of bytes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2933</td>
    <td class="codeLine">  /// number of bytes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2934</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2934</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2935</td>
    <td class="codeLine">  /// Note that this routine assumes an i8 is a byte. If that isn't true, don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2935</td>
    <td class="codeLine">  /// Note that this routine assumes an i8 is a byte. If that isn't true, don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2936</td>
    <td class="codeLine">  /// call this routine.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2936</td>
    <td class="codeLine">  /// call this routine.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2937</td>
    <td class="codeLine">  /// FIXME: Heed the advice above.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2937</td>
    <td class="codeLine">  /// FIXME: Heed the advice above.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2938</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2938</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2939</td>
    <td class="codeLine">  /// \param V The i8 value to splat.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2939</td>
    <td class="codeLine">  /// \param V The i8 value to splat.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2940</td>
    <td class="codeLine">  /// \param Size The number of bytes in the output (assuming i8 is one byte)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2940</td>
    <td class="codeLine">  /// \param Size The number of bytes in the output (assuming i8 is one byte)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2941</td>
    <td class="codeLine">  Value *getIntegerSplat(Value *V, unsigned Size) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2941</td>
    <td class="codeLine">  Value *getIntegerSplat(Value *V, unsigned Size) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2942</td>
    <td class="codeLine">    assert(Size > 0 && "Expected a positive number of bytes.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2942</td>
    <td class="codeLine">    assert(Size > 0 && "Expected a positive number of bytes.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2943</td>
    <td class="codeLine">    IntegerType *VTy = cast<IntegerType>(V->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2943</td>
    <td class="codeLine">    IntegerType *VTy = cast<IntegerType>(V->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2944</td>
    <td class="codeLine">    assert(VTy->getBitWidth() == 8 && "Expected an i8 value for the byte");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2944</td>
    <td class="codeLine">    assert(VTy->getBitWidth() == 8 && "Expected an i8 value for the byte");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2945</td>
    <td class="codeLine">    if (Size == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2945</td>
    <td class="codeLine">    if (Size == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2946</td>
    <td class="codeLine">      return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2946</td>
    <td class="codeLine">      return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2947</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2948</td>
    <td class="codeLine">    Type *SplatIntTy = Type::getIntNTy(VTy->getContext(), Size * 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2948</td>
    <td class="codeLine">    Type *SplatIntTy = Type::getIntNTy(VTy->getContext(), Size * 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2949</td>
    <td class="codeLine">    V = IRB.CreateMul(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2949</td>
    <td class="codeLine">    V = IRB.CreateMul(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2950</td>
    <td class="codeLine">        IRB.CreateZExt(V, SplatIntTy, "zext"),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2950</td>
    <td class="codeLine">        IRB.CreateZExt(V, SplatIntTy, "zext"),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2951</td>
    <td class="codeLine">        IRB.CreateUDiv(Constant::getAllOnesValue(SplatIntTy),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2951</td>
    <td class="codeLine">        IRB.CreateUDiv(Constant::getAllOnesValue(SplatIntTy),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2952</td>
    <td class="codeLine">                       IRB.CreateZExt(Constant::getAllOnesValue(V->getType()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2952</td>
    <td class="codeLine">                       IRB.CreateZExt(Constant::getAllOnesValue(V->getType()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2953</td>
    <td class="codeLine">                                      SplatIntTy)),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2953</td>
    <td class="codeLine">                                      SplatIntTy)),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2954</td>
    <td class="codeLine">        "isplat");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2954</td>
    <td class="codeLine">        "isplat");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2955</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2955</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2956</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2956</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2957</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2957</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2958</td>
    <td class="codeLine">  /// Compute a vector splat for a given element value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2958</td>
    <td class="codeLine">  /// Compute a vector splat for a given element value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2959</td>
    <td class="codeLine">  Value *getVectorSplat(Value *V, unsigned NumElements) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2959</td>
    <td class="codeLine">  Value *getVectorSplat(Value *V, unsigned NumElements) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2960</td>
    <td class="codeLine">    V = IRB.CreateVectorSplat(NumElements, V, "vsplat");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2960</td>
    <td class="codeLine">    V = IRB.CreateVectorSplat(NumElements, V, "vsplat");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2961</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "       splat: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2961</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "       splat: " << *V << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2962</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2962</td>
    <td class="codeLine">    return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2963</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2963</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2964</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2965</td>
    <td class="codeLine">  bool visitMemSetInst(MemSetInst &II) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2965</td>
    <td class="codeLine">  bool visitMemSetInst(MemSetInst &II) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2966</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2966</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2967</td>
    <td class="codeLine">    assert(II.getRawDest() == OldPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2967</td>
    <td class="codeLine">    assert(II.getRawDest() == OldPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2969</td>
    <td class="codeLine">    AAMDNodes AATags = II.getAAMetadata();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2969</td>
    <td class="codeLine">    AAMDNodes AATags = II.getAAMetadata();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2971</td>
    <td class="codeLine">    // If the memset has a variable size, it cannot be split, just adjust the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2971</td>
    <td class="codeLine">    // If the memset has a variable size, it cannot be split, just adjust the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2972</td>
    <td class="codeLine">    // pointer to the new alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2972</td>
    <td class="codeLine">    // pointer to the new alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2973</td>
    <td class="codeLine">    if (!isa<ConstantInt>(II.getLength())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2973</td>
    <td class="codeLine">    if (!isa<ConstantInt>(II.getLength())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2974</td>
    <td class="codeLine">      assert(!IsSplit);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2974</td>
    <td class="codeLine">      assert(!IsSplit);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2975</td>
    <td class="codeLine">      assert(NewBeginOffset == BeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2975</td>
    <td class="codeLine">      assert(NewBeginOffset == BeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2976</td>
    <td class="codeLine">      II.setDest(getNewAllocaSlicePtr(IRB, OldPtr->getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2976</td>
    <td class="codeLine">      II.setDest(getNewAllocaSlicePtr(IRB, OldPtr->getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2977</td>
    <td class="codeLine">      II.setDestAlignment(getSliceAlign());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2977</td>
    <td class="codeLine">      II.setDestAlignment(getSliceAlign());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2978</td>
    <td class="codeLine">      // In theory we should call migrateDebugInfo here. However, we do not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2978</td>
    <td class="codeLine">      // In theory we should call migrateDebugInfo here. However, we do not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2979</td>
    <td class="codeLine">      // emit dbg.assign intrinsics for mem intrinsics storing through non-</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2979</td>
    <td class="codeLine">      // emit dbg.assign intrinsics for mem intrinsics storing through non-</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2980</td>
    <td class="codeLine">      // constant geps, or storing a variable number of bytes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2980</td>
    <td class="codeLine">      // constant geps, or storing a variable number of bytes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2981</td>
    <td class="codeLine">      assert(at::getAssignmentMarkers(&II).empty() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2981</td>
    <td class="codeLine">      assert(at::getAssignmentMarkers(&II).empty() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2982</td>
    <td class="codeLine">             "AT: Unexpected link to non-const GEP");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2982</td>
    <td class="codeLine">             "AT: Unexpected link to non-const GEP");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2983</td>
    <td class="codeLine">      deleteIfTriviallyDead(OldPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2983</td>
    <td class="codeLine">      deleteIfTriviallyDead(OldPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2984</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2984</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2985</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2985</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2986</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2986</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2987</td>
    <td class="codeLine">    // Record this instruction for deletion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2987</td>
    <td class="codeLine">    // Record this instruction for deletion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2988</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2988</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2989</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2990</td>
    <td class="codeLine">    Type *AllocaTy = NewAI.getAllocatedType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2990</td>
    <td class="codeLine">    Type *AllocaTy = NewAI.getAllocatedType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2991</td>
    <td class="codeLine">    Type *ScalarTy = AllocaTy->getScalarType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2991</td>
    <td class="codeLine">    Type *ScalarTy = AllocaTy->getScalarType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2993</td>
    <td class="codeLine">    const bool CanContinue = [&]() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2993</td>
    <td class="codeLine">    const bool CanContinue = [&]() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2994</td>
    <td class="codeLine">      if (VecTy || IntTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2994</td>
    <td class="codeLine">      if (VecTy || IntTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2995</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2995</td>
    <td class="codeLine">        return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2996</td>
    <td class="codeLine">      if (BeginOffset > NewAllocaBeginOffset ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2996</td>
    <td class="codeLine">      if (BeginOffset > NewAllocaBeginOffset ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2997</td>
    <td class="codeLine">          EndOffset < NewAllocaEndOffset)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2997</td>
    <td class="codeLine">          EndOffset < NewAllocaEndOffset)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2998</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2998</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2999</td>
    <td class="codeLine">      // Length must be in range for FixedVectorType.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2999</td>
    <td class="codeLine">      // Length must be in range for FixedVectorType.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3000</td>
    <td class="codeLine">      auto *C = cast<ConstantInt>(II.getLength());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3000</td>
    <td class="codeLine">      auto *C = cast<ConstantInt>(II.getLength());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3001</td>
    <td class="codeLine">      const uint64_t Len = C->getLimitedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3001</td>
    <td class="codeLine">      const uint64_t Len = C->getLimitedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3002</td>
    <td class="codeLine">      if (Len > std::numeric_limits<unsigned>::max())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3002</td>
    <td class="codeLine">      if (Len > std::numeric_limits<unsigned>::max())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3003</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3003</td>
    <td class="codeLine">        return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3004</td>
    <td class="codeLine">      auto *Int8Ty = IntegerType::getInt8Ty(NewAI.getContext());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3004</td>
    <td class="codeLine">      auto *Int8Ty = IntegerType::getInt8Ty(NewAI.getContext());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3005</td>
    <td class="codeLine">      auto *SrcTy = FixedVectorType::get(Int8Ty, Len);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3005</td>
    <td class="codeLine">      auto *SrcTy = FixedVectorType::get(Int8Ty, Len);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3006</td>
    <td class="codeLine">      return canConvertValue(DL, SrcTy, AllocaTy) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3006</td>
    <td class="codeLine">      return canConvertValue(DL, SrcTy, AllocaTy) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3007</td>
    <td class="codeLine">             DL.isLegalInteger(DL.getTypeSizeInBits(ScalarTy).getFixedValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3007</td>
    <td class="codeLine">             DL.isLegalInteger(DL.getTypeSizeInBits(ScalarTy).getFixedValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3008</td>
    <td class="codeLine">    }();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3008</td>
    <td class="codeLine">    }();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3010</td>
    <td class="codeLine">    // If this doesn't map cleanly onto the alloca type, and that type isn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3010</td>
    <td class="codeLine">    // If this doesn't map cleanly onto the alloca type, and that type isn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3011</td>
    <td class="codeLine">    // a single value type, just emit a memset.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3011</td>
    <td class="codeLine">    // a single value type, just emit a memset.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3012</td>
    <td class="codeLine">    if (!CanContinue) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3012</td>
    <td class="codeLine">    if (!CanContinue) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3013</td>
    <td class="codeLine">      Type *SizeTy = II.getLength()->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3013</td>
    <td class="codeLine">      Type *SizeTy = II.getLength()->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3014</td>
    <td class="codeLine">      Constant *Size = ConstantInt::get(SizeTy, NewEndOffset - NewBeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3014</td>
    <td class="codeLine">      Constant *Size = ConstantInt::get(SizeTy, NewEndOffset - NewBeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3015</td>
    <td class="codeLine">      MemIntrinsic *New = cast<MemIntrinsic>(IRB.CreateMemSet(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3015</td>
    <td class="codeLine">      MemIntrinsic *New = cast<MemIntrinsic>(IRB.CreateMemSet(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3016</td>
    <td class="codeLine">          getNewAllocaSlicePtr(IRB, OldPtr->getType()), II.getValue(), Size,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3016</td>
    <td class="codeLine">          getNewAllocaSlicePtr(IRB, OldPtr->getType()), II.getValue(), Size,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3017</td>
    <td class="codeLine">          MaybeAlign(getSliceAlign()), II.isVolatile()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3017</td>
    <td class="codeLine">          MaybeAlign(getSliceAlign()), II.isVolatile()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3018</td>
    <td class="codeLine">      if (AATags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3018</td>
    <td class="codeLine">      if (AATags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3019</td>
    <td class="codeLine">        New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3019</td>
    <td class="codeLine">        New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3021</td>
    <td class="codeLine">      migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3021</td>
    <td class="codeLine">      migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3022</td>
    <td class="codeLine">                       New, New->getRawDest(), nullptr, DL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3022</td>
    <td class="codeLine">                       New, New->getRawDest(), nullptr, DL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3024</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3024</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3025</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3025</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3026</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3026</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3027</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3027</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3028</td>
    <td class="codeLine">    // If we can represent this as a simple value, we have to build the actual</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3028</td>
    <td class="codeLine">    // If we can represent this as a simple value, we have to build the actual</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3029</td>
    <td class="codeLine">    // value to store, which requires expanding the byte present in memset to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3029</td>
    <td class="codeLine">    // value to store, which requires expanding the byte present in memset to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3030</td>
    <td class="codeLine">    // a sensible representation for the alloca type. This is essentially</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3030</td>
    <td class="codeLine">    // a sensible representation for the alloca type. This is essentially</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3031</td>
    <td class="codeLine">    // splatting the byte to a sufficiently wide integer, splatting it across</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3031</td>
    <td class="codeLine">    // splatting the byte to a sufficiently wide integer, splatting it across</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3032</td>
    <td class="codeLine">    // any desired vector width, and bitcasting to the final type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3032</td>
    <td class="codeLine">    // any desired vector width, and bitcasting to the final type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3033</td>
    <td class="codeLine">    Value *V;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3033</td>
    <td class="codeLine">    Value *V;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3034</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3035</td>
    <td class="codeLine">    if (VecTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3035</td>
    <td class="codeLine">    if (VecTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3036</td>
    <td class="codeLine">      // If this is a memset of a vectorized alloca, insert it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3036</td>
    <td class="codeLine">      // If this is a memset of a vectorized alloca, insert it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3037</td>
    <td class="codeLine">      assert(ElementTy == ScalarTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3037</td>
    <td class="codeLine">      assert(ElementTy == ScalarTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3038</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3039</td>
    <td class="codeLine">      unsigned BeginIndex = getIndex(NewBeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3039</td>
    <td class="codeLine">      unsigned BeginIndex = getIndex(NewBeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3040</td>
    <td class="codeLine">      unsigned EndIndex = getIndex(NewEndOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3040</td>
    <td class="codeLine">      unsigned EndIndex = getIndex(NewEndOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3041</td>
    <td class="codeLine">      assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3041</td>
    <td class="codeLine">      assert(EndIndex > BeginIndex && "Empty vector!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3042</td>
    <td class="codeLine">      unsigned NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3042</td>
    <td class="codeLine">      unsigned NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3043</td>
    <td class="codeLine">      assert(NumElements <= cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3043</td>
    <td class="codeLine">      assert(NumElements <= cast<FixedVectorType>(VecTy)->getNumElements() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3044</td>
    <td class="codeLine">             "Too many elements!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3044</td>
    <td class="codeLine">             "Too many elements!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3045</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3045</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3046</td>
    <td class="codeLine">      Value *Splat = getIntegerSplat(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3046</td>
    <td class="codeLine">      Value *Splat = getIntegerSplat(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3047</td>
    <td class="codeLine">          II.getValue(), DL.getTypeSizeInBits(ElementTy).getFixedValue() / 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3047</td>
    <td class="codeLine">          II.getValue(), DL.getTypeSizeInBits(ElementTy).getFixedValue() / 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3048</td>
    <td class="codeLine">      Splat = convertValue(DL, IRB, Splat, ElementTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3048</td>
    <td class="codeLine">      Splat = convertValue(DL, IRB, Splat, ElementTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3049</td>
    <td class="codeLine">      if (NumElements > 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3049</td>
    <td class="codeLine">      if (NumElements > 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3050</td>
    <td class="codeLine">        Splat = getVectorSplat(Splat, NumElements);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3050</td>
    <td class="codeLine">        Splat = getVectorSplat(Splat, NumElements);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3052</td>
    <td class="codeLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3052</td>
    <td class="codeLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3053</td>
    <td class="codeLine">                                         NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3053</td>
    <td class="codeLine">                                         NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3054</td>
    <td class="codeLine">      V = insertVector(IRB, Old, Splat, BeginIndex, "vec");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3054</td>
    <td class="codeLine">      V = insertVector(IRB, Old, Splat, BeginIndex, "vec");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3055</td>
    <td class="codeLine">    } else if (IntTy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3055</td>
    <td class="codeLine">    } else if (IntTy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3056</td>
    <td class="codeLine">      // If this is a memset on an alloca where we can widen stores, insert the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3056</td>
    <td class="codeLine">      // If this is a memset on an alloca where we can widen stores, insert the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3057</td>
    <td class="codeLine">      // set integer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3057</td>
    <td class="codeLine">      // set integer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3058</td>
    <td class="codeLine">      assert(!II.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3058</td>
    <td class="codeLine">      assert(!II.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3060</td>
    <td class="codeLine">      uint64_t Size = NewEndOffset - NewBeginOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3060</td>
    <td class="codeLine">      uint64_t Size = NewEndOffset - NewBeginOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3061</td>
    <td class="codeLine">      V = getIntegerSplat(II.getValue(), Size);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3061</td>
    <td class="codeLine">      V = getIntegerSplat(II.getValue(), Size);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3062</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3062</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3063</td>
    <td class="codeLine">      if (IntTy && (BeginOffset != NewAllocaBeginOffset ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3063</td>
    <td class="codeLine">      if (IntTy && (BeginOffset != NewAllocaBeginOffset ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3064</td>
    <td class="codeLine">                    EndOffset != NewAllocaBeginOffset)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3064</td>
    <td class="codeLine">                    EndOffset != NewAllocaBeginOffset)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3065</td>
    <td class="codeLine">        Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3065</td>
    <td class="codeLine">        Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3066</td>
    <td class="codeLine">                                           NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3066</td>
    <td class="codeLine">                                           NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3067</td>
    <td class="codeLine">        Old = convertValue(DL, IRB, Old, IntTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3067</td>
    <td class="codeLine">        Old = convertValue(DL, IRB, Old, IntTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3068</td>
    <td class="codeLine">        uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3068</td>
    <td class="codeLine">        uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3069</td>
    <td class="codeLine">        V = insertInteger(DL, IRB, Old, V, Offset, "insert");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3069</td>
    <td class="codeLine">        V = insertInteger(DL, IRB, Old, V, Offset, "insert");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3070</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3070</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3071</td>
    <td class="codeLine">        assert(V->getType() == IntTy &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3071</td>
    <td class="codeLine">        assert(V->getType() == IntTy &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3072</td>
    <td class="codeLine">               "Wrong type for an alloca wide integer!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3072</td>
    <td class="codeLine">               "Wrong type for an alloca wide integer!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3073</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3073</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3074</td>
    <td class="codeLine">      V = convertValue(DL, IRB, V, AllocaTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3074</td>
    <td class="codeLine">      V = convertValue(DL, IRB, V, AllocaTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3075</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3075</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3076</td>
    <td class="codeLine">      // Established these invariants above.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3076</td>
    <td class="codeLine">      // Established these invariants above.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3077</td>
    <td class="codeLine">      assert(NewBeginOffset == NewAllocaBeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3077</td>
    <td class="codeLine">      assert(NewBeginOffset == NewAllocaBeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3078</td>
    <td class="codeLine">      assert(NewEndOffset == NewAllocaEndOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3078</td>
    <td class="codeLine">      assert(NewEndOffset == NewAllocaEndOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3079</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3080</td>
    <td class="codeLine">      V = getIntegerSplat(II.getValue(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3080</td>
    <td class="codeLine">      V = getIntegerSplat(II.getValue(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3081</td>
    <td class="codeLine">                          DL.getTypeSizeInBits(ScalarTy).getFixedValue() / 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3081</td>
    <td class="codeLine">                          DL.getTypeSizeInBits(ScalarTy).getFixedValue() / 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3082</td>
    <td class="codeLine">      if (VectorType *AllocaVecTy = dyn_cast<VectorType>(AllocaTy))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3082</td>
    <td class="codeLine">      if (VectorType *AllocaVecTy = dyn_cast<VectorType>(AllocaTy))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3083</td>
    <td class="codeLine">        V = getVectorSplat(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3083</td>
    <td class="codeLine">        V = getVectorSplat(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3084</td>
    <td class="codeLine">            V, cast<FixedVectorType>(AllocaVecTy)->getNumElements());</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3084</td>
    <td class="codeLine">            V, cast<FixedVectorType>(AllocaVecTy)->getNumElements());</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3085</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3085</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3086</td>
    <td class="codeLine">      V = convertValue(DL, IRB, V, AllocaTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3086</td>
    <td class="codeLine">      V = convertValue(DL, IRB, V, AllocaTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3087</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3087</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3089</td>
    <td class="codeLine">    Value *NewPtr = getPtrToNewAI(II.getDestAddressSpace(), II.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3089</td>
    <td class="codeLine">    Value *NewPtr = getPtrToNewAI(II.getDestAddressSpace(), II.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3090</td>
    <td class="codeLine">    StoreInst *New =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3090</td>
    <td class="codeLine">    StoreInst *New =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3091</td>
    <td class="codeLine">        IRB.CreateAlignedStore(V, NewPtr, NewAI.getAlign(), II.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3091</td>
    <td class="codeLine">        IRB.CreateAlignedStore(V, NewPtr, NewAI.getAlign(), II.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3092</td>
    <td class="codeLine">    New->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3092</td>
    <td class="codeLine">    New->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3093</td>
    <td class="codeLine">                           LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3093</td>
    <td class="codeLine">                           LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3094</td>
    <td class="codeLine">    if (AATags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3094</td>
    <td class="codeLine">    if (AATags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3095</td>
    <td class="codeLine">      New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3095</td>
    <td class="codeLine">      New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3097</td>
    <td class="codeLine">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3097</td>
    <td class="codeLine">    migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3098</td>
    <td class="codeLine">                     New, New->getPointerOperand(), V, DL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3098</td>
    <td class="codeLine">                     New, New->getPointerOperand(), V, DL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3100</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3100</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3101</td>
    <td class="codeLine">    return !II.isVolatile();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3101</td>
    <td class="codeLine">    return !II.isVolatile();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3102</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3104</td>
    <td class="codeLine">  bool visitMemTransferInst(MemTransferInst &II) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3104</td>
    <td class="codeLine">  bool visitMemTransferInst(MemTransferInst &II) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3105</td>
    <td class="codeLine">    // Rewriting of memory transfer instructions can be a bit tricky. We break</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3105</td>
    <td class="codeLine">    // Rewriting of memory transfer instructions can be a bit tricky. We break</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3106</td>
    <td class="codeLine">    // them into two categories: split intrinsics and unsplit intrinsics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3106</td>
    <td class="codeLine">    // them into two categories: split intrinsics and unsplit intrinsics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3107</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3108</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3108</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3110</td>
    <td class="codeLine">    AAMDNodes AATags = II.getAAMetadata();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3110</td>
    <td class="codeLine">    AAMDNodes AATags = II.getAAMetadata();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3112</td>
    <td class="codeLine">    bool IsDest = &II.getRawDestUse() == OldUse;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3112</td>
    <td class="codeLine">    bool IsDest = &II.getRawDestUse() == OldUse;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3113</td>
    <td class="codeLine">    assert((IsDest && II.getRawDest() == OldPtr) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3113</td>
    <td class="codeLine">    assert((IsDest && II.getRawDest() == OldPtr) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3114</td>
    <td class="codeLine">           (!IsDest && II.getRawSource() == OldPtr));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3114</td>
    <td class="codeLine">           (!IsDest && II.getRawSource() == OldPtr));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3115</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3116</td>
    <td class="codeLine">    Align SliceAlign = getSliceAlign();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3116</td>
    <td class="codeLine">    Align SliceAlign = getSliceAlign();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3117</td>
    <td class="codeLine">    // For unsplit intrinsics, we simply modify the source and destination</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3117</td>
    <td class="codeLine">    // For unsplit intrinsics, we simply modify the source and destination</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3118</td>
    <td class="codeLine">    // pointers in place. This isn't just an optimization, it is a matter of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3118</td>
    <td class="codeLine">    // pointers in place. This isn't just an optimization, it is a matter of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3119</td>
    <td class="codeLine">    // correctness. With unsplit intrinsics we may be dealing with transfers</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3119</td>
    <td class="codeLine">    // correctness. With unsplit intrinsics we may be dealing with transfers</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3120</td>
    <td class="codeLine">    // within a single alloca before SROA ran, or with transfers that have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3120</td>
    <td class="codeLine">    // within a single alloca before SROA ran, or with transfers that have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3121</td>
    <td class="codeLine">    // a variable length. We may also be dealing with memmove instead of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3121</td>
    <td class="codeLine">    // a variable length. We may also be dealing with memmove instead of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3122</td>
    <td class="codeLine">    // memcpy, and so simply updating the pointers is the necessary for us to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3122</td>
    <td class="codeLine">    // memcpy, and so simply updating the pointers is the necessary for us to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3123</td>
    <td class="codeLine">    // update both source and dest of a single call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3123</td>
    <td class="codeLine">    // update both source and dest of a single call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3124</td>
    <td class="codeLine">    if (!IsSplittable) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3124</td>
    <td class="codeLine">    if (!IsSplittable) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3125</td>
    <td class="codeLine">      Value *AdjustedPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3125</td>
    <td class="codeLine">      Value *AdjustedPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3126</td>
    <td class="codeLine">      if (IsDest) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3126</td>
    <td class="codeLine">      if (IsDest) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3127</td>
    <td class="codeLine">        // Update the address component of linked dbg.assigns.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3127</td>
    <td class="codeLine">        // Update the address component of linked dbg.assigns.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3128</td>
    <td class="codeLine">        for (auto *DAI : at::getAssignmentMarkers(&II)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3128</td>
    <td class="codeLine">        for (auto *DAI : at::getAssignmentMarkers(&II)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3129</td>
    <td class="codeLine">          if (any_of(DAI->location_ops(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3129</td>
    <td class="codeLine">          if (any_of(DAI->location_ops(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3130</td>
    <td class="codeLine">                     [&](Value *V) { return V == II.getDest(); }) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3130</td>
    <td class="codeLine">                     [&](Value *V) { return V == II.getDest(); }) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3131</td>
    <td class="codeLine">              DAI->getAddress() == II.getDest())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3131</td>
    <td class="codeLine">              DAI->getAddress() == II.getDest())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3132</td>
    <td class="codeLine">            DAI->replaceVariableLocationOp(II.getDest(), AdjustedPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3132</td>
    <td class="codeLine">            DAI->replaceVariableLocationOp(II.getDest(), AdjustedPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3133</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3133</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3134</td>
    <td class="codeLine">        II.setDest(AdjustedPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3134</td>
    <td class="codeLine">        II.setDest(AdjustedPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3135</td>
    <td class="codeLine">        II.setDestAlignment(SliceAlign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3135</td>
    <td class="codeLine">        II.setDestAlignment(SliceAlign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3136</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3136</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3137</td>
    <td class="codeLine">        II.setSource(AdjustedPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3137</td>
    <td class="codeLine">        II.setSource(AdjustedPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3138</td>
    <td class="codeLine">        II.setSourceAlignment(SliceAlign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3138</td>
    <td class="codeLine">        II.setSourceAlignment(SliceAlign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3139</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3139</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3140</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3141</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "          to: " << II << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3141</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "          to: " << II << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3142</td>
    <td class="codeLine">      deleteIfTriviallyDead(OldPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3142</td>
    <td class="codeLine">      deleteIfTriviallyDead(OldPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3143</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3143</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3144</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3144</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3145</td>
    <td class="codeLine">    // For split transfer intrinsics we have an incredibly useful assurance:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3145</td>
    <td class="codeLine">    // For split transfer intrinsics we have an incredibly useful assurance:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3146</td>
    <td class="codeLine">    // the source and destination do not reside within the same alloca, and at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3146</td>
    <td class="codeLine">    // the source and destination do not reside within the same alloca, and at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3147</td>
    <td class="codeLine">    // least one of them does not escape. This means that we can replace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3147</td>
    <td class="codeLine">    // least one of them does not escape. This means that we can replace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3148</td>
    <td class="codeLine">    // memmove with memcpy, and we don't need to worry about all manner of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3148</td>
    <td class="codeLine">    // memmove with memcpy, and we don't need to worry about all manner of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3149</td>
    <td class="codeLine">    // downsides to splitting and transforming the operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3149</td>
    <td class="codeLine">    // downsides to splitting and transforming the operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3150</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3151</td>
    <td class="codeLine">    // If this doesn't map cleanly onto the alloca type, and that type isn't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3151</td>
    <td class="codeLine">    // If this doesn't map cleanly onto the alloca type, and that type isn't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3152</td>
    <td class="codeLine">    // a single value type, just emit a memcpy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3152</td>
    <td class="codeLine">    // a single value type, just emit a memcpy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3153</td>
    <td class="codeLine">    bool EmitMemCpy =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3153</td>
    <td class="codeLine">    bool EmitMemCpy =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3154</td>
    <td class="codeLine">        !VecTy && !IntTy &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3154</td>
    <td class="codeLine">        !VecTy && !IntTy &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3155</td>
    <td class="codeLine">        (BeginOffset > NewAllocaBeginOffset || EndOffset < NewAllocaEndOffset ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3155</td>
    <td class="codeLine">        (BeginOffset > NewAllocaBeginOffset || EndOffset < NewAllocaEndOffset ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3156</td>
    <td class="codeLine">         SliceSize !=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3156</td>
    <td class="codeLine">         SliceSize !=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3157</td>
    <td class="codeLine">             DL.getTypeStoreSize(NewAI.getAllocatedType()).getFixedValue() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3157</td>
    <td class="codeLine">             DL.getTypeStoreSize(NewAI.getAllocatedType()).getFixedValue() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3158</td>
    <td class="codeLine">         !NewAI.getAllocatedType()->isSingleValueType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3158</td>
    <td class="codeLine">         !NewAI.getAllocatedType()->isSingleValueType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3159</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3160</td>
    <td class="codeLine">    // If we're just going to emit a memcpy, the alloca hasn't changed, and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3160</td>
    <td class="codeLine">    // If we're just going to emit a memcpy, the alloca hasn't changed, and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3161</td>
    <td class="codeLine">    // size hasn't been shrunk based on analysis of the viable range, this is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3161</td>
    <td class="codeLine">    // size hasn't been shrunk based on analysis of the viable range, this is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3162</td>
    <td class="codeLine">    // a no-op.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3162</td>
    <td class="codeLine">    // a no-op.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3163</td>
    <td class="codeLine">    if (EmitMemCpy && &OldAI == &NewAI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3163</td>
    <td class="codeLine">    if (EmitMemCpy && &OldAI == &NewAI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3164</td>
    <td class="codeLine">      // Ensure the start lines up.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3164</td>
    <td class="codeLine">      // Ensure the start lines up.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3165</td>
    <td class="codeLine">      assert(NewBeginOffset == BeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3165</td>
    <td class="codeLine">      assert(NewBeginOffset == BeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3167</td>
    <td class="codeLine">      // Rewrite the size as needed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3167</td>
    <td class="codeLine">      // Rewrite the size as needed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3168</td>
    <td class="codeLine">      if (NewEndOffset != EndOffset)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3168</td>
    <td class="codeLine">      if (NewEndOffset != EndOffset)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3169</td>
    <td class="codeLine">        II.setLength(ConstantInt::get(II.getLength()->getType(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3169</td>
    <td class="codeLine">        II.setLength(ConstantInt::get(II.getLength()->getType(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3170</td>
    <td class="codeLine">                                      NewEndOffset - NewBeginOffset));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3170</td>
    <td class="codeLine">                                      NewEndOffset - NewBeginOffset));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3171</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3171</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3172</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3172</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3173</td>
    <td class="codeLine">    // Record this instruction for deletion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3173</td>
    <td class="codeLine">    // Record this instruction for deletion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3174</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3174</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3176</td>
    <td class="codeLine">    // Strip all inbounds GEPs and pointer casts to try to dig out any root</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3176</td>
    <td class="codeLine">    // Strip all inbounds GEPs and pointer casts to try to dig out any root</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3177</td>
    <td class="codeLine">    // alloca that should be re-examined after rewriting this instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3177</td>
    <td class="codeLine">    // alloca that should be re-examined after rewriting this instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3178</td>
    <td class="codeLine">    Value *OtherPtr = IsDest ? II.getRawSource() : II.getRawDest();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3178</td>
    <td class="codeLine">    Value *OtherPtr = IsDest ? II.getRawSource() : II.getRawDest();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3179</td>
    <td class="codeLine">    if (AllocaInst *AI =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3179</td>
    <td class="codeLine">    if (AllocaInst *AI =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3180</td>
    <td class="codeLine">            dyn_cast<AllocaInst>(OtherPtr->stripInBoundsOffsets())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3180</td>
    <td class="codeLine">            dyn_cast<AllocaInst>(OtherPtr->stripInBoundsOffsets())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3181</td>
    <td class="codeLine">      assert(AI != &OldAI && AI != &NewAI &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3181</td>
    <td class="codeLine">      assert(AI != &OldAI && AI != &NewAI &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3182</td>
    <td class="codeLine">             "Splittable transfers cannot reach the same alloca on both ends.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3182</td>
    <td class="codeLine">             "Splittable transfers cannot reach the same alloca on both ends.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3183</td>
    <td class="codeLine">      Pass.Worklist.insert(AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3183</td>
    <td class="codeLine">      Pass.Worklist.insert(AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3184</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3184</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3186</td>
    <td class="codeLine">    Type *OtherPtrTy = OtherPtr->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3186</td>
    <td class="codeLine">    Type *OtherPtrTy = OtherPtr->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3187</td>
    <td class="codeLine">    unsigned OtherAS = OtherPtrTy->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3187</td>
    <td class="codeLine">    unsigned OtherAS = OtherPtrTy->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3189</td>
    <td class="codeLine">    // Compute the relative offset for the other pointer within the transfer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3189</td>
    <td class="codeLine">    // Compute the relative offset for the other pointer within the transfer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3190</td>
    <td class="codeLine">    unsigned OffsetWidth = DL.getIndexSizeInBits(OtherAS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3190</td>
    <td class="codeLine">    unsigned OffsetWidth = DL.getIndexSizeInBits(OtherAS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3191</td>
    <td class="codeLine">    APInt OtherOffset(OffsetWidth, NewBeginOffset - BeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3191</td>
    <td class="codeLine">    APInt OtherOffset(OffsetWidth, NewBeginOffset - BeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3192</td>
    <td class="codeLine">    Align OtherAlign =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3192</td>
    <td class="codeLine">    Align OtherAlign =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3193</td>
    <td class="codeLine">        (IsDest ? II.getSourceAlign() : II.getDestAlign()).valueOrOne();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3193</td>
    <td class="codeLine">        (IsDest ? II.getSourceAlign() : II.getDestAlign()).valueOrOne();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3194</td>
    <td class="codeLine">    OtherAlign =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3194</td>
    <td class="codeLine">    OtherAlign =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3195</td>
    <td class="codeLine">        commonAlignment(OtherAlign, OtherOffset.zextOrTrunc(64).getZExtValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3195</td>
    <td class="codeLine">        commonAlignment(OtherAlign, OtherOffset.zextOrTrunc(64).getZExtValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3196</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3197</td>
    <td class="codeLine">    if (EmitMemCpy) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3197</td>
    <td class="codeLine">    if (EmitMemCpy) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3198</td>
    <td class="codeLine">      // Compute the other pointer, folding as much as possible to produce</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3198</td>
    <td class="codeLine">      // Compute the other pointer, folding as much as possible to produce</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3199</td>
    <td class="codeLine">      // a single, simple GEP in most cases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3199</td>
    <td class="codeLine">      // a single, simple GEP in most cases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3200</td>
    <td class="codeLine">      OtherPtr = getAdjustedPtr(IRB, DL, OtherPtr, OtherOffset, OtherPtrTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3200</td>
    <td class="codeLine">      OtherPtr = getAdjustedPtr(IRB, DL, OtherPtr, OtherOffset, OtherPtrTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3201</td>
    <td class="codeLine">                                OtherPtr->getName() + ".");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3201</td>
    <td class="codeLine">                                OtherPtr->getName() + ".");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3202</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3203</td>
    <td class="codeLine">      Value *OurPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3203</td>
    <td class="codeLine">      Value *OurPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3204</td>
    <td class="codeLine">      Type *SizeTy = II.getLength()->getType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3204</td>
    <td class="codeLine">      Type *SizeTy = II.getLength()->getType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3205</td>
    <td class="codeLine">      Constant *Size = ConstantInt::get(SizeTy, NewEndOffset - NewBeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3205</td>
    <td class="codeLine">      Constant *Size = ConstantInt::get(SizeTy, NewEndOffset - NewBeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3206</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3207</td>
    <td class="codeLine">      Value *DestPtr, *SrcPtr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3207</td>
    <td class="codeLine">      Value *DestPtr, *SrcPtr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3208</td>
    <td class="codeLine">      MaybeAlign DestAlign, SrcAlign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3208</td>
    <td class="codeLine">      MaybeAlign DestAlign, SrcAlign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3209</td>
    <td class="codeLine">      // Note: IsDest is true iff we're copying into the new alloca slice</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3209</td>
    <td class="codeLine">      // Note: IsDest is true iff we're copying into the new alloca slice</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3210</td>
    <td class="codeLine">      if (IsDest) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3210</td>
    <td class="codeLine">      if (IsDest) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3211</td>
    <td class="codeLine">        DestPtr = OurPtr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3211</td>
    <td class="codeLine">        DestPtr = OurPtr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3212</td>
    <td class="codeLine">        DestAlign = SliceAlign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3212</td>
    <td class="codeLine">        DestAlign = SliceAlign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3213</td>
    <td class="codeLine">        SrcPtr = OtherPtr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3213</td>
    <td class="codeLine">        SrcPtr = OtherPtr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3214</td>
    <td class="codeLine">        SrcAlign = OtherAlign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3214</td>
    <td class="codeLine">        SrcAlign = OtherAlign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3215</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3215</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3216</td>
    <td class="codeLine">        DestPtr = OtherPtr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3216</td>
    <td class="codeLine">        DestPtr = OtherPtr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3217</td>
    <td class="codeLine">        DestAlign = OtherAlign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3217</td>
    <td class="codeLine">        DestAlign = OtherAlign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3218</td>
    <td class="codeLine">        SrcPtr = OurPtr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3218</td>
    <td class="codeLine">        SrcPtr = OurPtr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3219</td>
    <td class="codeLine">        SrcAlign = SliceAlign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3219</td>
    <td class="codeLine">        SrcAlign = SliceAlign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3220</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3220</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3221</td>
    <td class="codeLine">      CallInst *New = IRB.CreateMemCpy(DestPtr, DestAlign, SrcPtr, SrcAlign,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3221</td>
    <td class="codeLine">      CallInst *New = IRB.CreateMemCpy(DestPtr, DestAlign, SrcPtr, SrcAlign,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3222</td>
    <td class="codeLine">                                       Size, II.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3222</td>
    <td class="codeLine">                                       Size, II.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3223</td>
    <td class="codeLine">      if (AATags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3223</td>
    <td class="codeLine">      if (AATags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3224</td>
    <td class="codeLine">        New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3224</td>
    <td class="codeLine">        New->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3226</td>
    <td class="codeLine">      APInt Offset(DL.getIndexTypeSizeInBits(DestPtr->getType()), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3226</td>
    <td class="codeLine">      APInt Offset(DL.getIndexTypeSizeInBits(DestPtr->getType()), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3227</td>
    <td class="codeLine">      if (IsDest) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3227</td>
    <td class="codeLine">      if (IsDest) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3228</td>
    <td class="codeLine">        migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3228</td>
    <td class="codeLine">        migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3229</td>
    <td class="codeLine">                         &II, New, DestPtr, nullptr, DL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3229</td>
    <td class="codeLine">                         &II, New, DestPtr, nullptr, DL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3230</td>
    <td class="codeLine">      } else if (AllocaInst *Base = dyn_cast<AllocaInst>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3230</td>
    <td class="codeLine">      } else if (AllocaInst *Base = dyn_cast<AllocaInst>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3231</td>
    <td class="codeLine">                     DestPtr->stripAndAccumulateConstantOffsets(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3231</td>
    <td class="codeLine">                     DestPtr->stripAndAccumulateConstantOffsets(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3232</td>
    <td class="codeLine">                         DL, Offset, /*AllowNonInbounds*/ true))) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3232</td>
    <td class="codeLine">                         DL, Offset, /*AllowNonInbounds*/ true))) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3233</td>
    <td class="codeLine">        migrateDebugInfo(Base, IsSplit, Offset.getZExtValue() * 8,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3233</td>
    <td class="codeLine">        migrateDebugInfo(Base, IsSplit, Offset.getZExtValue() * 8,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3234</td>
    <td class="codeLine">                         SliceSize * 8, &II, New, DestPtr, nullptr, DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3234</td>
    <td class="codeLine">                         SliceSize * 8, &II, New, DestPtr, nullptr, DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3235</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3235</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3236</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3236</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3237</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3237</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3238</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3238</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3239</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3240</td>
    <td class="codeLine">    bool IsWholeAlloca = NewBeginOffset == NewAllocaBeginOffset &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3240</td>
    <td class="codeLine">    bool IsWholeAlloca = NewBeginOffset == NewAllocaBeginOffset &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3241</td>
    <td class="codeLine">                         NewEndOffset == NewAllocaEndOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3241</td>
    <td class="codeLine">                         NewEndOffset == NewAllocaEndOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3242</td>
    <td class="codeLine">    uint64_t Size = NewEndOffset - NewBeginOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3242</td>
    <td class="codeLine">    uint64_t Size = NewEndOffset - NewBeginOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3243</td>
    <td class="codeLine">    unsigned BeginIndex = VecTy ? getIndex(NewBeginOffset) : 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3243</td>
    <td class="codeLine">    unsigned BeginIndex = VecTy ? getIndex(NewBeginOffset) : 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3244</td>
    <td class="codeLine">    unsigned EndIndex = VecTy ? getIndex(NewEndOffset) : 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3244</td>
    <td class="codeLine">    unsigned EndIndex = VecTy ? getIndex(NewEndOffset) : 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3245</td>
    <td class="codeLine">    unsigned NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3245</td>
    <td class="codeLine">    unsigned NumElements = EndIndex - BeginIndex;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3246</td>
    <td class="codeLine">    IntegerType *SubIntTy =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3246</td>
    <td class="codeLine">    IntegerType *SubIntTy =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3247</td>
    <td class="codeLine">        IntTy ? Type::getIntNTy(IntTy->getContext(), Size * 8) : nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3247</td>
    <td class="codeLine">        IntTy ? Type::getIntNTy(IntTy->getContext(), Size * 8) : nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3249</td>
    <td class="codeLine">    // Reset the other pointer type to match the register type we're going to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3249</td>
    <td class="codeLine">    // Reset the other pointer type to match the register type we're going to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3250</td>
    <td class="codeLine">    // use, but using the address space of the original other pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3250</td>
    <td class="codeLine">    // use, but using the address space of the original other pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3251</td>
    <td class="codeLine">    Type *OtherTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3251</td>
    <td class="codeLine">    Type *OtherTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3252</td>
    <td class="codeLine">    if (VecTy && !IsWholeAlloca) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3252</td>
    <td class="codeLine">    if (VecTy && !IsWholeAlloca) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3253</td>
    <td class="codeLine">      if (NumElements == 1)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3253</td>
    <td class="codeLine">      if (NumElements == 1)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3254</td>
    <td class="codeLine">        OtherTy = VecTy->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3254</td>
    <td class="codeLine">        OtherTy = VecTy->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3255</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3255</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3256</td>
    <td class="codeLine">        OtherTy = FixedVectorType::get(VecTy->getElementType(), NumElements);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3256</td>
    <td class="codeLine">        OtherTy = FixedVectorType::get(VecTy->getElementType(), NumElements);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3257</td>
    <td class="codeLine">    } else if (IntTy && !IsWholeAlloca) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3257</td>
    <td class="codeLine">    } else if (IntTy && !IsWholeAlloca) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3258</td>
    <td class="codeLine">      OtherTy = SubIntTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3258</td>
    <td class="codeLine">      OtherTy = SubIntTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3259</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3259</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3260</td>
    <td class="codeLine">      OtherTy = NewAllocaTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3260</td>
    <td class="codeLine">      OtherTy = NewAllocaTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3261</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3261</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3262</td>
    <td class="codeLine">    OtherPtrTy = OtherTy->getPointerTo(OtherAS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3262</td>
    <td class="codeLine">    OtherPtrTy = OtherTy->getPointerTo(OtherAS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3264</td>
    <td class="codeLine">    Value *AdjPtr = getAdjustedPtr(IRB, DL, OtherPtr, OtherOffset, OtherPtrTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3264</td>
    <td class="codeLine">    Value *AdjPtr = getAdjustedPtr(IRB, DL, OtherPtr, OtherOffset, OtherPtrTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3265</td>
    <td class="codeLine">                                   OtherPtr->getName() + ".");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3265</td>
    <td class="codeLine">                                   OtherPtr->getName() + ".");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3266</td>
    <td class="codeLine">    MaybeAlign SrcAlign = OtherAlign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3266</td>
    <td class="codeLine">    MaybeAlign SrcAlign = OtherAlign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3267</td>
    <td class="codeLine">    MaybeAlign DstAlign = SliceAlign;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3267</td>
    <td class="codeLine">    MaybeAlign DstAlign = SliceAlign;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3268</td>
    <td class="codeLine">    if (!IsDest)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3268</td>
    <td class="codeLine">    if (!IsDest)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3269</td>
    <td class="codeLine">      std::swap(SrcAlign, DstAlign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3269</td>
    <td class="codeLine">      std::swap(SrcAlign, DstAlign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3270</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3271</td>
    <td class="codeLine">    Value *SrcPtr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3271</td>
    <td class="codeLine">    Value *SrcPtr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3272</td>
    <td class="codeLine">    Value *DstPtr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3272</td>
    <td class="codeLine">    Value *DstPtr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3273</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3274</td>
    <td class="codeLine">    if (IsDest) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3274</td>
    <td class="codeLine">    if (IsDest) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3275</td>
    <td class="codeLine">      DstPtr = getPtrToNewAI(II.getDestAddressSpace(), II.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3275</td>
    <td class="codeLine">      DstPtr = getPtrToNewAI(II.getDestAddressSpace(), II.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3276</td>
    <td class="codeLine">      SrcPtr = AdjPtr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3276</td>
    <td class="codeLine">      SrcPtr = AdjPtr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3277</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3277</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3278</td>
    <td class="codeLine">      DstPtr = AdjPtr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3278</td>
    <td class="codeLine">      DstPtr = AdjPtr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3279</td>
    <td class="codeLine">      SrcPtr = getPtrToNewAI(II.getSourceAddressSpace(), II.isVolatile());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3279</td>
    <td class="codeLine">      SrcPtr = getPtrToNewAI(II.getSourceAddressSpace(), II.isVolatile());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3280</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3280</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3282</td>
    <td class="codeLine">    Value *Src;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3282</td>
    <td class="codeLine">    Value *Src;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3283</td>
    <td class="codeLine">    if (VecTy && !IsWholeAlloca && !IsDest) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3283</td>
    <td class="codeLine">    if (VecTy && !IsWholeAlloca && !IsDest) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3284</td>
    <td class="codeLine">      Src = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3284</td>
    <td class="codeLine">      Src = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3285</td>
    <td class="codeLine">                                  NewAI.getAlign(), "load");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3285</td>
    <td class="codeLine">                                  NewAI.getAlign(), "load");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3286</td>
    <td class="codeLine">      Src = extractVector(IRB, Src, BeginIndex, EndIndex, "vec");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3286</td>
    <td class="codeLine">      Src = extractVector(IRB, Src, BeginIndex, EndIndex, "vec");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3287</td>
    <td class="codeLine">    } else if (IntTy && !IsWholeAlloca && !IsDest) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3287</td>
    <td class="codeLine">    } else if (IntTy && !IsWholeAlloca && !IsDest) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3288</td>
    <td class="codeLine">      Src = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3288</td>
    <td class="codeLine">      Src = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3289</td>
    <td class="codeLine">                                  NewAI.getAlign(), "load");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3289</td>
    <td class="codeLine">                                  NewAI.getAlign(), "load");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3290</td>
    <td class="codeLine">      Src = convertValue(DL, IRB, Src, IntTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3290</td>
    <td class="codeLine">      Src = convertValue(DL, IRB, Src, IntTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3291</td>
    <td class="codeLine">      uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3291</td>
    <td class="codeLine">      uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3292</td>
    <td class="codeLine">      Src = extractInteger(DL, IRB, Src, SubIntTy, Offset, "extract");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3292</td>
    <td class="codeLine">      Src = extractInteger(DL, IRB, Src, SubIntTy, Offset, "extract");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3293</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3293</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3294</td>
    <td class="codeLine">      LoadInst *Load = IRB.CreateAlignedLoad(OtherTy, SrcPtr, SrcAlign,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3294</td>
    <td class="codeLine">      LoadInst *Load = IRB.CreateAlignedLoad(OtherTy, SrcPtr, SrcAlign,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3295</td>
    <td class="codeLine">                                             II.isVolatile(), "copyload");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3295</td>
    <td class="codeLine">                                             II.isVolatile(), "copyload");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3296</td>
    <td class="codeLine">      Load->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3296</td>
    <td class="codeLine">      Load->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3297</td>
    <td class="codeLine">                              LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3297</td>
    <td class="codeLine">                              LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3298</td>
    <td class="codeLine">      if (AATags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3298</td>
    <td class="codeLine">      if (AATags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3299</td>
    <td class="codeLine">        Load->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3299</td>
    <td class="codeLine">        Load->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3300</td>
    <td class="codeLine">      Src = Load;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3300</td>
    <td class="codeLine">      Src = Load;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3301</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3301</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3303</td>
    <td class="codeLine">    if (VecTy && !IsWholeAlloca && IsDest) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3303</td>
    <td class="codeLine">    if (VecTy && !IsWholeAlloca && IsDest) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3304</td>
    <td class="codeLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3304</td>
    <td class="codeLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3305</td>
    <td class="codeLine">                                         NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3305</td>
    <td class="codeLine">                                         NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3306</td>
    <td class="codeLine">      Src = insertVector(IRB, Old, Src, BeginIndex, "vec");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3306</td>
    <td class="codeLine">      Src = insertVector(IRB, Old, Src, BeginIndex, "vec");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3307</td>
    <td class="codeLine">    } else if (IntTy && !IsWholeAlloca && IsDest) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3307</td>
    <td class="codeLine">    } else if (IntTy && !IsWholeAlloca && IsDest) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3308</td>
    <td class="codeLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3308</td>
    <td class="codeLine">      Value *Old = IRB.CreateAlignedLoad(NewAI.getAllocatedType(), &NewAI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3309</td>
    <td class="codeLine">                                         NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3309</td>
    <td class="codeLine">                                         NewAI.getAlign(), "oldload");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3310</td>
    <td class="codeLine">      Old = convertValue(DL, IRB, Old, IntTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3310</td>
    <td class="codeLine">      Old = convertValue(DL, IRB, Old, IntTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3311</td>
    <td class="codeLine">      uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3311</td>
    <td class="codeLine">      uint64_t Offset = NewBeginOffset - NewAllocaBeginOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3312</td>
    <td class="codeLine">      Src = insertInteger(DL, IRB, Old, Src, Offset, "insert");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3312</td>
    <td class="codeLine">      Src = insertInteger(DL, IRB, Old, Src, Offset, "insert");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3313</td>
    <td class="codeLine">      Src = convertValue(DL, IRB, Src, NewAllocaTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3313</td>
    <td class="codeLine">      Src = convertValue(DL, IRB, Src, NewAllocaTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3314</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3314</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3316</td>
    <td class="codeLine">    StoreInst *Store = cast<StoreInst>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3316</td>
    <td class="codeLine">    StoreInst *Store = cast<StoreInst>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3317</td>
    <td class="codeLine">        IRB.CreateAlignedStore(Src, DstPtr, DstAlign, II.isVolatile()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3317</td>
    <td class="codeLine">        IRB.CreateAlignedStore(Src, DstPtr, DstAlign, II.isVolatile()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3318</td>
    <td class="codeLine">    Store->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3318</td>
    <td class="codeLine">    Store->copyMetadata(II, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3319</td>
    <td class="codeLine">                             LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3319</td>
    <td class="codeLine">                             LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3320</td>
    <td class="codeLine">    if (AATags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3320</td>
    <td class="codeLine">    if (AATags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3321</td>
    <td class="codeLine">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3321</td>
    <td class="codeLine">      Store->setAAMetadata(AATags.shift(NewBeginOffset - BeginOffset));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3323</td>
    <td class="codeLine">    APInt Offset(DL.getIndexTypeSizeInBits(DstPtr->getType()), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3323</td>
    <td class="codeLine">    APInt Offset(DL.getIndexTypeSizeInBits(DstPtr->getType()), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3324</td>
    <td class="codeLine">    if (IsDest) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3324</td>
    <td class="codeLine">    if (IsDest) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3326</td>
    <td class="codeLine">      migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3326</td>
    <td class="codeLine">      migrateDebugInfo(&OldAI, IsSplit, NewBeginOffset * 8, SliceSize * 8, &II,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3327</td>
    <td class="codeLine">                       Store, DstPtr, Src, DL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3327</td>
    <td class="codeLine">                       Store, DstPtr, Src, DL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3328</td>
    <td class="codeLine">    } else if (AllocaInst *Base = dyn_cast<AllocaInst>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3328</td>
    <td class="codeLine">    } else if (AllocaInst *Base = dyn_cast<AllocaInst>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3329</td>
    <td class="codeLine">                   DstPtr->stripAndAccumulateConstantOffsets(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3329</td>
    <td class="codeLine">                   DstPtr->stripAndAccumulateConstantOffsets(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3330</td>
    <td class="codeLine">                       DL, Offset, /*AllowNonInbounds*/ true))) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3330</td>
    <td class="codeLine">                       DL, Offset, /*AllowNonInbounds*/ true))) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3331</td>
    <td class="codeLine">      migrateDebugInfo(Base, IsSplit, Offset.getZExtValue() * 8, SliceSize * 8,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3331</td>
    <td class="codeLine">      migrateDebugInfo(Base, IsSplit, Offset.getZExtValue() * 8, SliceSize * 8,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3332</td>
    <td class="codeLine">                       &II, Store, DstPtr, Src, DL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3332</td>
    <td class="codeLine">                       &II, Store, DstPtr, Src, DL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3333</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3333</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3334</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3335</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3335</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3336</td>
    <td class="codeLine">    return !II.isVolatile();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3336</td>
    <td class="codeLine">    return !II.isVolatile();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3337</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3337</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3338</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3339</td>
    <td class="codeLine">  bool visitIntrinsicInst(IntrinsicInst &II) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3339</td>
    <td class="codeLine">  bool visitIntrinsicInst(IntrinsicInst &II) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3340</td>
    <td class="codeLine">    assert((II.isLifetimeStartOrEnd() || II.isDroppable()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3340</td>
    <td class="codeLine">    assert((II.isLifetimeStartOrEnd() || II.isDroppable()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3341</td>
    <td class="codeLine">           "Unexpected intrinsic!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3341</td>
    <td class="codeLine">           "Unexpected intrinsic!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3342</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3342</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << II << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3344</td>
    <td class="codeLine">    // Record this instruction for deletion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3344</td>
    <td class="codeLine">    // Record this instruction for deletion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3345</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3345</td>
    <td class="codeLine">    Pass.DeadInsts.push_back(&II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3346</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3347</td>
    <td class="codeLine">    if (II.isDroppable()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3347</td>
    <td class="codeLine">    if (II.isDroppable()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3348</td>
    <td class="codeLine">      assert(II.getIntrinsicID() == Intrinsic::assume && "Expected assume");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3348</td>
    <td class="codeLine">      assert(II.getIntrinsicID() == Intrinsic::assume && "Expected assume");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3349</td>
    <td class="codeLine">      // TODO For now we forget assumed information, this can be improved.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3349</td>
    <td class="codeLine">      // TODO For now we forget assumed information, this can be improved.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3350</td>
    <td class="codeLine">      OldPtr->dropDroppableUsesIn(II);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3350</td>
    <td class="codeLine">      OldPtr->dropDroppableUsesIn(II);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3351</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3351</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3352</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3352</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3353</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3354</td>
    <td class="codeLine">    assert(II.getArgOperand(1) == OldPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3354</td>
    <td class="codeLine">    assert(II.getArgOperand(1) == OldPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3355</td>
    <td class="codeLine">    // Lifetime intrinsics are only promotable if they cover the whole alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3355</td>
    <td class="codeLine">    // Lifetime intrinsics are only promotable if they cover the whole alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3356</td>
    <td class="codeLine">    // Therefore, we drop lifetime intrinsics which don't cover the whole</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3356</td>
    <td class="codeLine">    // Therefore, we drop lifetime intrinsics which don't cover the whole</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3357</td>
    <td class="codeLine">    // alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3357</td>
    <td class="codeLine">    // alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3358</td>
    <td class="codeLine">    // (In theory, intrinsics which partially cover an alloca could be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3358</td>
    <td class="codeLine">    // (In theory, intrinsics which partially cover an alloca could be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3359</td>
    <td class="codeLine">    // promoted, but PromoteMemToReg doesn't handle that case.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3359</td>
    <td class="codeLine">    // promoted, but PromoteMemToReg doesn't handle that case.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3360</td>
    <td class="codeLine">    // FIXME: Check whether the alloca is promotable before dropping the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3360</td>
    <td class="codeLine">    // FIXME: Check whether the alloca is promotable before dropping the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3361</td>
    <td class="codeLine">    // lifetime intrinsics?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3361</td>
    <td class="codeLine">    // lifetime intrinsics?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3362</td>
    <td class="codeLine">    if (NewBeginOffset != NewAllocaBeginOffset ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3362</td>
    <td class="codeLine">    if (NewBeginOffset != NewAllocaBeginOffset ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3363</td>
    <td class="codeLine">        NewEndOffset != NewAllocaEndOffset)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3363</td>
    <td class="codeLine">        NewEndOffset != NewAllocaEndOffset)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3364</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3364</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3366</td>
    <td class="codeLine">    ConstantInt *Size =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3366</td>
    <td class="codeLine">    ConstantInt *Size =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3367</td>
    <td class="codeLine">        ConstantInt::get(cast<IntegerType>(II.getArgOperand(0)->getType()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3367</td>
    <td class="codeLine">        ConstantInt::get(cast<IntegerType>(II.getArgOperand(0)->getType()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3368</td>
    <td class="codeLine">                         NewEndOffset - NewBeginOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3368</td>
    <td class="codeLine">                         NewEndOffset - NewBeginOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3369</td>
    <td class="codeLine">    // Lifetime intrinsics always expect an i8* so directly get such a pointer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3369</td>
    <td class="codeLine">    // Lifetime intrinsics always expect an i8* so directly get such a pointer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3370</td>
    <td class="codeLine">    // for the new alloca slice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3370</td>
    <td class="codeLine">    // for the new alloca slice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3371</td>
    <td class="codeLine">    Type *PointerTy = IRB.getInt8PtrTy(OldPtr->getType()->getPointerAddressSpace());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3371</td>
    <td class="codeLine">    Type *PointerTy = IRB.getInt8PtrTy(OldPtr->getType()->getPointerAddressSpace());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3372</td>
    <td class="codeLine">    Value *Ptr = getNewAllocaSlicePtr(IRB, PointerTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3372</td>
    <td class="codeLine">    Value *Ptr = getNewAllocaSlicePtr(IRB, PointerTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3373</td>
    <td class="codeLine">    Value *New;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3373</td>
    <td class="codeLine">    Value *New;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3374</td>
    <td class="codeLine">    if (II.getIntrinsicID() == Intrinsic::lifetime_start)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3374</td>
    <td class="codeLine">    if (II.getIntrinsicID() == Intrinsic::lifetime_start)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3375</td>
    <td class="codeLine">      New = IRB.CreateLifetimeStart(Ptr, Size);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3375</td>
    <td class="codeLine">      New = IRB.CreateLifetimeStart(Ptr, Size);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3376</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3376</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3377</td>
    <td class="codeLine">      New = IRB.CreateLifetimeEnd(Ptr, Size);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3377</td>
    <td class="codeLine">      New = IRB.CreateLifetimeEnd(Ptr, Size);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3378</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3379</td>
    <td class="codeLine">    (void)New;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3379</td>
    <td class="codeLine">    (void)New;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3380</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3380</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << *New << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3381</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3382</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3382</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3383</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3383</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3385</td>
    <td class="codeLine">  void fixLoadStoreAlign(Instruction &Root) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3385</td>
    <td class="codeLine">  void fixLoadStoreAlign(Instruction &Root) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3386</td>
    <td class="codeLine">    // This algorithm implements the same visitor loop as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3386</td>
    <td class="codeLine">    // This algorithm implements the same visitor loop as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3387</td>
    <td class="codeLine">    // hasUnsafePHIOrSelectUse, and fixes the alignment of each load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3387</td>
    <td class="codeLine">    // hasUnsafePHIOrSelectUse, and fixes the alignment of each load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3388</td>
    <td class="codeLine">    // or store found.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3388</td>
    <td class="codeLine">    // or store found.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3389</td>
    <td class="codeLine">    SmallPtrSet<Instruction *, 4> Visited;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3389</td>
    <td class="codeLine">    SmallPtrSet<Instruction *, 4> Visited;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3390</td>
    <td class="codeLine">    SmallVector<Instruction *, 4> Uses;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3390</td>
    <td class="codeLine">    SmallVector<Instruction *, 4> Uses;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3391</td>
    <td class="codeLine">    Visited.insert(&Root);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3391</td>
    <td class="codeLine">    Visited.insert(&Root);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3392</td>
    <td class="codeLine">    Uses.push_back(&Root);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3392</td>
    <td class="codeLine">    Uses.push_back(&Root);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3393</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3393</td>
    <td class="codeLine">    do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3394</td>
    <td class="codeLine">      Instruction *I = Uses.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3394</td>
    <td class="codeLine">      Instruction *I = Uses.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3395</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3396</td>
    <td class="codeLine">      if (LoadInst *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3396</td>
    <td class="codeLine">      if (LoadInst *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3397</td>
    <td class="codeLine">        LI->setAlignment(std::min(LI->getAlign(), getSliceAlign()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3397</td>
    <td class="codeLine">        LI->setAlignment(std::min(LI->getAlign(), getSliceAlign()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3398</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3398</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3399</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3399</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3400</td>
    <td class="codeLine">      if (StoreInst *SI = dyn_cast<StoreInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3400</td>
    <td class="codeLine">      if (StoreInst *SI = dyn_cast<StoreInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3401</td>
    <td class="codeLine">        SI->setAlignment(std::min(SI->getAlign(), getSliceAlign()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3401</td>
    <td class="codeLine">        SI->setAlignment(std::min(SI->getAlign(), getSliceAlign()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3402</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3402</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3403</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3403</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3404</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3404</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3405</td>
    <td class="codeLine">      assert(isa<BitCastInst>(I) || isa<AddrSpaceCastInst>(I) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3405</td>
    <td class="codeLine">      assert(isa<BitCastInst>(I) || isa<AddrSpaceCastInst>(I) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3406</td>
    <td class="codeLine">             isa<PHINode>(I) || isa<SelectInst>(I) ||</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3406</td>
    <td class="codeLine">             isa<PHINode>(I) || isa<SelectInst>(I) ||</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3407</td>
    <td class="codeLine">             isa<GetElementPtrInst>(I));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3407</td>
    <td class="codeLine">             isa<GetElementPtrInst>(I));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3408</td>
    <td class="codeLine">      for (User *U : I->users())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3408</td>
    <td class="codeLine">      for (User *U : I->users())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3409</td>
    <td class="codeLine">        if (Visited.insert(cast<Instruction>(U)).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3409</td>
    <td class="codeLine">        if (Visited.insert(cast<Instruction>(U)).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3410</td>
    <td class="codeLine">          Uses.push_back(cast<Instruction>(U));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3410</td>
    <td class="codeLine">          Uses.push_back(cast<Instruction>(U));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3411</td>
    <td class="codeLine">    } while (!Uses.empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3411</td>
    <td class="codeLine">    } while (!Uses.empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3412</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3412</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3413</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3414</td>
    <td class="codeLine">  bool visitPHINode(PHINode &PN) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3414</td>
    <td class="codeLine">  bool visitPHINode(PHINode &PN) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3415</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << PN << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3415</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << PN << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3416</td>
    <td class="codeLine">    assert(BeginOffset >= NewAllocaBeginOffset && "PHIs are unsplittable");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3416</td>
    <td class="codeLine">    assert(BeginOffset >= NewAllocaBeginOffset && "PHIs are unsplittable");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3417</td>
    <td class="codeLine">    assert(EndOffset <= NewAllocaEndOffset && "PHIs are unsplittable");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3417</td>
    <td class="codeLine">    assert(EndOffset <= NewAllocaEndOffset && "PHIs are unsplittable");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3418</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3419</td>
    <td class="codeLine">    // We would like to compute a new pointer in only one place, but have it be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3419</td>
    <td class="codeLine">    // We would like to compute a new pointer in only one place, but have it be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3420</td>
    <td class="codeLine">    // as local as possible to the PHI. To do that, we re-use the location of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3420</td>
    <td class="codeLine">    // as local as possible to the PHI. To do that, we re-use the location of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3421</td>
    <td class="codeLine">    // the old pointer, which necessarily must be in the right position to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3421</td>
    <td class="codeLine">    // the old pointer, which necessarily must be in the right position to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3422</td>
    <td class="codeLine">    // dominate the PHI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3422</td>
    <td class="codeLine">    // dominate the PHI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3423</td>
    <td class="codeLine">    IRBuilderBase::InsertPointGuard Guard(IRB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3423</td>
    <td class="codeLine">    IRBuilderBase::InsertPointGuard Guard(IRB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3424</td>
    <td class="codeLine">    if (isa<PHINode>(OldPtr))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3424</td>
    <td class="codeLine">    if (isa<PHINode>(OldPtr))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3425</td>
    <td class="codeLine">      IRB.SetInsertPoint(&*OldPtr->getParent()->getFirstInsertionPt());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3425</td>
    <td class="codeLine">      IRB.SetInsertPoint(&*OldPtr->getParent()->getFirstInsertionPt());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3426</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3426</td>
    <td class="codeLine">    else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3427</td>
    <td class="codeLine">      IRB.SetInsertPoint(OldPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3427</td>
    <td class="codeLine">      IRB.SetInsertPoint(OldPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3428</td>
    <td class="codeLine">    IRB.SetCurrentDebugLocation(OldPtr->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3428</td>
    <td class="codeLine">    IRB.SetCurrentDebugLocation(OldPtr->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3430</td>
    <td class="codeLine">    Value *NewPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3430</td>
    <td class="codeLine">    Value *NewPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3431</td>
    <td class="codeLine">    // Replace the operands which were using the old pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3431</td>
    <td class="codeLine">    // Replace the operands which were using the old pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3432</td>
    <td class="codeLine">    std::replace(PN.op_begin(), PN.op_end(), cast<Value>(OldPtr), NewPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3432</td>
    <td class="codeLine">    std::replace(PN.op_begin(), PN.op_end(), cast<Value>(OldPtr), NewPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3434</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << PN << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3434</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << PN << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3435</td>
    <td class="codeLine">    deleteIfTriviallyDead(OldPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3435</td>
    <td class="codeLine">    deleteIfTriviallyDead(OldPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3436</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3437</td>
    <td class="codeLine">    // Fix the alignment of any loads or stores using this PHI node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3437</td>
    <td class="codeLine">    // Fix the alignment of any loads or stores using this PHI node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3438</td>
    <td class="codeLine">    fixLoadStoreAlign(PN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3438</td>
    <td class="codeLine">    fixLoadStoreAlign(PN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3439</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3440</td>
    <td class="codeLine">    // PHIs can't be promoted on their own, but often can be speculated. We</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3440</td>
    <td class="codeLine">    // PHIs can't be promoted on their own, but often can be speculated. We</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3441</td>
    <td class="codeLine">    // check the speculation outside of the rewriter so that we see the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3441</td>
    <td class="codeLine">    // check the speculation outside of the rewriter so that we see the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3442</td>
    <td class="codeLine">    // fully-rewritten alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3442</td>
    <td class="codeLine">    // fully-rewritten alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3443</td>
    <td class="codeLine">    PHIUsers.insert(&PN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3443</td>
    <td class="codeLine">    PHIUsers.insert(&PN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3444</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3444</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3445</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3445</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3447</td>
    <td class="codeLine">  bool visitSelectInst(SelectInst &SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3447</td>
    <td class="codeLine">  bool visitSelectInst(SelectInst &SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3448</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3448</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3449</td>
    <td class="codeLine">    assert((SI.getTrueValue() == OldPtr || SI.getFalseValue() == OldPtr) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3449</td>
    <td class="codeLine">    assert((SI.getTrueValue() == OldPtr || SI.getFalseValue() == OldPtr) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3450</td>
    <td class="codeLine">           "Pointer isn't an operand!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3450</td>
    <td class="codeLine">           "Pointer isn't an operand!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3451</td>
    <td class="codeLine">    assert(BeginOffset >= NewAllocaBeginOffset && "Selects are unsplittable");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3451</td>
    <td class="codeLine">    assert(BeginOffset >= NewAllocaBeginOffset && "Selects are unsplittable");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3452</td>
    <td class="codeLine">    assert(EndOffset <= NewAllocaEndOffset && "Selects are unsplittable");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3452</td>
    <td class="codeLine">    assert(EndOffset <= NewAllocaEndOffset && "Selects are unsplittable");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3454</td>
    <td class="codeLine">    Value *NewPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3454</td>
    <td class="codeLine">    Value *NewPtr = getNewAllocaSlicePtr(IRB, OldPtr->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3455</td>
    <td class="codeLine">    // Replace the operands which were using the old pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3455</td>
    <td class="codeLine">    // Replace the operands which were using the old pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3456</td>
    <td class="codeLine">    if (SI.getOperand(1) == OldPtr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3456</td>
    <td class="codeLine">    if (SI.getOperand(1) == OldPtr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3457</td>
    <td class="codeLine">      SI.setOperand(1, NewPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3457</td>
    <td class="codeLine">      SI.setOperand(1, NewPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3458</td>
    <td class="codeLine">    if (SI.getOperand(2) == OldPtr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3458</td>
    <td class="codeLine">    if (SI.getOperand(2) == OldPtr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3459</td>
    <td class="codeLine">      SI.setOperand(2, NewPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3459</td>
    <td class="codeLine">      SI.setOperand(2, NewPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3460</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3461</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << SI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3461</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "          to: " << SI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3462</td>
    <td class="codeLine">    deleteIfTriviallyDead(OldPtr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3462</td>
    <td class="codeLine">    deleteIfTriviallyDead(OldPtr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3464</td>
    <td class="codeLine">    // Fix the alignment of any loads or stores using this select.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3464</td>
    <td class="codeLine">    // Fix the alignment of any loads or stores using this select.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3465</td>
    <td class="codeLine">    fixLoadStoreAlign(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3465</td>
    <td class="codeLine">    fixLoadStoreAlign(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3467</td>
    <td class="codeLine">    // Selects can't be promoted on their own, but often can be speculated. We</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3467</td>
    <td class="codeLine">    // Selects can't be promoted on their own, but often can be speculated. We</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3468</td>
    <td class="codeLine">    // check the speculation outside of the rewriter so that we see the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3468</td>
    <td class="codeLine">    // check the speculation outside of the rewriter so that we see the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3469</td>
    <td class="codeLine">    // fully-rewritten alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3469</td>
    <td class="codeLine">    // fully-rewritten alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3470</td>
    <td class="codeLine">    SelectUsers.insert(&SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3470</td>
    <td class="codeLine">    SelectUsers.insert(&SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3471</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3471</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3472</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3472</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3473</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3473</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3474</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3475</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3475</td>
    <td class="codeLine">namespace {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3477</td>
    <td class="codeLine">/// Visitor to rewrite aggregate loads and stores as scalar.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3477</td>
    <td class="codeLine">/// Visitor to rewrite aggregate loads and stores as scalar.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3478</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3478</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3479</td>
    <td class="codeLine">/// This pass aggressively rewrites all aggregate loads and stores on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3479</td>
    <td class="codeLine">/// This pass aggressively rewrites all aggregate loads and stores on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3480</td>
    <td class="codeLine">/// a particular pointer (or any pointer derived from it which we can identify)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3480</td>
    <td class="codeLine">/// a particular pointer (or any pointer derived from it which we can identify)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3481</td>
    <td class="codeLine">/// with scalar loads and stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3481</td>
    <td class="codeLine">/// with scalar loads and stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3482</td>
    <td class="codeLine">class AggLoadStoreRewriter : public InstVisitor<AggLoadStoreRewriter, bool> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3482</td>
    <td class="codeLine">class AggLoadStoreRewriter : public InstVisitor<AggLoadStoreRewriter, bool> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3483</td>
    <td class="codeLine">  // Befriend the base class so it can delegate to private visit methods.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3483</td>
    <td class="codeLine">  // Befriend the base class so it can delegate to private visit methods.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3484</td>
    <td class="codeLine">  friend class InstVisitor<AggLoadStoreRewriter, bool>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3484</td>
    <td class="codeLine">  friend class InstVisitor<AggLoadStoreRewriter, bool>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3485</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3486</td>
    <td class="codeLine">  /// Queue of pointer uses to analyze and potentially rewrite.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3486</td>
    <td class="codeLine">  /// Queue of pointer uses to analyze and potentially rewrite.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3487</td>
    <td class="codeLine">  SmallVector<Use *, 8> Queue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3487</td>
    <td class="codeLine">  SmallVector<Use *, 8> Queue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3489</td>
    <td class="codeLine">  /// Set to prevent us from cycling with phi nodes and loops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3489</td>
    <td class="codeLine">  /// Set to prevent us from cycling with phi nodes and loops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3490</td>
    <td class="codeLine">  SmallPtrSet<User *, 8> Visited;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3490</td>
    <td class="codeLine">  SmallPtrSet<User *, 8> Visited;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3491</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3492</td>
    <td class="codeLine">  /// The current pointer use being rewritten. This is used to dig up the used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3492</td>
    <td class="codeLine">  /// The current pointer use being rewritten. This is used to dig up the used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3493</td>
    <td class="codeLine">  /// value (as opposed to the user).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3493</td>
    <td class="codeLine">  /// value (as opposed to the user).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3494</td>
    <td class="codeLine">  Use *U = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3494</td>
    <td class="codeLine">  Use *U = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3496</td>
    <td class="codeLine">  /// Used to calculate offsets, and hence alignment, of subobjects.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3496</td>
    <td class="codeLine">  /// Used to calculate offsets, and hence alignment, of subobjects.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3497</td>
    <td class="codeLine">  const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3497</td>
    <td class="codeLine">  const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3498</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3499</td>
    <td class="codeLine">  IRBuilderTy &IRB;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3499</td>
    <td class="codeLine">  IRBuilderTy &IRB;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3500</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3501</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3501</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3502</td>
    <td class="codeLine">  AggLoadStoreRewriter(const DataLayout &DL, IRBuilderTy &IRB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3502</td>
    <td class="codeLine">  AggLoadStoreRewriter(const DataLayout &DL, IRBuilderTy &IRB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3503</td>
    <td class="codeLine">      : DL(DL), IRB(IRB) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3503</td>
    <td class="codeLine">      : DL(DL), IRB(IRB) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3504</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3505</td>
    <td class="codeLine">  /// Rewrite loads and stores through a pointer and all pointers derived from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3505</td>
    <td class="codeLine">  /// Rewrite loads and stores through a pointer and all pointers derived from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3506</td>
    <td class="codeLine">  /// it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3506</td>
    <td class="codeLine">  /// it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3507</td>
    <td class="codeLine">  bool rewrite(Instruction &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3507</td>
    <td class="codeLine">  bool rewrite(Instruction &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3508</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  Rewriting FCA loads and stores...\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3508</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  Rewriting FCA loads and stores...\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3509</td>
    <td class="codeLine">    enqueueUsers(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3509</td>
    <td class="codeLine">    enqueueUsers(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3510</td>
    <td class="codeLine">    bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3510</td>
    <td class="codeLine">    bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3511</td>
    <td class="codeLine">    while (!Queue.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3511</td>
    <td class="codeLine">    while (!Queue.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3512</td>
    <td class="codeLine">      U = Queue.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3512</td>
    <td class="codeLine">      U = Queue.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3513</td>
    <td class="codeLine">      Changed |= visit(cast<Instruction>(U->getUser()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3513</td>
    <td class="codeLine">      Changed |= visit(cast<Instruction>(U->getUser()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3514</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3514</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3515</td>
    <td class="codeLine">    return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3515</td>
    <td class="codeLine">    return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3516</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3516</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3517</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3518</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3518</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3519</td>
    <td class="codeLine">  /// Enqueue all the users of the given instruction for further processing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3519</td>
    <td class="codeLine">  /// Enqueue all the users of the given instruction for further processing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3520</td>
    <td class="codeLine">  /// This uses a set to de-duplicate users.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3520</td>
    <td class="codeLine">  /// This uses a set to de-duplicate users.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3521</td>
    <td class="codeLine">  void enqueueUsers(Instruction &I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3521</td>
    <td class="codeLine">  void enqueueUsers(Instruction &I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3522</td>
    <td class="codeLine">    for (Use &U : I.uses())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3522</td>
    <td class="codeLine">    for (Use &U : I.uses())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3523</td>
    <td class="codeLine">      if (Visited.insert(U.getUser()).second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3523</td>
    <td class="codeLine">      if (Visited.insert(U.getUser()).second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3524</td>
    <td class="codeLine">        Queue.push_back(&U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3524</td>
    <td class="codeLine">        Queue.push_back(&U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3525</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3525</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3526</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3527</td>
    <td class="codeLine">  // Conservative default is to not rewrite anything.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3527</td>
    <td class="codeLine">  // Conservative default is to not rewrite anything.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3528</td>
    <td class="codeLine">  bool visitInstruction(Instruction &I) { return false; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3528</td>
    <td class="codeLine">  bool visitInstruction(Instruction &I) { return false; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3529</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3529</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3530</td>
    <td class="codeLine">  /// Generic recursive split emission class.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3530</td>
    <td class="codeLine">  /// Generic recursive split emission class.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3531</td>
    <td class="codeLine">  template <typename Derived> class OpSplitter {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3531</td>
    <td class="codeLine">  template <typename Derived> class OpSplitter {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3532</td>
    <td class="codeLine">  protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3532</td>
    <td class="codeLine">  protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3533</td>
    <td class="codeLine">    /// The builder used to form new instructions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3533</td>
    <td class="codeLine">    /// The builder used to form new instructions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3534</td>
    <td class="codeLine">    IRBuilderTy &IRB;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3534</td>
    <td class="codeLine">    IRBuilderTy &IRB;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3536</td>
    <td class="codeLine">    /// The indices which to be used with insert- or extractvalue to select the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3536</td>
    <td class="codeLine">    /// The indices which to be used with insert- or extractvalue to select the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3537</td>
    <td class="codeLine">    /// appropriate value within the aggregate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3537</td>
    <td class="codeLine">    /// appropriate value within the aggregate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3538</td>
    <td class="codeLine">    SmallVector<unsigned, 4> Indices;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3538</td>
    <td class="codeLine">    SmallVector<unsigned, 4> Indices;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3539</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3539</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3540</td>
    <td class="codeLine">    /// The indices to a GEP instruction which will move Ptr to the correct slot</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3540</td>
    <td class="codeLine">    /// The indices to a GEP instruction which will move Ptr to the correct slot</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3541</td>
    <td class="codeLine">    /// within the aggregate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3541</td>
    <td class="codeLine">    /// within the aggregate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3542</td>
    <td class="codeLine">    SmallVector<Value *, 4> GEPIndices;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3542</td>
    <td class="codeLine">    SmallVector<Value *, 4> GEPIndices;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3543</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3544</td>
    <td class="codeLine">    /// The base pointer of the original op, used as a base for GEPing the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3544</td>
    <td class="codeLine">    /// The base pointer of the original op, used as a base for GEPing the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3545</td>
    <td class="codeLine">    /// split operations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3545</td>
    <td class="codeLine">    /// split operations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3546</td>
    <td class="codeLine">    Value *Ptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3546</td>
    <td class="codeLine">    Value *Ptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3547</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3548</td>
    <td class="codeLine">    /// The base pointee type being GEPed into.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3548</td>
    <td class="codeLine">    /// The base pointee type being GEPed into.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3549</td>
    <td class="codeLine">    Type *BaseTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3549</td>
    <td class="codeLine">    Type *BaseTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3550</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3550</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3551</td>
    <td class="codeLine">    /// Known alignment of the base pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3551</td>
    <td class="codeLine">    /// Known alignment of the base pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3552</td>
    <td class="codeLine">    Align BaseAlign;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3552</td>
    <td class="codeLine">    Align BaseAlign;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3553</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3554</td>
    <td class="codeLine">    /// To calculate offset of each component so we can correctly deduce</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3554</td>
    <td class="codeLine">    /// To calculate offset of each component so we can correctly deduce</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3555</td>
    <td class="codeLine">    /// alignments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3555</td>
    <td class="codeLine">    /// alignments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3556</td>
    <td class="codeLine">    const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3556</td>
    <td class="codeLine">    const DataLayout &DL;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3557</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3558</td>
    <td class="codeLine">    /// Initialize the splitter with an insertion point, Ptr and start with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3558</td>
    <td class="codeLine">    /// Initialize the splitter with an insertion point, Ptr and start with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3559</td>
    <td class="codeLine">    /// single zero GEP index.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3559</td>
    <td class="codeLine">    /// single zero GEP index.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3560</td>
    <td class="codeLine">    OpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3560</td>
    <td class="codeLine">    OpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3561</td>
    <td class="codeLine">               Align BaseAlign, const DataLayout &DL, IRBuilderTy &IRB)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3561</td>
    <td class="codeLine">               Align BaseAlign, const DataLayout &DL, IRBuilderTy &IRB)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3562</td>
    <td class="codeLine">        : IRB(IRB), GEPIndices(1, IRB.getInt32(0)), Ptr(Ptr), BaseTy(BaseTy),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3562</td>
    <td class="codeLine">        : IRB(IRB), GEPIndices(1, IRB.getInt32(0)), Ptr(Ptr), BaseTy(BaseTy),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3563</td>
    <td class="codeLine">          BaseAlign(BaseAlign), DL(DL) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3563</td>
    <td class="codeLine">          BaseAlign(BaseAlign), DL(DL) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3564</td>
    <td class="codeLine">      IRB.SetInsertPoint(InsertionPoint);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3564</td>
    <td class="codeLine">      IRB.SetInsertPoint(InsertionPoint);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3565</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3565</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3567</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3567</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3568</td>
    <td class="codeLine">    /// Generic recursive split emission routine.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3568</td>
    <td class="codeLine">    /// Generic recursive split emission routine.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3569</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3569</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3570</td>
    <td class="codeLine">    /// This method recursively splits an aggregate op (load or store) into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3570</td>
    <td class="codeLine">    /// This method recursively splits an aggregate op (load or store) into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3571</td>
    <td class="codeLine">    /// scalar or vector ops. It splits recursively until it hits a single value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3571</td>
    <td class="codeLine">    /// scalar or vector ops. It splits recursively until it hits a single value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3572</td>
    <td class="codeLine">    /// and emits that single value operation via the template argument.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3572</td>
    <td class="codeLine">    /// and emits that single value operation via the template argument.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3573</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3573</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3574</td>
    <td class="codeLine">    /// The logic of this routine relies on GEPs and insertvalue and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3574</td>
    <td class="codeLine">    /// The logic of this routine relies on GEPs and insertvalue and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3575</td>
    <td class="codeLine">    /// extractvalue all operating with the same fundamental index list, merely</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3575</td>
    <td class="codeLine">    /// extractvalue all operating with the same fundamental index list, merely</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3576</td>
    <td class="codeLine">    /// formatted differently (GEPs need actual values).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3576</td>
    <td class="codeLine">    /// formatted differently (GEPs need actual values).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3577</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3577</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3578</td>
    <td class="codeLine">    /// \param Ty  The type being split recursively into smaller ops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3578</td>
    <td class="codeLine">    /// \param Ty  The type being split recursively into smaller ops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3579</td>
    <td class="codeLine">    /// \param Agg The aggregate value being built up or stored, depending on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3579</td>
    <td class="codeLine">    /// \param Agg The aggregate value being built up or stored, depending on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3580</td>
    <td class="codeLine">    /// whether this is splitting a load or a store respectively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3580</td>
    <td class="codeLine">    /// whether this is splitting a load or a store respectively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3581</td>
    <td class="codeLine">    void emitSplitOps(Type *Ty, Value *&Agg, const Twine &Name) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3581</td>
    <td class="codeLine">    void emitSplitOps(Type *Ty, Value *&Agg, const Twine &Name) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3582</td>
    <td class="codeLine">      if (Ty->isSingleValueType()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3582</td>
    <td class="codeLine">      if (Ty->isSingleValueType()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3583</td>
    <td class="codeLine">        unsigned Offset = DL.getIndexedOffsetInType(BaseTy, GEPIndices);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3583</td>
    <td class="codeLine">        unsigned Offset = DL.getIndexedOffsetInType(BaseTy, GEPIndices);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3584</td>
    <td class="codeLine">        return static_cast<Derived *>(this)->emitFunc(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3584</td>
    <td class="codeLine">        return static_cast<Derived *>(this)->emitFunc(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3585</td>
    <td class="codeLine">            Ty, Agg, commonAlignment(BaseAlign, Offset), Name);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3585</td>
    <td class="codeLine">            Ty, Agg, commonAlignment(BaseAlign, Offset), Name);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3586</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3586</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3587</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3588</td>
    <td class="codeLine">      if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3588</td>
    <td class="codeLine">      if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3589</td>
    <td class="codeLine">        unsigned OldSize = Indices.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3589</td>
    <td class="codeLine">        unsigned OldSize = Indices.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3590</td>
    <td class="codeLine">        (void)OldSize;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3590</td>
    <td class="codeLine">        (void)OldSize;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3591</td>
    <td class="codeLine">        for (unsigned Idx = 0, Size = ATy->getNumElements(); Idx != Size;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3591</td>
    <td class="codeLine">        for (unsigned Idx = 0, Size = ATy->getNumElements(); Idx != Size;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3592</td>
    <td class="codeLine">             ++Idx) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3592</td>
    <td class="codeLine">             ++Idx) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3593</td>
    <td class="codeLine">          assert(Indices.size() == OldSize && "Did not return to the old size");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3593</td>
    <td class="codeLine">          assert(Indices.size() == OldSize && "Did not return to the old size");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3594</td>
    <td class="codeLine">          Indices.push_back(Idx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3594</td>
    <td class="codeLine">          Indices.push_back(Idx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3595</td>
    <td class="codeLine">          GEPIndices.push_back(IRB.getInt32(Idx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3595</td>
    <td class="codeLine">          GEPIndices.push_back(IRB.getInt32(Idx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3596</td>
    <td class="codeLine">          emitSplitOps(ATy->getElementType(), Agg, Name + "." + Twine(Idx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3596</td>
    <td class="codeLine">          emitSplitOps(ATy->getElementType(), Agg, Name + "." + Twine(Idx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3597</td>
    <td class="codeLine">          GEPIndices.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3597</td>
    <td class="codeLine">          GEPIndices.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3598</td>
    <td class="codeLine">          Indices.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3598</td>
    <td class="codeLine">          Indices.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3599</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3599</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3600</td>
    <td class="codeLine">        return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3600</td>
    <td class="codeLine">        return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3601</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3601</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3602</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3603</td>
    <td class="codeLine">      if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3603</td>
    <td class="codeLine">      if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3604</td>
    <td class="codeLine">        unsigned OldSize = Indices.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3604</td>
    <td class="codeLine">        unsigned OldSize = Indices.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3605</td>
    <td class="codeLine">        (void)OldSize;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3605</td>
    <td class="codeLine">        (void)OldSize;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3606</td>
    <td class="codeLine">        for (unsigned Idx = 0, Size = STy->getNumElements(); Idx != Size;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3606</td>
    <td class="codeLine">        for (unsigned Idx = 0, Size = STy->getNumElements(); Idx != Size;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3607</td>
    <td class="codeLine">             ++Idx) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3607</td>
    <td class="codeLine">             ++Idx) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3608</td>
    <td class="codeLine">          assert(Indices.size() == OldSize && "Did not return to the old size");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3608</td>
    <td class="codeLine">          assert(Indices.size() == OldSize && "Did not return to the old size");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3609</td>
    <td class="codeLine">          Indices.push_back(Idx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3609</td>
    <td class="codeLine">          Indices.push_back(Idx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3610</td>
    <td class="codeLine">          GEPIndices.push_back(IRB.getInt32(Idx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3610</td>
    <td class="codeLine">          GEPIndices.push_back(IRB.getInt32(Idx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3611</td>
    <td class="codeLine">          emitSplitOps(STy->getElementType(Idx), Agg, Name + "." + Twine(Idx));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3611</td>
    <td class="codeLine">          emitSplitOps(STy->getElementType(Idx), Agg, Name + "." + Twine(Idx));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3612</td>
    <td class="codeLine">          GEPIndices.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3612</td>
    <td class="codeLine">          GEPIndices.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3613</td>
    <td class="codeLine">          Indices.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3613</td>
    <td class="codeLine">          Indices.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3614</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3614</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3615</td>
    <td class="codeLine">        return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3615</td>
    <td class="codeLine">        return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3616</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3616</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3617</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3617</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3618</td>
    <td class="codeLine">      llvm_unreachable("Only arrays and structs are aggregate loadable types");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3618</td>
    <td class="codeLine">      llvm_unreachable("Only arrays and structs are aggregate loadable types");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3619</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3619</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3620</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3620</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3621</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3622</td>
    <td class="codeLine">  struct LoadOpSplitter : public OpSplitter<LoadOpSplitter> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3622</td>
    <td class="codeLine">  struct LoadOpSplitter : public OpSplitter<LoadOpSplitter> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3623</td>
    <td class="codeLine">    AAMDNodes AATags;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3623</td>
    <td class="codeLine">    AAMDNodes AATags;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3624</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3625</td>
    <td class="codeLine">    LoadOpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3625</td>
    <td class="codeLine">    LoadOpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3626</td>
    <td class="codeLine">                   AAMDNodes AATags, Align BaseAlign, const DataLayout &DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3626</td>
    <td class="codeLine">                   AAMDNodes AATags, Align BaseAlign, const DataLayout &DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3627</td>
    <td class="codeLine">                   IRBuilderTy &IRB)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3627</td>
    <td class="codeLine">                   IRBuilderTy &IRB)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3628</td>
    <td class="codeLine">        : OpSplitter<LoadOpSplitter>(InsertionPoint, Ptr, BaseTy, BaseAlign, DL,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3628</td>
    <td class="codeLine">        : OpSplitter<LoadOpSplitter>(InsertionPoint, Ptr, BaseTy, BaseAlign, DL,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3629</td>
    <td class="codeLine">                                     IRB),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3629</td>
    <td class="codeLine">                                     IRB),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3630</td>
    <td class="codeLine">          AATags(AATags) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3630</td>
    <td class="codeLine">          AATags(AATags) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3632</td>
    <td class="codeLine">    /// Emit a leaf load of a single value. This is called at the leaves of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3632</td>
    <td class="codeLine">    /// Emit a leaf load of a single value. This is called at the leaves of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3633</td>
    <td class="codeLine">    /// recursive emission to actually load values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3633</td>
    <td class="codeLine">    /// recursive emission to actually load values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3634</td>
    <td class="codeLine">    void emitFunc(Type *Ty, Value *&Agg, Align Alignment, const Twine &Name) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3634</td>
    <td class="codeLine">    void emitFunc(Type *Ty, Value *&Agg, Align Alignment, const Twine &Name) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3635</td>
    <td class="codeLine">      assert(Ty->isSingleValueType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3635</td>
    <td class="codeLine">      assert(Ty->isSingleValueType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3636</td>
    <td class="codeLine">      // Load the single value and insert it using the indices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3636</td>
    <td class="codeLine">      // Load the single value and insert it using the indices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3637</td>
    <td class="codeLine">      Value *GEP =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3637</td>
    <td class="codeLine">      Value *GEP =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3638</td>
    <td class="codeLine">          IRB.CreateInBoundsGEP(BaseTy, Ptr, GEPIndices, Name + ".gep");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3638</td>
    <td class="codeLine">          IRB.CreateInBoundsGEP(BaseTy, Ptr, GEPIndices, Name + ".gep");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3639</td>
    <td class="codeLine">      LoadInst *Load =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3639</td>
    <td class="codeLine">      LoadInst *Load =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3640</td>
    <td class="codeLine">          IRB.CreateAlignedLoad(Ty, GEP, Alignment, Name + ".load");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3640</td>
    <td class="codeLine">          IRB.CreateAlignedLoad(Ty, GEP, Alignment, Name + ".load");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3642</td>
    <td class="codeLine">      APInt Offset(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3642</td>
    <td class="codeLine">      APInt Offset(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3643</td>
    <td class="codeLine">          DL.getIndexSizeInBits(Ptr->getType()->getPointerAddressSpace()), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3643</td>
    <td class="codeLine">          DL.getIndexSizeInBits(Ptr->getType()->getPointerAddressSpace()), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3644</td>
    <td class="codeLine">      if (AATags &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3644</td>
    <td class="codeLine">      if (AATags &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3645</td>
    <td class="codeLine">          GEPOperator::accumulateConstantOffset(BaseTy, GEPIndices, DL, Offset))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3645</td>
    <td class="codeLine">          GEPOperator::accumulateConstantOffset(BaseTy, GEPIndices, DL, Offset))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3646</td>
    <td class="codeLine">        Load->setAAMetadata(AATags.shift(Offset.getZExtValue()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3646</td>
    <td class="codeLine">        Load->setAAMetadata(AATags.shift(Offset.getZExtValue()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3648</td>
    <td class="codeLine">      Agg = IRB.CreateInsertValue(Agg, Load, Indices, Name + ".insert");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3648</td>
    <td class="codeLine">      Agg = IRB.CreateInsertValue(Agg, Load, Indices, Name + ".insert");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3649</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "          to: " << *Load << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3649</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "          to: " << *Load << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3650</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3650</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3651</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3651</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3653</td>
    <td class="codeLine">  bool visitLoadInst(LoadInst &LI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3653</td>
    <td class="codeLine">  bool visitLoadInst(LoadInst &LI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3654</td>
    <td class="codeLine">    assert(LI.getPointerOperand() == *U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3654</td>
    <td class="codeLine">    assert(LI.getPointerOperand() == *U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3655</td>
    <td class="codeLine">    if (!LI.isSimple() || LI.getType()->isSingleValueType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3655</td>
    <td class="codeLine">    if (!LI.isSimple() || LI.getType()->isSingleValueType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3656</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3656</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3658</td>
    <td class="codeLine">    // We have an aggregate being loaded, split it apart.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3658</td>
    <td class="codeLine">    // We have an aggregate being loaded, split it apart.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3659</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << LI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3659</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << LI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3660</td>
    <td class="codeLine">    LoadOpSplitter Splitter(&LI, *U, LI.getType(), LI.getAAMetadata(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3660</td>
    <td class="codeLine">    LoadOpSplitter Splitter(&LI, *U, LI.getType(), LI.getAAMetadata(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3661</td>
    <td class="codeLine">                            getAdjustedAlignment(&LI, 0), DL, IRB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3661</td>
    <td class="codeLine">                            getAdjustedAlignment(&LI, 0), DL, IRB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3662</td>
    <td class="codeLine">    Value *V = PoisonValue::get(LI.getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3662</td>
    <td class="codeLine">    Value *V = PoisonValue::get(LI.getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3663</td>
    <td class="codeLine">    Splitter.emitSplitOps(LI.getType(), V, LI.getName() + ".fca");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3663</td>
    <td class="codeLine">    Splitter.emitSplitOps(LI.getType(), V, LI.getName() + ".fca");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3664</td>
    <td class="codeLine">    Visited.erase(&LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3664</td>
    <td class="codeLine">    Visited.erase(&LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3665</td>
    <td class="codeLine">    LI.replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3665</td>
    <td class="codeLine">    LI.replaceAllUsesWith(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3666</td>
    <td class="codeLine">    LI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3666</td>
    <td class="codeLine">    LI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3667</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3667</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3668</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3668</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3669</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3670</td>
    <td class="codeLine">  struct StoreOpSplitter : public OpSplitter<StoreOpSplitter> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3670</td>
    <td class="codeLine">  struct StoreOpSplitter : public OpSplitter<StoreOpSplitter> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3671</td>
    <td class="codeLine">    StoreOpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3671</td>
    <td class="codeLine">    StoreOpSplitter(Instruction *InsertionPoint, Value *Ptr, Type *BaseTy,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3672</td>
    <td class="codeLine">                    AAMDNodes AATags, StoreInst *AggStore, Align BaseAlign,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3672</td>
    <td class="codeLine">                    AAMDNodes AATags, StoreInst *AggStore, Align BaseAlign,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3673</td>
    <td class="codeLine">                    const DataLayout &DL, IRBuilderTy &IRB)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3673</td>
    <td class="codeLine">                    const DataLayout &DL, IRBuilderTy &IRB)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3674</td>
    <td class="codeLine">        : OpSplitter<StoreOpSplitter>(InsertionPoint, Ptr, BaseTy, BaseAlign,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3674</td>
    <td class="codeLine">        : OpSplitter<StoreOpSplitter>(InsertionPoint, Ptr, BaseTy, BaseAlign,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3675</td>
    <td class="codeLine">                                      DL, IRB),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3675</td>
    <td class="codeLine">                                      DL, IRB),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3676</td>
    <td class="codeLine">          AATags(AATags), AggStore(AggStore) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3676</td>
    <td class="codeLine">          AATags(AATags), AggStore(AggStore) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3677</td>
    <td class="codeLine">    AAMDNodes AATags;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3677</td>
    <td class="codeLine">    AAMDNodes AATags;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3678</td>
    <td class="codeLine">    StoreInst *AggStore;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3678</td>
    <td class="codeLine">    StoreInst *AggStore;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3679</td>
    <td class="codeLine">    /// Emit a leaf store of a single value. This is called at the leaves of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3679</td>
    <td class="codeLine">    /// Emit a leaf store of a single value. This is called at the leaves of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3680</td>
    <td class="codeLine">    /// recursive emission to actually produce stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3680</td>
    <td class="codeLine">    /// recursive emission to actually produce stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3681</td>
    <td class="codeLine">    void emitFunc(Type *Ty, Value *&Agg, Align Alignment, const Twine &Name) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3681</td>
    <td class="codeLine">    void emitFunc(Type *Ty, Value *&Agg, Align Alignment, const Twine &Name) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3682</td>
    <td class="codeLine">      assert(Ty->isSingleValueType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3682</td>
    <td class="codeLine">      assert(Ty->isSingleValueType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3683</td>
    <td class="codeLine">      // Extract the single value and store it using the indices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3683</td>
    <td class="codeLine">      // Extract the single value and store it using the indices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3684</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3684</td>
    <td class="codeLine">      //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3685</td>
    <td class="codeLine">      // The gep and extractvalue values are factored out of the CreateStore</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3685</td>
    <td class="codeLine">      // The gep and extractvalue values are factored out of the CreateStore</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3686</td>
    <td class="codeLine">      // call to make the output independent of the argument evaluation order.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3686</td>
    <td class="codeLine">      // call to make the output independent of the argument evaluation order.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3687</td>
    <td class="codeLine">      Value *ExtractValue =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3687</td>
    <td class="codeLine">      Value *ExtractValue =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3688</td>
    <td class="codeLine">          IRB.CreateExtractValue(Agg, Indices, Name + ".extract");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3688</td>
    <td class="codeLine">          IRB.CreateExtractValue(Agg, Indices, Name + ".extract");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3689</td>
    <td class="codeLine">      Value *InBoundsGEP =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3689</td>
    <td class="codeLine">      Value *InBoundsGEP =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3690</td>
    <td class="codeLine">          IRB.CreateInBoundsGEP(BaseTy, Ptr, GEPIndices, Name + ".gep");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3690</td>
    <td class="codeLine">          IRB.CreateInBoundsGEP(BaseTy, Ptr, GEPIndices, Name + ".gep");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3691</td>
    <td class="codeLine">      StoreInst *Store =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3691</td>
    <td class="codeLine">      StoreInst *Store =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3692</td>
    <td class="codeLine">          IRB.CreateAlignedStore(ExtractValue, InBoundsGEP, Alignment);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3692</td>
    <td class="codeLine">          IRB.CreateAlignedStore(ExtractValue, InBoundsGEP, Alignment);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3694</td>
    <td class="codeLine">      APInt Offset(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3694</td>
    <td class="codeLine">      APInt Offset(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3695</td>
    <td class="codeLine">          DL.getIndexSizeInBits(Ptr->getType()->getPointerAddressSpace()), 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3695</td>
    <td class="codeLine">          DL.getIndexSizeInBits(Ptr->getType()->getPointerAddressSpace()), 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3696</td>
    <td class="codeLine">      GEPOperator::accumulateConstantOffset(BaseTy, GEPIndices, DL, Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3696</td>
    <td class="codeLine">      GEPOperator::accumulateConstantOffset(BaseTy, GEPIndices, DL, Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3697</td>
    <td class="codeLine">      if (AATags)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3697</td>
    <td class="codeLine">      if (AATags)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3698</td>
    <td class="codeLine">        Store->setAAMetadata(AATags.shift(Offset.getZExtValue()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3698</td>
    <td class="codeLine">        Store->setAAMetadata(AATags.shift(Offset.getZExtValue()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3699</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3700</td>
    <td class="codeLine">      // migrateDebugInfo requires the base Alloca. Walk to it from this gep.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3700</td>
    <td class="codeLine">      // migrateDebugInfo requires the base Alloca. Walk to it from this gep.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3701</td>
    <td class="codeLine">      // If we cannot (because there's an intervening non-const or unbounded</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3701</td>
    <td class="codeLine">      // If we cannot (because there's an intervening non-const or unbounded</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3702</td>
    <td class="codeLine">      // gep) then we wouldn't expect to see dbg.assign intrinsics linked to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3702</td>
    <td class="codeLine">      // gep) then we wouldn't expect to see dbg.assign intrinsics linked to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3703</td>
    <td class="codeLine">      // this instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3703</td>
    <td class="codeLine">      // this instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3704</td>
    <td class="codeLine">      Value *Base = AggStore->getPointerOperand()->stripInBoundsOffsets();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3704</td>
    <td class="codeLine">      Value *Base = AggStore->getPointerOperand()->stripInBoundsOffsets();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3705</td>
    <td class="codeLine">      if (auto *OldAI = dyn_cast<AllocaInst>(Base)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3705</td>
    <td class="codeLine">      if (auto *OldAI = dyn_cast<AllocaInst>(Base)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3706</td>
    <td class="codeLine">        uint64_t SizeInBits =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3706</td>
    <td class="codeLine">        uint64_t SizeInBits =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3707</td>
    <td class="codeLine">            DL.getTypeSizeInBits(Store->getValueOperand()->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3707</td>
    <td class="codeLine">            DL.getTypeSizeInBits(Store->getValueOperand()->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3708</td>
    <td class="codeLine">        migrateDebugInfo(OldAI, /*IsSplit*/ true, Offset.getZExtValue() * 8,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3708</td>
    <td class="codeLine">        migrateDebugInfo(OldAI, /*IsSplit*/ true, Offset.getZExtValue() * 8,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3709</td>
    <td class="codeLine">                         SizeInBits, AggStore, Store,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3709</td>
    <td class="codeLine">                         SizeInBits, AggStore, Store,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3710</td>
    <td class="codeLine">                         Store->getPointerOperand(), Store->getValueOperand(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3710</td>
    <td class="codeLine">                         Store->getPointerOperand(), Store->getValueOperand(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3711</td>
    <td class="codeLine">                         DL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3711</td>
    <td class="codeLine">                         DL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3712</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3712</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3713</td>
    <td class="codeLine">        assert(at::getAssignmentMarkers(Store).empty() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3713</td>
    <td class="codeLine">        assert(at::getAssignmentMarkers(Store).empty() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3714</td>
    <td class="codeLine">               "AT: unexpected debug.assign linked to store through "</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3714</td>
    <td class="codeLine">               "AT: unexpected debug.assign linked to store through "</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3715</td>
    <td class="codeLine">               "unbounded GEP");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3715</td>
    <td class="codeLine">               "unbounded GEP");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3716</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3716</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3717</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3717</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "          to: " << *Store << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3718</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3718</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3719</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3719</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3720</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3721</td>
    <td class="codeLine">  bool visitStoreInst(StoreInst &SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3721</td>
    <td class="codeLine">  bool visitStoreInst(StoreInst &SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3722</td>
    <td class="codeLine">    if (!SI.isSimple() || SI.getPointerOperand() != *U)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3722</td>
    <td class="codeLine">    if (!SI.isSimple() || SI.getPointerOperand() != *U)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3723</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3723</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3724</td>
    <td class="codeLine">    Value *V = SI.getValueOperand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3724</td>
    <td class="codeLine">    Value *V = SI.getValueOperand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3725</td>
    <td class="codeLine">    if (V->getType()->isSingleValueType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3725</td>
    <td class="codeLine">    if (V->getType()->isSingleValueType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3726</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3726</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3728</td>
    <td class="codeLine">    // We have an aggregate being stored, split it apart.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3728</td>
    <td class="codeLine">    // We have an aggregate being stored, split it apart.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3729</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3729</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    original: " << SI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3730</td>
    <td class="codeLine">    StoreOpSplitter Splitter(&SI, *U, V->getType(), SI.getAAMetadata(), &SI,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3730</td>
    <td class="codeLine">    StoreOpSplitter Splitter(&SI, *U, V->getType(), SI.getAAMetadata(), &SI,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3731</td>
    <td class="codeLine">                             getAdjustedAlignment(&SI, 0), DL, IRB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3731</td>
    <td class="codeLine">                             getAdjustedAlignment(&SI, 0), DL, IRB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3732</td>
    <td class="codeLine">    Splitter.emitSplitOps(V->getType(), V, V->getName() + ".fca");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3732</td>
    <td class="codeLine">    Splitter.emitSplitOps(V->getType(), V, V->getName() + ".fca");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3733</td>
    <td class="codeLine">    Visited.erase(&SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3733</td>
    <td class="codeLine">    Visited.erase(&SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3734</td>
    <td class="codeLine">    // The stores replacing SI each have markers describing fragments of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3734</td>
    <td class="codeLine">    // The stores replacing SI each have markers describing fragments of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3735</td>
    <td class="codeLine">    // assignment so delete the assignment markers linked to SI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3735</td>
    <td class="codeLine">    // assignment so delete the assignment markers linked to SI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3736</td>
    <td class="codeLine">    at::deleteAssignmentMarkers(&SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3736</td>
    <td class="codeLine">    at::deleteAssignmentMarkers(&SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3737</td>
    <td class="codeLine">    SI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3737</td>
    <td class="codeLine">    SI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3738</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3738</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3739</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3739</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3740</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3741</td>
    <td class="codeLine">  bool visitBitCastInst(BitCastInst &BC) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3741</td>
    <td class="codeLine">  bool visitBitCastInst(BitCastInst &BC) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3742</td>
    <td class="codeLine">    enqueueUsers(BC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3742</td>
    <td class="codeLine">    enqueueUsers(BC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3743</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3743</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3744</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3744</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3746</td>
    <td class="codeLine">  bool visitAddrSpaceCastInst(AddrSpaceCastInst &ASC) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3746</td>
    <td class="codeLine">  bool visitAddrSpaceCastInst(AddrSpaceCastInst &ASC) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3747</td>
    <td class="codeLine">    enqueueUsers(ASC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3747</td>
    <td class="codeLine">    enqueueUsers(ASC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3748</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3748</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3749</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3749</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3751</td>
    <td class="codeLine">  // Fold gep (select cond, ptr1, ptr2) => select cond, gep(ptr1), gep(ptr2)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3751</td>
    <td class="codeLine">  // Fold gep (select cond, ptr1, ptr2) => select cond, gep(ptr1), gep(ptr2)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3752</td>
    <td class="codeLine">  bool foldGEPSelect(GetElementPtrInst &GEPI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3752</td>
    <td class="codeLine">  bool foldGEPSelect(GetElementPtrInst &GEPI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3753</td>
    <td class="codeLine">    if (!GEPI.hasAllConstantIndices())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3753</td>
    <td class="codeLine">    if (!GEPI.hasAllConstantIndices())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3754</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3754</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3756</td>
    <td class="codeLine">    SelectInst *Sel = cast<SelectInst>(GEPI.getPointerOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3756</td>
    <td class="codeLine">    SelectInst *Sel = cast<SelectInst>(GEPI.getPointerOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3757</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3758</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  Rewriting gep(select) -> select(gep):"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3758</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  Rewriting gep(select) -> select(gep):"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3759</td>
    <td class="codeLine">                      << "\n    original: " << *Sel</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3759</td>
    <td class="codeLine">                      << "\n    original: " << *Sel</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3760</td>
    <td class="codeLine">                      << "\n              " << GEPI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3760</td>
    <td class="codeLine">                      << "\n              " << GEPI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3762</td>
    <td class="codeLine">    IRB.SetInsertPoint(&GEPI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3762</td>
    <td class="codeLine">    IRB.SetInsertPoint(&GEPI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3763</td>
    <td class="codeLine">    SmallVector<Value *, 4> Index(GEPI.indices());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3763</td>
    <td class="codeLine">    SmallVector<Value *, 4> Index(GEPI.indices());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3764</td>
    <td class="codeLine">    bool IsInBounds = GEPI.isInBounds();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3764</td>
    <td class="codeLine">    bool IsInBounds = GEPI.isInBounds();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3766</td>
    <td class="codeLine">    Type *Ty = GEPI.getSourceElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3766</td>
    <td class="codeLine">    Type *Ty = GEPI.getSourceElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3767</td>
    <td class="codeLine">    Value *True = Sel->getTrueValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3767</td>
    <td class="codeLine">    Value *True = Sel->getTrueValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3768</td>
    <td class="codeLine">    Value *NTrue = IRB.CreateGEP(Ty, True, Index, True->getName() + ".sroa.gep",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3768</td>
    <td class="codeLine">    Value *NTrue = IRB.CreateGEP(Ty, True, Index, True->getName() + ".sroa.gep",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3769</td>
    <td class="codeLine">                                 IsInBounds);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3769</td>
    <td class="codeLine">                                 IsInBounds);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3770</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3771</td>
    <td class="codeLine">    Value *False = Sel->getFalseValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3771</td>
    <td class="codeLine">    Value *False = Sel->getFalseValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3772</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3773</td>
    <td class="codeLine">    Value *NFalse = IRB.CreateGEP(Ty, False, Index,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3773</td>
    <td class="codeLine">    Value *NFalse = IRB.CreateGEP(Ty, False, Index,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3774</td>
    <td class="codeLine">                                  False->getName() + ".sroa.gep", IsInBounds);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3774</td>
    <td class="codeLine">                                  False->getName() + ".sroa.gep", IsInBounds);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3776</td>
    <td class="codeLine">    Value *NSel = IRB.CreateSelect(Sel->getCondition(), NTrue, NFalse,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3776</td>
    <td class="codeLine">    Value *NSel = IRB.CreateSelect(Sel->getCondition(), NTrue, NFalse,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3777</td>
    <td class="codeLine">                                   Sel->getName() + ".sroa.sel");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3777</td>
    <td class="codeLine">                                   Sel->getName() + ".sroa.sel");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3778</td>
    <td class="codeLine">    Visited.erase(&GEPI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3778</td>
    <td class="codeLine">    Visited.erase(&GEPI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3779</td>
    <td class="codeLine">    GEPI.replaceAllUsesWith(NSel);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3779</td>
    <td class="codeLine">    GEPI.replaceAllUsesWith(NSel);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3780</td>
    <td class="codeLine">    GEPI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3780</td>
    <td class="codeLine">    GEPI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3781</td>
    <td class="codeLine">    Instruction *NSelI = cast<Instruction>(NSel);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3781</td>
    <td class="codeLine">    Instruction *NSelI = cast<Instruction>(NSel);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3782</td>
    <td class="codeLine">    Visited.insert(NSelI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3782</td>
    <td class="codeLine">    Visited.insert(NSelI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3783</td>
    <td class="codeLine">    enqueueUsers(*NSelI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3783</td>
    <td class="codeLine">    enqueueUsers(*NSelI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3784</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3785</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "\n          to: " << *NTrue</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3785</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "\n          to: " << *NTrue</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3786</td>
    <td class="codeLine">                      << "\n              " << *NFalse</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3786</td>
    <td class="codeLine">                      << "\n              " << *NFalse</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3787</td>
    <td class="codeLine">                      << "\n              " << *NSel << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3787</td>
    <td class="codeLine">                      << "\n              " << *NSel << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3788</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3788</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3789</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3789</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3790</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3790</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3792</td>
    <td class="codeLine">  // Fold gep (phi ptr1, ptr2) => phi gep(ptr1), gep(ptr2)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3792</td>
    <td class="codeLine">  // Fold gep (phi ptr1, ptr2) => phi gep(ptr1), gep(ptr2)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3793</td>
    <td class="codeLine">  bool foldGEPPhi(GetElementPtrInst &GEPI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3793</td>
    <td class="codeLine">  bool foldGEPPhi(GetElementPtrInst &GEPI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3794</td>
    <td class="codeLine">    if (!GEPI.hasAllConstantIndices())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3794</td>
    <td class="codeLine">    if (!GEPI.hasAllConstantIndices())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3795</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3795</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3797</td>
    <td class="codeLine">    PHINode *PHI = cast<PHINode>(GEPI.getPointerOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3797</td>
    <td class="codeLine">    PHINode *PHI = cast<PHINode>(GEPI.getPointerOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3798</td>
    <td class="codeLine">    if (GEPI.getParent() != PHI->getParent() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3798</td>
    <td class="codeLine">    if (GEPI.getParent() != PHI->getParent() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3799</td>
    <td class="codeLine">        llvm::any_of(PHI->incoming_values(), [](Value *In)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3799</td>
    <td class="codeLine">        llvm::any_of(PHI->incoming_values(), [](Value *In)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3800</td>
    <td class="codeLine">          { Instruction *I = dyn_cast<Instruction>(In);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3800</td>
    <td class="codeLine">          { Instruction *I = dyn_cast<Instruction>(In);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3801</td>
    <td class="codeLine">            return !I || isa<GetElementPtrInst>(I) || isa<PHINode>(I) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3801</td>
    <td class="codeLine">            return !I || isa<GetElementPtrInst>(I) || isa<PHINode>(I) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3802</td>
    <td class="codeLine">                   succ_empty(I->getParent()) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3802</td>
    <td class="codeLine">                   succ_empty(I->getParent()) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3803</td>
    <td class="codeLine">                   !I->getParent()->isLegalToHoistInto();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3803</td>
    <td class="codeLine">                   !I->getParent()->isLegalToHoistInto();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3804</td>
    <td class="codeLine">          }))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3804</td>
    <td class="codeLine">          }))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3805</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3805</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3806</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3806</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3807</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  Rewriting gep(phi) -> phi(gep):"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3807</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  Rewriting gep(phi) -> phi(gep):"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3808</td>
    <td class="codeLine">                      << "\n    original: " << *PHI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3808</td>
    <td class="codeLine">                      << "\n    original: " << *PHI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3809</td>
    <td class="codeLine">                      << "\n              " << GEPI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3809</td>
    <td class="codeLine">                      << "\n              " << GEPI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3810</td>
    <td class="codeLine">                      << "\n          to: ");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3810</td>
    <td class="codeLine">                      << "\n          to: ");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3811</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3811</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3812</td>
    <td class="codeLine">    SmallVector<Value *, 4> Index(GEPI.indices());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3812</td>
    <td class="codeLine">    SmallVector<Value *, 4> Index(GEPI.indices());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3813</td>
    <td class="codeLine">    bool IsInBounds = GEPI.isInBounds();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3813</td>
    <td class="codeLine">    bool IsInBounds = GEPI.isInBounds();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3814</td>
    <td class="codeLine">    IRB.SetInsertPoint(GEPI.getParent()->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3814</td>
    <td class="codeLine">    IRB.SetInsertPoint(GEPI.getParent()->getFirstNonPHI());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3815</td>
    <td class="codeLine">    PHINode *NewPN = IRB.CreatePHI(GEPI.getType(), PHI->getNumIncomingValues(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3815</td>
    <td class="codeLine">    PHINode *NewPN = IRB.CreatePHI(GEPI.getType(), PHI->getNumIncomingValues(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3816</td>
    <td class="codeLine">                                   PHI->getName() + ".sroa.phi");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3816</td>
    <td class="codeLine">                                   PHI->getName() + ".sroa.phi");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3817</td>
    <td class="codeLine">    for (unsigned I = 0, E = PHI->getNumIncomingValues(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3817</td>
    <td class="codeLine">    for (unsigned I = 0, E = PHI->getNumIncomingValues(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3818</td>
    <td class="codeLine">      BasicBlock *B = PHI->getIncomingBlock(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3818</td>
    <td class="codeLine">      BasicBlock *B = PHI->getIncomingBlock(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3819</td>
    <td class="codeLine">      Value *NewVal = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3819</td>
    <td class="codeLine">      Value *NewVal = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3820</td>
    <td class="codeLine">      int Idx = NewPN->getBasicBlockIndex(B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3820</td>
    <td class="codeLine">      int Idx = NewPN->getBasicBlockIndex(B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3821</td>
    <td class="codeLine">      if (Idx >= 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3821</td>
    <td class="codeLine">      if (Idx >= 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3822</td>
    <td class="codeLine">        NewVal = NewPN->getIncomingValue(Idx);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3822</td>
    <td class="codeLine">        NewVal = NewPN->getIncomingValue(Idx);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3823</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3823</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3824</td>
    <td class="codeLine">        Instruction *In = cast<Instruction>(PHI->getIncomingValue(I));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3824</td>
    <td class="codeLine">        Instruction *In = cast<Instruction>(PHI->getIncomingValue(I));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3825</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3825</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3826</td>
    <td class="codeLine">        IRB.SetInsertPoint(In->getParent(), std::next(In->getIterator()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3826</td>
    <td class="codeLine">        IRB.SetInsertPoint(In->getParent(), std::next(In->getIterator()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3827</td>
    <td class="codeLine">        Type *Ty = GEPI.getSourceElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3827</td>
    <td class="codeLine">        Type *Ty = GEPI.getSourceElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3828</td>
    <td class="codeLine">        NewVal = IRB.CreateGEP(Ty, In, Index, In->getName() + ".sroa.gep",</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3828</td>
    <td class="codeLine">        NewVal = IRB.CreateGEP(Ty, In, Index, In->getName() + ".sroa.gep",</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3829</td>
    <td class="codeLine">                               IsInBounds);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3829</td>
    <td class="codeLine">                               IsInBounds);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3830</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3830</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3831</td>
    <td class="codeLine">      NewPN->addIncoming(NewVal, B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3831</td>
    <td class="codeLine">      NewPN->addIncoming(NewVal, B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3832</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3832</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3834</td>
    <td class="codeLine">    Visited.erase(&GEPI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3834</td>
    <td class="codeLine">    Visited.erase(&GEPI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3835</td>
    <td class="codeLine">    GEPI.replaceAllUsesWith(NewPN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3835</td>
    <td class="codeLine">    GEPI.replaceAllUsesWith(NewPN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3836</td>
    <td class="codeLine">    GEPI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3836</td>
    <td class="codeLine">    GEPI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3837</td>
    <td class="codeLine">    Visited.insert(NewPN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3837</td>
    <td class="codeLine">    Visited.insert(NewPN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3838</td>
    <td class="codeLine">    enqueueUsers(*NewPN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3838</td>
    <td class="codeLine">    enqueueUsers(*NewPN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3839</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3840</td>
    <td class="codeLine">    LLVM_DEBUG(for (Value *In : NewPN->incoming_values())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3840</td>
    <td class="codeLine">    LLVM_DEBUG(for (Value *In : NewPN->incoming_values())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3841</td>
    <td class="codeLine">                 dbgs() << "\n              " << *In;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3841</td>
    <td class="codeLine">                 dbgs() << "\n              " << *In;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3842</td>
    <td class="codeLine">               dbgs() << "\n              " << *NewPN << '\n');</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3842</td>
    <td class="codeLine">               dbgs() << "\n              " << *NewPN << '\n');</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3843</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3843</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3844</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3844</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3845</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3845</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3846</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3847</td>
    <td class="codeLine">  bool visitGetElementPtrInst(GetElementPtrInst &GEPI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3847</td>
    <td class="codeLine">  bool visitGetElementPtrInst(GetElementPtrInst &GEPI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3848</td>
    <td class="codeLine">    if (isa<SelectInst>(GEPI.getPointerOperand()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3848</td>
    <td class="codeLine">    if (isa<SelectInst>(GEPI.getPointerOperand()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3849</td>
    <td class="codeLine">        foldGEPSelect(GEPI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3849</td>
    <td class="codeLine">        foldGEPSelect(GEPI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3850</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3850</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3851</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3852</td>
    <td class="codeLine">    if (isa<PHINode>(GEPI.getPointerOperand()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3852</td>
    <td class="codeLine">    if (isa<PHINode>(GEPI.getPointerOperand()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3853</td>
    <td class="codeLine">        foldGEPPhi(GEPI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3853</td>
    <td class="codeLine">        foldGEPPhi(GEPI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3854</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3854</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3855</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3856</td>
    <td class="codeLine">    enqueueUsers(GEPI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3856</td>
    <td class="codeLine">    enqueueUsers(GEPI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3857</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3857</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3858</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3858</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3859</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3860</td>
    <td class="codeLine">  bool visitPHINode(PHINode &PN) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3860</td>
    <td class="codeLine">  bool visitPHINode(PHINode &PN) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3861</td>
    <td class="codeLine">    enqueueUsers(PN);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3861</td>
    <td class="codeLine">    enqueueUsers(PN);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3862</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3862</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3863</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3863</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3864</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3864</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3865</td>
    <td class="codeLine">  bool visitSelectInst(SelectInst &SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3865</td>
    <td class="codeLine">  bool visitSelectInst(SelectInst &SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3866</td>
    <td class="codeLine">    enqueueUsers(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3866</td>
    <td class="codeLine">    enqueueUsers(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3867</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3867</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3868</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3868</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3869</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3869</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3870</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3870</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3871</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3871</td>
    <td class="codeLine">} // end anonymous namespace</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3872</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3873</td>
    <td class="codeLine">/// Strip aggregate type wrapping.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3873</td>
    <td class="codeLine">/// Strip aggregate type wrapping.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3874</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3874</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3875</td>
    <td class="codeLine">/// This removes no-op aggregate types wrapping an underlying type. It will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3875</td>
    <td class="codeLine">/// This removes no-op aggregate types wrapping an underlying type. It will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3876</td>
    <td class="codeLine">/// strip as many layers of types as it can without changing either the type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3876</td>
    <td class="codeLine">/// strip as many layers of types as it can without changing either the type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3877</td>
    <td class="codeLine">/// size or the allocated size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3877</td>
    <td class="codeLine">/// size or the allocated size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3878</td>
    <td class="codeLine">static Type *stripAggregateTypeWrapping(const DataLayout &DL, Type *Ty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3878</td>
    <td class="codeLine">static Type *stripAggregateTypeWrapping(const DataLayout &DL, Type *Ty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3879</td>
    <td class="codeLine">  if (Ty->isSingleValueType())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3879</td>
    <td class="codeLine">  if (Ty->isSingleValueType())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3880</td>
    <td class="codeLine">    return Ty;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3880</td>
    <td class="codeLine">    return Ty;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3881</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3882</td>
    <td class="codeLine">  uint64_t AllocSize = DL.getTypeAllocSize(Ty).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3882</td>
    <td class="codeLine">  uint64_t AllocSize = DL.getTypeAllocSize(Ty).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3883</td>
    <td class="codeLine">  uint64_t TypeSize = DL.getTypeSizeInBits(Ty).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3883</td>
    <td class="codeLine">  uint64_t TypeSize = DL.getTypeSizeInBits(Ty).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3885</td>
    <td class="codeLine">  Type *InnerTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3885</td>
    <td class="codeLine">  Type *InnerTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3886</td>
    <td class="codeLine">  if (ArrayType *ArrTy = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3886</td>
    <td class="codeLine">  if (ArrayType *ArrTy = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3887</td>
    <td class="codeLine">    InnerTy = ArrTy->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3887</td>
    <td class="codeLine">    InnerTy = ArrTy->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3888</td>
    <td class="codeLine">  } else if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3888</td>
    <td class="codeLine">  } else if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3889</td>
    <td class="codeLine">    const StructLayout *SL = DL.getStructLayout(STy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3889</td>
    <td class="codeLine">    const StructLayout *SL = DL.getStructLayout(STy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3890</td>
    <td class="codeLine">    unsigned Index = SL->getElementContainingOffset(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3890</td>
    <td class="codeLine">    unsigned Index = SL->getElementContainingOffset(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3891</td>
    <td class="codeLine">    InnerTy = STy->getElementType(Index);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3891</td>
    <td class="codeLine">    InnerTy = STy->getElementType(Index);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3892</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3892</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3893</td>
    <td class="codeLine">    return Ty;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3893</td>
    <td class="codeLine">    return Ty;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3894</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3894</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3895</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3895</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3896</td>
    <td class="codeLine">  if (AllocSize > DL.getTypeAllocSize(InnerTy).getFixedValue() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3896</td>
    <td class="codeLine">  if (AllocSize > DL.getTypeAllocSize(InnerTy).getFixedValue() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3897</td>
    <td class="codeLine">      TypeSize > DL.getTypeSizeInBits(InnerTy).getFixedValue())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3897</td>
    <td class="codeLine">      TypeSize > DL.getTypeSizeInBits(InnerTy).getFixedValue())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3898</td>
    <td class="codeLine">    return Ty;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3898</td>
    <td class="codeLine">    return Ty;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3899</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3899</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3900</td>
    <td class="codeLine">  return stripAggregateTypeWrapping(DL, InnerTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3900</td>
    <td class="codeLine">  return stripAggregateTypeWrapping(DL, InnerTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3901</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3901</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3902</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3903</td>
    <td class="codeLine">/// Try to find a partition of the aggregate type passed in for a given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3903</td>
    <td class="codeLine">/// Try to find a partition of the aggregate type passed in for a given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3904</td>
    <td class="codeLine">/// offset and size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3904</td>
    <td class="codeLine">/// offset and size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3905</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3905</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3906</td>
    <td class="codeLine">/// This recurses through the aggregate type and tries to compute a subtype</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3906</td>
    <td class="codeLine">/// This recurses through the aggregate type and tries to compute a subtype</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3907</td>
    <td class="codeLine">/// based on the offset and size. When the offset and size span a sub-section</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3907</td>
    <td class="codeLine">/// based on the offset and size. When the offset and size span a sub-section</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3908</td>
    <td class="codeLine">/// of an array, it will even compute a new array type for that sub-section,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3908</td>
    <td class="codeLine">/// of an array, it will even compute a new array type for that sub-section,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3909</td>
    <td class="codeLine">/// and the same for structs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3909</td>
    <td class="codeLine">/// and the same for structs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3910</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3910</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3911</td>
    <td class="codeLine">/// Note that this routine is very strict and tries to find a partition of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3911</td>
    <td class="codeLine">/// Note that this routine is very strict and tries to find a partition of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3912</td>
    <td class="codeLine">/// type which produces the *exact* right offset and size. It is not forgiving</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3912</td>
    <td class="codeLine">/// type which produces the *exact* right offset and size. It is not forgiving</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3913</td>
    <td class="codeLine">/// when the size or offset cause either end of type-based partition to be off.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3913</td>
    <td class="codeLine">/// when the size or offset cause either end of type-based partition to be off.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3914</td>
    <td class="codeLine">/// Also, this is a best-effort routine. It is reasonable to give up and not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3914</td>
    <td class="codeLine">/// Also, this is a best-effort routine. It is reasonable to give up and not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3915</td>
    <td class="codeLine">/// return a type if necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3915</td>
    <td class="codeLine">/// return a type if necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3916</td>
    <td class="codeLine">static Type *getTypePartition(const DataLayout &DL, Type *Ty, uint64_t Offset,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3916</td>
    <td class="codeLine">static Type *getTypePartition(const DataLayout &DL, Type *Ty, uint64_t Offset,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3917</td>
    <td class="codeLine">                              uint64_t Size) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3917</td>
    <td class="codeLine">                              uint64_t Size) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3918</td>
    <td class="codeLine">  if (Offset == 0 && DL.getTypeAllocSize(Ty).getFixedValue() == Size)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3918</td>
    <td class="codeLine">  if (Offset == 0 && DL.getTypeAllocSize(Ty).getFixedValue() == Size)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3919</td>
    <td class="codeLine">    return stripAggregateTypeWrapping(DL, Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3919</td>
    <td class="codeLine">    return stripAggregateTypeWrapping(DL, Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3920</td>
    <td class="codeLine">  if (Offset > DL.getTypeAllocSize(Ty).getFixedValue() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3920</td>
    <td class="codeLine">  if (Offset > DL.getTypeAllocSize(Ty).getFixedValue() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3921</td>
    <td class="codeLine">      (DL.getTypeAllocSize(Ty).getFixedValue() - Offset) < Size)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3921</td>
    <td class="codeLine">      (DL.getTypeAllocSize(Ty).getFixedValue() - Offset) < Size)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3922</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3922</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3923</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3924</td>
    <td class="codeLine">  if (isa<ArrayType>(Ty) || isa<VectorType>(Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3924</td>
    <td class="codeLine">  if (isa<ArrayType>(Ty) || isa<VectorType>(Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3925</td>
    <td class="codeLine">     Type *ElementTy;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3925</td>
    <td class="codeLine">     Type *ElementTy;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3926</td>
    <td class="codeLine">     uint64_t TyNumElements;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3926</td>
    <td class="codeLine">     uint64_t TyNumElements;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3927</td>
    <td class="codeLine">     if (auto *AT = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3927</td>
    <td class="codeLine">     if (auto *AT = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3928</td>
    <td class="codeLine">       ElementTy = AT->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3928</td>
    <td class="codeLine">       ElementTy = AT->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3929</td>
    <td class="codeLine">       TyNumElements = AT->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3929</td>
    <td class="codeLine">       TyNumElements = AT->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3930</td>
    <td class="codeLine">     } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3930</td>
    <td class="codeLine">     } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3931</td>
    <td class="codeLine">       // FIXME: This isn't right for vectors with non-byte-sized or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3931</td>
    <td class="codeLine">       // FIXME: This isn't right for vectors with non-byte-sized or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3932</td>
    <td class="codeLine">       // non-power-of-two sized elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3932</td>
    <td class="codeLine">       // non-power-of-two sized elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3933</td>
    <td class="codeLine">       auto *VT = cast<FixedVectorType>(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3933</td>
    <td class="codeLine">       auto *VT = cast<FixedVectorType>(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3934</td>
    <td class="codeLine">       ElementTy = VT->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3934</td>
    <td class="codeLine">       ElementTy = VT->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3935</td>
    <td class="codeLine">       TyNumElements = VT->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3935</td>
    <td class="codeLine">       TyNumElements = VT->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3936</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3936</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3937</td>
    <td class="codeLine">    uint64_t ElementSize = DL.getTypeAllocSize(ElementTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3937</td>
    <td class="codeLine">    uint64_t ElementSize = DL.getTypeAllocSize(ElementTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3938</td>
    <td class="codeLine">    uint64_t NumSkippedElements = Offset / ElementSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3938</td>
    <td class="codeLine">    uint64_t NumSkippedElements = Offset / ElementSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3939</td>
    <td class="codeLine">    if (NumSkippedElements >= TyNumElements)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3939</td>
    <td class="codeLine">    if (NumSkippedElements >= TyNumElements)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3940</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3940</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3941</td>
    <td class="codeLine">    Offset -= NumSkippedElements * ElementSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3941</td>
    <td class="codeLine">    Offset -= NumSkippedElements * ElementSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3942</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3942</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3943</td>
    <td class="codeLine">    // First check if we need to recurse.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3943</td>
    <td class="codeLine">    // First check if we need to recurse.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3944</td>
    <td class="codeLine">    if (Offset > 0 || Size < ElementSize) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3944</td>
    <td class="codeLine">    if (Offset > 0 || Size < ElementSize) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3945</td>
    <td class="codeLine">      // Bail if the partition ends in a different array element.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3945</td>
    <td class="codeLine">      // Bail if the partition ends in a different array element.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3946</td>
    <td class="codeLine">      if ((Offset + Size) > ElementSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3946</td>
    <td class="codeLine">      if ((Offset + Size) > ElementSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3947</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3947</td>
    <td class="codeLine">        return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3948</td>
    <td class="codeLine">      // Recurse through the element type trying to peel off offset bytes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3948</td>
    <td class="codeLine">      // Recurse through the element type trying to peel off offset bytes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3949</td>
    <td class="codeLine">      return getTypePartition(DL, ElementTy, Offset, Size);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3949</td>
    <td class="codeLine">      return getTypePartition(DL, ElementTy, Offset, Size);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3950</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3950</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3951</td>
    <td class="codeLine">    assert(Offset == 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3951</td>
    <td class="codeLine">    assert(Offset == 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3952</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3952</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3953</td>
    <td class="codeLine">    if (Size == ElementSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3953</td>
    <td class="codeLine">    if (Size == ElementSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3954</td>
    <td class="codeLine">      return stripAggregateTypeWrapping(DL, ElementTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3954</td>
    <td class="codeLine">      return stripAggregateTypeWrapping(DL, ElementTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3955</td>
    <td class="codeLine">    assert(Size > ElementSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3955</td>
    <td class="codeLine">    assert(Size > ElementSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3956</td>
    <td class="codeLine">    uint64_t NumElements = Size / ElementSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3956</td>
    <td class="codeLine">    uint64_t NumElements = Size / ElementSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3957</td>
    <td class="codeLine">    if (NumElements * ElementSize != Size)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3957</td>
    <td class="codeLine">    if (NumElements * ElementSize != Size)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3958</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3958</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3959</td>
    <td class="codeLine">    return ArrayType::get(ElementTy, NumElements);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3959</td>
    <td class="codeLine">    return ArrayType::get(ElementTy, NumElements);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3960</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3960</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3961</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3962</td>
    <td class="codeLine">  StructType *STy = dyn_cast<StructType>(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3962</td>
    <td class="codeLine">  StructType *STy = dyn_cast<StructType>(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3963</td>
    <td class="codeLine">  if (!STy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3963</td>
    <td class="codeLine">  if (!STy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3964</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3964</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3966</td>
    <td class="codeLine">  const StructLayout *SL = DL.getStructLayout(STy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3966</td>
    <td class="codeLine">  const StructLayout *SL = DL.getStructLayout(STy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3967</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3968</td>
    <td class="codeLine">  if (SL->getSizeInBits().isScalable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3968</td>
    <td class="codeLine">  if (SL->getSizeInBits().isScalable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3969</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3969</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3970</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3971</td>
    <td class="codeLine">  if (Offset >= SL->getSizeInBytes())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3971</td>
    <td class="codeLine">  if (Offset >= SL->getSizeInBytes())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3972</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3972</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3973</td>
    <td class="codeLine">  uint64_t EndOffset = Offset + Size;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3973</td>
    <td class="codeLine">  uint64_t EndOffset = Offset + Size;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3974</td>
    <td class="codeLine">  if (EndOffset > SL->getSizeInBytes())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3974</td>
    <td class="codeLine">  if (EndOffset > SL->getSizeInBytes())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3975</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3975</td>
    <td class="codeLine">    return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3976</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3977</td>
    <td class="codeLine">  unsigned Index = SL->getElementContainingOffset(Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3977</td>
    <td class="codeLine">  unsigned Index = SL->getElementContainingOffset(Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3978</td>
    <td class="codeLine">  Offset -= SL->getElementOffset(Index);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3978</td>
    <td class="codeLine">  Offset -= SL->getElementOffset(Index);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3979</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3980</td>
    <td class="codeLine">  Type *ElementTy = STy->getElementType(Index);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3980</td>
    <td class="codeLine">  Type *ElementTy = STy->getElementType(Index);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3981</td>
    <td class="codeLine">  uint64_t ElementSize = DL.getTypeAllocSize(ElementTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3981</td>
    <td class="codeLine">  uint64_t ElementSize = DL.getTypeAllocSize(ElementTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3982</td>
    <td class="codeLine">  if (Offset >= ElementSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3982</td>
    <td class="codeLine">  if (Offset >= ElementSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3983</td>
    <td class="codeLine">    return nullptr; // The offset points into alignment padding.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3983</td>
    <td class="codeLine">    return nullptr; // The offset points into alignment padding.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3985</td>
    <td class="codeLine">  // See if any partition must be contained by the element.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3985</td>
    <td class="codeLine">  // See if any partition must be contained by the element.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3986</td>
    <td class="codeLine">  if (Offset > 0 || Size < ElementSize) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3986</td>
    <td class="codeLine">  if (Offset > 0 || Size < ElementSize) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3987</td>
    <td class="codeLine">    if ((Offset + Size) > ElementSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3987</td>
    <td class="codeLine">    if ((Offset + Size) > ElementSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3988</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3988</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3989</td>
    <td class="codeLine">    return getTypePartition(DL, ElementTy, Offset, Size);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3989</td>
    <td class="codeLine">    return getTypePartition(DL, ElementTy, Offset, Size);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3990</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3990</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3991</td>
    <td class="codeLine">  assert(Offset == 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3991</td>
    <td class="codeLine">  assert(Offset == 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3993</td>
    <td class="codeLine">  if (Size == ElementSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3993</td>
    <td class="codeLine">  if (Size == ElementSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3994</td>
    <td class="codeLine">    return stripAggregateTypeWrapping(DL, ElementTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3994</td>
    <td class="codeLine">    return stripAggregateTypeWrapping(DL, ElementTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3995</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3995</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3996</td>
    <td class="codeLine">  StructType::element_iterator EI = STy->element_begin() + Index,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3996</td>
    <td class="codeLine">  StructType::element_iterator EI = STy->element_begin() + Index,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3997</td>
    <td class="codeLine">                               EE = STy->element_end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3997</td>
    <td class="codeLine">                               EE = STy->element_end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3998</td>
    <td class="codeLine">  if (EndOffset < SL->getSizeInBytes()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3998</td>
    <td class="codeLine">  if (EndOffset < SL->getSizeInBytes()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3999</td>
    <td class="codeLine">    unsigned EndIndex = SL->getElementContainingOffset(EndOffset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">3999</td>
    <td class="codeLine">    unsigned EndIndex = SL->getElementContainingOffset(EndOffset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4000</td>
    <td class="codeLine">    if (Index == EndIndex)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4000</td>
    <td class="codeLine">    if (Index == EndIndex)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4001</td>
    <td class="codeLine">      return nullptr; // Within a single element and its padding.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4001</td>
    <td class="codeLine">      return nullptr; // Within a single element and its padding.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4002</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4003</td>
    <td class="codeLine">    // Don't try to form "natural" types if the elements don't line up with the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4003</td>
    <td class="codeLine">    // Don't try to form "natural" types if the elements don't line up with the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4004</td>
    <td class="codeLine">    // expected size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4004</td>
    <td class="codeLine">    // expected size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4005</td>
    <td class="codeLine">    // FIXME: We could potentially recurse down through the last element in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4005</td>
    <td class="codeLine">    // FIXME: We could potentially recurse down through the last element in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4006</td>
    <td class="codeLine">    // sub-struct to find a natural end point.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4006</td>
    <td class="codeLine">    // sub-struct to find a natural end point.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4007</td>
    <td class="codeLine">    if (SL->getElementOffset(EndIndex) != EndOffset)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4007</td>
    <td class="codeLine">    if (SL->getElementOffset(EndIndex) != EndOffset)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4008</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4008</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4010</td>
    <td class="codeLine">    assert(Index < EndIndex);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4010</td>
    <td class="codeLine">    assert(Index < EndIndex);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4011</td>
    <td class="codeLine">    EE = STy->element_begin() + EndIndex;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4011</td>
    <td class="codeLine">    EE = STy->element_begin() + EndIndex;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4012</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4012</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4014</td>
    <td class="codeLine">  // Try to build up a sub-structure.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4014</td>
    <td class="codeLine">  // Try to build up a sub-structure.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4015</td>
    <td class="codeLine">  StructType *SubTy =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4015</td>
    <td class="codeLine">  StructType *SubTy =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4016</td>
    <td class="codeLine">      StructType::get(STy->getContext(), ArrayRef(EI, EE), STy->isPacked());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4016</td>
    <td class="codeLine">      StructType::get(STy->getContext(), ArrayRef(EI, EE), STy->isPacked());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4017</td>
    <td class="codeLine">  const StructLayout *SubSL = DL.getStructLayout(SubTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4017</td>
    <td class="codeLine">  const StructLayout *SubSL = DL.getStructLayout(SubTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4018</td>
    <td class="codeLine">  if (Size != SubSL->getSizeInBytes())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4018</td>
    <td class="codeLine">  if (Size != SubSL->getSizeInBytes())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4019</td>
    <td class="codeLine">    return nullptr; // The sub-struct doesn't have quite the size needed.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4019</td>
    <td class="codeLine">    return nullptr; // The sub-struct doesn't have quite the size needed.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4020</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4021</td>
    <td class="codeLine">  return SubTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4021</td>
    <td class="codeLine">  return SubTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4022</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4022</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4023</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4024</td>
    <td class="codeLine">/// Pre-split loads and stores to simplify rewriting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4024</td>
    <td class="codeLine">/// Pre-split loads and stores to simplify rewriting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4025</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4025</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4026</td>
    <td class="codeLine">/// We want to break up the splittable load+store pairs as much as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4026</td>
    <td class="codeLine">/// We want to break up the splittable load+store pairs as much as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4027</td>
    <td class="codeLine">/// possible. This is important to do as a preprocessing step, as once we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4027</td>
    <td class="codeLine">/// possible. This is important to do as a preprocessing step, as once we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4028</td>
    <td class="codeLine">/// start rewriting the accesses to partitions of the alloca we lose the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4028</td>
    <td class="codeLine">/// start rewriting the accesses to partitions of the alloca we lose the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4029</td>
    <td class="codeLine">/// necessary information to correctly split apart paired loads and stores</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4029</td>
    <td class="codeLine">/// necessary information to correctly split apart paired loads and stores</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4030</td>
    <td class="codeLine">/// which both point into this alloca. The case to consider is something like</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4030</td>
    <td class="codeLine">/// which both point into this alloca. The case to consider is something like</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4031</td>
    <td class="codeLine">/// the following:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4031</td>
    <td class="codeLine">/// the following:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4032</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4032</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4033</td>
    <td class="codeLine">///   %a = alloca [12 x i8]</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4033</td>
    <td class="codeLine">///   %a = alloca [12 x i8]</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4034</td>
    <td class="codeLine">///   %gep1 = getelementptr i8, ptr %a, i32 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4034</td>
    <td class="codeLine">///   %gep1 = getelementptr i8, ptr %a, i32 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4035</td>
    <td class="codeLine">///   %gep2 = getelementptr i8, ptr %a, i32 4</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4035</td>
    <td class="codeLine">///   %gep2 = getelementptr i8, ptr %a, i32 4</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4036</td>
    <td class="codeLine">///   %gep3 = getelementptr i8, ptr %a, i32 8</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4036</td>
    <td class="codeLine">///   %gep3 = getelementptr i8, ptr %a, i32 8</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4037</td>
    <td class="codeLine">///   store float 0.0, ptr %gep1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4037</td>
    <td class="codeLine">///   store float 0.0, ptr %gep1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4038</td>
    <td class="codeLine">///   store float 1.0, ptr %gep2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4038</td>
    <td class="codeLine">///   store float 1.0, ptr %gep2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4039</td>
    <td class="codeLine">///   %v = load i64, ptr %gep1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4039</td>
    <td class="codeLine">///   %v = load i64, ptr %gep1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4040</td>
    <td class="codeLine">///   store i64 %v, ptr %gep2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4040</td>
    <td class="codeLine">///   store i64 %v, ptr %gep2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4041</td>
    <td class="codeLine">///   %f1 = load float, ptr %gep2</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4041</td>
    <td class="codeLine">///   %f1 = load float, ptr %gep2</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4042</td>
    <td class="codeLine">///   %f2 = load float, ptr %gep3</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4042</td>
    <td class="codeLine">///   %f2 = load float, ptr %gep3</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4043</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4043</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4044</td>
    <td class="codeLine">/// Here we want to form 3 partitions of the alloca, each 4 bytes large, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4044</td>
    <td class="codeLine">/// Here we want to form 3 partitions of the alloca, each 4 bytes large, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4045</td>
    <td class="codeLine">/// promote everything so we recover the 2 SSA values that should have been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4045</td>
    <td class="codeLine">/// promote everything so we recover the 2 SSA values that should have been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4046</td>
    <td class="codeLine">/// there all along.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4046</td>
    <td class="codeLine">/// there all along.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4047</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4047</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4048</td>
    <td class="codeLine">/// \returns true if any changes are made.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4048</td>
    <td class="codeLine">/// \returns true if any changes are made.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4049</td>
    <td class="codeLine">bool SROAPass::presplitLoadsAndStores(AllocaInst &AI, AllocaSlices &AS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4049</td>
    <td class="codeLine">bool SROAPass::presplitLoadsAndStores(AllocaInst &AI, AllocaSlices &AS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4050</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Pre-splitting loads and stores\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4050</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Pre-splitting loads and stores\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4052</td>
    <td class="codeLine">  // Track the loads and stores which are candidates for pre-splitting here, in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4052</td>
    <td class="codeLine">  // Track the loads and stores which are candidates for pre-splitting here, in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4053</td>
    <td class="codeLine">  // the order they first appear during the partition scan. These give stable</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4053</td>
    <td class="codeLine">  // the order they first appear during the partition scan. These give stable</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4054</td>
    <td class="codeLine">  // iteration order and a basis for tracking which loads and stores we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4054</td>
    <td class="codeLine">  // iteration order and a basis for tracking which loads and stores we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4055</td>
    <td class="codeLine">  // actually split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4055</td>
    <td class="codeLine">  // actually split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4056</td>
    <td class="codeLine">  SmallVector<LoadInst *, 4> Loads;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4056</td>
    <td class="codeLine">  SmallVector<LoadInst *, 4> Loads;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4057</td>
    <td class="codeLine">  SmallVector<StoreInst *, 4> Stores;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4057</td>
    <td class="codeLine">  SmallVector<StoreInst *, 4> Stores;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4059</td>
    <td class="codeLine">  // We need to accumulate the splits required of each load or store where we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4059</td>
    <td class="codeLine">  // We need to accumulate the splits required of each load or store where we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4060</td>
    <td class="codeLine">  // can find them via a direct lookup. This is important to cross-check loads</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4060</td>
    <td class="codeLine">  // can find them via a direct lookup. This is important to cross-check loads</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4061</td>
    <td class="codeLine">  // and stores against each other. We also track the slice so that we can kill</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4061</td>
    <td class="codeLine">  // and stores against each other. We also track the slice so that we can kill</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4062</td>
    <td class="codeLine">  // all the slices that end up split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4062</td>
    <td class="codeLine">  // all the slices that end up split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4063</td>
    <td class="codeLine">  struct SplitOffsets {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4063</td>
    <td class="codeLine">  struct SplitOffsets {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4064</td>
    <td class="codeLine">    Slice *S;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4064</td>
    <td class="codeLine">    Slice *S;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4065</td>
    <td class="codeLine">    std::vector<uint64_t> Splits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4065</td>
    <td class="codeLine">    std::vector<uint64_t> Splits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4066</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4066</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4067</td>
    <td class="codeLine">  SmallDenseMap<Instruction *, SplitOffsets, 8> SplitOffsetsMap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4067</td>
    <td class="codeLine">  SmallDenseMap<Instruction *, SplitOffsets, 8> SplitOffsetsMap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4068</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4069</td>
    <td class="codeLine">  // Track loads out of this alloca which cannot, for any reason, be pre-split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4069</td>
    <td class="codeLine">  // Track loads out of this alloca which cannot, for any reason, be pre-split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4070</td>
    <td class="codeLine">  // This is important as we also cannot pre-split stores of those loads!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4070</td>
    <td class="codeLine">  // This is important as we also cannot pre-split stores of those loads!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4071</td>
    <td class="codeLine">  // FIXME: This is all pretty gross. It means that we can be more aggressive</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4071</td>
    <td class="codeLine">  // FIXME: This is all pretty gross. It means that we can be more aggressive</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4072</td>
    <td class="codeLine">  // in pre-splitting when the load feeding the store happens to come from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4072</td>
    <td class="codeLine">  // in pre-splitting when the load feeding the store happens to come from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4073</td>
    <td class="codeLine">  // a separate alloca. Put another way, the effectiveness of SROA would be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4073</td>
    <td class="codeLine">  // a separate alloca. Put another way, the effectiveness of SROA would be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4074</td>
    <td class="codeLine">  // decreased by a frontend which just concatenated all of its local allocas</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4074</td>
    <td class="codeLine">  // decreased by a frontend which just concatenated all of its local allocas</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4075</td>
    <td class="codeLine">  // into one big flat alloca. But defeating such patterns is exactly the job</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4075</td>
    <td class="codeLine">  // into one big flat alloca. But defeating such patterns is exactly the job</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4076</td>
    <td class="codeLine">  // SROA is tasked with! Sadly, to not have this discrepancy we would have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4076</td>
    <td class="codeLine">  // SROA is tasked with! Sadly, to not have this discrepancy we would have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4077</td>
    <td class="codeLine">  // change store pre-splitting to actually force pre-splitting of the load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4077</td>
    <td class="codeLine">  // change store pre-splitting to actually force pre-splitting of the load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4078</td>
    <td class="codeLine">  // that feeds it *and all stores*. That makes pre-splitting much harder, but</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4078</td>
    <td class="codeLine">  // that feeds it *and all stores*. That makes pre-splitting much harder, but</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4079</td>
    <td class="codeLine">  // maybe it would make it more principled?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4079</td>
    <td class="codeLine">  // maybe it would make it more principled?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4080</td>
    <td class="codeLine">  SmallPtrSet<LoadInst *, 8> UnsplittableLoads;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4080</td>
    <td class="codeLine">  SmallPtrSet<LoadInst *, 8> UnsplittableLoads;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4082</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Searching for candidate loads and stores\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4082</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Searching for candidate loads and stores\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4083</td>
    <td class="codeLine">  for (auto &P : AS.partitions()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4083</td>
    <td class="codeLine">  for (auto &P : AS.partitions()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4084</td>
    <td class="codeLine">    for (Slice &S : P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4084</td>
    <td class="codeLine">    for (Slice &S : P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4085</td>
    <td class="codeLine">      Instruction *I = cast<Instruction>(S.getUse()->getUser());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4085</td>
    <td class="codeLine">      Instruction *I = cast<Instruction>(S.getUse()->getUser());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4086</td>
    <td class="codeLine">      if (!S.isSplittable() || S.endOffset() <= P.endOffset()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4086</td>
    <td class="codeLine">      if (!S.isSplittable() || S.endOffset() <= P.endOffset()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4087</td>
    <td class="codeLine">        // If this is a load we have to track that it can't participate in any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4087</td>
    <td class="codeLine">        // If this is a load we have to track that it can't participate in any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4088</td>
    <td class="codeLine">        // pre-splitting. If this is a store of a load we have to track that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4088</td>
    <td class="codeLine">        // pre-splitting. If this is a store of a load we have to track that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4089</td>
    <td class="codeLine">        // that load also can't participate in any pre-splitting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4089</td>
    <td class="codeLine">        // that load also can't participate in any pre-splitting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4090</td>
    <td class="codeLine">        if (auto *LI = dyn_cast<LoadInst>(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4090</td>
    <td class="codeLine">        if (auto *LI = dyn_cast<LoadInst>(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4091</td>
    <td class="codeLine">          UnsplittableLoads.insert(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4091</td>
    <td class="codeLine">          UnsplittableLoads.insert(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4092</td>
    <td class="codeLine">        else if (auto *SI = dyn_cast<StoreInst>(I))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4092</td>
    <td class="codeLine">        else if (auto *SI = dyn_cast<StoreInst>(I))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4093</td>
    <td class="codeLine">          if (auto *LI = dyn_cast<LoadInst>(SI->getValueOperand()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4093</td>
    <td class="codeLine">          if (auto *LI = dyn_cast<LoadInst>(SI->getValueOperand()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4094</td>
    <td class="codeLine">            UnsplittableLoads.insert(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4094</td>
    <td class="codeLine">            UnsplittableLoads.insert(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4095</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4095</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4096</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4096</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4097</td>
    <td class="codeLine">      assert(P.endOffset() > S.beginOffset() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4097</td>
    <td class="codeLine">      assert(P.endOffset() > S.beginOffset() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4098</td>
    <td class="codeLine">             "Empty or backwards partition!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4098</td>
    <td class="codeLine">             "Empty or backwards partition!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4100</td>
    <td class="codeLine">      // Determine if this is a pre-splittable slice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4100</td>
    <td class="codeLine">      // Determine if this is a pre-splittable slice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4101</td>
    <td class="codeLine">      if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4101</td>
    <td class="codeLine">      if (auto *LI = dyn_cast<LoadInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4102</td>
    <td class="codeLine">        assert(!LI->isVolatile() && "Cannot split volatile loads!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4102</td>
    <td class="codeLine">        assert(!LI->isVolatile() && "Cannot split volatile loads!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4103</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4104</td>
    <td class="codeLine">        // The load must be used exclusively to store into other pointers for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4104</td>
    <td class="codeLine">        // The load must be used exclusively to store into other pointers for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4105</td>
    <td class="codeLine">        // us to be able to arbitrarily pre-split it. The stores must also be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4105</td>
    <td class="codeLine">        // us to be able to arbitrarily pre-split it. The stores must also be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4106</td>
    <td class="codeLine">        // simple to avoid changing semantics.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4106</td>
    <td class="codeLine">        // simple to avoid changing semantics.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4107</td>
    <td class="codeLine">        auto IsLoadSimplyStored = [](LoadInst *LI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4107</td>
    <td class="codeLine">        auto IsLoadSimplyStored = [](LoadInst *LI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4108</td>
    <td class="codeLine">          for (User *LU : LI->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4108</td>
    <td class="codeLine">          for (User *LU : LI->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4109</td>
    <td class="codeLine">            auto *SI = dyn_cast<StoreInst>(LU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4109</td>
    <td class="codeLine">            auto *SI = dyn_cast<StoreInst>(LU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4110</td>
    <td class="codeLine">            if (!SI || !SI->isSimple())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4110</td>
    <td class="codeLine">            if (!SI || !SI->isSimple())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4111</td>
    <td class="codeLine">              return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4111</td>
    <td class="codeLine">              return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4112</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4112</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4113</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4113</td>
    <td class="codeLine">          return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4114</td>
    <td class="codeLine">        };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4114</td>
    <td class="codeLine">        };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4115</td>
    <td class="codeLine">        if (!IsLoadSimplyStored(LI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4115</td>
    <td class="codeLine">        if (!IsLoadSimplyStored(LI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4116</td>
    <td class="codeLine">          UnsplittableLoads.insert(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4116</td>
    <td class="codeLine">          UnsplittableLoads.insert(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4117</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4117</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4118</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4118</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4119</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4120</td>
    <td class="codeLine">        Loads.push_back(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4120</td>
    <td class="codeLine">        Loads.push_back(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4121</td>
    <td class="codeLine">      } else if (auto *SI = dyn_cast<StoreInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4121</td>
    <td class="codeLine">      } else if (auto *SI = dyn_cast<StoreInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4122</td>
    <td class="codeLine">        if (S.getUse() != &SI->getOperandUse(SI->getPointerOperandIndex()))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4122</td>
    <td class="codeLine">        if (S.getUse() != &SI->getOperandUse(SI->getPointerOperandIndex()))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4123</td>
    <td class="codeLine">          // Skip stores *of* pointers. FIXME: This shouldn't even be possible!</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4123</td>
    <td class="codeLine">          // Skip stores *of* pointers. FIXME: This shouldn't even be possible!</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4124</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4124</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4125</td>
    <td class="codeLine">        auto *StoredLoad = dyn_cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4125</td>
    <td class="codeLine">        auto *StoredLoad = dyn_cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4126</td>
    <td class="codeLine">        if (!StoredLoad || !StoredLoad->isSimple())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4126</td>
    <td class="codeLine">        if (!StoredLoad || !StoredLoad->isSimple())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4127</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4127</td>
    <td class="codeLine">          continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4128</td>
    <td class="codeLine">        assert(!SI->isVolatile() && "Cannot split volatile stores!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4128</td>
    <td class="codeLine">        assert(!SI->isVolatile() && "Cannot split volatile stores!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4130</td>
    <td class="codeLine">        Stores.push_back(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4130</td>
    <td class="codeLine">        Stores.push_back(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4131</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4131</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4132</td>
    <td class="codeLine">        // Other uses cannot be pre-split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4132</td>
    <td class="codeLine">        // Other uses cannot be pre-split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4133</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4133</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4134</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4134</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4135</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4136</td>
    <td class="codeLine">      // Record the initial split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4136</td>
    <td class="codeLine">      // Record the initial split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4137</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "    Candidate: " << *I << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4137</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "    Candidate: " << *I << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4138</td>
    <td class="codeLine">      auto &Offsets = SplitOffsetsMap[I];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4138</td>
    <td class="codeLine">      auto &Offsets = SplitOffsetsMap[I];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4139</td>
    <td class="codeLine">      assert(Offsets.Splits.empty() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4139</td>
    <td class="codeLine">      assert(Offsets.Splits.empty() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4140</td>
    <td class="codeLine">             "Should not have splits the first time we see an instruction!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4140</td>
    <td class="codeLine">             "Should not have splits the first time we see an instruction!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4141</td>
    <td class="codeLine">      Offsets.S = &S;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4141</td>
    <td class="codeLine">      Offsets.S = &S;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4142</td>
    <td class="codeLine">      Offsets.Splits.push_back(P.endOffset() - S.beginOffset());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4142</td>
    <td class="codeLine">      Offsets.Splits.push_back(P.endOffset() - S.beginOffset());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4143</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4143</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4144</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4145</td>
    <td class="codeLine">    // Now scan the already split slices, and add a split for any of them which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4145</td>
    <td class="codeLine">    // Now scan the already split slices, and add a split for any of them which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4146</td>
    <td class="codeLine">    // we're going to pre-split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4146</td>
    <td class="codeLine">    // we're going to pre-split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4147</td>
    <td class="codeLine">    for (Slice *S : P.splitSliceTails()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4147</td>
    <td class="codeLine">    for (Slice *S : P.splitSliceTails()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4148</td>
    <td class="codeLine">      auto SplitOffsetsMapI =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4148</td>
    <td class="codeLine">      auto SplitOffsetsMapI =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4149</td>
    <td class="codeLine">          SplitOffsetsMap.find(cast<Instruction>(S->getUse()->getUser()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4149</td>
    <td class="codeLine">          SplitOffsetsMap.find(cast<Instruction>(S->getUse()->getUser()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4150</td>
    <td class="codeLine">      if (SplitOffsetsMapI == SplitOffsetsMap.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4150</td>
    <td class="codeLine">      if (SplitOffsetsMapI == SplitOffsetsMap.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4151</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4151</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4152</td>
    <td class="codeLine">      auto &Offsets = SplitOffsetsMapI->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4152</td>
    <td class="codeLine">      auto &Offsets = SplitOffsetsMapI->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4154</td>
    <td class="codeLine">      assert(Offsets.S == S && "Found a mismatched slice!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4154</td>
    <td class="codeLine">      assert(Offsets.S == S && "Found a mismatched slice!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4155</td>
    <td class="codeLine">      assert(!Offsets.Splits.empty() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4155</td>
    <td class="codeLine">      assert(!Offsets.Splits.empty() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4156</td>
    <td class="codeLine">             "Cannot have an empty set of splits on the second partition!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4156</td>
    <td class="codeLine">             "Cannot have an empty set of splits on the second partition!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4157</td>
    <td class="codeLine">      assert(Offsets.Splits.back() ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4157</td>
    <td class="codeLine">      assert(Offsets.Splits.back() ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4158</td>
    <td class="codeLine">                 P.beginOffset() - Offsets.S->beginOffset() &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4158</td>
    <td class="codeLine">                 P.beginOffset() - Offsets.S->beginOffset() &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4159</td>
    <td class="codeLine">             "Previous split does not end where this one begins!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4159</td>
    <td class="codeLine">             "Previous split does not end where this one begins!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4161</td>
    <td class="codeLine">      // Record each split. The last partition's end isn't needed as the size</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4161</td>
    <td class="codeLine">      // Record each split. The last partition's end isn't needed as the size</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4162</td>
    <td class="codeLine">      // of the slice dictates that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4162</td>
    <td class="codeLine">      // of the slice dictates that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4163</td>
    <td class="codeLine">      if (S->endOffset() > P.endOffset())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4163</td>
    <td class="codeLine">      if (S->endOffset() > P.endOffset())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4164</td>
    <td class="codeLine">        Offsets.Splits.push_back(P.endOffset() - Offsets.S->beginOffset());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4164</td>
    <td class="codeLine">        Offsets.Splits.push_back(P.endOffset() - Offsets.S->beginOffset());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4165</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4165</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4166</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4166</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4167</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4168</td>
    <td class="codeLine">  // We may have split loads where some of their stores are split stores. For</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4168</td>
    <td class="codeLine">  // We may have split loads where some of their stores are split stores. For</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4169</td>
    <td class="codeLine">  // such loads and stores, we can only pre-split them if their splits exactly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4169</td>
    <td class="codeLine">  // such loads and stores, we can only pre-split them if their splits exactly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4170</td>
    <td class="codeLine">  // match relative to their starting offset. We have to verify this prior to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4170</td>
    <td class="codeLine">  // match relative to their starting offset. We have to verify this prior to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4171</td>
    <td class="codeLine">  // any rewriting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4171</td>
    <td class="codeLine">  // any rewriting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4172</td>
    <td class="codeLine">  llvm::erase_if(Stores, [&UnsplittableLoads, &SplitOffsetsMap](StoreInst *SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4172</td>
    <td class="codeLine">  llvm::erase_if(Stores, [&UnsplittableLoads, &SplitOffsetsMap](StoreInst *SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4173</td>
    <td class="codeLine">    // Lookup the load we are storing in our map of split</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4173</td>
    <td class="codeLine">    // Lookup the load we are storing in our map of split</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4174</td>
    <td class="codeLine">    // offsets.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4174</td>
    <td class="codeLine">    // offsets.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4175</td>
    <td class="codeLine">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4175</td>
    <td class="codeLine">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4176</td>
    <td class="codeLine">    // If it was completely unsplittable, then we're done,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4176</td>
    <td class="codeLine">    // If it was completely unsplittable, then we're done,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4177</td>
    <td class="codeLine">    // and this store can't be pre-split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4177</td>
    <td class="codeLine">    // and this store can't be pre-split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4178</td>
    <td class="codeLine">    if (UnsplittableLoads.count(LI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4178</td>
    <td class="codeLine">    if (UnsplittableLoads.count(LI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4179</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4179</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4181</td>
    <td class="codeLine">    auto LoadOffsetsI = SplitOffsetsMap.find(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4181</td>
    <td class="codeLine">    auto LoadOffsetsI = SplitOffsetsMap.find(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4182</td>
    <td class="codeLine">    if (LoadOffsetsI == SplitOffsetsMap.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4182</td>
    <td class="codeLine">    if (LoadOffsetsI == SplitOffsetsMap.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4183</td>
    <td class="codeLine">      return false; // Unrelated loads are definitely safe.</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4183</td>
    <td class="codeLine">      return false; // Unrelated loads are definitely safe.</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4184</td>
    <td class="codeLine">    auto &LoadOffsets = LoadOffsetsI->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4184</td>
    <td class="codeLine">    auto &LoadOffsets = LoadOffsetsI->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4185</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4186</td>
    <td class="codeLine">    // Now lookup the store's offsets.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4186</td>
    <td class="codeLine">    // Now lookup the store's offsets.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4187</td>
    <td class="codeLine">    auto &StoreOffsets = SplitOffsetsMap[SI];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4187</td>
    <td class="codeLine">    auto &StoreOffsets = SplitOffsetsMap[SI];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4189</td>
    <td class="codeLine">    // If the relative offsets of each split in the load and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4189</td>
    <td class="codeLine">    // If the relative offsets of each split in the load and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4190</td>
    <td class="codeLine">    // store match exactly, then we can split them and we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4190</td>
    <td class="codeLine">    // store match exactly, then we can split them and we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4191</td>
    <td class="codeLine">    // don't need to remove them here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4191</td>
    <td class="codeLine">    // don't need to remove them here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4192</td>
    <td class="codeLine">    if (LoadOffsets.Splits == StoreOffsets.Splits)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4192</td>
    <td class="codeLine">    if (LoadOffsets.Splits == StoreOffsets.Splits)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4193</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4193</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4195</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    Mismatched splits for load and store:\n"</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4195</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "    Mismatched splits for load and store:\n"</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4196</td>
    <td class="codeLine">                      << "      " << *LI << "\n"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4196</td>
    <td class="codeLine">                      << "      " << *LI << "\n"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4197</td>
    <td class="codeLine">                      << "      " << *SI << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4197</td>
    <td class="codeLine">                      << "      " << *SI << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4199</td>
    <td class="codeLine">    // We've found a store and load that we need to split</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4199</td>
    <td class="codeLine">    // We've found a store and load that we need to split</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4200</td>
    <td class="codeLine">    // with mismatched relative splits. Just give up on them</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4200</td>
    <td class="codeLine">    // with mismatched relative splits. Just give up on them</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4201</td>
    <td class="codeLine">    // and remove both instructions from our list of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4201</td>
    <td class="codeLine">    // and remove both instructions from our list of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4202</td>
    <td class="codeLine">    // candidates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4202</td>
    <td class="codeLine">    // candidates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4203</td>
    <td class="codeLine">    UnsplittableLoads.insert(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4203</td>
    <td class="codeLine">    UnsplittableLoads.insert(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4204</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4204</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4205</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4205</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4206</td>
    <td class="codeLine">  // Now we have to go *back* through all the stores, because a later store may</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4206</td>
    <td class="codeLine">  // Now we have to go *back* through all the stores, because a later store may</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4207</td>
    <td class="codeLine">  // have caused an earlier store's load to become unsplittable and if it is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4207</td>
    <td class="codeLine">  // have caused an earlier store's load to become unsplittable and if it is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4208</td>
    <td class="codeLine">  // unsplittable for the later store, then we can't rely on it being split in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4208</td>
    <td class="codeLine">  // unsplittable for the later store, then we can't rely on it being split in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4209</td>
    <td class="codeLine">  // the earlier store either.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4209</td>
    <td class="codeLine">  // the earlier store either.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4210</td>
    <td class="codeLine">  llvm::erase_if(Stores, [&UnsplittableLoads](StoreInst *SI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4210</td>
    <td class="codeLine">  llvm::erase_if(Stores, [&UnsplittableLoads](StoreInst *SI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4211</td>
    <td class="codeLine">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4211</td>
    <td class="codeLine">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4212</td>
    <td class="codeLine">    return UnsplittableLoads.count(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4212</td>
    <td class="codeLine">    return UnsplittableLoads.count(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4213</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4213</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4214</td>
    <td class="codeLine">  // Once we've established all the loads that can't be split for some reason,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4214</td>
    <td class="codeLine">  // Once we've established all the loads that can't be split for some reason,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4215</td>
    <td class="codeLine">  // filter any that made it into our list out.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4215</td>
    <td class="codeLine">  // filter any that made it into our list out.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4216</td>
    <td class="codeLine">  llvm::erase_if(Loads, [&UnsplittableLoads](LoadInst *LI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4216</td>
    <td class="codeLine">  llvm::erase_if(Loads, [&UnsplittableLoads](LoadInst *LI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4217</td>
    <td class="codeLine">    return UnsplittableLoads.count(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4217</td>
    <td class="codeLine">    return UnsplittableLoads.count(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4218</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4218</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4220</td>
    <td class="codeLine">  // If no loads or stores are left, there is no pre-splitting to be done for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4220</td>
    <td class="codeLine">  // If no loads or stores are left, there is no pre-splitting to be done for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4221</td>
    <td class="codeLine">  // this alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4221</td>
    <td class="codeLine">  // this alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4222</td>
    <td class="codeLine">  if (Loads.empty() && Stores.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4222</td>
    <td class="codeLine">  if (Loads.empty() && Stores.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4223</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4223</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4225</td>
    <td class="codeLine">  // From here on, we can't fail and will be building new accesses, so rig up</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4225</td>
    <td class="codeLine">  // From here on, we can't fail and will be building new accesses, so rig up</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4226</td>
    <td class="codeLine">  // an IR builder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4226</td>
    <td class="codeLine">  // an IR builder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4227</td>
    <td class="codeLine">  IRBuilderTy IRB(&AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4227</td>
    <td class="codeLine">  IRBuilderTy IRB(&AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4229</td>
    <td class="codeLine">  // Collect the new slices which we will merge into the alloca slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4229</td>
    <td class="codeLine">  // Collect the new slices which we will merge into the alloca slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4230</td>
    <td class="codeLine">  SmallVector<Slice, 4> NewSlices;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4230</td>
    <td class="codeLine">  SmallVector<Slice, 4> NewSlices;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4232</td>
    <td class="codeLine">  // Track any allocas we end up splitting loads and stores for so we iterate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4232</td>
    <td class="codeLine">  // Track any allocas we end up splitting loads and stores for so we iterate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4233</td>
    <td class="codeLine">  // on them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4233</td>
    <td class="codeLine">  // on them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4234</td>
    <td class="codeLine">  SmallPtrSet<AllocaInst *, 4> ResplitPromotableAllocas;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4234</td>
    <td class="codeLine">  SmallPtrSet<AllocaInst *, 4> ResplitPromotableAllocas;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4235</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4236</td>
    <td class="codeLine">  // At this point, we have collected all of the loads and stores we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4236</td>
    <td class="codeLine">  // At this point, we have collected all of the loads and stores we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4237</td>
    <td class="codeLine">  // pre-split, and the specific splits needed for them. We actually do the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4237</td>
    <td class="codeLine">  // pre-split, and the specific splits needed for them. We actually do the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4238</td>
    <td class="codeLine">  // splitting in a specific order in order to handle when one of the loads in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4238</td>
    <td class="codeLine">  // splitting in a specific order in order to handle when one of the loads in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4239</td>
    <td class="codeLine">  // the value operand to one of the stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4239</td>
    <td class="codeLine">  // the value operand to one of the stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4240</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4240</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4241</td>
    <td class="codeLine">  // First, we rewrite all of the split loads, and just accumulate each split</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4241</td>
    <td class="codeLine">  // First, we rewrite all of the split loads, and just accumulate each split</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4242</td>
    <td class="codeLine">  // load in a parallel structure. We also build the slices for them and append</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4242</td>
    <td class="codeLine">  // load in a parallel structure. We also build the slices for them and append</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4243</td>
    <td class="codeLine">  // them to the alloca slices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4243</td>
    <td class="codeLine">  // them to the alloca slices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4244</td>
    <td class="codeLine">  SmallDenseMap<LoadInst *, std::vector<LoadInst *>, 1> SplitLoadsMap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4244</td>
    <td class="codeLine">  SmallDenseMap<LoadInst *, std::vector<LoadInst *>, 1> SplitLoadsMap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4245</td>
    <td class="codeLine">  std::vector<LoadInst *> SplitLoads;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4245</td>
    <td class="codeLine">  std::vector<LoadInst *> SplitLoads;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4246</td>
    <td class="codeLine">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4246</td>
    <td class="codeLine">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4247</td>
    <td class="codeLine">  for (LoadInst *LI : Loads) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4247</td>
    <td class="codeLine">  for (LoadInst *LI : Loads) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4248</td>
    <td class="codeLine">    SplitLoads.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4248</td>
    <td class="codeLine">    SplitLoads.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4250</td>
    <td class="codeLine">    auto &Offsets = SplitOffsetsMap[LI];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4250</td>
    <td class="codeLine">    auto &Offsets = SplitOffsetsMap[LI];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4251</td>
    <td class="codeLine">    unsigned SliceSize = Offsets.S->endOffset() - Offsets.S->beginOffset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4251</td>
    <td class="codeLine">    unsigned SliceSize = Offsets.S->endOffset() - Offsets.S->beginOffset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4252</td>
    <td class="codeLine">    assert(LI->getType()->getIntegerBitWidth() % 8 == 0 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4252</td>
    <td class="codeLine">    assert(LI->getType()->getIntegerBitWidth() % 8 == 0 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4253</td>
    <td class="codeLine">           "Load must have type size equal to store size");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4253</td>
    <td class="codeLine">           "Load must have type size equal to store size");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4254</td>
    <td class="codeLine">    assert(LI->getType()->getIntegerBitWidth() / 8 >= SliceSize &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4254</td>
    <td class="codeLine">    assert(LI->getType()->getIntegerBitWidth() / 8 >= SliceSize &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4255</td>
    <td class="codeLine">           "Load must be >= slice size");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4255</td>
    <td class="codeLine">           "Load must be >= slice size");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4256</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4257</td>
    <td class="codeLine">    uint64_t BaseOffset = Offsets.S->beginOffset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4257</td>
    <td class="codeLine">    uint64_t BaseOffset = Offsets.S->beginOffset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4258</td>
    <td class="codeLine">    assert(BaseOffset + SliceSize > BaseOffset &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4258</td>
    <td class="codeLine">    assert(BaseOffset + SliceSize > BaseOffset &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4259</td>
    <td class="codeLine">           "Cannot represent alloca access size using 64-bit integers!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4259</td>
    <td class="codeLine">           "Cannot represent alloca access size using 64-bit integers!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4261</td>
    <td class="codeLine">    Instruction *BasePtr = cast<Instruction>(LI->getPointerOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4261</td>
    <td class="codeLine">    Instruction *BasePtr = cast<Instruction>(LI->getPointerOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4262</td>
    <td class="codeLine">    IRB.SetInsertPoint(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4262</td>
    <td class="codeLine">    IRB.SetInsertPoint(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4264</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  Splitting load: " << *LI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4264</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  Splitting load: " << *LI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4265</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4266</td>
    <td class="codeLine">    uint64_t PartOffset = 0, PartSize = Offsets.Splits.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4266</td>
    <td class="codeLine">    uint64_t PartOffset = 0, PartSize = Offsets.Splits.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4267</td>
    <td class="codeLine">    int Idx = 0, Size = Offsets.Splits.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4267</td>
    <td class="codeLine">    int Idx = 0, Size = Offsets.Splits.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4268</td>
    <td class="codeLine">    for (;;) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4268</td>
    <td class="codeLine">    for (;;) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4269</td>
    <td class="codeLine">      auto *PartTy = Type::getIntNTy(LI->getContext(), PartSize * 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4269</td>
    <td class="codeLine">      auto *PartTy = Type::getIntNTy(LI->getContext(), PartSize * 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4270</td>
    <td class="codeLine">      auto AS = LI->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4270</td>
    <td class="codeLine">      auto AS = LI->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4271</td>
    <td class="codeLine">      auto *PartPtrTy = PartTy->getPointerTo(AS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4271</td>
    <td class="codeLine">      auto *PartPtrTy = PartTy->getPointerTo(AS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4272</td>
    <td class="codeLine">      LoadInst *PLoad = IRB.CreateAlignedLoad(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4272</td>
    <td class="codeLine">      LoadInst *PLoad = IRB.CreateAlignedLoad(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4273</td>
    <td class="codeLine">          PartTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4273</td>
    <td class="codeLine">          PartTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4274</td>
    <td class="codeLine">          getAdjustedPtr(IRB, DL, BasePtr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4274</td>
    <td class="codeLine">          getAdjustedPtr(IRB, DL, BasePtr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4275</td>
    <td class="codeLine">                         APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4275</td>
    <td class="codeLine">                         APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4276</td>
    <td class="codeLine">                         PartPtrTy, BasePtr->getName() + "."),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4276</td>
    <td class="codeLine">                         PartPtrTy, BasePtr->getName() + "."),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4277</td>
    <td class="codeLine">          getAdjustedAlignment(LI, PartOffset),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4277</td>
    <td class="codeLine">          getAdjustedAlignment(LI, PartOffset),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4278</td>
    <td class="codeLine">          /*IsVolatile*/ false, LI->getName());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4278</td>
    <td class="codeLine">          /*IsVolatile*/ false, LI->getName());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4279</td>
    <td class="codeLine">      PLoad->copyMetadata(*LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4279</td>
    <td class="codeLine">      PLoad->copyMetadata(*LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4280</td>
    <td class="codeLine">                                LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4280</td>
    <td class="codeLine">                                LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4281</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4282</td>
    <td class="codeLine">      // Append this load onto the list of split loads so we can find it later</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4282</td>
    <td class="codeLine">      // Append this load onto the list of split loads so we can find it later</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4283</td>
    <td class="codeLine">      // to rewrite the stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4283</td>
    <td class="codeLine">      // to rewrite the stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4284</td>
    <td class="codeLine">      SplitLoads.push_back(PLoad);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4284</td>
    <td class="codeLine">      SplitLoads.push_back(PLoad);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4285</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4286</td>
    <td class="codeLine">      // Now build a new slice for the alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4286</td>
    <td class="codeLine">      // Now build a new slice for the alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4287</td>
    <td class="codeLine">      NewSlices.push_back(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4287</td>
    <td class="codeLine">      NewSlices.push_back(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4288</td>
    <td class="codeLine">          Slice(BaseOffset + PartOffset, BaseOffset + PartOffset + PartSize,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4288</td>
    <td class="codeLine">          Slice(BaseOffset + PartOffset, BaseOffset + PartOffset + PartSize,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4289</td>
    <td class="codeLine">                &PLoad->getOperandUse(PLoad->getPointerOperandIndex()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4289</td>
    <td class="codeLine">                &PLoad->getOperandUse(PLoad->getPointerOperandIndex()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4290</td>
    <td class="codeLine">                /*IsSplittable*/ false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4290</td>
    <td class="codeLine">                /*IsSplittable*/ false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4291</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "    new slice [" << NewSlices.back().beginOffset()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4291</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "    new slice [" << NewSlices.back().beginOffset()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4292</td>
    <td class="codeLine">                        << ", " << NewSlices.back().endOffset()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4292</td>
    <td class="codeLine">                        << ", " << NewSlices.back().endOffset()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4293</td>
    <td class="codeLine">                        << "): " << *PLoad << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4293</td>
    <td class="codeLine">                        << "): " << *PLoad << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4295</td>
    <td class="codeLine">      // See if we've handled all the splits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4295</td>
    <td class="codeLine">      // See if we've handled all the splits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4296</td>
    <td class="codeLine">      if (Idx >= Size)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4296</td>
    <td class="codeLine">      if (Idx >= Size)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4297</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4297</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4299</td>
    <td class="codeLine">      // Setup the next partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4299</td>
    <td class="codeLine">      // Setup the next partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4300</td>
    <td class="codeLine">      PartOffset = Offsets.Splits[Idx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4300</td>
    <td class="codeLine">      PartOffset = Offsets.Splits[Idx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4301</td>
    <td class="codeLine">      ++Idx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4301</td>
    <td class="codeLine">      ++Idx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4302</td>
    <td class="codeLine">      PartSize = (Idx < Size ? Offsets.Splits[Idx] : SliceSize) - PartOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4302</td>
    <td class="codeLine">      PartSize = (Idx < Size ? Offsets.Splits[Idx] : SliceSize) - PartOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4303</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4303</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4305</td>
    <td class="codeLine">    // Now that we have the split loads, do the slow walk over all uses of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4305</td>
    <td class="codeLine">    // Now that we have the split loads, do the slow walk over all uses of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4306</td>
    <td class="codeLine">    // load and rewrite them as split stores, or save the split loads to use</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4306</td>
    <td class="codeLine">    // load and rewrite them as split stores, or save the split loads to use</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4307</td>
    <td class="codeLine">    // below if the store is going to be split there anyways.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4307</td>
    <td class="codeLine">    // below if the store is going to be split there anyways.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4308</td>
    <td class="codeLine">    bool DeferredStores = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4308</td>
    <td class="codeLine">    bool DeferredStores = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4309</td>
    <td class="codeLine">    for (User *LU : LI->users()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4309</td>
    <td class="codeLine">    for (User *LU : LI->users()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4310</td>
    <td class="codeLine">      StoreInst *SI = cast<StoreInst>(LU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4310</td>
    <td class="codeLine">      StoreInst *SI = cast<StoreInst>(LU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4311</td>
    <td class="codeLine">      if (!Stores.empty() && SplitOffsetsMap.count(SI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4311</td>
    <td class="codeLine">      if (!Stores.empty() && SplitOffsetsMap.count(SI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4312</td>
    <td class="codeLine">        DeferredStores = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4312</td>
    <td class="codeLine">        DeferredStores = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4313</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "    Deferred splitting of store: " << *SI</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4313</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "    Deferred splitting of store: " << *SI</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4314</td>
    <td class="codeLine">                          << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4314</td>
    <td class="codeLine">                          << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4315</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4315</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4316</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4316</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4318</td>
    <td class="codeLine">      Value *StoreBasePtr = SI->getPointerOperand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4318</td>
    <td class="codeLine">      Value *StoreBasePtr = SI->getPointerOperand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4319</td>
    <td class="codeLine">      IRB.SetInsertPoint(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4319</td>
    <td class="codeLine">      IRB.SetInsertPoint(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4320</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4321</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "    Splitting store of load: " << *SI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4321</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "    Splitting store of load: " << *SI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4323</td>
    <td class="codeLine">      for (int Idx = 0, Size = SplitLoads.size(); Idx < Size; ++Idx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4323</td>
    <td class="codeLine">      for (int Idx = 0, Size = SplitLoads.size(); Idx < Size; ++Idx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4324</td>
    <td class="codeLine">        LoadInst *PLoad = SplitLoads[Idx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4324</td>
    <td class="codeLine">        LoadInst *PLoad = SplitLoads[Idx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4325</td>
    <td class="codeLine">        uint64_t PartOffset = Idx == 0 ? 0 : Offsets.Splits[Idx - 1];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4325</td>
    <td class="codeLine">        uint64_t PartOffset = Idx == 0 ? 0 : Offsets.Splits[Idx - 1];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4326</td>
    <td class="codeLine">        auto *PartPtrTy =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4326</td>
    <td class="codeLine">        auto *PartPtrTy =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4327</td>
    <td class="codeLine">            PLoad->getType()->getPointerTo(SI->getPointerAddressSpace());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4327</td>
    <td class="codeLine">            PLoad->getType()->getPointerTo(SI->getPointerAddressSpace());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4328</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4329</td>
    <td class="codeLine">        auto AS = SI->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4329</td>
    <td class="codeLine">        auto AS = SI->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4330</td>
    <td class="codeLine">        StoreInst *PStore = IRB.CreateAlignedStore(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4330</td>
    <td class="codeLine">        StoreInst *PStore = IRB.CreateAlignedStore(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4331</td>
    <td class="codeLine">            PLoad,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4331</td>
    <td class="codeLine">            PLoad,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4332</td>
    <td class="codeLine">            getAdjustedPtr(IRB, DL, StoreBasePtr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4332</td>
    <td class="codeLine">            getAdjustedPtr(IRB, DL, StoreBasePtr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4333</td>
    <td class="codeLine">                           APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4333</td>
    <td class="codeLine">                           APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4334</td>
    <td class="codeLine">                           PartPtrTy, StoreBasePtr->getName() + "."),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4334</td>
    <td class="codeLine">                           PartPtrTy, StoreBasePtr->getName() + "."),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4335</td>
    <td class="codeLine">            getAdjustedAlignment(SI, PartOffset),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4335</td>
    <td class="codeLine">            getAdjustedAlignment(SI, PartOffset),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4336</td>
    <td class="codeLine">            /*IsVolatile*/ false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4336</td>
    <td class="codeLine">            /*IsVolatile*/ false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4337</td>
    <td class="codeLine">        PStore->copyMetadata(*SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4337</td>
    <td class="codeLine">        PStore->copyMetadata(*SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4338</td>
    <td class="codeLine">                                   LLVMContext::MD_access_group,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4338</td>
    <td class="codeLine">                                   LLVMContext::MD_access_group,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4339</td>
    <td class="codeLine">                                   LLVMContext::MD_DIAssignID});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4339</td>
    <td class="codeLine">                                   LLVMContext::MD_DIAssignID});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4340</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "      +" << PartOffset << ":" << *PStore << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4340</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "      +" << PartOffset << ":" << *PStore << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4341</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4341</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4343</td>
    <td class="codeLine">      // We want to immediately iterate on any allocas impacted by splitting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4343</td>
    <td class="codeLine">      // We want to immediately iterate on any allocas impacted by splitting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4344</td>
    <td class="codeLine">      // this store, and we have to track any promotable alloca (indicated by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4344</td>
    <td class="codeLine">      // this store, and we have to track any promotable alloca (indicated by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4345</td>
    <td class="codeLine">      // a direct store) as needing to be resplit because it is no longer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4345</td>
    <td class="codeLine">      // a direct store) as needing to be resplit because it is no longer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4346</td>
    <td class="codeLine">      // promotable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4346</td>
    <td class="codeLine">      // promotable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4347</td>
    <td class="codeLine">      if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(StoreBasePtr)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4347</td>
    <td class="codeLine">      if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(StoreBasePtr)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4348</td>
    <td class="codeLine">        ResplitPromotableAllocas.insert(OtherAI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4348</td>
    <td class="codeLine">        ResplitPromotableAllocas.insert(OtherAI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4349</td>
    <td class="codeLine">        Worklist.insert(OtherAI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4349</td>
    <td class="codeLine">        Worklist.insert(OtherAI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4350</td>
    <td class="codeLine">      } else if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4350</td>
    <td class="codeLine">      } else if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4351</td>
    <td class="codeLine">                     StoreBasePtr->stripInBoundsOffsets())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4351</td>
    <td class="codeLine">                     StoreBasePtr->stripInBoundsOffsets())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4352</td>
    <td class="codeLine">        Worklist.insert(OtherAI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4352</td>
    <td class="codeLine">        Worklist.insert(OtherAI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4353</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4353</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4354</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4355</td>
    <td class="codeLine">      // Mark the original store as dead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4355</td>
    <td class="codeLine">      // Mark the original store as dead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4356</td>
    <td class="codeLine">      DeadInsts.push_back(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4356</td>
    <td class="codeLine">      DeadInsts.push_back(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4357</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4357</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4359</td>
    <td class="codeLine">    // Save the split loads if there are deferred stores among the users.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4359</td>
    <td class="codeLine">    // Save the split loads if there are deferred stores among the users.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4360</td>
    <td class="codeLine">    if (DeferredStores)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4360</td>
    <td class="codeLine">    if (DeferredStores)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4361</td>
    <td class="codeLine">      SplitLoadsMap.insert(std::make_pair(LI, std::move(SplitLoads)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4361</td>
    <td class="codeLine">      SplitLoadsMap.insert(std::make_pair(LI, std::move(SplitLoads)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4363</td>
    <td class="codeLine">    // Mark the original load as dead and kill the original slice.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4363</td>
    <td class="codeLine">    // Mark the original load as dead and kill the original slice.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4364</td>
    <td class="codeLine">    DeadInsts.push_back(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4364</td>
    <td class="codeLine">    DeadInsts.push_back(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4365</td>
    <td class="codeLine">    Offsets.S->kill();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4365</td>
    <td class="codeLine">    Offsets.S->kill();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4366</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4366</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4368</td>
    <td class="codeLine">  // Second, we rewrite all of the split stores. At this point, we know that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4368</td>
    <td class="codeLine">  // Second, we rewrite all of the split stores. At this point, we know that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4369</td>
    <td class="codeLine">  // all loads from this alloca have been split already. For stores of such</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4369</td>
    <td class="codeLine">  // all loads from this alloca have been split already. For stores of such</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4370</td>
    <td class="codeLine">  // loads, we can simply look up the pre-existing split loads. For stores of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4370</td>
    <td class="codeLine">  // loads, we can simply look up the pre-existing split loads. For stores of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4371</td>
    <td class="codeLine">  // other loads, we split those loads first and then write split stores of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4371</td>
    <td class="codeLine">  // other loads, we split those loads first and then write split stores of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4372</td>
    <td class="codeLine">  // them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4372</td>
    <td class="codeLine">  // them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4373</td>
    <td class="codeLine">  for (StoreInst *SI : Stores) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4373</td>
    <td class="codeLine">  for (StoreInst *SI : Stores) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4374</td>
    <td class="codeLine">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4374</td>
    <td class="codeLine">    auto *LI = cast<LoadInst>(SI->getValueOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4375</td>
    <td class="codeLine">    IntegerType *Ty = cast<IntegerType>(LI->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4375</td>
    <td class="codeLine">    IntegerType *Ty = cast<IntegerType>(LI->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4376</td>
    <td class="codeLine">    assert(Ty->getBitWidth() % 8 == 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4376</td>
    <td class="codeLine">    assert(Ty->getBitWidth() % 8 == 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4377</td>
    <td class="codeLine">    uint64_t StoreSize = Ty->getBitWidth() / 8;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4377</td>
    <td class="codeLine">    uint64_t StoreSize = Ty->getBitWidth() / 8;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4378</td>
    <td class="codeLine">    assert(StoreSize > 0 && "Cannot have a zero-sized integer store!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4378</td>
    <td class="codeLine">    assert(StoreSize > 0 && "Cannot have a zero-sized integer store!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4380</td>
    <td class="codeLine">    auto &Offsets = SplitOffsetsMap[SI];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4380</td>
    <td class="codeLine">    auto &Offsets = SplitOffsetsMap[SI];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4381</td>
    <td class="codeLine">    assert(StoreSize == Offsets.S->endOffset() - Offsets.S->beginOffset() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4381</td>
    <td class="codeLine">    assert(StoreSize == Offsets.S->endOffset() - Offsets.S->beginOffset() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4382</td>
    <td class="codeLine">           "Slice size should always match load size exactly!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4382</td>
    <td class="codeLine">           "Slice size should always match load size exactly!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4383</td>
    <td class="codeLine">    uint64_t BaseOffset = Offsets.S->beginOffset();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4383</td>
    <td class="codeLine">    uint64_t BaseOffset = Offsets.S->beginOffset();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4384</td>
    <td class="codeLine">    assert(BaseOffset + StoreSize > BaseOffset &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4384</td>
    <td class="codeLine">    assert(BaseOffset + StoreSize > BaseOffset &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4385</td>
    <td class="codeLine">           "Cannot represent alloca access size using 64-bit integers!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4385</td>
    <td class="codeLine">           "Cannot represent alloca access size using 64-bit integers!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4386</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4387</td>
    <td class="codeLine">    Value *LoadBasePtr = LI->getPointerOperand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4387</td>
    <td class="codeLine">    Value *LoadBasePtr = LI->getPointerOperand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4388</td>
    <td class="codeLine">    Instruction *StoreBasePtr = cast<Instruction>(SI->getPointerOperand());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4388</td>
    <td class="codeLine">    Instruction *StoreBasePtr = cast<Instruction>(SI->getPointerOperand());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4390</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  Splitting store: " << *SI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4390</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "  Splitting store: " << *SI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4392</td>
    <td class="codeLine">    // Check whether we have an already split load.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4392</td>
    <td class="codeLine">    // Check whether we have an already split load.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4393</td>
    <td class="codeLine">    auto SplitLoadsMapI = SplitLoadsMap.find(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4393</td>
    <td class="codeLine">    auto SplitLoadsMapI = SplitLoadsMap.find(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4394</td>
    <td class="codeLine">    std::vector<LoadInst *> *SplitLoads = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4394</td>
    <td class="codeLine">    std::vector<LoadInst *> *SplitLoads = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4395</td>
    <td class="codeLine">    if (SplitLoadsMapI != SplitLoadsMap.end()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4395</td>
    <td class="codeLine">    if (SplitLoadsMapI != SplitLoadsMap.end()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4396</td>
    <td class="codeLine">      SplitLoads = &SplitLoadsMapI->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4396</td>
    <td class="codeLine">      SplitLoads = &SplitLoadsMapI->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4397</td>
    <td class="codeLine">      assert(SplitLoads->size() == Offsets.Splits.size() + 1 &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4397</td>
    <td class="codeLine">      assert(SplitLoads->size() == Offsets.Splits.size() + 1 &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4398</td>
    <td class="codeLine">             "Too few split loads for the number of splits in the store!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4398</td>
    <td class="codeLine">             "Too few split loads for the number of splits in the store!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4399</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4399</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4400</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "          of load: " << *LI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4400</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "          of load: " << *LI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4401</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4401</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4403</td>
    <td class="codeLine">    uint64_t PartOffset = 0, PartSize = Offsets.Splits.front();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4403</td>
    <td class="codeLine">    uint64_t PartOffset = 0, PartSize = Offsets.Splits.front();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4404</td>
    <td class="codeLine">    int Idx = 0, Size = Offsets.Splits.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4404</td>
    <td class="codeLine">    int Idx = 0, Size = Offsets.Splits.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4405</td>
    <td class="codeLine">    for (;;) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4405</td>
    <td class="codeLine">    for (;;) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4406</td>
    <td class="codeLine">      auto *PartTy = Type::getIntNTy(Ty->getContext(), PartSize * 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4406</td>
    <td class="codeLine">      auto *PartTy = Type::getIntNTy(Ty->getContext(), PartSize * 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4407</td>
    <td class="codeLine">      auto *LoadPartPtrTy = PartTy->getPointerTo(LI->getPointerAddressSpace());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4407</td>
    <td class="codeLine">      auto *LoadPartPtrTy = PartTy->getPointerTo(LI->getPointerAddressSpace());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4408</td>
    <td class="codeLine">      auto *StorePartPtrTy = PartTy->getPointerTo(SI->getPointerAddressSpace());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4408</td>
    <td class="codeLine">      auto *StorePartPtrTy = PartTy->getPointerTo(SI->getPointerAddressSpace());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4410</td>
    <td class="codeLine">      // Either lookup a split load or create one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4410</td>
    <td class="codeLine">      // Either lookup a split load or create one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4411</td>
    <td class="codeLine">      LoadInst *PLoad;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4411</td>
    <td class="codeLine">      LoadInst *PLoad;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4412</td>
    <td class="codeLine">      if (SplitLoads) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4412</td>
    <td class="codeLine">      if (SplitLoads) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4413</td>
    <td class="codeLine">        PLoad = (*SplitLoads)[Idx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4413</td>
    <td class="codeLine">        PLoad = (*SplitLoads)[Idx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4414</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4414</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4415</td>
    <td class="codeLine">        IRB.SetInsertPoint(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4415</td>
    <td class="codeLine">        IRB.SetInsertPoint(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4416</td>
    <td class="codeLine">        auto AS = LI->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4416</td>
    <td class="codeLine">        auto AS = LI->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4417</td>
    <td class="codeLine">        PLoad = IRB.CreateAlignedLoad(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4417</td>
    <td class="codeLine">        PLoad = IRB.CreateAlignedLoad(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4418</td>
    <td class="codeLine">            PartTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4418</td>
    <td class="codeLine">            PartTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4419</td>
    <td class="codeLine">            getAdjustedPtr(IRB, DL, LoadBasePtr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4419</td>
    <td class="codeLine">            getAdjustedPtr(IRB, DL, LoadBasePtr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4420</td>
    <td class="codeLine">                           APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4420</td>
    <td class="codeLine">                           APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4421</td>
    <td class="codeLine">                           LoadPartPtrTy, LoadBasePtr->getName() + "."),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4421</td>
    <td class="codeLine">                           LoadPartPtrTy, LoadBasePtr->getName() + "."),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4422</td>
    <td class="codeLine">            getAdjustedAlignment(LI, PartOffset),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4422</td>
    <td class="codeLine">            getAdjustedAlignment(LI, PartOffset),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4423</td>
    <td class="codeLine">            /*IsVolatile*/ false, LI->getName());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4423</td>
    <td class="codeLine">            /*IsVolatile*/ false, LI->getName());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4424</td>
    <td class="codeLine">        PLoad->copyMetadata(*LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4424</td>
    <td class="codeLine">        PLoad->copyMetadata(*LI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4425</td>
    <td class="codeLine">                                  LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4425</td>
    <td class="codeLine">                                  LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4426</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4426</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4427</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4428</td>
    <td class="codeLine">      // And store this partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4428</td>
    <td class="codeLine">      // And store this partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4429</td>
    <td class="codeLine">      IRB.SetInsertPoint(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4429</td>
    <td class="codeLine">      IRB.SetInsertPoint(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4430</td>
    <td class="codeLine">      auto AS = SI->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4430</td>
    <td class="codeLine">      auto AS = SI->getPointerAddressSpace();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4431</td>
    <td class="codeLine">      StoreInst *PStore = IRB.CreateAlignedStore(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4431</td>
    <td class="codeLine">      StoreInst *PStore = IRB.CreateAlignedStore(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4432</td>
    <td class="codeLine">          PLoad,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4432</td>
    <td class="codeLine">          PLoad,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4433</td>
    <td class="codeLine">          getAdjustedPtr(IRB, DL, StoreBasePtr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4433</td>
    <td class="codeLine">          getAdjustedPtr(IRB, DL, StoreBasePtr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4434</td>
    <td class="codeLine">                         APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4434</td>
    <td class="codeLine">                         APInt(DL.getIndexSizeInBits(AS), PartOffset),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4435</td>
    <td class="codeLine">                         StorePartPtrTy, StoreBasePtr->getName() + "."),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4435</td>
    <td class="codeLine">                         StorePartPtrTy, StoreBasePtr->getName() + "."),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4436</td>
    <td class="codeLine">          getAdjustedAlignment(SI, PartOffset),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4436</td>
    <td class="codeLine">          getAdjustedAlignment(SI, PartOffset),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4437</td>
    <td class="codeLine">          /*IsVolatile*/ false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4437</td>
    <td class="codeLine">          /*IsVolatile*/ false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4438</td>
    <td class="codeLine">      PStore->copyMetadata(*SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4438</td>
    <td class="codeLine">      PStore->copyMetadata(*SI, {LLVMContext::MD_mem_parallel_loop_access,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4439</td>
    <td class="codeLine">                                 LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4439</td>
    <td class="codeLine">                                 LLVMContext::MD_access_group});</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4440</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4441</td>
    <td class="codeLine">      // Now build a new slice for the alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4441</td>
    <td class="codeLine">      // Now build a new slice for the alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4442</td>
    <td class="codeLine">      NewSlices.push_back(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4442</td>
    <td class="codeLine">      NewSlices.push_back(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4443</td>
    <td class="codeLine">          Slice(BaseOffset + PartOffset, BaseOffset + PartOffset + PartSize,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4443</td>
    <td class="codeLine">          Slice(BaseOffset + PartOffset, BaseOffset + PartOffset + PartSize,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4444</td>
    <td class="codeLine">                &PStore->getOperandUse(PStore->getPointerOperandIndex()),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4444</td>
    <td class="codeLine">                &PStore->getOperandUse(PStore->getPointerOperandIndex()),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4445</td>
    <td class="codeLine">                /*IsSplittable*/ false));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4445</td>
    <td class="codeLine">                /*IsSplittable*/ false));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4446</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "    new slice [" << NewSlices.back().beginOffset()</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4446</td>
    <td class="codeLine">      LLVM_DEBUG(dbgs() << "    new slice [" << NewSlices.back().beginOffset()</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4447</td>
    <td class="codeLine">                        << ", " << NewSlices.back().endOffset()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4447</td>
    <td class="codeLine">                        << ", " << NewSlices.back().endOffset()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4448</td>
    <td class="codeLine">                        << "): " << *PStore << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4448</td>
    <td class="codeLine">                        << "): " << *PStore << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4449</td>
    <td class="codeLine">      if (!SplitLoads) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4449</td>
    <td class="codeLine">      if (!SplitLoads) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4450</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "      of split load: " << *PLoad << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4450</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "      of split load: " << *PLoad << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4451</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4451</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4452</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4453</td>
    <td class="codeLine">      // See if we've finished all the splits.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4453</td>
    <td class="codeLine">      // See if we've finished all the splits.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4454</td>
    <td class="codeLine">      if (Idx >= Size)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4454</td>
    <td class="codeLine">      if (Idx >= Size)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4455</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4455</td>
    <td class="codeLine">        break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4456</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4457</td>
    <td class="codeLine">      // Setup the next partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4457</td>
    <td class="codeLine">      // Setup the next partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4458</td>
    <td class="codeLine">      PartOffset = Offsets.Splits[Idx];</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4458</td>
    <td class="codeLine">      PartOffset = Offsets.Splits[Idx];</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4459</td>
    <td class="codeLine">      ++Idx;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4459</td>
    <td class="codeLine">      ++Idx;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4460</td>
    <td class="codeLine">      PartSize = (Idx < Size ? Offsets.Splits[Idx] : StoreSize) - PartOffset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4460</td>
    <td class="codeLine">      PartSize = (Idx < Size ? Offsets.Splits[Idx] : StoreSize) - PartOffset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4461</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4461</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4463</td>
    <td class="codeLine">    // We want to immediately iterate on any allocas impacted by splitting</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4463</td>
    <td class="codeLine">    // We want to immediately iterate on any allocas impacted by splitting</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4464</td>
    <td class="codeLine">    // this load, which is only relevant if it isn't a load of this alloca and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4464</td>
    <td class="codeLine">    // this load, which is only relevant if it isn't a load of this alloca and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4465</td>
    <td class="codeLine">    // thus we didn't already split the loads above. We also have to keep track</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4465</td>
    <td class="codeLine">    // thus we didn't already split the loads above. We also have to keep track</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4466</td>
    <td class="codeLine">    // of any promotable allocas we split loads on as they can no longer be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4466</td>
    <td class="codeLine">    // of any promotable allocas we split loads on as they can no longer be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4467</td>
    <td class="codeLine">    // promoted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4467</td>
    <td class="codeLine">    // promoted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4468</td>
    <td class="codeLine">    if (!SplitLoads) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4468</td>
    <td class="codeLine">    if (!SplitLoads) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4469</td>
    <td class="codeLine">      if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(LoadBasePtr)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4469</td>
    <td class="codeLine">      if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(LoadBasePtr)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4470</td>
    <td class="codeLine">        assert(OtherAI != &AI && "We can't re-split our own alloca!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4470</td>
    <td class="codeLine">        assert(OtherAI != &AI && "We can't re-split our own alloca!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4471</td>
    <td class="codeLine">        ResplitPromotableAllocas.insert(OtherAI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4471</td>
    <td class="codeLine">        ResplitPromotableAllocas.insert(OtherAI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4472</td>
    <td class="codeLine">        Worklist.insert(OtherAI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4472</td>
    <td class="codeLine">        Worklist.insert(OtherAI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4473</td>
    <td class="codeLine">      } else if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4473</td>
    <td class="codeLine">      } else if (AllocaInst *OtherAI = dyn_cast<AllocaInst>(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4474</td>
    <td class="codeLine">                     LoadBasePtr->stripInBoundsOffsets())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4474</td>
    <td class="codeLine">                     LoadBasePtr->stripInBoundsOffsets())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4475</td>
    <td class="codeLine">        assert(OtherAI != &AI && "We can't re-split our own alloca!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4475</td>
    <td class="codeLine">        assert(OtherAI != &AI && "We can't re-split our own alloca!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4476</td>
    <td class="codeLine">        Worklist.insert(OtherAI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4476</td>
    <td class="codeLine">        Worklist.insert(OtherAI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4477</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4477</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4478</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4478</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4479</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4480</td>
    <td class="codeLine">    // Mark the original store as dead now that we've split it up and kill its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4480</td>
    <td class="codeLine">    // Mark the original store as dead now that we've split it up and kill its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4481</td>
    <td class="codeLine">    // slice. Note that we leave the original load in place unless this store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4481</td>
    <td class="codeLine">    // slice. Note that we leave the original load in place unless this store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4482</td>
    <td class="codeLine">    // was its only use. It may in turn be split up if it is an alloca load</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4482</td>
    <td class="codeLine">    // was its only use. It may in turn be split up if it is an alloca load</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4483</td>
    <td class="codeLine">    // for some other alloca, but it may be a normal load. This may introduce</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4483</td>
    <td class="codeLine">    // for some other alloca, but it may be a normal load. This may introduce</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4484</td>
    <td class="codeLine">    // redundant loads, but where those can be merged the rest of the optimizer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4484</td>
    <td class="codeLine">    // redundant loads, but where those can be merged the rest of the optimizer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4485</td>
    <td class="codeLine">    // should handle the merging, and this uncovers SSA splits which is more</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4485</td>
    <td class="codeLine">    // should handle the merging, and this uncovers SSA splits which is more</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4486</td>
    <td class="codeLine">    // important. In practice, the original loads will almost always be fully</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4486</td>
    <td class="codeLine">    // important. In practice, the original loads will almost always be fully</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4487</td>
    <td class="codeLine">    // split and removed eventually, and the splits will be merged by any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4487</td>
    <td class="codeLine">    // split and removed eventually, and the splits will be merged by any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4488</td>
    <td class="codeLine">    // trivial CSE, including instcombine.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4488</td>
    <td class="codeLine">    // trivial CSE, including instcombine.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4489</td>
    <td class="codeLine">    if (LI->hasOneUse()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4489</td>
    <td class="codeLine">    if (LI->hasOneUse()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4490</td>
    <td class="codeLine">      assert(*LI->user_begin() == SI && "Single use isn't this store!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4490</td>
    <td class="codeLine">      assert(*LI->user_begin() == SI && "Single use isn't this store!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4491</td>
    <td class="codeLine">      DeadInsts.push_back(LI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4491</td>
    <td class="codeLine">      DeadInsts.push_back(LI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4492</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4492</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4493</td>
    <td class="codeLine">    DeadInsts.push_back(SI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4493</td>
    <td class="codeLine">    DeadInsts.push_back(SI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4494</td>
    <td class="codeLine">    Offsets.S->kill();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4494</td>
    <td class="codeLine">    Offsets.S->kill();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4495</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4495</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4497</td>
    <td class="codeLine">  // Remove the killed slices that have ben pre-split.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4497</td>
    <td class="codeLine">  // Remove the killed slices that have ben pre-split.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4498</td>
    <td class="codeLine">  llvm::erase_if(AS, [](const Slice &S) { return S.isDead(); });</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4498</td>
    <td class="codeLine">  llvm::erase_if(AS, [](const Slice &S) { return S.isDead(); });</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4499</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4500</td>
    <td class="codeLine">  // Insert our new slices. This will sort and merge them into the sorted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4500</td>
    <td class="codeLine">  // Insert our new slices. This will sort and merge them into the sorted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4501</td>
    <td class="codeLine">  // sequence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4501</td>
    <td class="codeLine">  // sequence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4502</td>
    <td class="codeLine">  AS.insert(NewSlices);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4502</td>
    <td class="codeLine">  AS.insert(NewSlices);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4503</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4504</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Pre-split slices:\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4504</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Pre-split slices:\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4505</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4505</td>
    <td class="codeLine">#ifndef NDEBUG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4506</td>
    <td class="codeLine">  for (auto I = AS.begin(), E = AS.end(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4506</td>
    <td class="codeLine">  for (auto I = AS.begin(), E = AS.end(); I != E; ++I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4507</td>
    <td class="codeLine">    LLVM_DEBUG(AS.print(dbgs(), I, "    "));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4507</td>
    <td class="codeLine">    LLVM_DEBUG(AS.print(dbgs(), I, "    "));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4508</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4508</td>
    <td class="codeLine">#endif</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4509</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4510</td>
    <td class="codeLine">  // Finally, don't try to promote any allocas that new require re-splitting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4510</td>
    <td class="codeLine">  // Finally, don't try to promote any allocas that new require re-splitting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4511</td>
    <td class="codeLine">  // They have already been added to the worklist above.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4511</td>
    <td class="codeLine">  // They have already been added to the worklist above.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4512</td>
    <td class="codeLine">  llvm::erase_if(PromotableAllocas, [&](AllocaInst *AI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4512</td>
    <td class="codeLine">  llvm::erase_if(PromotableAllocas, [&](AllocaInst *AI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4513</td>
    <td class="codeLine">    return ResplitPromotableAllocas.count(AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4513</td>
    <td class="codeLine">    return ResplitPromotableAllocas.count(AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4514</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4514</td>
    <td class="codeLine">  });</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4515</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4516</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4516</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4517</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4517</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4519</td>
    <td class="codeLine">/// Rewrite an alloca partition's users.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4519</td>
    <td class="codeLine">/// Rewrite an alloca partition's users.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4520</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4520</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4521</td>
    <td class="codeLine">/// This routine drives both of the rewriting goals of the SROA pass. It tries</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4521</td>
    <td class="codeLine">/// This routine drives both of the rewriting goals of the SROA pass. It tries</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4522</td>
    <td class="codeLine">/// to rewrite uses of an alloca partition to be conducive for SSA value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4522</td>
    <td class="codeLine">/// to rewrite uses of an alloca partition to be conducive for SSA value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4523</td>
    <td class="codeLine">/// promotion. If the partition needs a new, more refined alloca, this will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4523</td>
    <td class="codeLine">/// promotion. If the partition needs a new, more refined alloca, this will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4524</td>
    <td class="codeLine">/// build that new alloca, preserving as much type information as possible, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4524</td>
    <td class="codeLine">/// build that new alloca, preserving as much type information as possible, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4525</td>
    <td class="codeLine">/// rewrite the uses of the old alloca to point at the new one and have the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4525</td>
    <td class="codeLine">/// rewrite the uses of the old alloca to point at the new one and have the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4526</td>
    <td class="codeLine">/// appropriate new offsets. It also evaluates how successful the rewrite was</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4526</td>
    <td class="codeLine">/// appropriate new offsets. It also evaluates how successful the rewrite was</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4527</td>
    <td class="codeLine">/// at enabling promotion and if it was successful queues the alloca to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4527</td>
    <td class="codeLine">/// at enabling promotion and if it was successful queues the alloca to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4528</td>
    <td class="codeLine">/// promoted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4528</td>
    <td class="codeLine">/// promoted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4529</td>
    <td class="codeLine">AllocaInst *SROAPass::rewritePartition(AllocaInst &AI, AllocaSlices &AS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4529</td>
    <td class="codeLine">AllocaInst *SROAPass::rewritePartition(AllocaInst &AI, AllocaSlices &AS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4530</td>
    <td class="codeLine">                                       Partition &P) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4530</td>
    <td class="codeLine">                                       Partition &P) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4531</td>
    <td class="codeLine">  // Try to compute a friendly type for this partition of the alloca. This</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4531</td>
    <td class="codeLine">  // Try to compute a friendly type for this partition of the alloca. This</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4532</td>
    <td class="codeLine">  // won't always succeed, in which case we fall back to a legal integer type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4532</td>
    <td class="codeLine">  // won't always succeed, in which case we fall back to a legal integer type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4533</td>
    <td class="codeLine">  // or an i8 array of an appropriate size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4533</td>
    <td class="codeLine">  // or an i8 array of an appropriate size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4534</td>
    <td class="codeLine">  Type *SliceTy = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4534</td>
    <td class="codeLine">  Type *SliceTy = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4535</td>
    <td class="codeLine">  VectorType *SliceVecTy = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4535</td>
    <td class="codeLine">  VectorType *SliceVecTy = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4536</td>
    <td class="codeLine">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4536</td>
    <td class="codeLine">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4537</td>
    <td class="codeLine">  std::pair<Type *, IntegerType *> CommonUseTy =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4537</td>
    <td class="codeLine">  std::pair<Type *, IntegerType *> CommonUseTy =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4538</td>
    <td class="codeLine">      findCommonType(P.begin(), P.end(), P.endOffset());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4538</td>
    <td class="codeLine">      findCommonType(P.begin(), P.end(), P.endOffset());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4539</td>
    <td class="codeLine">  // Do all uses operate on the same type?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4539</td>
    <td class="codeLine">  // Do all uses operate on the same type?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4540</td>
    <td class="codeLine">  if (CommonUseTy.first)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4540</td>
    <td class="codeLine">  if (CommonUseTy.first)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4541</td>
    <td class="codeLine">    if (DL.getTypeAllocSize(CommonUseTy.first).getFixedValue() >= P.size()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4541</td>
    <td class="codeLine">    if (DL.getTypeAllocSize(CommonUseTy.first).getFixedValue() >= P.size()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4542</td>
    <td class="codeLine">      SliceTy = CommonUseTy.first;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4542</td>
    <td class="codeLine">      SliceTy = CommonUseTy.first;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4543</td>
    <td class="codeLine">      SliceVecTy = dyn_cast<VectorType>(SliceTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4543</td>
    <td class="codeLine">      SliceVecTy = dyn_cast<VectorType>(SliceTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4544</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4544</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4545</td>
    <td class="codeLine">  // If not, can we find an appropriate subtype in the original allocated type?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4545</td>
    <td class="codeLine">  // If not, can we find an appropriate subtype in the original allocated type?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4546</td>
    <td class="codeLine">  if (!SliceTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4546</td>
    <td class="codeLine">  if (!SliceTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4547</td>
    <td class="codeLine">    if (Type *TypePartitionTy = getTypePartition(DL, AI.getAllocatedType(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4547</td>
    <td class="codeLine">    if (Type *TypePartitionTy = getTypePartition(DL, AI.getAllocatedType(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4548</td>
    <td class="codeLine">                                                 P.beginOffset(), P.size()))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4548</td>
    <td class="codeLine">                                                 P.beginOffset(), P.size()))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4549</td>
    <td class="codeLine">      SliceTy = TypePartitionTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4549</td>
    <td class="codeLine">      SliceTy = TypePartitionTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4550</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4550</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4551</td>
    <td class="codeLine">  // If still not, can we use the largest bitwidth integer type used?</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4551</td>
    <td class="codeLine">  // If still not, can we use the largest bitwidth integer type used?</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4552</td>
    <td class="codeLine">  if (!SliceTy && CommonUseTy.second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4552</td>
    <td class="codeLine">  if (!SliceTy && CommonUseTy.second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4553</td>
    <td class="codeLine">    if (DL.getTypeAllocSize(CommonUseTy.second).getFixedValue() >= P.size()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4553</td>
    <td class="codeLine">    if (DL.getTypeAllocSize(CommonUseTy.second).getFixedValue() >= P.size()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4554</td>
    <td class="codeLine">      SliceTy = CommonUseTy.second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4554</td>
    <td class="codeLine">      SliceTy = CommonUseTy.second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4555</td>
    <td class="codeLine">      SliceVecTy = dyn_cast<VectorType>(SliceTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4555</td>
    <td class="codeLine">      SliceVecTy = dyn_cast<VectorType>(SliceTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4556</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4556</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4557</td>
    <td class="codeLine">  if ((!SliceTy || (SliceTy->isArrayTy() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4557</td>
    <td class="codeLine">  if ((!SliceTy || (SliceTy->isArrayTy() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4558</td>
    <td class="codeLine">                    SliceTy->getArrayElementType()->isIntegerTy())) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4558</td>
    <td class="codeLine">                    SliceTy->getArrayElementType()->isIntegerTy())) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4559</td>
    <td class="codeLine">      DL.isLegalInteger(P.size() * 8)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4559</td>
    <td class="codeLine">      DL.isLegalInteger(P.size() * 8)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4560</td>
    <td class="codeLine">    SliceTy = Type::getIntNTy(*C, P.size() * 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4560</td>
    <td class="codeLine">    SliceTy = Type::getIntNTy(*C, P.size() * 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4561</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4561</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4563</td>
    <td class="codeLine">  // If the common use types are not viable for promotion then attempt to find</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4563</td>
    <td class="codeLine">  // If the common use types are not viable for promotion then attempt to find</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4564</td>
    <td class="codeLine">  // another type that is viable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4564</td>
    <td class="codeLine">  // another type that is viable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4565</td>
    <td class="codeLine">  if (SliceVecTy && !checkVectorTypeForPromotion(P, SliceVecTy, DL))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4565</td>
    <td class="codeLine">  if (SliceVecTy && !checkVectorTypeForPromotion(P, SliceVecTy, DL))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4566</td>
    <td class="codeLine">    if (Type *TypePartitionTy = getTypePartition(DL, AI.getAllocatedType(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4566</td>
    <td class="codeLine">    if (Type *TypePartitionTy = getTypePartition(DL, AI.getAllocatedType(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4567</td>
    <td class="codeLine">                                                 P.beginOffset(), P.size())) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4567</td>
    <td class="codeLine">                                                 P.beginOffset(), P.size())) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4568</td>
    <td class="codeLine">      VectorType *TypePartitionVecTy = dyn_cast<VectorType>(TypePartitionTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4568</td>
    <td class="codeLine">      VectorType *TypePartitionVecTy = dyn_cast<VectorType>(TypePartitionTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4569</td>
    <td class="codeLine">      if (TypePartitionVecTy &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4569</td>
    <td class="codeLine">      if (TypePartitionVecTy &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4570</td>
    <td class="codeLine">          checkVectorTypeForPromotion(P, TypePartitionVecTy, DL))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4570</td>
    <td class="codeLine">          checkVectorTypeForPromotion(P, TypePartitionVecTy, DL))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4571</td>
    <td class="codeLine">        SliceTy = TypePartitionTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4571</td>
    <td class="codeLine">        SliceTy = TypePartitionTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4572</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4572</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4574</td>
    <td class="codeLine">  if (!SliceTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4574</td>
    <td class="codeLine">  if (!SliceTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4575</td>
    <td class="codeLine">    SliceTy = ArrayType::get(Type::getInt8Ty(*C), P.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4575</td>
    <td class="codeLine">    SliceTy = ArrayType::get(Type::getInt8Ty(*C), P.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4576</td>
    <td class="codeLine">  assert(DL.getTypeAllocSize(SliceTy).getFixedValue() >= P.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4576</td>
    <td class="codeLine">  assert(DL.getTypeAllocSize(SliceTy).getFixedValue() >= P.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4577</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4578</td>
    <td class="codeLine">  bool IsIntegerPromotable = isIntegerWideningViable(P, SliceTy, DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4578</td>
    <td class="codeLine">  bool IsIntegerPromotable = isIntegerWideningViable(P, SliceTy, DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4579</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4580</td>
    <td class="codeLine">  VectorType *VecTy =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4580</td>
    <td class="codeLine">  VectorType *VecTy =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4581</td>
    <td class="codeLine">      IsIntegerPromotable ? nullptr : isVectorPromotionViable(P, DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4581</td>
    <td class="codeLine">      IsIntegerPromotable ? nullptr : isVectorPromotionViable(P, DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4582</td>
    <td class="codeLine">  if (VecTy)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4582</td>
    <td class="codeLine">  if (VecTy)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4583</td>
    <td class="codeLine">    SliceTy = VecTy;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4583</td>
    <td class="codeLine">    SliceTy = VecTy;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4584</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4585</td>
    <td class="codeLine">  // Check for the case where we're going to rewrite to a new alloca of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4585</td>
    <td class="codeLine">  // Check for the case where we're going to rewrite to a new alloca of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4586</td>
    <td class="codeLine">  // exact same type as the original, and with the same access offsets. In that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4586</td>
    <td class="codeLine">  // exact same type as the original, and with the same access offsets. In that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4587</td>
    <td class="codeLine">  // case, re-use the existing alloca, but still run through the rewriter to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4587</td>
    <td class="codeLine">  // case, re-use the existing alloca, but still run through the rewriter to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4588</td>
    <td class="codeLine">  // perform phi and select speculation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4588</td>
    <td class="codeLine">  // perform phi and select speculation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4589</td>
    <td class="codeLine">  // P.beginOffset() can be non-zero even with the same type in a case with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4589</td>
    <td class="codeLine">  // P.beginOffset() can be non-zero even with the same type in a case with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4590</td>
    <td class="codeLine">  // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4590</td>
    <td class="codeLine">  // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4591</td>
    <td class="codeLine">  AllocaInst *NewAI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4591</td>
    <td class="codeLine">  AllocaInst *NewAI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4592</td>
    <td class="codeLine">  if (SliceTy == AI.getAllocatedType() && P.beginOffset() == 0) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4592</td>
    <td class="codeLine">  if (SliceTy == AI.getAllocatedType() && P.beginOffset() == 0) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4593</td>
    <td class="codeLine">    NewAI = &AI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4593</td>
    <td class="codeLine">    NewAI = &AI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4594</td>
    <td class="codeLine">    // FIXME: We should be able to bail at this point with "nothing changed".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4594</td>
    <td class="codeLine">    // FIXME: We should be able to bail at this point with "nothing changed".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4595</td>
    <td class="codeLine">    // FIXME: We might want to defer PHI speculation until after here.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4595</td>
    <td class="codeLine">    // FIXME: We might want to defer PHI speculation until after here.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4596</td>
    <td class="codeLine">    // FIXME: return nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4596</td>
    <td class="codeLine">    // FIXME: return nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4597</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4597</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4598</td>
    <td class="codeLine">    // Make sure the alignment is compatible with P.beginOffset().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4598</td>
    <td class="codeLine">    // Make sure the alignment is compatible with P.beginOffset().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4599</td>
    <td class="codeLine">    const Align Alignment = commonAlignment(AI.getAlign(), P.beginOffset());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4599</td>
    <td class="codeLine">    const Align Alignment = commonAlignment(AI.getAlign(), P.beginOffset());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4600</td>
    <td class="codeLine">    // If we will get at least this much alignment from the type alone, leave</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4600</td>
    <td class="codeLine">    // If we will get at least this much alignment from the type alone, leave</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4601</td>
    <td class="codeLine">    // the alloca's alignment unconstrained.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4601</td>
    <td class="codeLine">    // the alloca's alignment unconstrained.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4602</td>
    <td class="codeLine">    const bool IsUnconstrained = Alignment <= DL.getABITypeAlign(SliceTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4602</td>
    <td class="codeLine">    const bool IsUnconstrained = Alignment <= DL.getABITypeAlign(SliceTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4603</td>
    <td class="codeLine">    NewAI = new AllocaInst(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4603</td>
    <td class="codeLine">    NewAI = new AllocaInst(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4604</td>
    <td class="codeLine">        SliceTy, AI.getAddressSpace(), nullptr,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4604</td>
    <td class="codeLine">        SliceTy, AI.getAddressSpace(), nullptr,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4605</td>
    <td class="codeLine">        IsUnconstrained ? DL.getPrefTypeAlign(SliceTy) : Alignment,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4605</td>
    <td class="codeLine">        IsUnconstrained ? DL.getPrefTypeAlign(SliceTy) : Alignment,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4606</td>
    <td class="codeLine">        AI.getName() + ".sroa." + Twine(P.begin() - AS.begin()), &AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4606</td>
    <td class="codeLine">        AI.getName() + ".sroa." + Twine(P.begin() - AS.begin()), &AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4607</td>
    <td class="codeLine">    // Copy the old AI debug location over to the new one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4607</td>
    <td class="codeLine">    // Copy the old AI debug location over to the new one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4608</td>
    <td class="codeLine">    NewAI->setDebugLoc(AI.getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4608</td>
    <td class="codeLine">    NewAI->setDebugLoc(AI.getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4609</td>
    <td class="codeLine">    ++NumNewAllocas;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4609</td>
    <td class="codeLine">    ++NumNewAllocas;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4610</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4610</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4611</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4612</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Rewriting alloca partition "</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4612</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "Rewriting alloca partition "</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4613</td>
    <td class="codeLine">                    << "[" << P.beginOffset() << "," << P.endOffset()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4613</td>
    <td class="codeLine">                    << "[" << P.beginOffset() << "," << P.endOffset()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4614</td>
    <td class="codeLine">                    << ") to: " << *NewAI << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4614</td>
    <td class="codeLine">                    << ") to: " << *NewAI << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4615</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4616</td>
    <td class="codeLine">  // Track the high watermark on the worklist as it is only relevant for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4616</td>
    <td class="codeLine">  // Track the high watermark on the worklist as it is only relevant for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4617</td>
    <td class="codeLine">  // promoted allocas. We will reset it to this point if the alloca is not in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4617</td>
    <td class="codeLine">  // promoted allocas. We will reset it to this point if the alloca is not in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4618</td>
    <td class="codeLine">  // fact scheduled for promotion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4618</td>
    <td class="codeLine">  // fact scheduled for promotion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4619</td>
    <td class="codeLine">  unsigned PPWOldSize = PostPromotionWorklist.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4619</td>
    <td class="codeLine">  unsigned PPWOldSize = PostPromotionWorklist.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4620</td>
    <td class="codeLine">  unsigned NumUses = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4620</td>
    <td class="codeLine">  unsigned NumUses = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4621</td>
    <td class="codeLine">  SmallSetVector<PHINode *, 8> PHIUsers;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4621</td>
    <td class="codeLine">  SmallSetVector<PHINode *, 8> PHIUsers;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4622</td>
    <td class="codeLine">  SmallSetVector<SelectInst *, 8> SelectUsers;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4622</td>
    <td class="codeLine">  SmallSetVector<SelectInst *, 8> SelectUsers;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4624</td>
    <td class="codeLine">  AllocaSliceRewriter Rewriter(DL, AS, *this, AI, *NewAI, P.beginOffset(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4624</td>
    <td class="codeLine">  AllocaSliceRewriter Rewriter(DL, AS, *this, AI, *NewAI, P.beginOffset(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4625</td>
    <td class="codeLine">                               P.endOffset(), IsIntegerPromotable, VecTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4625</td>
    <td class="codeLine">                               P.endOffset(), IsIntegerPromotable, VecTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4626</td>
    <td class="codeLine">                               PHIUsers, SelectUsers);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4626</td>
    <td class="codeLine">                               PHIUsers, SelectUsers);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4627</td>
    <td class="codeLine">  bool Promotable = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4627</td>
    <td class="codeLine">  bool Promotable = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4628</td>
    <td class="codeLine">  for (Slice *S : P.splitSliceTails()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4628</td>
    <td class="codeLine">  for (Slice *S : P.splitSliceTails()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4629</td>
    <td class="codeLine">    Promotable &= Rewriter.visit(S);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4629</td>
    <td class="codeLine">    Promotable &= Rewriter.visit(S);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4630</td>
    <td class="codeLine">    ++NumUses;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4630</td>
    <td class="codeLine">    ++NumUses;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4631</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4631</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4632</td>
    <td class="codeLine">  for (Slice &S : P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4632</td>
    <td class="codeLine">  for (Slice &S : P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4633</td>
    <td class="codeLine">    Promotable &= Rewriter.visit(&S);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4633</td>
    <td class="codeLine">    Promotable &= Rewriter.visit(&S);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4634</td>
    <td class="codeLine">    ++NumUses;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4634</td>
    <td class="codeLine">    ++NumUses;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4635</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4635</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4636</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4637</td>
    <td class="codeLine">  NumAllocaPartitionUses += NumUses;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4637</td>
    <td class="codeLine">  NumAllocaPartitionUses += NumUses;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4638</td>
    <td class="codeLine">  MaxUsesPerAllocaPartition.updateMax(NumUses);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4638</td>
    <td class="codeLine">  MaxUsesPerAllocaPartition.updateMax(NumUses);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4639</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4639</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4640</td>
    <td class="codeLine">  // Now that we've processed all the slices in the new partition, check if any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4640</td>
    <td class="codeLine">  // Now that we've processed all the slices in the new partition, check if any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4641</td>
    <td class="codeLine">  // PHIs or Selects would block promotion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4641</td>
    <td class="codeLine">  // PHIs or Selects would block promotion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4642</td>
    <td class="codeLine">  for (PHINode *PHI : PHIUsers)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4642</td>
    <td class="codeLine">  for (PHINode *PHI : PHIUsers)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4643</td>
    <td class="codeLine">    if (!isSafePHIToSpeculate(*PHI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4643</td>
    <td class="codeLine">    if (!isSafePHIToSpeculate(*PHI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4644</td>
    <td class="codeLine">      Promotable = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4644</td>
    <td class="codeLine">      Promotable = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4645</td>
    <td class="codeLine">      PHIUsers.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4645</td>
    <td class="codeLine">      PHIUsers.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4646</td>
    <td class="codeLine">      SelectUsers.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4646</td>
    <td class="codeLine">      SelectUsers.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4647</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4647</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4648</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4648</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4649</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4650</td>
    <td class="codeLine">  SmallVector<std::pair<SelectInst *, RewriteableMemOps>, 2></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4650</td>
    <td class="codeLine">  SmallVector<std::pair<SelectInst *, RewriteableMemOps>, 2></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4651</td>
    <td class="codeLine">      NewSelectsToRewrite;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4651</td>
    <td class="codeLine">      NewSelectsToRewrite;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4652</td>
    <td class="codeLine">  NewSelectsToRewrite.reserve(SelectUsers.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4652</td>
    <td class="codeLine">  NewSelectsToRewrite.reserve(SelectUsers.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4653</td>
    <td class="codeLine">  for (SelectInst *Sel : SelectUsers) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4653</td>
    <td class="codeLine">  for (SelectInst *Sel : SelectUsers) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4654</td>
    <td class="codeLine">    std::optional<RewriteableMemOps> Ops =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4654</td>
    <td class="codeLine">    std::optional<RewriteableMemOps> Ops =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4655</td>
    <td class="codeLine">        isSafeSelectToSpeculate(*Sel, PreserveCFG);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4655</td>
    <td class="codeLine">        isSafeSelectToSpeculate(*Sel, PreserveCFG);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4656</td>
    <td class="codeLine">    if (!Ops) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4656</td>
    <td class="codeLine">    if (!Ops) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4657</td>
    <td class="codeLine">      Promotable = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4657</td>
    <td class="codeLine">      Promotable = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4658</td>
    <td class="codeLine">      PHIUsers.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4658</td>
    <td class="codeLine">      PHIUsers.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4659</td>
    <td class="codeLine">      SelectUsers.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4659</td>
    <td class="codeLine">      SelectUsers.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4660</td>
    <td class="codeLine">      NewSelectsToRewrite.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4660</td>
    <td class="codeLine">      NewSelectsToRewrite.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4661</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4661</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4662</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4662</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4663</td>
    <td class="codeLine">    NewSelectsToRewrite.emplace_back(std::make_pair(Sel, *Ops));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4663</td>
    <td class="codeLine">    NewSelectsToRewrite.emplace_back(std::make_pair(Sel, *Ops));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4664</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4664</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4666</td>
    <td class="codeLine">  if (Promotable) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4666</td>
    <td class="codeLine">  if (Promotable) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4667</td>
    <td class="codeLine">    for (Use *U : AS.getDeadUsesIfPromotable()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4667</td>
    <td class="codeLine">    for (Use *U : AS.getDeadUsesIfPromotable()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4668</td>
    <td class="codeLine">      auto *OldInst = dyn_cast<Instruction>(U->get());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4668</td>
    <td class="codeLine">      auto *OldInst = dyn_cast<Instruction>(U->get());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4669</td>
    <td class="codeLine">      Value::dropDroppableUse(*U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4669</td>
    <td class="codeLine">      Value::dropDroppableUse(*U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4670</td>
    <td class="codeLine">      if (OldInst)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4670</td>
    <td class="codeLine">      if (OldInst)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4671</td>
    <td class="codeLine">        if (isInstructionTriviallyDead(OldInst))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4671</td>
    <td class="codeLine">        if (isInstructionTriviallyDead(OldInst))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4672</td>
    <td class="codeLine">          DeadInsts.push_back(OldInst);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4672</td>
    <td class="codeLine">          DeadInsts.push_back(OldInst);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4673</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4673</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4674</td>
    <td class="codeLine">    if (PHIUsers.empty() && SelectUsers.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4674</td>
    <td class="codeLine">    if (PHIUsers.empty() && SelectUsers.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4675</td>
    <td class="codeLine">      // Promote the alloca.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4675</td>
    <td class="codeLine">      // Promote the alloca.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4676</td>
    <td class="codeLine">      PromotableAllocas.push_back(NewAI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4676</td>
    <td class="codeLine">      PromotableAllocas.push_back(NewAI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4677</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4677</td>
    <td class="codeLine">    } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4678</td>
    <td class="codeLine">      // If we have either PHIs or Selects to speculate, add them to those</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4678</td>
    <td class="codeLine">      // If we have either PHIs or Selects to speculate, add them to those</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4679</td>
    <td class="codeLine">      // worklists and re-queue the new alloca so that we promote in on the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4679</td>
    <td class="codeLine">      // worklists and re-queue the new alloca so that we promote in on the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4680</td>
    <td class="codeLine">      // next iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4680</td>
    <td class="codeLine">      // next iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4681</td>
    <td class="codeLine">      for (PHINode *PHIUser : PHIUsers)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4681</td>
    <td class="codeLine">      for (PHINode *PHIUser : PHIUsers)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4682</td>
    <td class="codeLine">        SpeculatablePHIs.insert(PHIUser);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4682</td>
    <td class="codeLine">        SpeculatablePHIs.insert(PHIUser);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4683</td>
    <td class="codeLine">      SelectsToRewrite.reserve(SelectsToRewrite.size() +</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4683</td>
    <td class="codeLine">      SelectsToRewrite.reserve(SelectsToRewrite.size() +</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4684</td>
    <td class="codeLine">                               NewSelectsToRewrite.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4684</td>
    <td class="codeLine">                               NewSelectsToRewrite.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4685</td>
    <td class="codeLine">      for (auto &&KV : llvm::make_range(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4685</td>
    <td class="codeLine">      for (auto &&KV : llvm::make_range(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4686</td>
    <td class="codeLine">               std::make_move_iterator(NewSelectsToRewrite.begin()),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4686</td>
    <td class="codeLine">               std::make_move_iterator(NewSelectsToRewrite.begin()),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4687</td>
    <td class="codeLine">               std::make_move_iterator(NewSelectsToRewrite.end())))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4687</td>
    <td class="codeLine">               std::make_move_iterator(NewSelectsToRewrite.end())))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4688</td>
    <td class="codeLine">        SelectsToRewrite.insert(std::move(KV));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4688</td>
    <td class="codeLine">        SelectsToRewrite.insert(std::move(KV));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4689</td>
    <td class="codeLine">      Worklist.insert(NewAI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4689</td>
    <td class="codeLine">      Worklist.insert(NewAI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4690</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4690</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4691</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4691</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4692</td>
    <td class="codeLine">    // Drop any post-promotion work items if promotion didn't happen.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4692</td>
    <td class="codeLine">    // Drop any post-promotion work items if promotion didn't happen.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4693</td>
    <td class="codeLine">    while (PostPromotionWorklist.size() > PPWOldSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4693</td>
    <td class="codeLine">    while (PostPromotionWorklist.size() > PPWOldSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4694</td>
    <td class="codeLine">      PostPromotionWorklist.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4694</td>
    <td class="codeLine">      PostPromotionWorklist.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4695</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4695</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4696</td>
    <td class="codeLine">    // We couldn't promote and we didn't create a new partition, nothing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4696</td>
    <td class="codeLine">    // We couldn't promote and we didn't create a new partition, nothing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4697</td>
    <td class="codeLine">    // happened.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4697</td>
    <td class="codeLine">    // happened.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4698</td>
    <td class="codeLine">    if (NewAI == &AI)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4698</td>
    <td class="codeLine">    if (NewAI == &AI)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4699</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4699</td>
    <td class="codeLine">      return nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4700</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4701</td>
    <td class="codeLine">    // If we can't promote the alloca, iterate on it to check for new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4701</td>
    <td class="codeLine">    // If we can't promote the alloca, iterate on it to check for new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4702</td>
    <td class="codeLine">    // refinements exposed by splitting the current alloca. Don't iterate on an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4702</td>
    <td class="codeLine">    // refinements exposed by splitting the current alloca. Don't iterate on an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4703</td>
    <td class="codeLine">    // alloca which didn't actually change and didn't get promoted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4703</td>
    <td class="codeLine">    // alloca which didn't actually change and didn't get promoted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4704</td>
    <td class="codeLine">    Worklist.insert(NewAI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4704</td>
    <td class="codeLine">    Worklist.insert(NewAI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4705</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4705</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4707</td>
    <td class="codeLine">  return NewAI;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4707</td>
    <td class="codeLine">  return NewAI;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4708</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4708</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4710</td>
    <td class="codeLine">/// Walks the slices of an alloca and form partitions based on them,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4710</td>
    <td class="codeLine">/// Walks the slices of an alloca and form partitions based on them,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4711</td>
    <td class="codeLine">/// rewriting each of their uses.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4711</td>
    <td class="codeLine">/// rewriting each of their uses.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4712</td>
    <td class="codeLine">bool SROAPass::splitAlloca(AllocaInst &AI, AllocaSlices &AS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4712</td>
    <td class="codeLine">bool SROAPass::splitAlloca(AllocaInst &AI, AllocaSlices &AS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4713</td>
    <td class="codeLine">  if (AS.begin() == AS.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4713</td>
    <td class="codeLine">  if (AS.begin() == AS.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4714</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4714</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4715</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4716</td>
    <td class="codeLine">  unsigned NumPartitions = 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4716</td>
    <td class="codeLine">  unsigned NumPartitions = 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4717</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4717</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4718</td>
    <td class="codeLine">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4718</td>
    <td class="codeLine">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4720</td>
    <td class="codeLine">  // First try to pre-split loads and stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4720</td>
    <td class="codeLine">  // First try to pre-split loads and stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4721</td>
    <td class="codeLine">  Changed |= presplitLoadsAndStores(AI, AS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4721</td>
    <td class="codeLine">  Changed |= presplitLoadsAndStores(AI, AS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4723</td>
    <td class="codeLine">  // Now that we have identified any pre-splitting opportunities,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4723</td>
    <td class="codeLine">  // Now that we have identified any pre-splitting opportunities,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4724</td>
    <td class="codeLine">  // mark loads and stores unsplittable except for the following case.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4724</td>
    <td class="codeLine">  // mark loads and stores unsplittable except for the following case.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4725</td>
    <td class="codeLine">  // We leave a slice splittable if all other slices are disjoint or fully</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4725</td>
    <td class="codeLine">  // We leave a slice splittable if all other slices are disjoint or fully</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4726</td>
    <td class="codeLine">  // included in the slice, such as whole-alloca loads and stores.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4726</td>
    <td class="codeLine">  // included in the slice, such as whole-alloca loads and stores.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4727</td>
    <td class="codeLine">  // If we fail to split these during pre-splitting, we want to force them</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4727</td>
    <td class="codeLine">  // If we fail to split these during pre-splitting, we want to force them</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4728</td>
    <td class="codeLine">  // to be rewritten into a partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4728</td>
    <td class="codeLine">  // to be rewritten into a partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4729</td>
    <td class="codeLine">  bool IsSorted = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4729</td>
    <td class="codeLine">  bool IsSorted = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4730</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4731</td>
    <td class="codeLine">  uint64_t AllocaSize =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4731</td>
    <td class="codeLine">  uint64_t AllocaSize =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4732</td>
    <td class="codeLine">      DL.getTypeAllocSize(AI.getAllocatedType()).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4732</td>
    <td class="codeLine">      DL.getTypeAllocSize(AI.getAllocatedType()).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4733</td>
    <td class="codeLine">  const uint64_t MaxBitVectorSize = 1024;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4733</td>
    <td class="codeLine">  const uint64_t MaxBitVectorSize = 1024;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4734</td>
    <td class="codeLine">  if (AllocaSize <= MaxBitVectorSize) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4734</td>
    <td class="codeLine">  if (AllocaSize <= MaxBitVectorSize) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4735</td>
    <td class="codeLine">    // If a byte boundary is included in any load or store, a slice starting or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4735</td>
    <td class="codeLine">    // If a byte boundary is included in any load or store, a slice starting or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4736</td>
    <td class="codeLine">    // ending at the boundary is not splittable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4736</td>
    <td class="codeLine">    // ending at the boundary is not splittable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4737</td>
    <td class="codeLine">    SmallBitVector SplittableOffset(AllocaSize + 1, true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4737</td>
    <td class="codeLine">    SmallBitVector SplittableOffset(AllocaSize + 1, true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4738</td>
    <td class="codeLine">    for (Slice &S : AS)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4738</td>
    <td class="codeLine">    for (Slice &S : AS)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4739</td>
    <td class="codeLine">      for (unsigned O = S.beginOffset() + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4739</td>
    <td class="codeLine">      for (unsigned O = S.beginOffset() + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4740</td>
    <td class="codeLine">           O < S.endOffset() && O < AllocaSize; O++)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4740</td>
    <td class="codeLine">           O < S.endOffset() && O < AllocaSize; O++)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4741</td>
    <td class="codeLine">        SplittableOffset.reset(O);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4741</td>
    <td class="codeLine">        SplittableOffset.reset(O);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4743</td>
    <td class="codeLine">    for (Slice &S : AS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4743</td>
    <td class="codeLine">    for (Slice &S : AS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4744</td>
    <td class="codeLine">      if (!S.isSplittable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4744</td>
    <td class="codeLine">      if (!S.isSplittable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4745</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4745</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4746</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4747</td>
    <td class="codeLine">      if ((S.beginOffset() > AllocaSize || SplittableOffset[S.beginOffset()]) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4747</td>
    <td class="codeLine">      if ((S.beginOffset() > AllocaSize || SplittableOffset[S.beginOffset()]) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4748</td>
    <td class="codeLine">          (S.endOffset() > AllocaSize || SplittableOffset[S.endOffset()]))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4748</td>
    <td class="codeLine">          (S.endOffset() > AllocaSize || SplittableOffset[S.endOffset()]))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4749</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4749</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4751</td>
    <td class="codeLine">      if (isa<LoadInst>(S.getUse()->getUser()) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4751</td>
    <td class="codeLine">      if (isa<LoadInst>(S.getUse()->getUser()) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4752</td>
    <td class="codeLine">          isa<StoreInst>(S.getUse()->getUser())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4752</td>
    <td class="codeLine">          isa<StoreInst>(S.getUse()->getUser())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4753</td>
    <td class="codeLine">        S.makeUnsplittable();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4753</td>
    <td class="codeLine">        S.makeUnsplittable();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4754</td>
    <td class="codeLine">        IsSorted = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4754</td>
    <td class="codeLine">        IsSorted = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4755</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4755</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4756</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4756</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4757</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4757</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4758</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4758</td>
    <td class="codeLine">  else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4759</td>
    <td class="codeLine">    // We only allow whole-alloca splittable loads and stores</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4759</td>
    <td class="codeLine">    // We only allow whole-alloca splittable loads and stores</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4760</td>
    <td class="codeLine">    // for a large alloca to avoid creating too large BitVector.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4760</td>
    <td class="codeLine">    // for a large alloca to avoid creating too large BitVector.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4761</td>
    <td class="codeLine">    for (Slice &S : AS) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4761</td>
    <td class="codeLine">    for (Slice &S : AS) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4762</td>
    <td class="codeLine">      if (!S.isSplittable())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4762</td>
    <td class="codeLine">      if (!S.isSplittable())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4763</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4763</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4764</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4764</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4765</td>
    <td class="codeLine">      if (S.beginOffset() == 0 && S.endOffset() >= AllocaSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4765</td>
    <td class="codeLine">      if (S.beginOffset() == 0 && S.endOffset() >= AllocaSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4766</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4766</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4767</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4768</td>
    <td class="codeLine">      if (isa<LoadInst>(S.getUse()->getUser()) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4768</td>
    <td class="codeLine">      if (isa<LoadInst>(S.getUse()->getUser()) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4769</td>
    <td class="codeLine">          isa<StoreInst>(S.getUse()->getUser())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4769</td>
    <td class="codeLine">          isa<StoreInst>(S.getUse()->getUser())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4770</td>
    <td class="codeLine">        S.makeUnsplittable();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4770</td>
    <td class="codeLine">        S.makeUnsplittable();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4771</td>
    <td class="codeLine">        IsSorted = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4771</td>
    <td class="codeLine">        IsSorted = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4772</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4772</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4773</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4773</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4774</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4774</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4775</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4776</td>
    <td class="codeLine">  if (!IsSorted)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4776</td>
    <td class="codeLine">  if (!IsSorted)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4777</td>
    <td class="codeLine">    llvm::sort(AS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4777</td>
    <td class="codeLine">    llvm::sort(AS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4779</td>
    <td class="codeLine">  /// Describes the allocas introduced by rewritePartition in order to migrate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4779</td>
    <td class="codeLine">  /// Describes the allocas introduced by rewritePartition in order to migrate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4780</td>
    <td class="codeLine">  /// the debug info.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4780</td>
    <td class="codeLine">  /// the debug info.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4781</td>
    <td class="codeLine">  struct Fragment {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4781</td>
    <td class="codeLine">  struct Fragment {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4782</td>
    <td class="codeLine">    AllocaInst *Alloca;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4782</td>
    <td class="codeLine">    AllocaInst *Alloca;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4783</td>
    <td class="codeLine">    uint64_t Offset;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4783</td>
    <td class="codeLine">    uint64_t Offset;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4784</td>
    <td class="codeLine">    uint64_t Size;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4784</td>
    <td class="codeLine">    uint64_t Size;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4785</td>
    <td class="codeLine">    Fragment(AllocaInst *AI, uint64_t O, uint64_t S)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4785</td>
    <td class="codeLine">    Fragment(AllocaInst *AI, uint64_t O, uint64_t S)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4786</td>
    <td class="codeLine">      : Alloca(AI), Offset(O), Size(S) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4786</td>
    <td class="codeLine">      : Alloca(AI), Offset(O), Size(S) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4787</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4787</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4788</td>
    <td class="codeLine">  SmallVector<Fragment, 4> Fragments;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4788</td>
    <td class="codeLine">  SmallVector<Fragment, 4> Fragments;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4790</td>
    <td class="codeLine">  // Rewrite each partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4790</td>
    <td class="codeLine">  // Rewrite each partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4791</td>
    <td class="codeLine">  for (auto &P : AS.partitions()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4791</td>
    <td class="codeLine">  for (auto &P : AS.partitions()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4792</td>
    <td class="codeLine">    if (AllocaInst *NewAI = rewritePartition(AI, AS, P)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4792</td>
    <td class="codeLine">    if (AllocaInst *NewAI = rewritePartition(AI, AS, P)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4793</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4793</td>
    <td class="codeLine">      Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4794</td>
    <td class="codeLine">      if (NewAI != &AI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4794</td>
    <td class="codeLine">      if (NewAI != &AI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4795</td>
    <td class="codeLine">        uint64_t SizeOfByte = 8;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4795</td>
    <td class="codeLine">        uint64_t SizeOfByte = 8;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4796</td>
    <td class="codeLine">        uint64_t AllocaSize =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4796</td>
    <td class="codeLine">        uint64_t AllocaSize =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4797</td>
    <td class="codeLine">            DL.getTypeSizeInBits(NewAI->getAllocatedType()).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4797</td>
    <td class="codeLine">            DL.getTypeSizeInBits(NewAI->getAllocatedType()).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4798</td>
    <td class="codeLine">        // Don't include any padding.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4798</td>
    <td class="codeLine">        // Don't include any padding.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4799</td>
    <td class="codeLine">        uint64_t Size = std::min(AllocaSize, P.size() * SizeOfByte);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4799</td>
    <td class="codeLine">        uint64_t Size = std::min(AllocaSize, P.size() * SizeOfByte);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4800</td>
    <td class="codeLine">        Fragments.push_back(Fragment(NewAI, P.beginOffset() * SizeOfByte, Size));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4800</td>
    <td class="codeLine">        Fragments.push_back(Fragment(NewAI, P.beginOffset() * SizeOfByte, Size));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4801</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4801</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4802</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4802</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4803</td>
    <td class="codeLine">    ++NumPartitions;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4803</td>
    <td class="codeLine">    ++NumPartitions;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4804</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4804</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4805</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4806</td>
    <td class="codeLine">  NumAllocaPartitions += NumPartitions;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4806</td>
    <td class="codeLine">  NumAllocaPartitions += NumPartitions;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4807</td>
    <td class="codeLine">  MaxPartitionsPerAlloca.updateMax(NumPartitions);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4807</td>
    <td class="codeLine">  MaxPartitionsPerAlloca.updateMax(NumPartitions);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4808</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4809</td>
    <td class="codeLine">  // Migrate debug information from the old alloca to the new alloca(s)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4809</td>
    <td class="codeLine">  // Migrate debug information from the old alloca to the new alloca(s)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4810</td>
    <td class="codeLine">  // and the individual partitions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4810</td>
    <td class="codeLine">  // and the individual partitions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4811</td>
    <td class="codeLine">  TinyPtrVector<DbgVariableIntrinsic *> DbgVariables;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4811</td>
    <td class="codeLine">  TinyPtrVector<DbgVariableIntrinsic *> DbgVariables;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4812</td>
    <td class="codeLine">  for (auto *DbgDeclare : FindDbgDeclareUses(&AI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4812</td>
    <td class="codeLine">  for (auto *DbgDeclare : FindDbgDeclareUses(&AI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4813</td>
    <td class="codeLine">    DbgVariables.push_back(DbgDeclare);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4813</td>
    <td class="codeLine">    DbgVariables.push_back(DbgDeclare);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4814</td>
    <td class="codeLine">  for (auto *DbgAssign : at::getAssignmentMarkers(&AI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4814</td>
    <td class="codeLine">  for (auto *DbgAssign : at::getAssignmentMarkers(&AI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4815</td>
    <td class="codeLine">    DbgVariables.push_back(DbgAssign);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4815</td>
    <td class="codeLine">    DbgVariables.push_back(DbgAssign);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4816</td>
    <td class="codeLine">  for (DbgVariableIntrinsic *DbgVariable : DbgVariables) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4816</td>
    <td class="codeLine">  for (DbgVariableIntrinsic *DbgVariable : DbgVariables) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4817</td>
    <td class="codeLine">    auto *Expr = DbgVariable->getExpression();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4817</td>
    <td class="codeLine">    auto *Expr = DbgVariable->getExpression();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4818</td>
    <td class="codeLine">    DIBuilder DIB(*AI.getModule(), /*AllowUnresolved*/ false);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4818</td>
    <td class="codeLine">    DIBuilder DIB(*AI.getModule(), /*AllowUnresolved*/ false);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4819</td>
    <td class="codeLine">    uint64_t AllocaSize =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4819</td>
    <td class="codeLine">    uint64_t AllocaSize =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4820</td>
    <td class="codeLine">        DL.getTypeSizeInBits(AI.getAllocatedType()).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4820</td>
    <td class="codeLine">        DL.getTypeSizeInBits(AI.getAllocatedType()).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4821</td>
    <td class="codeLine">    for (auto Fragment : Fragments) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4821</td>
    <td class="codeLine">    for (auto Fragment : Fragments) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4822</td>
    <td class="codeLine">      // Create a fragment expression describing the new partition or reuse AI's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4822</td>
    <td class="codeLine">      // Create a fragment expression describing the new partition or reuse AI's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4823</td>
    <td class="codeLine">      // expression if there is only one partition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4823</td>
    <td class="codeLine">      // expression if there is only one partition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4824</td>
    <td class="codeLine">      auto *FragmentExpr = Expr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4824</td>
    <td class="codeLine">      auto *FragmentExpr = Expr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4825</td>
    <td class="codeLine">      if (Fragment.Size < AllocaSize || Expr->isFragment()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4825</td>
    <td class="codeLine">      if (Fragment.Size < AllocaSize || Expr->isFragment()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4826</td>
    <td class="codeLine">        // If this alloca is already a scalar replacement of a larger aggregate,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4826</td>
    <td class="codeLine">        // If this alloca is already a scalar replacement of a larger aggregate,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4827</td>
    <td class="codeLine">        // Fragment.Offset describes the offset inside the scalar.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4827</td>
    <td class="codeLine">        // Fragment.Offset describes the offset inside the scalar.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4828</td>
    <td class="codeLine">        auto ExprFragment = Expr->getFragmentInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4828</td>
    <td class="codeLine">        auto ExprFragment = Expr->getFragmentInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4829</td>
    <td class="codeLine">        uint64_t Offset = ExprFragment ? ExprFragment->OffsetInBits : 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4829</td>
    <td class="codeLine">        uint64_t Offset = ExprFragment ? ExprFragment->OffsetInBits : 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4830</td>
    <td class="codeLine">        uint64_t Start = Offset + Fragment.Offset;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4830</td>
    <td class="codeLine">        uint64_t Start = Offset + Fragment.Offset;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4831</td>
    <td class="codeLine">        uint64_t Size = Fragment.Size;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4831</td>
    <td class="codeLine">        uint64_t Size = Fragment.Size;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4832</td>
    <td class="codeLine">        if (ExprFragment) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4832</td>
    <td class="codeLine">        if (ExprFragment) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4833</td>
    <td class="codeLine">          uint64_t AbsEnd =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4833</td>
    <td class="codeLine">          uint64_t AbsEnd =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4834</td>
    <td class="codeLine">              ExprFragment->OffsetInBits + ExprFragment->SizeInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4834</td>
    <td class="codeLine">              ExprFragment->OffsetInBits + ExprFragment->SizeInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4835</td>
    <td class="codeLine">          if (Start >= AbsEnd) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4835</td>
    <td class="codeLine">          if (Start >= AbsEnd) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4836</td>
    <td class="codeLine">            // No need to describe a SROAed padding.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4836</td>
    <td class="codeLine">            // No need to describe a SROAed padding.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4837</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4837</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4838</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4838</td>
    <td class="codeLine">          }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4839</td>
    <td class="codeLine">          Size = std::min(Size, AbsEnd - Start);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4839</td>
    <td class="codeLine">          Size = std::min(Size, AbsEnd - Start);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4840</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4840</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4841</td>
    <td class="codeLine">        // The new, smaller fragment is stenciled out from the old fragment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4841</td>
    <td class="codeLine">        // The new, smaller fragment is stenciled out from the old fragment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4842</td>
    <td class="codeLine">        if (auto OrigFragment = FragmentExpr->getFragmentInfo()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4842</td>
    <td class="codeLine">        if (auto OrigFragment = FragmentExpr->getFragmentInfo()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4843</td>
    <td class="codeLine">          assert(Start >= OrigFragment->OffsetInBits &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4843</td>
    <td class="codeLine">          assert(Start >= OrigFragment->OffsetInBits &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4844</td>
    <td class="codeLine">                 "new fragment is outside of original fragment");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4844</td>
    <td class="codeLine">                 "new fragment is outside of original fragment");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4845</td>
    <td class="codeLine">          Start -= OrigFragment->OffsetInBits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4845</td>
    <td class="codeLine">          Start -= OrigFragment->OffsetInBits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4846</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4846</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4848</td>
    <td class="codeLine">        // The alloca may be larger than the variable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4848</td>
    <td class="codeLine">        // The alloca may be larger than the variable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4849</td>
    <td class="codeLine">        auto VarSize = DbgVariable->getVariable()->getSizeInBits();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4849</td>
    <td class="codeLine">        auto VarSize = DbgVariable->getVariable()->getSizeInBits();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4850</td>
    <td class="codeLine">        if (VarSize) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4850</td>
    <td class="codeLine">        if (VarSize) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4851</td>
    <td class="codeLine">          if (Size > *VarSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4851</td>
    <td class="codeLine">          if (Size > *VarSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4852</td>
    <td class="codeLine">            Size = *VarSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4852</td>
    <td class="codeLine">            Size = *VarSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4853</td>
    <td class="codeLine">          if (Size == 0 || Start + Size > *VarSize)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4853</td>
    <td class="codeLine">          if (Size == 0 || Start + Size > *VarSize)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4854</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4854</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4855</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4855</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4856</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4856</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4857</td>
    <td class="codeLine">        // Avoid creating a fragment expression that covers the entire variable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4857</td>
    <td class="codeLine">        // Avoid creating a fragment expression that covers the entire variable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4858</td>
    <td class="codeLine">        if (!VarSize || *VarSize != Size) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4858</td>
    <td class="codeLine">        if (!VarSize || *VarSize != Size) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4859</td>
    <td class="codeLine">          if (auto E =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4859</td>
    <td class="codeLine">          if (auto E =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4860</td>
    <td class="codeLine">                  DIExpression::createFragmentExpression(Expr, Start, Size))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4860</td>
    <td class="codeLine">                  DIExpression::createFragmentExpression(Expr, Start, Size))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4861</td>
    <td class="codeLine">            FragmentExpr = *E;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4861</td>
    <td class="codeLine">            FragmentExpr = *E;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4862</td>
    <td class="codeLine">          else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4862</td>
    <td class="codeLine">          else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4863</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4863</td>
    <td class="codeLine">            continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4864</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4864</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4865</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4865</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4867</td>
    <td class="codeLine">      // Remove any existing intrinsics on the new alloca describing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4867</td>
    <td class="codeLine">      // Remove any existing intrinsics on the new alloca describing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4868</td>
    <td class="codeLine">      // the variable fragment.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4868</td>
    <td class="codeLine">      // the variable fragment.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4869</td>
    <td class="codeLine">      for (DbgDeclareInst *OldDII : FindDbgDeclareUses(Fragment.Alloca)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4869</td>
    <td class="codeLine">      for (DbgDeclareInst *OldDII : FindDbgDeclareUses(Fragment.Alloca)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4870</td>
    <td class="codeLine">        auto SameVariableFragment = [](const DbgVariableIntrinsic *LHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4870</td>
    <td class="codeLine">        auto SameVariableFragment = [](const DbgVariableIntrinsic *LHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4871</td>
    <td class="codeLine">                                       const DbgVariableIntrinsic *RHS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4871</td>
    <td class="codeLine">                                       const DbgVariableIntrinsic *RHS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4872</td>
    <td class="codeLine">          return LHS->getVariable() == RHS->getVariable() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4872</td>
    <td class="codeLine">          return LHS->getVariable() == RHS->getVariable() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4873</td>
    <td class="codeLine">                 LHS->getDebugLoc()->getInlinedAt() ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4873</td>
    <td class="codeLine">                 LHS->getDebugLoc()->getInlinedAt() ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4874</td>
    <td class="codeLine">                     RHS->getDebugLoc()->getInlinedAt();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4874</td>
    <td class="codeLine">                     RHS->getDebugLoc()->getInlinedAt();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4875</td>
    <td class="codeLine">        };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4875</td>
    <td class="codeLine">        };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4876</td>
    <td class="codeLine">        if (SameVariableFragment(OldDII, DbgVariable))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4876</td>
    <td class="codeLine">        if (SameVariableFragment(OldDII, DbgVariable))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4877</td>
    <td class="codeLine">          OldDII->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4877</td>
    <td class="codeLine">          OldDII->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4878</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4878</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4879</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4880</td>
    <td class="codeLine">      if (auto *DbgAssign = dyn_cast<DbgAssignIntrinsic>(DbgVariable)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4880</td>
    <td class="codeLine">      if (auto *DbgAssign = dyn_cast<DbgAssignIntrinsic>(DbgVariable)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4881</td>
    <td class="codeLine">        if (!Fragment.Alloca->hasMetadata(LLVMContext::MD_DIAssignID)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4881</td>
    <td class="codeLine">        if (!Fragment.Alloca->hasMetadata(LLVMContext::MD_DIAssignID)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4882</td>
    <td class="codeLine">          Fragment.Alloca->setMetadata(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4882</td>
    <td class="codeLine">          Fragment.Alloca->setMetadata(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4883</td>
    <td class="codeLine">              LLVMContext::MD_DIAssignID,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4883</td>
    <td class="codeLine">              LLVMContext::MD_DIAssignID,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4884</td>
    <td class="codeLine">              DIAssignID::getDistinct(AI.getContext()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4884</td>
    <td class="codeLine">              DIAssignID::getDistinct(AI.getContext()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4885</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4885</td>
    <td class="codeLine">        }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4886</td>
    <td class="codeLine">        auto *NewAssign = DIB.insertDbgAssign(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4886</td>
    <td class="codeLine">        auto *NewAssign = DIB.insertDbgAssign(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4887</td>
    <td class="codeLine">            Fragment.Alloca, DbgAssign->getValue(), DbgAssign->getVariable(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4887</td>
    <td class="codeLine">            Fragment.Alloca, DbgAssign->getValue(), DbgAssign->getVariable(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4888</td>
    <td class="codeLine">            FragmentExpr, Fragment.Alloca, DbgAssign->getAddressExpression(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4888</td>
    <td class="codeLine">            FragmentExpr, Fragment.Alloca, DbgAssign->getAddressExpression(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4889</td>
    <td class="codeLine">            DbgAssign->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4889</td>
    <td class="codeLine">            DbgAssign->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4890</td>
    <td class="codeLine">        NewAssign->setDebugLoc(DbgAssign->getDebugLoc());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4890</td>
    <td class="codeLine">        NewAssign->setDebugLoc(DbgAssign->getDebugLoc());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4891</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "Created new assign intrinsic: " << *NewAssign</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4891</td>
    <td class="codeLine">        LLVM_DEBUG(dbgs() << "Created new assign intrinsic: " << *NewAssign</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4892</td>
    <td class="codeLine">                          << "\n");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4892</td>
    <td class="codeLine">                          << "\n");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4893</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4893</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4894</td>
    <td class="codeLine">        DIB.insertDeclare(Fragment.Alloca, DbgVariable->getVariable(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4894</td>
    <td class="codeLine">        DIB.insertDeclare(Fragment.Alloca, DbgVariable->getVariable(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4895</td>
    <td class="codeLine">                          FragmentExpr, DbgVariable->getDebugLoc(), &AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4895</td>
    <td class="codeLine">                          FragmentExpr, DbgVariable->getDebugLoc(), &AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4896</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4896</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4897</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4897</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4898</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4898</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4899</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4899</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4900</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4900</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4901</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4901</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4902</td>
    <td class="codeLine">/// Clobber a use with poison, deleting the used value if it becomes dead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4902</td>
    <td class="codeLine">/// Clobber a use with poison, deleting the used value if it becomes dead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4903</td>
    <td class="codeLine">void SROAPass::clobberUse(Use &U) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4903</td>
    <td class="codeLine">void SROAPass::clobberUse(Use &U) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4904</td>
    <td class="codeLine">  Value *OldV = U;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4904</td>
    <td class="codeLine">  Value *OldV = U;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4905</td>
    <td class="codeLine">  // Replace the use with an poison value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4905</td>
    <td class="codeLine">  // Replace the use with an poison value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4906</td>
    <td class="codeLine">  U = PoisonValue::get(OldV->getType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4906</td>
    <td class="codeLine">  U = PoisonValue::get(OldV->getType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4907</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4907</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4908</td>
    <td class="codeLine">  // Check for this making an instruction dead. We have to garbage collect</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4908</td>
    <td class="codeLine">  // Check for this making an instruction dead. We have to garbage collect</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4909</td>
    <td class="codeLine">  // all the dead instructions to ensure the uses of any alloca end up being</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4909</td>
    <td class="codeLine">  // all the dead instructions to ensure the uses of any alloca end up being</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4910</td>
    <td class="codeLine">  // minimal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4910</td>
    <td class="codeLine">  // minimal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4911</td>
    <td class="codeLine">  if (Instruction *OldI = dyn_cast<Instruction>(OldV))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4911</td>
    <td class="codeLine">  if (Instruction *OldI = dyn_cast<Instruction>(OldV))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4912</td>
    <td class="codeLine">    if (isInstructionTriviallyDead(OldI)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4912</td>
    <td class="codeLine">    if (isInstructionTriviallyDead(OldI)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4913</td>
    <td class="codeLine">      DeadInsts.push_back(OldI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4913</td>
    <td class="codeLine">      DeadInsts.push_back(OldI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4914</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4914</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4915</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4915</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4916</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4917</td>
    <td class="codeLine">/// Analyze an alloca for SROA.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4917</td>
    <td class="codeLine">/// Analyze an alloca for SROA.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4918</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4918</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4919</td>
    <td class="codeLine">/// This analyzes the alloca to ensure we can reason about it, builds</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4919</td>
    <td class="codeLine">/// This analyzes the alloca to ensure we can reason about it, builds</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4920</td>
    <td class="codeLine">/// the slices of the alloca, and then hands it off to be split and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4920</td>
    <td class="codeLine">/// the slices of the alloca, and then hands it off to be split and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4921</td>
    <td class="codeLine">/// rewritten as needed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4921</td>
    <td class="codeLine">/// rewritten as needed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4922</td>
    <td class="codeLine">std::pair<bool /*Changed*/, bool /*CFGChanged*/></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4922</td>
    <td class="codeLine">std::pair<bool /*Changed*/, bool /*CFGChanged*/></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4923</td>
    <td class="codeLine">SROAPass::runOnAlloca(AllocaInst &AI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4923</td>
    <td class="codeLine">SROAPass::runOnAlloca(AllocaInst &AI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4924</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4924</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4925</td>
    <td class="codeLine">  bool CFGChanged = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4925</td>
    <td class="codeLine">  bool CFGChanged = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4927</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "SROA alloca: " << AI << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4927</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "SROA alloca: " << AI << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4928</td>
    <td class="codeLine">  ++NumAllocasAnalyzed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4928</td>
    <td class="codeLine">  ++NumAllocasAnalyzed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4929</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4929</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4930</td>
    <td class="codeLine">  // Special case dead allocas, as they're trivial.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4930</td>
    <td class="codeLine">  // Special case dead allocas, as they're trivial.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4931</td>
    <td class="codeLine">  if (AI.use_empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4931</td>
    <td class="codeLine">  if (AI.use_empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4932</td>
    <td class="codeLine">    AI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4932</td>
    <td class="codeLine">    AI.eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4933</td>
    <td class="codeLine">    Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4933</td>
    <td class="codeLine">    Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4934</td>
    <td class="codeLine">    return {Changed, CFGChanged};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4934</td>
    <td class="codeLine">    return {Changed, CFGChanged};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4935</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4935</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4936</td>
    <td class="codeLine">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4936</td>
    <td class="codeLine">  const DataLayout &DL = AI.getModule()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4937</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4937</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4938</td>
    <td class="codeLine">  // Skip alloca forms that this analysis can't handle.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4938</td>
    <td class="codeLine">  // Skip alloca forms that this analysis can't handle.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4939</td>
    <td class="codeLine">  auto *AT = AI.getAllocatedType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4939</td>
    <td class="codeLine">  auto *AT = AI.getAllocatedType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4940</td>
    <td class="codeLine">  TypeSize Size = DL.getTypeAllocSize(AT);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4940</td>
    <td class="codeLine">  TypeSize Size = DL.getTypeAllocSize(AT);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4941</td>
    <td class="codeLine">  if (AI.isArrayAllocation() || !AT->isSized() || Size.isScalable() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4941</td>
    <td class="codeLine">  if (AI.isArrayAllocation() || !AT->isSized() || Size.isScalable() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4942</td>
    <td class="codeLine">      Size.getFixedValue() == 0)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4942</td>
    <td class="codeLine">      Size.getFixedValue() == 0)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4943</td>
    <td class="codeLine">    return {Changed, CFGChanged};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4943</td>
    <td class="codeLine">    return {Changed, CFGChanged};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4944</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4944</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4945</td>
    <td class="codeLine">  // First, split any FCA loads and stores touching this alloca to promote</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4945</td>
    <td class="codeLine">  // First, split any FCA loads and stores touching this alloca to promote</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4946</td>
    <td class="codeLine">  // better splitting and promotion opportunities.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4946</td>
    <td class="codeLine">  // better splitting and promotion opportunities.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4947</td>
    <td class="codeLine">  IRBuilderTy IRB(&AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4947</td>
    <td class="codeLine">  IRBuilderTy IRB(&AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4948</td>
    <td class="codeLine">  AggLoadStoreRewriter AggRewriter(DL, IRB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4948</td>
    <td class="codeLine">  AggLoadStoreRewriter AggRewriter(DL, IRB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4949</td>
    <td class="codeLine">  Changed |= AggRewriter.rewrite(AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4949</td>
    <td class="codeLine">  Changed |= AggRewriter.rewrite(AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4950</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4951</td>
    <td class="codeLine">  // Build the slices using a recursive instruction-visiting builder.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4951</td>
    <td class="codeLine">  // Build the slices using a recursive instruction-visiting builder.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4952</td>
    <td class="codeLine">  AllocaSlices AS(DL, AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4952</td>
    <td class="codeLine">  AllocaSlices AS(DL, AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4953</td>
    <td class="codeLine">  LLVM_DEBUG(AS.print(dbgs()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4953</td>
    <td class="codeLine">  LLVM_DEBUG(AS.print(dbgs()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4954</td>
    <td class="codeLine">  if (AS.isEscaped())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4954</td>
    <td class="codeLine">  if (AS.isEscaped())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4955</td>
    <td class="codeLine">    return {Changed, CFGChanged};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4955</td>
    <td class="codeLine">    return {Changed, CFGChanged};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4956</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4957</td>
    <td class="codeLine">  // Delete all the dead users of this alloca before splitting and rewriting it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4957</td>
    <td class="codeLine">  // Delete all the dead users of this alloca before splitting and rewriting it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4958</td>
    <td class="codeLine">  for (Instruction *DeadUser : AS.getDeadUsers()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4958</td>
    <td class="codeLine">  for (Instruction *DeadUser : AS.getDeadUsers()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4959</td>
    <td class="codeLine">    // Free up everything used by this instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4959</td>
    <td class="codeLine">    // Free up everything used by this instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4960</td>
    <td class="codeLine">    for (Use &DeadOp : DeadUser->operands())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4960</td>
    <td class="codeLine">    for (Use &DeadOp : DeadUser->operands())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4961</td>
    <td class="codeLine">      clobberUse(DeadOp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4961</td>
    <td class="codeLine">      clobberUse(DeadOp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4962</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4963</td>
    <td class="codeLine">    // Now replace the uses of this instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4963</td>
    <td class="codeLine">    // Now replace the uses of this instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4964</td>
    <td class="codeLine">    DeadUser->replaceAllUsesWith(PoisonValue::get(DeadUser->getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4964</td>
    <td class="codeLine">    DeadUser->replaceAllUsesWith(PoisonValue::get(DeadUser->getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4966</td>
    <td class="codeLine">    // And mark it for deletion.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4966</td>
    <td class="codeLine">    // And mark it for deletion.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4967</td>
    <td class="codeLine">    DeadInsts.push_back(DeadUser);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4967</td>
    <td class="codeLine">    DeadInsts.push_back(DeadUser);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4968</td>
    <td class="codeLine">    Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4968</td>
    <td class="codeLine">    Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4969</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4969</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4970</td>
    <td class="codeLine">  for (Use *DeadOp : AS.getDeadOperands()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4970</td>
    <td class="codeLine">  for (Use *DeadOp : AS.getDeadOperands()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4971</td>
    <td class="codeLine">    clobberUse(*DeadOp);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4971</td>
    <td class="codeLine">    clobberUse(*DeadOp);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4972</td>
    <td class="codeLine">    Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4972</td>
    <td class="codeLine">    Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4973</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4973</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4974</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4975</td>
    <td class="codeLine">  // No slices to split. Leave the dead alloca for a later pass to clean up.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4975</td>
    <td class="codeLine">  // No slices to split. Leave the dead alloca for a later pass to clean up.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4976</td>
    <td class="codeLine">  if (AS.begin() == AS.end())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4976</td>
    <td class="codeLine">  if (AS.begin() == AS.end())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4977</td>
    <td class="codeLine">    return {Changed, CFGChanged};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4977</td>
    <td class="codeLine">    return {Changed, CFGChanged};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4978</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4978</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4979</td>
    <td class="codeLine">  Changed |= splitAlloca(AI, AS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4979</td>
    <td class="codeLine">  Changed |= splitAlloca(AI, AS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4980</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4980</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4981</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Speculating PHIs\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4981</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Speculating PHIs\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4982</td>
    <td class="codeLine">  while (!SpeculatablePHIs.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4982</td>
    <td class="codeLine">  while (!SpeculatablePHIs.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4983</td>
    <td class="codeLine">    speculatePHINodeLoads(IRB, *SpeculatablePHIs.pop_back_val());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4983</td>
    <td class="codeLine">    speculatePHINodeLoads(IRB, *SpeculatablePHIs.pop_back_val());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4984</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4985</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Rewriting Selects\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4985</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "  Rewriting Selects\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4986</td>
    <td class="codeLine">  auto RemainingSelectsToRewrite = SelectsToRewrite.takeVector();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4986</td>
    <td class="codeLine">  auto RemainingSelectsToRewrite = SelectsToRewrite.takeVector();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4987</td>
    <td class="codeLine">  while (!RemainingSelectsToRewrite.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4987</td>
    <td class="codeLine">  while (!RemainingSelectsToRewrite.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4988</td>
    <td class="codeLine">    const auto [K, V] = RemainingSelectsToRewrite.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4988</td>
    <td class="codeLine">    const auto [K, V] = RemainingSelectsToRewrite.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4989</td>
    <td class="codeLine">    CFGChanged |=</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4989</td>
    <td class="codeLine">    CFGChanged |=</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4990</td>
    <td class="codeLine">        rewriteSelectInstMemOps(*K, V, IRB, PreserveCFG ? nullptr : DTU);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4990</td>
    <td class="codeLine">        rewriteSelectInstMemOps(*K, V, IRB, PreserveCFG ? nullptr : DTU);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4991</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4991</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4992</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4993</td>
    <td class="codeLine">  return {Changed, CFGChanged};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4993</td>
    <td class="codeLine">  return {Changed, CFGChanged};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4994</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">4994</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4995</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4995</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4996</td>
    <td class="codeLine">/// Delete the dead instructions accumulated in this run.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4996</td>
    <td class="codeLine">/// Delete the dead instructions accumulated in this run.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4997</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4997</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4998</td>
    <td class="codeLine">/// Recursively deletes the dead instructions we've accumulated. This is done</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4998</td>
    <td class="codeLine">/// Recursively deletes the dead instructions we've accumulated. This is done</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4999</td>
    <td class="codeLine">/// at the very end to maximize locality of the recursive delete and to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4999</td>
    <td class="codeLine">/// at the very end to maximize locality of the recursive delete and to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5000</td>
    <td class="codeLine">/// minimize the problems of invalidated instruction pointers as such pointers</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5000</td>
    <td class="codeLine">/// minimize the problems of invalidated instruction pointers as such pointers</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5001</td>
    <td class="codeLine">/// are used heavily in the intermediate stages of the algorithm.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5001</td>
    <td class="codeLine">/// are used heavily in the intermediate stages of the algorithm.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5002</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5002</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5003</td>
    <td class="codeLine">/// We also record the alloca instructions deleted here so that they aren't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5003</td>
    <td class="codeLine">/// We also record the alloca instructions deleted here so that they aren't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5004</td>
    <td class="codeLine">/// subsequently handed to mem2reg to promote.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5004</td>
    <td class="codeLine">/// subsequently handed to mem2reg to promote.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5005</td>
    <td class="codeLine">bool SROAPass::deleteDeadInstructions(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5005</td>
    <td class="codeLine">bool SROAPass::deleteDeadInstructions(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5006</td>
    <td class="codeLine">    SmallPtrSetImpl<AllocaInst *> &DeletedAllocas) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5006</td>
    <td class="codeLine">    SmallPtrSetImpl<AllocaInst *> &DeletedAllocas) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5007</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5007</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5008</td>
    <td class="codeLine">  while (!DeadInsts.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5008</td>
    <td class="codeLine">  while (!DeadInsts.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5009</td>
    <td class="codeLine">    Instruction *I = dyn_cast_or_null<Instruction>(DeadInsts.pop_back_val());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5009</td>
    <td class="codeLine">    Instruction *I = dyn_cast_or_null<Instruction>(DeadInsts.pop_back_val());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5010</td>
    <td class="codeLine">    if (!I)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5010</td>
    <td class="codeLine">    if (!I)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5011</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5011</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5012</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Deleting dead instruction: " << *I << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5012</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Deleting dead instruction: " << *I << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5013</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5014</td>
    <td class="codeLine">    // If the instruction is an alloca, find the possible dbg.declare connected</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5014</td>
    <td class="codeLine">    // If the instruction is an alloca, find the possible dbg.declare connected</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5015</td>
    <td class="codeLine">    // to it, and remove it too. We must do this before calling RAUW or we will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5015</td>
    <td class="codeLine">    // to it, and remove it too. We must do this before calling RAUW or we will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5016</td>
    <td class="codeLine">    // not be able to find it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5016</td>
    <td class="codeLine">    // not be able to find it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5017</td>
    <td class="codeLine">    if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5017</td>
    <td class="codeLine">    if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5018</td>
    <td class="codeLine">      DeletedAllocas.insert(AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5018</td>
    <td class="codeLine">      DeletedAllocas.insert(AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5019</td>
    <td class="codeLine">      for (DbgDeclareInst *OldDII : FindDbgDeclareUses(AI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5019</td>
    <td class="codeLine">      for (DbgDeclareInst *OldDII : FindDbgDeclareUses(AI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5020</td>
    <td class="codeLine">        OldDII->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5020</td>
    <td class="codeLine">        OldDII->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5021</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5021</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5022</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5023</td>
    <td class="codeLine">    at::deleteAssignmentMarkers(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5023</td>
    <td class="codeLine">    at::deleteAssignmentMarkers(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5024</td>
    <td class="codeLine">    I->replaceAllUsesWith(UndefValue::get(I->getType()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5024</td>
    <td class="codeLine">    I->replaceAllUsesWith(UndefValue::get(I->getType()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5025</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5026</td>
    <td class="codeLine">    for (Use &Operand : I->operands())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5026</td>
    <td class="codeLine">    for (Use &Operand : I->operands())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5027</td>
    <td class="codeLine">      if (Instruction *U = dyn_cast<Instruction>(Operand)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5027</td>
    <td class="codeLine">      if (Instruction *U = dyn_cast<Instruction>(Operand)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5028</td>
    <td class="codeLine">        // Zero out the operand and see if it becomes trivially dead.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5028</td>
    <td class="codeLine">        // Zero out the operand and see if it becomes trivially dead.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5029</td>
    <td class="codeLine">        Operand = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5029</td>
    <td class="codeLine">        Operand = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5030</td>
    <td class="codeLine">        if (isInstructionTriviallyDead(U))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5030</td>
    <td class="codeLine">        if (isInstructionTriviallyDead(U))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5031</td>
    <td class="codeLine">          DeadInsts.push_back(U);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5031</td>
    <td class="codeLine">          DeadInsts.push_back(U);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5032</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5032</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5034</td>
    <td class="codeLine">    ++NumDeleted;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5034</td>
    <td class="codeLine">    ++NumDeleted;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5035</td>
    <td class="codeLine">    I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5035</td>
    <td class="codeLine">    I->eraseFromParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5036</td>
    <td class="codeLine">    Changed = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5036</td>
    <td class="codeLine">    Changed = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5037</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5037</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5038</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5038</td>
    <td class="codeLine">  return Changed;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5039</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5039</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5040</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5040</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5041</td>
    <td class="codeLine">/// Promote the allocas, using the best available technique.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5041</td>
    <td class="codeLine">/// Promote the allocas, using the best available technique.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5042</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5042</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5043</td>
    <td class="codeLine">/// This attempts to promote whatever allocas have been identified as viable in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5043</td>
    <td class="codeLine">/// This attempts to promote whatever allocas have been identified as viable in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5044</td>
    <td class="codeLine">/// the PromotableAllocas list. If that list is empty, there is nothing to do.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5044</td>
    <td class="codeLine">/// the PromotableAllocas list. If that list is empty, there is nothing to do.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5045</td>
    <td class="codeLine">/// This function returns whether any promotion occurred.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5045</td>
    <td class="codeLine">/// This function returns whether any promotion occurred.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5046</td>
    <td class="codeLine">bool SROAPass::promoteAllocas(Function &F) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5046</td>
    <td class="codeLine">bool SROAPass::promoteAllocas(Function &F) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5047</td>
    <td class="codeLine">  if (PromotableAllocas.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5047</td>
    <td class="codeLine">  if (PromotableAllocas.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5048</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5048</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5049</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5050</td>
    <td class="codeLine">  NumPromoted += PromotableAllocas.size();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5050</td>
    <td class="codeLine">  NumPromoted += PromotableAllocas.size();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5051</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5052</td>
    <td class="codeLine">  if (SROASkipMem2Reg) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5052</td>
    <td class="codeLine">  if (SROASkipMem2Reg) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5053</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Not promoting allocas with mem2reg!\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5053</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Not promoting allocas with mem2reg!\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5054</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5054</td>
    <td class="codeLine">  } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5055</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Promoting allocas with mem2reg...\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5055</td>
    <td class="codeLine">    LLVM_DEBUG(dbgs() << "Promoting allocas with mem2reg...\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5056</td>
    <td class="codeLine">    PromoteMemToReg(PromotableAllocas, DTU->getDomTree(), AC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5056</td>
    <td class="codeLine">    PromoteMemToReg(PromotableAllocas, DTU->getDomTree(), AC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5057</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5057</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5059</td>
    <td class="codeLine">  PromotableAllocas.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5059</td>
    <td class="codeLine">  PromotableAllocas.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5060</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5060</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5061</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5061</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5062</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5062</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5063</td>
    <td class="codeLine">PreservedAnalyses SROAPass::runImpl(Function &F, DomTreeUpdater &RunDTU,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5063</td>
    <td class="codeLine">PreservedAnalyses SROAPass::runImpl(Function &F, DomTreeUpdater &RunDTU,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5064</td>
    <td class="codeLine">                                    AssumptionCache &RunAC) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5064</td>
    <td class="codeLine">                                    AssumptionCache &RunAC) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5065</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "SROA function: " << F.getName() << "\n");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5065</td>
    <td class="codeLine">  LLVM_DEBUG(dbgs() << "SROA function: " << F.getName() << "\n");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5066</td>
    <td class="codeLine">  C = &F.getContext();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5066</td>
    <td class="codeLine">  C = &F.getContext();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5067</td>
    <td class="codeLine">  DTU = &RunDTU;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5067</td>
    <td class="codeLine">  DTU = &RunDTU;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5068</td>
    <td class="codeLine">  AC = &RunAC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5068</td>
    <td class="codeLine">  AC = &RunAC;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5070</td>
    <td class="codeLine">  const DataLayout &DL = F.getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5070</td>
    <td class="codeLine">  const DataLayout &DL = F.getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5071</td>
    <td class="codeLine">  BasicBlock &EntryBB = F.getEntryBlock();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5071</td>
    <td class="codeLine">  BasicBlock &EntryBB = F.getEntryBlock();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5072</td>
    <td class="codeLine">  for (BasicBlock::iterator I = EntryBB.begin(), E = std::prev(EntryBB.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5072</td>
    <td class="codeLine">  for (BasicBlock::iterator I = EntryBB.begin(), E = std::prev(EntryBB.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5073</td>
    <td class="codeLine">       I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5073</td>
    <td class="codeLine">       I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5074</td>
    <td class="codeLine">    if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5074</td>
    <td class="codeLine">    if (AllocaInst *AI = dyn_cast<AllocaInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5075</td>
    <td class="codeLine">      if (DL.getTypeAllocSize(AI->getAllocatedType()).isScalable() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5075</td>
    <td class="codeLine">      if (DL.getTypeAllocSize(AI->getAllocatedType()).isScalable() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5076</td>
    <td class="codeLine">          isAllocaPromotable(AI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5076</td>
    <td class="codeLine">          isAllocaPromotable(AI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5077</td>
    <td class="codeLine">        PromotableAllocas.push_back(AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5077</td>
    <td class="codeLine">        PromotableAllocas.push_back(AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5078</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5078</td>
    <td class="codeLine">      else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5079</td>
    <td class="codeLine">        Worklist.insert(AI);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5079</td>
    <td class="codeLine">        Worklist.insert(AI);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5080</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5080</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5081</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5081</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5082</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5083</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5083</td>
    <td class="codeLine">  bool Changed = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5084</td>
    <td class="codeLine">  bool CFGChanged = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5084</td>
    <td class="codeLine">  bool CFGChanged = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5085</td>
    <td class="codeLine">  // A set of deleted alloca instruction pointers which should be removed from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5085</td>
    <td class="codeLine">  // A set of deleted alloca instruction pointers which should be removed from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5086</td>
    <td class="codeLine">  // the list of promotable allocas.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5086</td>
    <td class="codeLine">  // the list of promotable allocas.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5087</td>
    <td class="codeLine">  SmallPtrSet<AllocaInst *, 4> DeletedAllocas;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5087</td>
    <td class="codeLine">  SmallPtrSet<AllocaInst *, 4> DeletedAllocas;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5089</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5089</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5090</td>
    <td class="codeLine">    while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5090</td>
    <td class="codeLine">    while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5091</td>
    <td class="codeLine">      auto [IterationChanged, IterationCFGChanged] =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5091</td>
    <td class="codeLine">      auto [IterationChanged, IterationCFGChanged] =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5092</td>
    <td class="codeLine">          runOnAlloca(*Worklist.pop_back_val());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5092</td>
    <td class="codeLine">          runOnAlloca(*Worklist.pop_back_val());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5093</td>
    <td class="codeLine">      Changed |= IterationChanged;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5093</td>
    <td class="codeLine">      Changed |= IterationChanged;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5094</td>
    <td class="codeLine">      CFGChanged |= IterationCFGChanged;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5094</td>
    <td class="codeLine">      CFGChanged |= IterationCFGChanged;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5095</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5096</td>
    <td class="codeLine">      Changed |= deleteDeadInstructions(DeletedAllocas);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5096</td>
    <td class="codeLine">      Changed |= deleteDeadInstructions(DeletedAllocas);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5097</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5098</td>
    <td class="codeLine">      // Remove the deleted allocas from various lists so that we don't try to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5098</td>
    <td class="codeLine">      // Remove the deleted allocas from various lists so that we don't try to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5099</td>
    <td class="codeLine">      // continue processing them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5099</td>
    <td class="codeLine">      // continue processing them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5100</td>
    <td class="codeLine">      if (!DeletedAllocas.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5100</td>
    <td class="codeLine">      if (!DeletedAllocas.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5101</td>
    <td class="codeLine">        auto IsInSet = [&](AllocaInst *AI) { return DeletedAllocas.count(AI); };</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5101</td>
    <td class="codeLine">        auto IsInSet = [&](AllocaInst *AI) { return DeletedAllocas.count(AI); };</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5102</td>
    <td class="codeLine">        Worklist.remove_if(IsInSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5102</td>
    <td class="codeLine">        Worklist.remove_if(IsInSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5103</td>
    <td class="codeLine">        PostPromotionWorklist.remove_if(IsInSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5103</td>
    <td class="codeLine">        PostPromotionWorklist.remove_if(IsInSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5104</td>
    <td class="codeLine">        llvm::erase_if(PromotableAllocas, IsInSet);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5104</td>
    <td class="codeLine">        llvm::erase_if(PromotableAllocas, IsInSet);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5105</td>
    <td class="codeLine">        DeletedAllocas.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5105</td>
    <td class="codeLine">        DeletedAllocas.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5106</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5106</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5107</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5107</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5108</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5109</td>
    <td class="codeLine">    Changed |= promoteAllocas(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5109</td>
    <td class="codeLine">    Changed |= promoteAllocas(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5110</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5111</td>
    <td class="codeLine">    Worklist = PostPromotionWorklist;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5111</td>
    <td class="codeLine">    Worklist = PostPromotionWorklist;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5112</td>
    <td class="codeLine">    PostPromotionWorklist.clear();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5112</td>
    <td class="codeLine">    PostPromotionWorklist.clear();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5113</td>
    <td class="codeLine">  } while (!Worklist.empty());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5113</td>
    <td class="codeLine">  } while (!Worklist.empty());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5115</td>
    <td class="codeLine">  assert((!CFGChanged || Changed) && "Can not only modify the CFG.");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5115</td>
    <td class="codeLine">  assert((!CFGChanged || Changed) && "Can not only modify the CFG.");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5116</td>
    <td class="codeLine">  assert((!CFGChanged || !PreserveCFG) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5116</td>
    <td class="codeLine">  assert((!CFGChanged || !PreserveCFG) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5117</td>
    <td class="codeLine">         "Should not have modified the CFG when told to preserve it.");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5117</td>
    <td class="codeLine">         "Should not have modified the CFG when told to preserve it.");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5118</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5119</td>
    <td class="codeLine">  if (!Changed)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5119</td>
    <td class="codeLine">  if (!Changed)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5120</td>
    <td class="codeLine">    return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5120</td>
    <td class="codeLine">    return PreservedAnalyses::all();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5122</td>
    <td class="codeLine">  if (isAssignmentTrackingEnabled(*F.getParent())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5122</td>
    <td class="codeLine">  if (isAssignmentTrackingEnabled(*F.getParent())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5123</td>
    <td class="codeLine">    for (auto &BB : F)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5123</td>
    <td class="codeLine">    for (auto &BB : F)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5124</td>
    <td class="codeLine">      RemoveRedundantDbgInstrs(&BB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5124</td>
    <td class="codeLine">      RemoveRedundantDbgInstrs(&BB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5125</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5125</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5126</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5127</td>
    <td class="codeLine">  PreservedAnalyses PA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5127</td>
    <td class="codeLine">  PreservedAnalyses PA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5128</td>
    <td class="codeLine">  if (!CFGChanged)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5128</td>
    <td class="codeLine">  if (!CFGChanged)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5129</td>
    <td class="codeLine">    PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5129</td>
    <td class="codeLine">    PA.preserveSet<CFGAnalyses>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5130</td>
    <td class="codeLine">  PA.preserve<DominatorTreeAnalysis>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5130</td>
    <td class="codeLine">  PA.preserve<DominatorTreeAnalysis>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5131</td>
    <td class="codeLine">  return PA;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5131</td>
    <td class="codeLine">  return PA;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5132</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5132</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5133</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5134</td>
    <td class="codeLine">PreservedAnalyses SROAPass::runImpl(Function &F, DominatorTree &RunDT,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5134</td>
    <td class="codeLine">PreservedAnalyses SROAPass::runImpl(Function &F, DominatorTree &RunDT,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5135</td>
    <td class="codeLine">                                    AssumptionCache &RunAC) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5135</td>
    <td class="codeLine">                                    AssumptionCache &RunAC) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5136</td>
    <td class="codeLine">  DomTreeUpdater DTU(RunDT, DomTreeUpdater::UpdateStrategy::Lazy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5136</td>
    <td class="codeLine">  DomTreeUpdater DTU(RunDT, DomTreeUpdater::UpdateStrategy::Lazy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5137</td>
    <td class="codeLine">  return runImpl(F, DTU, RunAC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5137</td>
    <td class="codeLine">  return runImpl(F, DTU, RunAC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5138</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5138</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5139</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5139</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5140</td>
    <td class="codeLine">PreservedAnalyses SROAPass::run(Function &F, FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5140</td>
    <td class="codeLine">PreservedAnalyses SROAPass::run(Function &F, FunctionAnalysisManager &AM) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5141</td>
    <td class="codeLine">  DominatorTree &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5141</td>
    <td class="codeLine">  DominatorTree &DT = AM.getResult<DominatorTreeAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5142</td>
    <td class="codeLine">  AssumptionCache &AC = AM.getResult<AssumptionAnalysis>(F);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5142</td>
    <td class="codeLine">  AssumptionCache &AC = AM.getResult<AssumptionAnalysis>(F);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5143</td>
    <td class="codeLine">  return runImpl(F, DT, AC);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5143</td>
    <td class="codeLine">  return runImpl(F, DT, AC);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5144</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5144</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5146</td>
    <td class="codeLine">void SROAPass::printPipeline(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5146</td>
    <td class="codeLine">void SROAPass::printPipeline(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5147</td>
    <td class="codeLine">    raw_ostream &OS, function_ref<StringRef(StringRef)> MapClassName2PassName) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5147</td>
    <td class="codeLine">    raw_ostream &OS, function_ref<StringRef(StringRef)> MapClassName2PassName) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5148</td>
    <td class="codeLine">  static_cast<PassInfoMixin<SROAPass> *>(this)->printPipeline(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5148</td>
    <td class="codeLine">  static_cast<PassInfoMixin<SROAPass> *>(this)->printPipeline(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5149</td>
    <td class="codeLine">      OS, MapClassName2PassName);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5149</td>
    <td class="codeLine">      OS, MapClassName2PassName);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5150</td>
    <td class="codeLine">  OS << (PreserveCFG ? "<preserve-cfg>" : "<modify-cfg>");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5150</td>
    <td class="codeLine">  OS << (PreserveCFG ? "<preserve-cfg>" : "<modify-cfg>");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5151</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5151</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5152</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5153</td>
    <td class="codeLine">SROAPass::SROAPass(SROAOptions PreserveCFG_)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5153</td>
    <td class="codeLine">SROAPass::SROAPass(SROAOptions PreserveCFG_)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5154</td>
    <td class="codeLine">    : PreserveCFG(PreserveCFG_ == SROAOptions::PreserveCFG) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5154</td>
    <td class="codeLine">    : PreserveCFG(PreserveCFG_ == SROAOptions::PreserveCFG) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5155</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5156</td>
    <td class="codeLine">/// A legacy pass for the legacy pass manager that wraps the \c SROA pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5156</td>
    <td class="codeLine">/// A legacy pass for the legacy pass manager that wraps the \c SROA pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5157</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5157</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5158</td>
    <td class="codeLine">/// This is in the llvm namespace purely to allow it to be a friend of the \c</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5158</td>
    <td class="codeLine">/// This is in the llvm namespace purely to allow it to be a friend of the \c</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5159</td>
    <td class="codeLine">/// SROA pass.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5159</td>
    <td class="codeLine">/// SROA pass.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5160</td>
    <td class="codeLine">class llvm::sroa::SROALegacyPass : public FunctionPass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5160</td>
    <td class="codeLine">class llvm::sroa::SROALegacyPass : public FunctionPass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5161</td>
    <td class="codeLine">  /// The SROA implementation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5161</td>
    <td class="codeLine">  /// The SROA implementation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5162</td>
    <td class="codeLine">  SROAPass Impl;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5162</td>
    <td class="codeLine">  SROAPass Impl;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5163</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5163</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5164</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5164</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5165</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5165</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5166</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5167</td>
    <td class="codeLine">  SROALegacyPass(SROAOptions PreserveCFG = SROAOptions::PreserveCFG)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5167</td>
    <td class="codeLine">  SROALegacyPass(SROAOptions PreserveCFG = SROAOptions::PreserveCFG)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5168</td>
    <td class="codeLine">      : FunctionPass(ID), Impl(PreserveCFG) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5168</td>
    <td class="codeLine">      : FunctionPass(ID), Impl(PreserveCFG) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5169</td>
    <td class="codeLine">    initializeSROALegacyPassPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5169</td>
    <td class="codeLine">    initializeSROALegacyPassPass(*PassRegistry::getPassRegistry());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5170</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5170</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5171</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5172</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5172</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5173</td>
    <td class="codeLine">    if (skipFunction(F))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5173</td>
    <td class="codeLine">    if (skipFunction(F))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5174</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5174</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5176</td>
    <td class="codeLine">    auto PA = Impl.runImpl(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5176</td>
    <td class="codeLine">    auto PA = Impl.runImpl(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5177</td>
    <td class="codeLine">        F, getAnalysis<DominatorTreeWrapperPass>().getDomTree(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5177</td>
    <td class="codeLine">        F, getAnalysis<DominatorTreeWrapperPass>().getDomTree(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5178</td>
    <td class="codeLine">        getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5178</td>
    <td class="codeLine">        getAnalysis<AssumptionCacheTracker>().getAssumptionCache(F));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5179</td>
    <td class="codeLine">    return !PA.areAllPreserved();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5179</td>
    <td class="codeLine">    return !PA.areAllPreserved();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5180</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5182</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5182</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5183</td>
    <td class="codeLine">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5183</td>
    <td class="codeLine">    AU.addRequired<AssumptionCacheTracker>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5184</td>
    <td class="codeLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5184</td>
    <td class="codeLine">    AU.addRequired<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5185</td>
    <td class="codeLine">    AU.addPreserved<GlobalsAAWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5185</td>
    <td class="codeLine">    AU.addPreserved<GlobalsAAWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5186</td>
    <td class="codeLine">    AU.addPreserved<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5186</td>
    <td class="codeLine">    AU.addPreserved<DominatorTreeWrapperPass>();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5187</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5188</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5189</td>
    <td class="codeLine">  StringRef getPassName() const override { return "SROA"; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5189</td>
    <td class="codeLine">  StringRef getPassName() const override { return "SROA"; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5190</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5190</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5192</td>
    <td class="codeLine">char SROALegacyPass::ID = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5192</td>
    <td class="codeLine">char SROALegacyPass::ID = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5193</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5194</td>
    <td class="codeLine">FunctionPass *llvm::createSROAPass(bool PreserveCFG) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5194</td>
    <td class="codeLine">FunctionPass *llvm::createSROAPass(bool PreserveCFG) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5195</td>
    <td class="codeLine">  return new SROALegacyPass(PreserveCFG ? SROAOptions::PreserveCFG</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5195</td>
    <td class="codeLine">  return new SROALegacyPass(PreserveCFG ? SROAOptions::PreserveCFG</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5196</td>
    <td class="codeLine">                                        : SROAOptions::ModifyCFG);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">5196</td>
    <td class="codeLine">                                        : SROAOptions::ModifyCFG);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5197</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5197</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5199</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(SROALegacyPass, "sroa",</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">5199</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_BEGIN(SROALegacyPass, "sroa",</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5200</td>
    <td class="codeLine">                      "Scalar Replacement Of Aggregates", false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5200</td>
    <td class="codeLine">                      "Scalar Replacement Of Aggregates", false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5201</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">5201</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(AssumptionCacheTracker)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5202</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">5202</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_DEPENDENCY(DominatorTreeWrapperPass)</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5203</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(SROALegacyPass, "sroa", "Scalar Replacement Of Aggregates",</td>
    <td class="lineNumber">2</td>
    <td class="lineNumber">5203</td>
    <td class="codeLine coveredLine">INITIALIZE_PASS_END(SROALegacyPass, "sroa", "Scalar Replacement Of Aggregates",</td>
    <td class="lineNumber">2</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5204</td>
    <td class="codeLine">                    false, false)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5204</td>
    <td class="codeLine">                    false, false)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5205</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>