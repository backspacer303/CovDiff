<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Analysis.cpp</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/lib/CodeGen/Analysis.cpp
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===-- Analysis.cpp - CodeGen LLVM IR Analysis Utilities -----------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// This file defines several CodeGen-specific LLVM IR analysis utilities.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">#include "llvm/CodeGen/Analysis.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">#include "llvm/Analysis/ValueTracking.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="">#include "llvm/IR/DataLayout.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#include "llvm/IR/DerivedTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#include "llvm/IR/Function.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/IR/IntrinsicInst.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/IR/Module.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/Support/ErrorHandling.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/Target/TargetMachine.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">using namespace llvm;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">/// Compute the linearized index of a member in a nested aggregate/struct/array</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">/// by recursing and accumulating CurIndex as long as there are indices in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">/// index list.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="uncoveredLine">unsigned llvm::ComputeLinearIndex(Type *Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">                                  const unsigned *Indices,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">                                  const unsigned *IndicesEnd,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">                                  unsigned CurIndex) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">  // Base case: We're done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="uncoveredLine">  if (Indices && Indices == IndicesEnd)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="uncoveredLine">    return CurIndex;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">  // Given a struct type, recursively traverse the elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="uncoveredLine">  if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="uncoveredLine">    for (auto I : llvm::enumerate(STy->elements())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="uncoveredLine">      Type *ET = I.value();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="uncoveredLine">      if (Indices && *Indices == I.index())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="uncoveredLine">        return ComputeLinearIndex(ET, Indices + 1, IndicesEnd, CurIndex);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="uncoveredLine">      CurIndex = ComputeLinearIndex(ET, nullptr, nullptr, CurIndex);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="uncoveredLine">    assert(!Indices && "Unexpected out of bound");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="uncoveredLine">    return CurIndex;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">  // Given an array type, recursively traverse the elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="uncoveredLine">  else if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="uncoveredLine">    Type *EltTy = ATy->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="uncoveredLine">    unsigned NumElts = ATy->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">    // Compute the Linear offset when jumping one element of the array</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="uncoveredLine">    unsigned EltLinearOffset = ComputeLinearIndex(EltTy, nullptr, nullptr, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="uncoveredLine">    if (Indices) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="uncoveredLine">      assert(*Indices < NumElts && "Unexpected out of bound");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">      // If the indice is inside the array, compute the index to the requested</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">      // elt and recurse inside the element with the end of the indices list</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="uncoveredLine">      CurIndex += EltLinearOffset* *Indices;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="uncoveredLine">      return ComputeLinearIndex(EltTy, Indices+1, IndicesEnd, CurIndex);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="uncoveredLine">    CurIndex += EltLinearOffset*NumElts;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="uncoveredLine">    return CurIndex;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">  // We haven't found the type we're looking for, so keep searching.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="uncoveredLine">  return CurIndex + 1;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">/// ComputeValueVTs - Given an LLVM IR type, compute a sequence of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">/// EVTs that represent all the individual underlying</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">/// non-aggregate types that comprise it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">/// If Offsets is non-null, it points to a vector to be filled in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="">/// with the in-memory offsets of each of the individual values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="coveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td>30</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="">                           SmallVectorImpl<EVT> *MemVTs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">                           TypeSize StartingOffset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="">  // Given a struct type, recursively traverse the elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="coveredLine">  if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td>30</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">    // If the Offsets aren't needed, don't query the struct layout. This allows</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">    // us to support structs with scalable vectors for operations that don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="">    // need offsets.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="uncoveredLine">    const StructLayout *SL = Offsets ? DL.getStructLayout(STy) : nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="uncoveredLine">    for (StructType::element_iterator EB = STy->element_begin(),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="uncoveredLine">                                      EI = EB,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="uncoveredLine">                                      EE = STy->element_end();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="uncoveredLine">         EI != EE; ++EI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">      // Don't compute the element offset if we didn't get a StructLayout above.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="uncoveredLine">      TypeSize EltOffset = SL ? SL->getElementOffset(EI - EB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="uncoveredLine">                              : TypeSize::get(0, StartingOffset.isScalable());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="uncoveredLine">      ComputeValueVTs(TLI, DL, *EI, ValueVTs, MemVTs, Offsets,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">                      StartingOffset + EltOffset);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">  // Given an array type, recursively traverse the elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="coveredLine">  if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
    <td>30</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="uncoveredLine">    Type *EltTy = ATy->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="uncoveredLine">    TypeSize EltSize = DL.getTypeAllocSize(EltTy);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="uncoveredLine">    for (unsigned i = 0, e = ATy->getNumElements(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="uncoveredLine">      ComputeValueVTs(TLI, DL, EltTy, ValueVTs, MemVTs, Offsets,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="uncoveredLine">                      StartingOffset + i * EltSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">  // Interpret void as zero return values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="coveredLine">  if (Ty->isVoidTy())</td>
    <td>30</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">  // Base case: we can get an EVT for this LLVM IR type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="coveredLine">  ValueVTs.push_back(TLI.getValueType(DL, Ty));</td>
    <td>30</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="coveredLine">  if (MemVTs)</td>
    <td>30</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="coveredLine">    MemVTs->push_back(TLI.getMemValueType(DL, Ty));</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="coveredLine">  if (Offsets)</td>
    <td>30</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="coveredLine">    Offsets->push_back(StartingOffset);</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="coveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">                           TypeSize StartingOffset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="coveredLine">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, /*MemVTs=*/nullptr, Offsets,</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="coveredLine">                         StartingOffset);</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="coveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">                           uint64_t StartingOffset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="coveredLine">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="coveredLine">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, Offsets, Offset);</td>
    <td>12</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="uncoveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="">                           SmallVectorImpl<uint64_t> *FixedOffsets,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">                           uint64_t StartingOffset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="uncoveredLine">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="uncoveredLine">  SmallVector<TypeSize, 4> Offsets;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="uncoveredLine">  if (FixedOffsets)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="uncoveredLine">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, &Offsets, Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="uncoveredLine">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, nullptr, Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="uncoveredLine">  if (FixedOffsets)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="uncoveredLine">    for (TypeSize Offset : Offsets)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="uncoveredLine">      FixedOffsets->push_back(Offset.getKnownMinValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="uncoveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">                           SmallVectorImpl<EVT> *MemVTs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">                           uint64_t StartingOffset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="uncoveredLine">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="uncoveredLine">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, Offsets, Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="coveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">                           SmallVectorImpl<EVT> *MemVTs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">                           SmallVectorImpl<uint64_t> *FixedOffsets,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">                           uint64_t StartingOffset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="coveredLine">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="coveredLine">  SmallVector<TypeSize, 4> Offsets;</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="coveredLine">  if (FixedOffsets)</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="coveredLine">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, &Offsets, Offset);</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">  else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="uncoveredLine">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, nullptr, Offset);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="coveredLine">  if (FixedOffsets)</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="coveredLine">    for (TypeSize Offset : Offsets)</td>
    <td>36</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="coveredLine">      FixedOffsets->push_back(Offset.getKnownMinValue());</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="coveredLine">}</td>
    <td>18</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="uncoveredLine">void llvm::computeValueLLTs(const DataLayout &DL, Type &Ty,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">                            SmallVectorImpl<LLT> &ValueTys,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">                            SmallVectorImpl<uint64_t> *Offsets,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">                            uint64_t StartingOffset) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="">  // Given a struct type, recursively traverse the elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="uncoveredLine">  if (StructType *STy = dyn_cast<StructType>(&Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">    // If the Offsets aren't needed, don't query the struct layout. This allows</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">    // us to support structs with scalable vectors for operations that don't</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="">    // need offsets.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="uncoveredLine">    const StructLayout *SL = Offsets ? DL.getStructLayout(STy) : nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="uncoveredLine">    for (unsigned I = 0, E = STy->getNumElements(); I != E; ++I) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="uncoveredLine">      uint64_t EltOffset = SL ? SL->getElementOffset(I) : 0;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="uncoveredLine">      computeValueLLTs(DL, *STy->getElementType(I), ValueTys, Offsets,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">                       StartingOffset + EltOffset);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">  // Given an array type, recursively traverse the elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="uncoveredLine">  if (ArrayType *ATy = dyn_cast<ArrayType>(&Ty)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="uncoveredLine">    Type *EltTy = ATy->getElementType();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="uncoveredLine">    uint64_t EltSize = DL.getTypeAllocSize(EltTy).getFixedValue();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="uncoveredLine">    for (unsigned i = 0, e = ATy->getNumElements(); i != e; ++i)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="uncoveredLine">      computeValueLLTs(DL, *EltTy, ValueTys, Offsets,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="uncoveredLine">                       StartingOffset + i * EltSize);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">  // Interpret void as zero return values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="uncoveredLine">  if (Ty.isVoidTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="uncoveredLine">    return;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">  // Base case: we can get an LLT for this LLVM IR type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="uncoveredLine">  ValueTys.push_back(getLLTForType(Ty, DL));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="uncoveredLine">  if (Offsets != nullptr)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="uncoveredLine">    Offsets->push_back(StartingOffset * 8);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="">/// ExtractTypeInfo - Returns the type info, possibly bitcast, encoded in V.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="uncoveredLine">GlobalValue *llvm::ExtractTypeInfo(Value *V) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="uncoveredLine">  V = V->stripPointerCasts();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="uncoveredLine">  GlobalValue *GV = dyn_cast<GlobalValue>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="uncoveredLine">  GlobalVariable *Var = dyn_cast<GlobalVariable>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="uncoveredLine">  if (Var && Var->getName() == "llvm.eh.catch.all.value") {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="uncoveredLine">    assert(Var->hasInitializer() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">           "The EH catch-all value must have an initializer");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="uncoveredLine">    Value *Init = Var->getInitializer();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="uncoveredLine">    GV = dyn_cast<GlobalValue>(Init);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="uncoveredLine">    if (!GV) V = cast<ConstantPointerNull>(Init);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="uncoveredLine">  assert((GV || isa<ConstantPointerNull>(V)) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">         "TypeInfo must be a global variable or NULL");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="uncoveredLine">  return GV;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">/// getFCmpCondCode - Return the ISD condition code corresponding to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">/// the given LLVM IR floating-point condition code.  This includes</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="">/// consideration of global floating-point math flags.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="uncoveredLine">ISD::CondCode llvm::getFCmpCondCode(FCmpInst::Predicate Pred) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="uncoveredLine">  switch (Pred) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_FALSE: return ISD::SETFALSE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_OEQ:   return ISD::SETOEQ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_OGT:   return ISD::SETOGT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_OGE:   return ISD::SETOGE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_OLT:   return ISD::SETOLT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_OLE:   return ISD::SETOLE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_ONE:   return ISD::SETONE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_ORD:   return ISD::SETO;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_UNO:   return ISD::SETUO;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_UEQ:   return ISD::SETUEQ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_UGT:   return ISD::SETUGT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_UGE:   return ISD::SETUGE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_ULT:   return ISD::SETULT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_ULE:   return ISD::SETULE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_UNE:   return ISD::SETUNE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">  case FCmpInst::FCMP_TRUE:  return ISD::SETTRUE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">  default: llvm_unreachable("Invalid FCmp predicate opcode!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="uncoveredLine">ISD::CondCode llvm::getFCmpCodeWithoutNaN(ISD::CondCode CC) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="uncoveredLine">  switch (CC) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="uncoveredLine">    case ISD::SETOEQ: case ISD::SETUEQ: return ISD::SETEQ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="uncoveredLine">    case ISD::SETONE: case ISD::SETUNE: return ISD::SETNE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="uncoveredLine">    case ISD::SETOLT: case ISD::SETULT: return ISD::SETLT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="uncoveredLine">    case ISD::SETOLE: case ISD::SETULE: return ISD::SETLE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="uncoveredLine">    case ISD::SETOGT: case ISD::SETUGT: return ISD::SETGT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="uncoveredLine">    case ISD::SETOGE: case ISD::SETUGE: return ISD::SETGE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="uncoveredLine">    default: return CC;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="coveredLine">ISD::CondCode llvm::getICmpCondCode(ICmpInst::Predicate Pred) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="coveredLine">  switch (Pred) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="uncoveredLine">  case ICmpInst::ICMP_EQ:  return ISD::SETEQ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="uncoveredLine">  case ICmpInst::ICMP_NE:  return ISD::SETNE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="uncoveredLine">  case ICmpInst::ICMP_SLE: return ISD::SETLE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="uncoveredLine">  case ICmpInst::ICMP_ULE: return ISD::SETULE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="uncoveredLine">  case ICmpInst::ICMP_SGE: return ISD::SETGE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="uncoveredLine">  case ICmpInst::ICMP_UGE: return ISD::SETUGE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="uncoveredLine">  case ICmpInst::ICMP_SLT: return ISD::SETLT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="uncoveredLine">  case ICmpInst::ICMP_ULT: return ISD::SETULT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="coveredLine">  case ICmpInst::ICMP_SGT: return ISD::SETGT;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="uncoveredLine">  case ICmpInst::ICMP_UGT: return ISD::SETUGT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="uncoveredLine">    llvm_unreachable("Invalid ICmp predicate opcode!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="uncoveredLine">ICmpInst::Predicate llvm::getICmpCondCode(ISD::CondCode Pred) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="uncoveredLine">  switch (Pred) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="uncoveredLine">  case ISD::SETEQ:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="uncoveredLine">    return ICmpInst::ICMP_EQ;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="uncoveredLine">  case ISD::SETNE:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="uncoveredLine">    return ICmpInst::ICMP_NE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="uncoveredLine">  case ISD::SETLE:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="uncoveredLine">    return ICmpInst::ICMP_SLE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="uncoveredLine">  case ISD::SETULE:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="uncoveredLine">    return ICmpInst::ICMP_ULE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="uncoveredLine">  case ISD::SETGE:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="uncoveredLine">    return ICmpInst::ICMP_SGE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="uncoveredLine">  case ISD::SETUGE:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="uncoveredLine">    return ICmpInst::ICMP_UGE;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="uncoveredLine">  case ISD::SETLT:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="uncoveredLine">    return ICmpInst::ICMP_SLT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="uncoveredLine">  case ISD::SETULT:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">    return ICmpInst::ICMP_ULT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="uncoveredLine">  case ISD::SETGT:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="uncoveredLine">    return ICmpInst::ICMP_SGT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="uncoveredLine">  case ISD::SETUGT:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="uncoveredLine">    return ICmpInst::ICMP_UGT;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="uncoveredLine">  default:</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="uncoveredLine">    llvm_unreachable("Invalid ISD integer condition code!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="uncoveredLine">static bool isNoopBitcast(Type *T1, Type *T2,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">                          const TargetLoweringBase& TLI) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="uncoveredLine">  return T1 == T2 || (T1->isPointerTy() && T2->isPointerTy()) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="uncoveredLine">         (isa<VectorType>(T1) && isa<VectorType>(T2) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="uncoveredLine">          TLI.isTypeLegal(EVT::getEVT(T1)) && TLI.isTypeLegal(EVT::getEVT(T2)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">/// Look through operations that will be free to find the earliest source of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">/// this value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">/// @param ValLoc If V has aggregate type, we will be interested in a particular</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">/// scalar component. This records its address; the reverse of this list gives a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">/// sequence of indices appropriate for an extractvalue to locate the important</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">/// value. This value is updated during the function and on exit will indicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">/// similar information for the Value returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">/// @param DataBits If this function looks through truncate instructions, this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">/// will record the smallest size attained.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="uncoveredLine">static const Value *getNoopInput(const Value *V,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">                                 SmallVectorImpl<unsigned> &ValLoc,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">                                 unsigned &DataBits,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">                                 const TargetLoweringBase &TLI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">                                 const DataLayout &DL) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">  while (true) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">    // Try to look through V1; if V1 is not an instruction, it can't be looked</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">    // through.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="uncoveredLine">    const Instruction *I = dyn_cast<Instruction>(V);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="uncoveredLine">    if (!I || I->getNumOperands() == 0) return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="uncoveredLine">    const Value *NoopInput = nullptr;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="uncoveredLine">    Value *Op = I->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="uncoveredLine">    if (isa<BitCastInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">      // Look through truly no-op bitcasts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="uncoveredLine">      if (isNoopBitcast(Op->getType(), I->getType(), TLI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="uncoveredLine">        NoopInput = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="uncoveredLine">    } else if (isa<GetElementPtrInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="">      // Look through getelementptr</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="uncoveredLine">      if (cast<GetElementPtrInst>(I)->hasAllZeroIndices())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="uncoveredLine">        NoopInput = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="uncoveredLine">    } else if (isa<IntToPtrInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">      // Look through inttoptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="">      // Make sure this isn't a truncating or extending cast.  We could</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="">      // support this eventually, but don't bother for now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="uncoveredLine">      if (!isa<VectorType>(I->getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">          DL.getPointerSizeInBits() ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="uncoveredLine">              cast<IntegerType>(Op->getType())->getBitWidth())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="uncoveredLine">        NoopInput = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="uncoveredLine">    } else if (isa<PtrToIntInst>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">      // Look through ptrtoint.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">      // Make sure this isn't a truncating or extending cast.  We could</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">      // support this eventually, but don't bother for now.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="uncoveredLine">      if (!isa<VectorType>(I->getType()) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="uncoveredLine">          DL.getPointerSizeInBits() ==</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="uncoveredLine">              cast<IntegerType>(I->getType())->getBitWidth())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="uncoveredLine">        NoopInput = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="uncoveredLine">    } else if (isa<TruncInst>(I) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="uncoveredLine">               TLI.allowTruncateForTailCall(Op->getType(), I->getType())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="uncoveredLine">      DataBits =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">          std::min((uint64_t)DataBits,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">                   I->getType()->getPrimitiveSizeInBits().getFixedValue());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="uncoveredLine">      NoopInput = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="uncoveredLine">    } else if (auto *CB = dyn_cast<CallBase>(I)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="uncoveredLine">      const Value *ReturnedOp = CB->getReturnedArgOperand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="uncoveredLine">      if (ReturnedOp && isNoopBitcast(ReturnedOp->getType(), I->getType(), TLI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="uncoveredLine">        NoopInput = ReturnedOp;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="uncoveredLine">    } else if (const InsertValueInst *IVI = dyn_cast<InsertValueInst>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="">      // Value may come from either the aggregate or the scalar</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="uncoveredLine">      ArrayRef<unsigned> InsertLoc = IVI->getIndices();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="uncoveredLine">      if (ValLoc.size() >= InsertLoc.size() &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="uncoveredLine">          std::equal(InsertLoc.begin(), InsertLoc.end(), ValLoc.rbegin())) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">        // The type being inserted is a nested sub-type of the aggregate; we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">        // have to remove those initial indices to get the location we're</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="">        // interested in for the operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="uncoveredLine">        ValLoc.resize(ValLoc.size() - InsertLoc.size());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="uncoveredLine">        NoopInput = IVI->getInsertedValueOperand();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">      } else {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">        // The struct we're inserting into has the value we're interested in, no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">        // change of address.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="uncoveredLine">        NoopInput = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">      }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="uncoveredLine">    } else if (const ExtractValueInst *EVI = dyn_cast<ExtractValueInst>(V)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="">      // The part we're interested in will inevitably be some sub-section of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">      // previous aggregate. Combine the two paths to obtain the true address of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">      // our element.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="uncoveredLine">      ArrayRef<unsigned> ExtractLoc = EVI->getIndices();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="uncoveredLine">      ValLoc.append(ExtractLoc.rbegin(), ExtractLoc.rend());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="uncoveredLine">      NoopInput = Op;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">    // Terminate if we couldn't find anything to look through.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">    if (!NoopInput)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">      return V;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="uncoveredLine">    V = NoopInput;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">/// Return true if this scalar return value only has bits discarded on its path</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">/// from the "tail call" to the "ret". This includes the obvious noop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">/// instructions handled by getNoopInput above as well as free truncations (or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">/// extensions prior to the call).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="uncoveredLine">static bool slotOnlyDiscardsData(const Value *RetVal, const Value *CallVal,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">                                 SmallVectorImpl<unsigned> &RetIndices,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">                                 SmallVectorImpl<unsigned> &CallIndices,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">                                 bool AllowDifferingSizes,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="">                                 const TargetLoweringBase &TLI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">                                 const DataLayout &DL) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="">  // Trace the sub-value needed by the return value as far back up the graph as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">  // possible, in the hope that it will intersect with the value produced by the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">  // call. In the simple case with no "returned" attribute, the hope is actually</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="">  // that we end up back at the tail call instruction itself.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="uncoveredLine">  unsigned BitsRequired = UINT_MAX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="uncoveredLine">  RetVal = getNoopInput(RetVal, RetIndices, BitsRequired, TLI, DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="">  // If this slot in the value returned is undef, it doesn't matter what the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="">  // call puts there, it'll be fine.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="uncoveredLine">  if (isa<UndefValue>(RetVal))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">  // Now do a similar search up through the graph to find where the value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">  // actually returned by the "tail call" comes from. In the simple case without</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">  // a "returned" attribute, the search will be blocked immediately and the loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="">  // a Noop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="uncoveredLine">  unsigned BitsProvided = UINT_MAX;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="uncoveredLine">  CallVal = getNoopInput(CallVal, CallIndices, BitsProvided, TLI, DL);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="">  // There's no hope if we can't actually trace them to (the same part of!) the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="">  // same value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="uncoveredLine">  if (CallVal != RetVal || CallIndices != RetIndices)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">  // However, intervening truncates may have made the call non-tail. Make sure</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="">  // all the bits that are needed by the "ret" have been provided by the "tail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">  // call". FIXME: with sufficiently cunning bit-tracking, we could look through</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">  // extensions too.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="uncoveredLine">  if (BitsProvided < BitsRequired ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="uncoveredLine">      (!AllowDifferingSizes && BitsProvided != BitsRequired))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">/// For an aggregate type, determine whether a given index is within bounds or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">/// not.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="uncoveredLine">static bool indexReallyValid(Type *T, unsigned Idx) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="uncoveredLine">  if (ArrayType *AT = dyn_cast<ArrayType>(T))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="uncoveredLine">    return Idx < AT->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="uncoveredLine">  return Idx < cast<StructType>(T)->getNumElements();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">/// Move the given iterators to the next leaf type in depth first traversal.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="">/// Performs a depth-first traversal of the type as specified by its arguments,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">/// stopping at the next leaf node (which may be a legitimate scalar type or an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">/// empty struct or array).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">/// @param SubTypes List of the partial components making up the type from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="">/// outermost to innermost non-empty aggregate. The element currently</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">/// represented is SubTypes.back()->getTypeAtIndex(Path.back() - 1).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">/// @param Path Set of extractvalue indices leading from the outermost type</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="">/// (SubTypes[0]) to the leaf node currently represented.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">/// @returns true if a new type was found, false otherwise. Calling this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="">/// function again on a finished iterator will repeatedly return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">/// false. SubTypes.back()->getTypeAtIndex(Path.back()) is either an empty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">/// aggregate or a non-aggregate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="uncoveredLine">static bool advanceToNextLeafType(SmallVectorImpl<Type *> &SubTypes,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">                                  SmallVectorImpl<unsigned> &Path) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="">  // First march back up the tree until we can successfully increment one of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">  // coordinates in Path.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="uncoveredLine">  while (!Path.empty() && !indexReallyValid(SubTypes.back(), Path.back() + 1)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="uncoveredLine">    Path.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="uncoveredLine">    SubTypes.pop_back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="">  // If we reached the top, then the iterator is done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="uncoveredLine">  if (Path.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">  // We know there's *some* valid leaf now, so march back down the tree picking</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">  // out the left-most element at each node.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="uncoveredLine">  ++Path.back();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">  Type *DeeperType =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="uncoveredLine">      ExtractValueInst::getIndexedType(SubTypes.back(), Path.back());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="uncoveredLine">  while (DeeperType->isAggregateType()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="uncoveredLine">    if (!indexReallyValid(DeeperType, 0))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="uncoveredLine">    SubTypes.push_back(DeeperType);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="uncoveredLine">    Path.push_back(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="uncoveredLine">    DeeperType = ExtractValueInst::getIndexedType(DeeperType, 0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="">/// Find the first non-empty, scalar-like type in Next and setup the iterator</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">/// components.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">/// Assuming Next is an aggregate of some kind, this function will traverse the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">/// tree from left to right (i.e. depth-first) looking for the first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">/// non-aggregate type which will play a role in function return.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">/// For example, if Next was {[0 x i64], {{}, i32, {}}, i32} then we would setup</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">/// Path as [1, 1] and SubTypes as [Next, {{}, i32, {}}] to represent the first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">/// i32 in that type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="uncoveredLine">static bool firstRealType(Type *Next, SmallVectorImpl<Type *> &SubTypes,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">                          SmallVectorImpl<unsigned> &Path) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">  // First initialise the iterator components to the first "leaf" node</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="">  // (i.e. node with no valid sub-type at any index, so {} does count as a leaf</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="">  // despite nominally being an aggregate).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="uncoveredLine">  while (Type *FirstInner = ExtractValueInst::getIndexedType(Next, 0)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="uncoveredLine">    SubTypes.push_back(Next);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="uncoveredLine">    Path.push_back(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="uncoveredLine">    Next = FirstInner;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">  // If there's no Path now, Next was originally scalar already (or empty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">  // leaf). We're done.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="uncoveredLine">  if (Path.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">  // Otherwise, use normal iteration to keep looking through the tree until we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">  // find a non-aggregate type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="uncoveredLine">  while (ExtractValueInst::getIndexedType(SubTypes.back(), Path.back())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="uncoveredLine">             ->isAggregateType()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="uncoveredLine">    if (!advanceToNextLeafType(SubTypes, Path))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">/// Set the iterator data-structures to the next non-empty, non-aggregate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">/// subtype.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="uncoveredLine">static bool nextRealType(SmallVectorImpl<Type *> &SubTypes,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">                         SmallVectorImpl<unsigned> &Path) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">  do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="uncoveredLine">    if (!advanceToNextLeafType(SubTypes, Path))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="uncoveredLine">    assert(!Path.empty() && "found a leaf but didn't set the path?");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="uncoveredLine">  } while (ExtractValueInst::getIndexedType(SubTypes.back(), Path.back())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="uncoveredLine">               ->isAggregateType());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">/// Test if the given instruction is in a position to be optimized</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">/// with a tail-call. This roughly means that it's in a block with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">/// a return and there's nothing that needs to be scheduled</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">/// between it and the return.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">/// This function only tests target-independent requirements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="uncoveredLine">bool llvm::isInTailCallPosition(const CallBase &Call, const TargetMachine &TM) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="uncoveredLine">  const BasicBlock *ExitBB = Call.getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="uncoveredLine">  const Instruction *Term = ExitBB->getTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="uncoveredLine">  const ReturnInst *Ret = dyn_cast<ReturnInst>(Term);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="">  // The block must end in a return statement or unreachable.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">  // FIXME: Decline tailcall if it's not guaranteed and if the block ends in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="">  // an unreachable, for now. The way tailcall optimization is currently</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">  // implemented means it will add an epilogue followed by a jump. That is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="">  // not profitable. Also, if the callee is a special function (e.g.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">  // longjmp on x86), it can end up causing miscompilation that has not</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">  // been fully understood.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="uncoveredLine">  if (!Ret && ((!TM.Options.GuaranteedTailCallOpt &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="uncoveredLine">                Call.getCallingConv() != CallingConv::Tail &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="uncoveredLine">                Call.getCallingConv() != CallingConv::SwiftTail) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="uncoveredLine">               !isa<UnreachableInst>(Term)))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">  // If I will have a chain, make sure no other instruction that will have a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="">  // chain interposes between I and the return.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">  // Check for all calls including speculatable functions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="uncoveredLine">  for (BasicBlock::const_iterator BBI = std::prev(ExitBB->end(), 2);; --BBI) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="uncoveredLine">    if (&*BBI == &Call)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="uncoveredLine">      break;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="">    // Debug info intrinsics do not get in the way of tail call optimization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">    // Pseudo probe intrinsics do not block tail call optimization either.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="uncoveredLine">    if (BBI->isDebugOrPseudoInst())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="">    // A lifetime end, assume or noalias.decl intrinsic should not stop tail</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="">    // call optimization.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="uncoveredLine">    if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(BBI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="uncoveredLine">      if (II->getIntrinsicID() == Intrinsic::lifetime_end ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="uncoveredLine">          II->getIntrinsicID() == Intrinsic::assume ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">          II->getIntrinsicID() == Intrinsic::experimental_noalias_scope_decl)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">        continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="uncoveredLine">    if (BBI->mayHaveSideEffects() || BBI->mayReadFromMemory() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="uncoveredLine">        !isSafeToSpeculativelyExecute(&*BBI))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="uncoveredLine">  const Function *F = ExitBB->getParent();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="uncoveredLine">  return returnTypeIsEligibleForTailCall(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="uncoveredLine">      F, &Call, Ret, *TM.getSubtargetImpl(*F)->getTargetLowering());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="uncoveredLine">bool llvm::attributesPermitTailCall(const Function *F, const Instruction *I,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="">                                    const ReturnInst *Ret,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="">                                    const TargetLoweringBase &TLI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="">                                    bool *AllowDifferingSizes) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">  // ADS may be null, so don't write to it directly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">  bool DummyADS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="uncoveredLine">  bool &ADS = AllowDifferingSizes ? *AllowDifferingSizes : DummyADS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="uncoveredLine">  ADS = true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="uncoveredLine">  AttrBuilder CallerAttrs(F->getContext(), F->getAttributes().getRetAttrs());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="">  AttrBuilder CalleeAttrs(F->getContext(),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="uncoveredLine">                          cast<CallInst>(I)->getAttributes().getRetAttrs());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">  // Following attributes are completely benign as far as calling convention</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">  // goes, they shouldn't affect whether the call is a tail call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="uncoveredLine">  for (const auto &Attr : {Attribute::Alignment, Attribute::Dereferenceable,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">                           Attribute::DereferenceableOrNull, Attribute::NoAlias,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="uncoveredLine">                           Attribute::NonNull, Attribute::NoUndef}) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="uncoveredLine">    CallerAttrs.removeAttribute(Attr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="uncoveredLine">    CalleeAttrs.removeAttribute(Attr);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="uncoveredLine">  if (CallerAttrs.contains(Attribute::ZExt)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="uncoveredLine">    if (!CalleeAttrs.contains(Attribute::ZExt))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="uncoveredLine">    ADS = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="uncoveredLine">    CallerAttrs.removeAttribute(Attribute::ZExt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="uncoveredLine">    CalleeAttrs.removeAttribute(Attribute::ZExt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="uncoveredLine">  } else if (CallerAttrs.contains(Attribute::SExt)) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="uncoveredLine">    if (!CalleeAttrs.contains(Attribute::SExt))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="uncoveredLine">    ADS = false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="uncoveredLine">    CallerAttrs.removeAttribute(Attribute::SExt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="uncoveredLine">    CalleeAttrs.removeAttribute(Attribute::SExt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="">  // Drop sext and zext return attributes if the result is not used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">  // This enables tail calls for code like:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="">  // define void @caller() {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">  // entry:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="">  //   %unused_result = tail call zeroext i1 @callee()</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">  //   br label %retlabel</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">  // retlabel:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">  //   ret void</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="">  // }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="uncoveredLine">  if (I->use_empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="uncoveredLine">    CalleeAttrs.removeAttribute(Attribute::SExt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="uncoveredLine">    CalleeAttrs.removeAttribute(Attribute::ZExt);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">  // If they're still different, there's some facet we don't understand</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">  // (currently only "inreg", but in future who knows). It may be OK but the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="">  // only safe option is to reject the tail call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="uncoveredLine">  return CallerAttrs == CalleeAttrs;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">/// Check whether B is a bitcast of a pointer type to another pointer type,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">/// which is equal to A.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="uncoveredLine">static bool isPointerBitcastEqualTo(const Value *A, const Value *B) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="uncoveredLine">  assert(A && B && "Expected non-null inputs!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="uncoveredLine">  auto *BitCastIn = dyn_cast<BitCastInst>(B);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="uncoveredLine">  if (!BitCastIn)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="uncoveredLine">  if (!A->getType()->isPointerTy() || !B->getType()->isPointerTy())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="uncoveredLine">  return A == BitCastIn->getOperand(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="uncoveredLine">bool llvm::returnTypeIsEligibleForTailCall(const Function *F,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">                                           const Instruction *I,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="">                                           const ReturnInst *Ret,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">                                           const TargetLoweringBase &TLI) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">  // If the block ends with a void return or unreachable, it doesn't matter</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">  // what the call's return type is.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="uncoveredLine">  if (!Ret || Ret->getNumOperands() == 0) return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">  // If the return value is undef, it doesn't matter what the call's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="">  // return type is.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="uncoveredLine">  if (isa<UndefValue>(Ret->getOperand(0))) return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="">  // Make sure the attributes attached to each return are compatible.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="">  bool AllowDifferingSizes;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="uncoveredLine">  if (!attributesPermitTailCall(F, I, Ret, TLI, &AllowDifferingSizes))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="uncoveredLine">    return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="uncoveredLine">  const Value *RetVal = Ret->getOperand(0), *CallVal = I;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">  // Intrinsic like llvm.memcpy has no return value, but the expanded</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">  // libcall may or may not have return value. On most platforms, it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">  // will be expanded as memcpy in libc, which returns the first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">  // argument. On other platforms like arm-none-eabi, memcpy may be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="">  // expanded as library call without return value, like __aeabi_memcpy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="uncoveredLine">  const CallInst *Call = cast<CallInst>(I);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="uncoveredLine">  if (Function *F = Call->getCalledFunction()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="uncoveredLine">    Intrinsic::ID IID = F->getIntrinsicID();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="uncoveredLine">    if (((IID == Intrinsic::memcpy &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="uncoveredLine">          TLI.getLibcallName(RTLIB::MEMCPY) == StringRef("memcpy")) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="uncoveredLine">         (IID == Intrinsic::memmove &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="uncoveredLine">          TLI.getLibcallName(RTLIB::MEMMOVE) == StringRef("memmove")) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="uncoveredLine">         (IID == Intrinsic::memset &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="uncoveredLine">          TLI.getLibcallName(RTLIB::MEMSET) == StringRef("memset"))) &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="uncoveredLine">        (RetVal == Call->getArgOperand(0) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="uncoveredLine">         isPointerBitcastEqualTo(RetVal, Call->getArgOperand(0))))</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="uncoveredLine">      return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="uncoveredLine">  SmallVector<unsigned, 4> RetPath, CallPath;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="uncoveredLine">  SmallVector<Type *, 4> RetSubTypes, CallSubTypes;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="uncoveredLine">  bool RetEmpty = !firstRealType(RetVal->getType(), RetSubTypes, RetPath);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="uncoveredLine">  bool CallEmpty = !firstRealType(CallVal->getType(), CallSubTypes, CallPath);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">  // Nothing's actually returned, it doesn't matter what the callee put there</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="">  // it's a valid tail call.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="uncoveredLine">  if (RetEmpty)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="uncoveredLine">    return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="">  // Iterate pairwise through each of the value types making up the tail call</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">  // and the corresponding return. For each one we want to know whether it's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="">  // essentially going directly from the tail call to the ret, via operations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="">  // that end up not generating any code.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">  //</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">  // We allow a certain amount of covariance here. For example it's permitted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">  // for the tail call to define more bits than the ret actually cares about</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="">  // (e.g. via a truncate).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">  do {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="uncoveredLine">    if (CallEmpty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">      // We've exhausted the values produced by the tail call instruction, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">      // rest are essentially undef. The type doesn't really matter, but we need</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="">      // *something*.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">      Type *SlotType =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="uncoveredLine">          ExtractValueInst::getIndexedType(RetSubTypes.back(), RetPath.back());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="uncoveredLine">      CallVal = UndefValue::get(SlotType);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="">    // The manipulations performed when we're looking through an insertvalue or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">    // an extractvalue would happen at the front of the RetPath list, so since</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">    // we have to copy it anyway it's more efficient to create a reversed copy.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="uncoveredLine">    SmallVector<unsigned, 4> TmpRetPath(llvm::reverse(RetPath));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="uncoveredLine">    SmallVector<unsigned, 4> TmpCallPath(llvm::reverse(CallPath));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">    // Finally, we can check whether the value produced by the tail call at this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">    // index is compatible with the value we return.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="uncoveredLine">    if (!slotOnlyDiscardsData(RetVal, CallVal, TmpRetPath, TmpCallPath,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="">                              AllowDifferingSizes, TLI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="">                              F->getParent()->getDataLayout()))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="uncoveredLine">      return false;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="uncoveredLine">    CallEmpty  = !nextRealType(CallSubTypes, CallPath);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="uncoveredLine">  } while(nextRealType(RetSubTypes, RetPath));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="uncoveredLine">  return true;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="uncoveredLine">static void collectEHScopeMembers(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">    DenseMap<const MachineBasicBlock *, int> &EHScopeMembership, int EHScope,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">    const MachineBasicBlock *MBB) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="uncoveredLine">  SmallVector<const MachineBasicBlock *, 16> Worklist = {MBB};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="uncoveredLine">  while (!Worklist.empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="uncoveredLine">    const MachineBasicBlock *Visiting = Worklist.pop_back_val();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">    // Don't follow blocks which start new scopes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="uncoveredLine">    if (Visiting->isEHPad() && Visiting != MBB)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">    // Add this MBB to our scope.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="uncoveredLine">    auto P = EHScopeMembership.insert(std::make_pair(Visiting, EHScope));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">    // Don't revisit blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="uncoveredLine">    if (!P.second) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="uncoveredLine">      assert(P.first->second == EHScope && "MBB is part of two scopes!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">    // Returns are boundaries where scope transfer can occur, don't follow</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="">    // successors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="uncoveredLine">    if (Visiting->isEHScopeReturnBlock())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="uncoveredLine">    append_range(Worklist, Visiting->successors());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">DenseMap<const MachineBasicBlock *, int></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="coveredLine">llvm::getEHScopeMembership(const MachineFunction &MF) {</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="coveredLine">  DenseMap<const MachineBasicBlock *, int> EHScopeMembership;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">  // We don't have anything to do if there aren't any EH pads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="coveredLine">  if (!MF.hasEHScopes())</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="coveredLine">    return EHScopeMembership;</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="uncoveredLine">  int EntryBBNumber = MF.front().getNumber();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="uncoveredLine">  bool IsSEH = isAsynchronousEHPersonality(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="uncoveredLine">      classifyEHPersonality(MF.getFunction().getPersonalityFn()));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="uncoveredLine">  const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="uncoveredLine">  SmallVector<const MachineBasicBlock *, 16> EHScopeBlocks;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="uncoveredLine">  SmallVector<const MachineBasicBlock *, 16> UnreachableBlocks;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="uncoveredLine">  SmallVector<const MachineBasicBlock *, 16> SEHCatchPads;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="uncoveredLine">  SmallVector<std::pair<const MachineBasicBlock *, int>, 16> CatchRetSuccessors;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="uncoveredLine">  for (const MachineBasicBlock &MBB : MF) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="uncoveredLine">    if (MBB.isEHScopeEntry()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="uncoveredLine">      EHScopeBlocks.push_back(&MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="uncoveredLine">    } else if (IsSEH && MBB.isEHPad()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="uncoveredLine">      SEHCatchPads.push_back(&MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="uncoveredLine">    } else if (MBB.pred_empty()) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="uncoveredLine">      UnreachableBlocks.push_back(&MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="uncoveredLine">    MachineBasicBlock::const_iterator MBBI = MBB.getFirstTerminator();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">    // CatchPads are not scopes for SEH so do not consider CatchRet to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">    // transfer control to another scope.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="uncoveredLine">    if (MBBI == MBB.end() || MBBI->getOpcode() != TII->getCatchReturnOpcode())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="uncoveredLine">      continue;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">    // FIXME: SEH CatchPads are not necessarily in the parent function:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="">    // they could be inside a finally block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="uncoveredLine">    const MachineBasicBlock *Successor = MBBI->getOperand(0).getMBB();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="uncoveredLine">    const MachineBasicBlock *SuccessorColor = MBBI->getOperand(1).getMBB();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="uncoveredLine">    CatchRetSuccessors.push_back(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="uncoveredLine">        {Successor, IsSEH ? EntryBBNumber : SuccessorColor->getNumber()});</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="">  // We don't have anything to do if there aren't any EH pads.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="uncoveredLine">  if (EHScopeBlocks.empty())</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="uncoveredLine">    return EHScopeMembership;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="">  // Identify all the basic blocks reachable from the function entry.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="uncoveredLine">  collectEHScopeMembers(EHScopeMembership, EntryBBNumber, &MF.front());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">  // All blocks not part of a scope are in the parent function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="uncoveredLine">  for (const MachineBasicBlock *MBB : UnreachableBlocks)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="uncoveredLine">    collectEHScopeMembers(EHScopeMembership, EntryBBNumber, MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">  // Next, identify all the blocks inside the scopes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="uncoveredLine">  for (const MachineBasicBlock *MBB : EHScopeBlocks)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="uncoveredLine">    collectEHScopeMembers(EHScopeMembership, MBB->getNumber(), MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">  // SEH CatchPads aren't really scopes, handle them separately.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="uncoveredLine">  for (const MachineBasicBlock *MBB : SEHCatchPads)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="uncoveredLine">    collectEHScopeMembers(EHScopeMembership, EntryBBNumber, MBB);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">  // Finally, identify all the targets of a catchret.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="uncoveredLine">  for (std::pair<const MachineBasicBlock *, int> CatchRetPair :</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="uncoveredLine">       CatchRetSuccessors)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="uncoveredLine">    collectEHScopeMembers(EHScopeMembership, CatchRetPair.second,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="">                          CatchRetPair.first);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="uncoveredLine">  return EHScopeMembership;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="uncoveredLine">}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18ComputeLinearIndexEPNS_4TypeEPKjS3_j</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ComputeValueVTsERKNS_14TargetLoweringERKNS_10DataLayoutEPNS_4TypeERNS_15SmallVectorImplINS_3EVTEEEPSA_PNS8_INS_8TypeSizeEEESD_</td>
    <td class="numberOfCalls">30</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ComputeValueVTsERKNS_14TargetLoweringERKNS_10DataLayoutEPNS_4TypeERNS_15SmallVectorImplINS_3EVTEEEPNS8_INS_8TypeSizeEEESC_</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ComputeValueVTsERKNS_14TargetLoweringERKNS_10DataLayoutEPNS_4TypeERNS_15SmallVectorImplINS_3EVTEEEPNS8_INS_8TypeSizeEEEm</td>
    <td class="numberOfCalls">12</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ComputeValueVTsERKNS_14TargetLoweringERKNS_10DataLayoutEPNS_4TypeERNS_15SmallVectorImplINS_3EVTEEEPNS8_ImEEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ComputeValueVTsERKNS_14TargetLoweringERKNS_10DataLayoutEPNS_4TypeERNS_15SmallVectorImplINS_3EVTEEEPSA_PNS8_INS_8TypeSizeEEEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ComputeValueVTsERKNS_14TargetLoweringERKNS_10DataLayoutEPNS_4TypeERNS_15SmallVectorImplINS_3EVTEEEPSA_PNS8_ImEEm</td>
    <td class="numberOfCalls">18</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm16computeValueLLTsERKNS_10DataLayoutERNS_4TypeERNS_15SmallVectorImplINS_3LLTEEEPNS5_ImEEm</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ExtractTypeInfoEPNS_5ValueE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15getFCmpCondCodeENS_7CmpInst9PredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm21getFCmpCodeWithoutNaNENS_3ISD8CondCodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15getICmpCondCodeENS_7CmpInst9PredicateE</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15getICmpCondCodeENS_3ISD8CondCodeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL13isNoopBitcastPN4llvm4TypeES1_RKNS_18TargetLoweringBaseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL12getNoopInputPKN4llvm5ValueERNS_15SmallVectorImplIjEERjRKNS_18TargetLoweringBaseERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL20slotOnlyDiscardsDataPKN4llvm5ValueES2_RNS_15SmallVectorImplIjEES5_bRKNS_18TargetLoweringBaseERKNS_10DataLayoutE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL16indexReallyValidPN4llvm4TypeEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL21advanceToNextLeafTypeRN4llvm15SmallVectorImplIPNS_4TypeEEERNS0_IjEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL13firstRealTypePN4llvm4TypeERNS_15SmallVectorImplIS1_EERNS2_IjEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL12nextRealTypeRN4llvm15SmallVectorImplIPNS_4TypeEEERNS0_IjEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20isInTailCallPositionERKNS_8CallBaseERKNS_13TargetMachineE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm24attributesPermitTailCallEPKNS_8FunctionEPKNS_11InstructionEPKNS_10ReturnInstERKNS_18TargetLoweringBaseEPb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL23isPointerBitcastEqualToPKN4llvm5ValueES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm31returnTypeIsEligibleForTailCallEPKNS_8FunctionEPKNS_11InstructionEPKNS_10ReturnInstERKNS_18TargetLoweringBaseE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZL21collectEHScopeMembersRN4llvm8DenseMapIPKNS_17MachineBasicBlockEiNS_12DenseMapInfoIS3_vEENS_6detail12DenseMapPairIS3_iEEEEiS3_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20getEHScopeMembershipERKNS_15MachineFunctionE</td>
    <td class="numberOfCalls">2</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- Analysis.cpp - CodeGen LLVM IR Analysis Utilities -----------------===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===-- Analysis.cpp - CodeGen LLVM IR Analysis Utilities -----------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// This file defines several CodeGen-specific LLVM IR analysis utilities.</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// This file defines several CodeGen-specific LLVM IR analysis utilities.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
    <td class="lineNumber">10</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">11</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline"></td>
    <td class="lineNumber">12</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">#include "llvm/CodeGen/Analysis.h"</td>
    <td class="lineNumber">13</td>
    <td class="codeline">#include "llvm/CodeGen/Analysis.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">14</td>
    <td class="codeline">#include "llvm/Analysis/ValueTracking.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">15</td>
    <td class="codeline">#include "llvm/CodeGen/MachineFunction.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
    <td class="lineNumber">16</td>
    <td class="codeline">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td class="lineNumber">17</td>
    <td class="codeline">#include "llvm/CodeGen/TargetLowering.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">18</td>
    <td class="codeline">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">19</td>
    <td class="codeline">#include "llvm/IR/DataLayout.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#include "llvm/IR/DerivedTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#include "llvm/IR/Function.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">22</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/IR/IntrinsicInst.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/IR/Module.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/Support/ErrorHandling.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/Target/TargetMachine.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline"></td>
    <td class="lineNumber">27</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">using namespace llvm;</td>
    <td class="lineNumber">28</td>
    <td class="codeline">using namespace llvm;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline"></td>
    <td class="lineNumber">29</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">/// Compute the linearized index of a member in a nested aggregate/struct/array</td>
    <td class="lineNumber">30</td>
    <td class="codeline">/// Compute the linearized index of a member in a nested aggregate/struct/array</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">/// by recursing and accumulating CurIndex as long as there are indices in the</td>
    <td class="lineNumber">31</td>
    <td class="codeline">/// by recursing and accumulating CurIndex as long as there are indices in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">/// index list.</td>
    <td class="lineNumber">32</td>
    <td class="codeline">/// index list.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">unsigned llvm::ComputeLinearIndex(Type *Ty,</td>
    <td class="lineNumber">33</td>
    <td class="codeline">unsigned llvm::ComputeLinearIndex(Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">                                  const unsigned *Indices,</td>
    <td class="lineNumber">34</td>
    <td class="codeline">                                  const unsigned *Indices,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">                                  const unsigned *IndicesEnd,</td>
    <td class="lineNumber">35</td>
    <td class="codeline">                                  const unsigned *IndicesEnd,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">                                  unsigned CurIndex) {</td>
    <td class="lineNumber">36</td>
    <td class="codeline">                                  unsigned CurIndex) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">  // Base case: We're done.</td>
    <td class="lineNumber">37</td>
    <td class="codeline">  // Base case: We're done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">  if (Indices && Indices == IndicesEnd)</td>
    <td class="lineNumber">38</td>
    <td class="codeline">  if (Indices && Indices == IndicesEnd)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">    return CurIndex;</td>
    <td class="lineNumber">39</td>
    <td class="codeline">    return CurIndex;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline"></td>
    <td class="lineNumber">40</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">  // Given a struct type, recursively traverse the elements.</td>
    <td class="lineNumber">41</td>
    <td class="codeline">  // Given a struct type, recursively traverse the elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">  if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td class="lineNumber">42</td>
    <td class="codeline">  if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">    for (auto I : llvm::enumerate(STy->elements())) {</td>
    <td class="lineNumber">43</td>
    <td class="codeline">    for (auto I : llvm::enumerate(STy->elements())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline">      Type *ET = I.value();</td>
    <td class="lineNumber">44</td>
    <td class="codeline">      Type *ET = I.value();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">      if (Indices && *Indices == I.index())</td>
    <td class="lineNumber">45</td>
    <td class="codeline">      if (Indices && *Indices == I.index())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline">        return ComputeLinearIndex(ET, Indices + 1, IndicesEnd, CurIndex);</td>
    <td class="lineNumber">46</td>
    <td class="codeline">        return ComputeLinearIndex(ET, Indices + 1, IndicesEnd, CurIndex);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">      CurIndex = ComputeLinearIndex(ET, nullptr, nullptr, CurIndex);</td>
    <td class="lineNumber">47</td>
    <td class="codeline">      CurIndex = ComputeLinearIndex(ET, nullptr, nullptr, CurIndex);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">48</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">    assert(!Indices && "Unexpected out of bound");</td>
    <td class="lineNumber">49</td>
    <td class="codeline">    assert(!Indices && "Unexpected out of bound");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">    return CurIndex;</td>
    <td class="lineNumber">50</td>
    <td class="codeline">    return CurIndex;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">51</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">  // Given an array type, recursively traverse the elements.</td>
    <td class="lineNumber">52</td>
    <td class="codeline">  // Given an array type, recursively traverse the elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">  else if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">53</td>
    <td class="codeline">  else if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">    Type *EltTy = ATy->getElementType();</td>
    <td class="lineNumber">54</td>
    <td class="codeline">    Type *EltTy = ATy->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">    unsigned NumElts = ATy->getNumElements();</td>
    <td class="lineNumber">55</td>
    <td class="codeline">    unsigned NumElts = ATy->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">    // Compute the Linear offset when jumping one element of the array</td>
    <td class="lineNumber">56</td>
    <td class="codeline">    // Compute the Linear offset when jumping one element of the array</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">    unsigned EltLinearOffset = ComputeLinearIndex(EltTy, nullptr, nullptr, 0);</td>
    <td class="lineNumber">57</td>
    <td class="codeline">    unsigned EltLinearOffset = ComputeLinearIndex(EltTy, nullptr, nullptr, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">    if (Indices) {</td>
    <td class="lineNumber">58</td>
    <td class="codeline">    if (Indices) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">      assert(*Indices < NumElts && "Unexpected out of bound");</td>
    <td class="lineNumber">59</td>
    <td class="codeline">      assert(*Indices < NumElts && "Unexpected out of bound");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">      // If the indice is inside the array, compute the index to the requested</td>
    <td class="lineNumber">60</td>
    <td class="codeline">      // If the indice is inside the array, compute the index to the requested</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">      // elt and recurse inside the element with the end of the indices list</td>
    <td class="lineNumber">61</td>
    <td class="codeline">      // elt and recurse inside the element with the end of the indices list</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">      CurIndex += EltLinearOffset* *Indices;</td>
    <td class="lineNumber">62</td>
    <td class="codeline">      CurIndex += EltLinearOffset* *Indices;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">      return ComputeLinearIndex(EltTy, Indices+1, IndicesEnd, CurIndex);</td>
    <td class="lineNumber">63</td>
    <td class="codeline">      return ComputeLinearIndex(EltTy, Indices+1, IndicesEnd, CurIndex);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">64</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">    CurIndex += EltLinearOffset*NumElts;</td>
    <td class="lineNumber">65</td>
    <td class="codeline">    CurIndex += EltLinearOffset*NumElts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">    return CurIndex;</td>
    <td class="lineNumber">66</td>
    <td class="codeline">    return CurIndex;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">67</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">  // We haven't found the type we're looking for, so keep searching.</td>
    <td class="lineNumber">68</td>
    <td class="codeline">  // We haven't found the type we're looking for, so keep searching.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline">  return CurIndex + 1;</td>
    <td class="lineNumber">69</td>
    <td class="codeline">  return CurIndex + 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">}</td>
    <td class="lineNumber">70</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">/// ComputeValueVTs - Given an LLVM IR type, compute a sequence of</td>
    <td class="lineNumber">72</td>
    <td class="codeline">/// ComputeValueVTs - Given an LLVM IR type, compute a sequence of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">/// EVTs that represent all the individual underlying</td>
    <td class="lineNumber">73</td>
    <td class="codeline">/// EVTs that represent all the individual underlying</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">/// non-aggregate types that comprise it.</td>
    <td class="lineNumber">74</td>
    <td class="codeline">/// non-aggregate types that comprise it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">///</td>
    <td class="lineNumber">75</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">/// If Offsets is non-null, it points to a vector to be filled in</td>
    <td class="lineNumber">76</td>
    <td class="codeline">/// If Offsets is non-null, it points to a vector to be filled in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline">/// with the in-memory offsets of each of the individual values.</td>
    <td class="lineNumber">77</td>
    <td class="codeline">/// with the in-memory offsets of each of the individual values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">///</td>
    <td class="lineNumber">78</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">79</td>
    <td class="codeline">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">80</td>
    <td class="codeline">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline">                           SmallVectorImpl<EVT> *MemVTs,</td>
    <td class="lineNumber">81</td>
    <td class="codeline">                           SmallVectorImpl<EVT> *MemVTs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td class="lineNumber">82</td>
    <td class="codeline">                           SmallVectorImpl<TypeSize> *Offsets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">                           TypeSize StartingOffset) {</td>
    <td class="lineNumber">83</td>
    <td class="codeline">                           TypeSize StartingOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline">  // Given a struct type, recursively traverse the elements.</td>
    <td class="lineNumber">84</td>
    <td class="codeline">  // Given a struct type, recursively traverse the elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">  if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td class="lineNumber">85</td>
    <td class="codeline">  if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">    // If the Offsets aren't needed, don't query the struct layout. This allows</td>
    <td class="lineNumber">86</td>
    <td class="codeline">    // If the Offsets aren't needed, don't query the struct layout. This allows</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">    // us to support structs with scalable vectors for operations that don't</td>
    <td class="lineNumber">87</td>
    <td class="codeline">    // us to support structs with scalable vectors for operations that don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline">    // need offsets.</td>
    <td class="lineNumber">88</td>
    <td class="codeline">    // need offsets.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">    const StructLayout *SL = Offsets ? DL.getStructLayout(STy) : nullptr;</td>
    <td class="lineNumber">89</td>
    <td class="codeline">    const StructLayout *SL = Offsets ? DL.getStructLayout(STy) : nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">    for (StructType::element_iterator EB = STy->element_begin(),</td>
    <td class="lineNumber">90</td>
    <td class="codeline">    for (StructType::element_iterator EB = STy->element_begin(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">                                      EI = EB,</td>
    <td class="lineNumber">91</td>
    <td class="codeline">                                      EI = EB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline">                                      EE = STy->element_end();</td>
    <td class="lineNumber">92</td>
    <td class="codeline">                                      EE = STy->element_end();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">         EI != EE; ++EI) {</td>
    <td class="lineNumber">93</td>
    <td class="codeline">         EI != EE; ++EI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">      // Don't compute the element offset if we didn't get a StructLayout above.</td>
    <td class="lineNumber">94</td>
    <td class="codeline">      // Don't compute the element offset if we didn't get a StructLayout above.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">      TypeSize EltOffset = SL ? SL->getElementOffset(EI - EB)</td>
    <td class="lineNumber">95</td>
    <td class="codeline">      TypeSize EltOffset = SL ? SL->getElementOffset(EI - EB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">                              : TypeSize::get(0, StartingOffset.isScalable());</td>
    <td class="lineNumber">96</td>
    <td class="codeline">                              : TypeSize::get(0, StartingOffset.isScalable());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">      ComputeValueVTs(TLI, DL, *EI, ValueVTs, MemVTs, Offsets,</td>
    <td class="lineNumber">97</td>
    <td class="codeline">      ComputeValueVTs(TLI, DL, *EI, ValueVTs, MemVTs, Offsets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">                      StartingOffset + EltOffset);</td>
    <td class="lineNumber">98</td>
    <td class="codeline">                      StartingOffset + EltOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">99</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">100</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">101</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  // Given an array type, recursively traverse the elements.</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  // Given an array type, recursively traverse the elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">  if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">103</td>
    <td class="codeline">  if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">    Type *EltTy = ATy->getElementType();</td>
    <td class="lineNumber">104</td>
    <td class="codeline">    Type *EltTy = ATy->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">    TypeSize EltSize = DL.getTypeAllocSize(EltTy);</td>
    <td class="lineNumber">105</td>
    <td class="codeline">    TypeSize EltSize = DL.getTypeAllocSize(EltTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">    for (unsigned i = 0, e = ATy->getNumElements(); i != e; ++i)</td>
    <td class="lineNumber">106</td>
    <td class="codeline">    for (unsigned i = 0, e = ATy->getNumElements(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">      ComputeValueVTs(TLI, DL, EltTy, ValueVTs, MemVTs, Offsets,</td>
    <td class="lineNumber">107</td>
    <td class="codeline">      ComputeValueVTs(TLI, DL, EltTy, ValueVTs, MemVTs, Offsets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">                      StartingOffset + i * EltSize);</td>
    <td class="lineNumber">108</td>
    <td class="codeline">                      StartingOffset + i * EltSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">109</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">  // Interpret void as zero return values.</td>
    <td class="lineNumber">111</td>
    <td class="codeline">  // Interpret void as zero return values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">  if (Ty->isVoidTy())</td>
    <td class="lineNumber">112</td>
    <td class="codeline">  if (Ty->isVoidTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">113</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">  // Base case: we can get an EVT for this LLVM IR type.</td>
    <td class="lineNumber">114</td>
    <td class="codeline">  // Base case: we can get an EVT for this LLVM IR type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">  ValueVTs.push_back(TLI.getValueType(DL, Ty));</td>
    <td class="lineNumber">115</td>
    <td class="codeline">  ValueVTs.push_back(TLI.getValueType(DL, Ty));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">  if (MemVTs)</td>
    <td class="lineNumber">116</td>
    <td class="codeline">  if (MemVTs)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">    MemVTs->push_back(TLI.getMemValueType(DL, Ty));</td>
    <td class="lineNumber">117</td>
    <td class="codeline">    MemVTs->push_back(TLI.getMemValueType(DL, Ty));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  if (Offsets)</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  if (Offsets)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">    Offsets->push_back(StartingOffset);</td>
    <td class="lineNumber">119</td>
    <td class="codeline">    Offsets->push_back(StartingOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">}</td>
    <td class="lineNumber">120</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
    <td class="lineNumber">121</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">122</td>
    <td class="codeline">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">123</td>
    <td class="codeline">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td class="lineNumber">124</td>
    <td class="codeline">                           SmallVectorImpl<TypeSize> *Offsets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">                           TypeSize StartingOffset) {</td>
    <td class="lineNumber">125</td>
    <td class="codeline">                           TypeSize StartingOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, /*MemVTs=*/nullptr, Offsets,</td>
    <td class="lineNumber">126</td>
    <td class="codeline">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, /*MemVTs=*/nullptr, Offsets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">                         StartingOffset);</td>
    <td class="lineNumber">127</td>
    <td class="codeline">                         StartingOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">}</td>
    <td class="lineNumber">128</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline"></td>
    <td class="lineNumber">129</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">130</td>
    <td class="codeline">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">131</td>
    <td class="codeline">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td class="lineNumber">132</td>
    <td class="codeline">                           SmallVectorImpl<TypeSize> *Offsets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">                           uint64_t StartingOffset) {</td>
    <td class="lineNumber">133</td>
    <td class="codeline">                           uint64_t StartingOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td class="lineNumber">134</td>
    <td class="codeline">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, Offsets, Offset);</td>
    <td class="lineNumber">135</td>
    <td class="codeline">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, Offsets, Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">}</td>
    <td class="lineNumber">136</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">138</td>
    <td class="codeline">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">139</td>
    <td class="codeline">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">                           SmallVectorImpl<uint64_t> *FixedOffsets,</td>
    <td class="lineNumber">140</td>
    <td class="codeline">                           SmallVectorImpl<uint64_t> *FixedOffsets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">                           uint64_t StartingOffset) {</td>
    <td class="lineNumber">141</td>
    <td class="codeline">                           uint64_t StartingOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td class="lineNumber">142</td>
    <td class="codeline">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline">  SmallVector<TypeSize, 4> Offsets;</td>
    <td class="lineNumber">143</td>
    <td class="codeline">  SmallVector<TypeSize, 4> Offsets;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  if (FixedOffsets)</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  if (FixedOffsets)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, &Offsets, Offset);</td>
    <td class="lineNumber">145</td>
    <td class="codeline">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, &Offsets, Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">146</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, nullptr, Offset);</td>
    <td class="lineNumber">147</td>
    <td class="codeline">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, nullptr, Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline"></td>
    <td class="lineNumber">148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">  if (FixedOffsets)</td>
    <td class="lineNumber">149</td>
    <td class="codeline">  if (FixedOffsets)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">    for (TypeSize Offset : Offsets)</td>
    <td class="lineNumber">150</td>
    <td class="codeline">    for (TypeSize Offset : Offsets)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline">      FixedOffsets->push_back(Offset.getKnownMinValue());</td>
    <td class="lineNumber">151</td>
    <td class="codeline">      FixedOffsets->push_back(Offset.getKnownMinValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">}</td>
    <td class="lineNumber">152</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
    <td class="lineNumber">153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">154</td>
    <td class="codeline">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">155</td>
    <td class="codeline">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">                           SmallVectorImpl<EVT> *MemVTs,</td>
    <td class="lineNumber">156</td>
    <td class="codeline">                           SmallVectorImpl<EVT> *MemVTs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td class="lineNumber">157</td>
    <td class="codeline">                           SmallVectorImpl<TypeSize> *Offsets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">                           uint64_t StartingOffset) {</td>
    <td class="lineNumber">158</td>
    <td class="codeline">                           uint64_t StartingOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td class="lineNumber">159</td>
    <td class="codeline">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, Offsets, Offset);</td>
    <td class="lineNumber">160</td>
    <td class="codeline">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, Offsets, Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">}</td>
    <td class="lineNumber">161</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
    <td class="lineNumber">162</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">163</td>
    <td class="codeline">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">164</td>
    <td class="codeline">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">                           SmallVectorImpl<EVT> *MemVTs,</td>
    <td class="lineNumber">165</td>
    <td class="codeline">                           SmallVectorImpl<EVT> *MemVTs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">                           SmallVectorImpl<uint64_t> *FixedOffsets,</td>
    <td class="lineNumber">166</td>
    <td class="codeline">                           SmallVectorImpl<uint64_t> *FixedOffsets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">                           uint64_t StartingOffset) {</td>
    <td class="lineNumber">167</td>
    <td class="codeline">                           uint64_t StartingOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td class="lineNumber">168</td>
    <td class="codeline">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  SmallVector<TypeSize, 4> Offsets;</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  SmallVector<TypeSize, 4> Offsets;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  if (FixedOffsets)</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  if (FixedOffsets)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, &Offsets, Offset);</td>
    <td class="lineNumber">171</td>
    <td class="codeline">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, &Offsets, Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  else</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, nullptr, Offset);</td>
    <td class="lineNumber">173</td>
    <td class="codeline">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, nullptr, Offset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline"></td>
    <td class="lineNumber">174</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">  if (FixedOffsets)</td>
    <td class="lineNumber">175</td>
    <td class="codeline">  if (FixedOffsets)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline">    for (TypeSize Offset : Offsets)</td>
    <td class="lineNumber">176</td>
    <td class="codeline">    for (TypeSize Offset : Offsets)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">      FixedOffsets->push_back(Offset.getKnownMinValue());</td>
    <td class="lineNumber">177</td>
    <td class="codeline">      FixedOffsets->push_back(Offset.getKnownMinValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">}</td>
    <td class="lineNumber">178</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline"></td>
    <td class="lineNumber">179</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline">void llvm::computeValueLLTs(const DataLayout &DL, Type &Ty,</td>
    <td class="lineNumber">180</td>
    <td class="codeline">void llvm::computeValueLLTs(const DataLayout &DL, Type &Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">                            SmallVectorImpl<LLT> &ValueTys,</td>
    <td class="lineNumber">181</td>
    <td class="codeline">                            SmallVectorImpl<LLT> &ValueTys,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">                            SmallVectorImpl<uint64_t> *Offsets,</td>
    <td class="lineNumber">182</td>
    <td class="codeline">                            SmallVectorImpl<uint64_t> *Offsets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">                            uint64_t StartingOffset) {</td>
    <td class="lineNumber">183</td>
    <td class="codeline">                            uint64_t StartingOffset) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline">  // Given a struct type, recursively traverse the elements.</td>
    <td class="lineNumber">184</td>
    <td class="codeline">  // Given a struct type, recursively traverse the elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">  if (StructType *STy = dyn_cast<StructType>(&Ty)) {</td>
    <td class="lineNumber">185</td>
    <td class="codeline">  if (StructType *STy = dyn_cast<StructType>(&Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">    // If the Offsets aren't needed, don't query the struct layout. This allows</td>
    <td class="lineNumber">186</td>
    <td class="codeline">    // If the Offsets aren't needed, don't query the struct layout. This allows</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">    // us to support structs with scalable vectors for operations that don't</td>
    <td class="lineNumber">187</td>
    <td class="codeline">    // us to support structs with scalable vectors for operations that don't</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">    // need offsets.</td>
    <td class="lineNumber">188</td>
    <td class="codeline">    // need offsets.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline">    const StructLayout *SL = Offsets ? DL.getStructLayout(STy) : nullptr;</td>
    <td class="lineNumber">189</td>
    <td class="codeline">    const StructLayout *SL = Offsets ? DL.getStructLayout(STy) : nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">    for (unsigned I = 0, E = STy->getNumElements(); I != E; ++I) {</td>
    <td class="lineNumber">190</td>
    <td class="codeline">    for (unsigned I = 0, E = STy->getNumElements(); I != E; ++I) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">      uint64_t EltOffset = SL ? SL->getElementOffset(I) : 0;</td>
    <td class="lineNumber">191</td>
    <td class="codeline">      uint64_t EltOffset = SL ? SL->getElementOffset(I) : 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">      computeValueLLTs(DL, *STy->getElementType(I), ValueTys, Offsets,</td>
    <td class="lineNumber">192</td>
    <td class="codeline">      computeValueLLTs(DL, *STy->getElementType(I), ValueTys, Offsets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">                       StartingOffset + EltOffset);</td>
    <td class="lineNumber">193</td>
    <td class="codeline">                       StartingOffset + EltOffset);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">194</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">195</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">196</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">  // Given an array type, recursively traverse the elements.</td>
    <td class="lineNumber">197</td>
    <td class="codeline">  // Given an array type, recursively traverse the elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">  if (ArrayType *ATy = dyn_cast<ArrayType>(&Ty)) {</td>
    <td class="lineNumber">198</td>
    <td class="codeline">  if (ArrayType *ATy = dyn_cast<ArrayType>(&Ty)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline">    Type *EltTy = ATy->getElementType();</td>
    <td class="lineNumber">199</td>
    <td class="codeline">    Type *EltTy = ATy->getElementType();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">    uint64_t EltSize = DL.getTypeAllocSize(EltTy).getFixedValue();</td>
    <td class="lineNumber">200</td>
    <td class="codeline">    uint64_t EltSize = DL.getTypeAllocSize(EltTy).getFixedValue();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">    for (unsigned i = 0, e = ATy->getNumElements(); i != e; ++i)</td>
    <td class="lineNumber">201</td>
    <td class="codeline">    for (unsigned i = 0, e = ATy->getNumElements(); i != e; ++i)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">      computeValueLLTs(DL, *EltTy, ValueTys, Offsets,</td>
    <td class="lineNumber">202</td>
    <td class="codeline">      computeValueLLTs(DL, *EltTy, ValueTys, Offsets,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">                       StartingOffset + i * EltSize);</td>
    <td class="lineNumber">203</td>
    <td class="codeline">                       StartingOffset + i * EltSize);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">204</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">205</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">  // Interpret void as zero return values.</td>
    <td class="lineNumber">206</td>
    <td class="codeline">  // Interpret void as zero return values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">  if (Ty.isVoidTy())</td>
    <td class="lineNumber">207</td>
    <td class="codeline">  if (Ty.isVoidTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">    return;</td>
    <td class="lineNumber">208</td>
    <td class="codeline">    return;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">  // Base case: we can get an LLT for this LLVM IR type.</td>
    <td class="lineNumber">209</td>
    <td class="codeline">  // Base case: we can get an LLT for this LLVM IR type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">  ValueTys.push_back(getLLTForType(Ty, DL));</td>
    <td class="lineNumber">210</td>
    <td class="codeline">  ValueTys.push_back(getLLTForType(Ty, DL));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline">  if (Offsets != nullptr)</td>
    <td class="lineNumber">211</td>
    <td class="codeline">  if (Offsets != nullptr)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">    Offsets->push_back(StartingOffset * 8);</td>
    <td class="lineNumber">212</td>
    <td class="codeline">    Offsets->push_back(StartingOffset * 8);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">}</td>
    <td class="lineNumber">213</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
    <td class="lineNumber">214</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline">/// ExtractTypeInfo - Returns the type info, possibly bitcast, encoded in V.</td>
    <td class="lineNumber">215</td>
    <td class="codeline">/// ExtractTypeInfo - Returns the type info, possibly bitcast, encoded in V.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">GlobalValue *llvm::ExtractTypeInfo(Value *V) {</td>
    <td class="lineNumber">216</td>
    <td class="codeline">GlobalValue *llvm::ExtractTypeInfo(Value *V) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">  V = V->stripPointerCasts();</td>
    <td class="lineNumber">217</td>
    <td class="codeline">  V = V->stripPointerCasts();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">  GlobalValue *GV = dyn_cast<GlobalValue>(V);</td>
    <td class="lineNumber">218</td>
    <td class="codeline">  GlobalValue *GV = dyn_cast<GlobalValue>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  GlobalVariable *Var = dyn_cast<GlobalVariable>(V);</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  GlobalVariable *Var = dyn_cast<GlobalVariable>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  if (Var && Var->getName() == "llvm.eh.catch.all.value") {</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  if (Var && Var->getName() == "llvm.eh.catch.all.value") {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">    assert(Var->hasInitializer() &&</td>
    <td class="lineNumber">222</td>
    <td class="codeline">    assert(Var->hasInitializer() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">           "The EH catch-all value must have an initializer");</td>
    <td class="lineNumber">223</td>
    <td class="codeline">           "The EH catch-all value must have an initializer");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline">    Value *Init = Var->getInitializer();</td>
    <td class="lineNumber">224</td>
    <td class="codeline">    Value *Init = Var->getInitializer();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">    GV = dyn_cast<GlobalValue>(Init);</td>
    <td class="lineNumber">225</td>
    <td class="codeline">    GV = dyn_cast<GlobalValue>(Init);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">    if (!GV) V = cast<ConstantPointerNull>(Init);</td>
    <td class="lineNumber">226</td>
    <td class="codeline">    if (!GV) V = cast<ConstantPointerNull>(Init);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">227</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline"></td>
    <td class="lineNumber">228</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">  assert((GV || isa<ConstantPointerNull>(V)) &&</td>
    <td class="lineNumber">229</td>
    <td class="codeline">  assert((GV || isa<ConstantPointerNull>(V)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">         "TypeInfo must be a global variable or NULL");</td>
    <td class="lineNumber">230</td>
    <td class="codeline">         "TypeInfo must be a global variable or NULL");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  return GV;</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  return GV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">}</td>
    <td class="lineNumber">232</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">/// getFCmpCondCode - Return the ISD condition code corresponding to</td>
    <td class="lineNumber">234</td>
    <td class="codeline">/// getFCmpCondCode - Return the ISD condition code corresponding to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">/// the given LLVM IR floating-point condition code.  This includes</td>
    <td class="lineNumber">235</td>
    <td class="codeline">/// the given LLVM IR floating-point condition code.  This includes</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline">/// consideration of global floating-point math flags.</td>
    <td class="lineNumber">236</td>
    <td class="codeline">/// consideration of global floating-point math flags.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">///</td>
    <td class="lineNumber">237</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline">ISD::CondCode llvm::getFCmpCondCode(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">238</td>
    <td class="codeline">ISD::CondCode llvm::getFCmpCondCode(FCmpInst::Predicate Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  switch (Pred) {</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  switch (Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  case FCmpInst::FCMP_FALSE: return ISD::SETFALSE;</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  case FCmpInst::FCMP_FALSE: return ISD::SETFALSE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  case FCmpInst::FCMP_OEQ:   return ISD::SETOEQ;</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  case FCmpInst::FCMP_OEQ:   return ISD::SETOEQ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline">  case FCmpInst::FCMP_OGT:   return ISD::SETOGT;</td>
    <td class="lineNumber">242</td>
    <td class="codeline">  case FCmpInst::FCMP_OGT:   return ISD::SETOGT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  case FCmpInst::FCMP_OGE:   return ISD::SETOGE;</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  case FCmpInst::FCMP_OGE:   return ISD::SETOGE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  case FCmpInst::FCMP_OLT:   return ISD::SETOLT;</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  case FCmpInst::FCMP_OLT:   return ISD::SETOLT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">  case FCmpInst::FCMP_OLE:   return ISD::SETOLE;</td>
    <td class="lineNumber">245</td>
    <td class="codeline">  case FCmpInst::FCMP_OLE:   return ISD::SETOLE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline">  case FCmpInst::FCMP_ONE:   return ISD::SETONE;</td>
    <td class="lineNumber">246</td>
    <td class="codeline">  case FCmpInst::FCMP_ONE:   return ISD::SETONE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">  case FCmpInst::FCMP_ORD:   return ISD::SETO;</td>
    <td class="lineNumber">247</td>
    <td class="codeline">  case FCmpInst::FCMP_ORD:   return ISD::SETO;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">  case FCmpInst::FCMP_UNO:   return ISD::SETUO;</td>
    <td class="lineNumber">248</td>
    <td class="codeline">  case FCmpInst::FCMP_UNO:   return ISD::SETUO;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline">  case FCmpInst::FCMP_UEQ:   return ISD::SETUEQ;</td>
    <td class="lineNumber">249</td>
    <td class="codeline">  case FCmpInst::FCMP_UEQ:   return ISD::SETUEQ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  case FCmpInst::FCMP_UGT:   return ISD::SETUGT;</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  case FCmpInst::FCMP_UGT:   return ISD::SETUGT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">  case FCmpInst::FCMP_UGE:   return ISD::SETUGE;</td>
    <td class="lineNumber">251</td>
    <td class="codeline">  case FCmpInst::FCMP_UGE:   return ISD::SETUGE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  case FCmpInst::FCMP_ULT:   return ISD::SETULT;</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  case FCmpInst::FCMP_ULT:   return ISD::SETULT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">  case FCmpInst::FCMP_ULE:   return ISD::SETULE;</td>
    <td class="lineNumber">253</td>
    <td class="codeline">  case FCmpInst::FCMP_ULE:   return ISD::SETULE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline">  case FCmpInst::FCMP_UNE:   return ISD::SETUNE;</td>
    <td class="lineNumber">254</td>
    <td class="codeline">  case FCmpInst::FCMP_UNE:   return ISD::SETUNE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">  case FCmpInst::FCMP_TRUE:  return ISD::SETTRUE;</td>
    <td class="lineNumber">255</td>
    <td class="codeline">  case FCmpInst::FCMP_TRUE:  return ISD::SETTRUE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">  default: llvm_unreachable("Invalid FCmp predicate opcode!");</td>
    <td class="lineNumber">256</td>
    <td class="codeline">  default: llvm_unreachable("Invalid FCmp predicate opcode!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">}</td>
    <td class="lineNumber">258</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">ISD::CondCode llvm::getFCmpCodeWithoutNaN(ISD::CondCode CC) {</td>
    <td class="lineNumber">260</td>
    <td class="codeline">ISD::CondCode llvm::getFCmpCodeWithoutNaN(ISD::CondCode CC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">  switch (CC) {</td>
    <td class="lineNumber">261</td>
    <td class="codeline">  switch (CC) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">    case ISD::SETOEQ: case ISD::SETUEQ: return ISD::SETEQ;</td>
    <td class="lineNumber">262</td>
    <td class="codeline">    case ISD::SETOEQ: case ISD::SETUEQ: return ISD::SETEQ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">    case ISD::SETONE: case ISD::SETUNE: return ISD::SETNE;</td>
    <td class="lineNumber">263</td>
    <td class="codeline">    case ISD::SETONE: case ISD::SETUNE: return ISD::SETNE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">    case ISD::SETOLT: case ISD::SETULT: return ISD::SETLT;</td>
    <td class="lineNumber">264</td>
    <td class="codeline">    case ISD::SETOLT: case ISD::SETULT: return ISD::SETLT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">    case ISD::SETOLE: case ISD::SETULE: return ISD::SETLE;</td>
    <td class="lineNumber">265</td>
    <td class="codeline">    case ISD::SETOLE: case ISD::SETULE: return ISD::SETLE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">    case ISD::SETOGT: case ISD::SETUGT: return ISD::SETGT;</td>
    <td class="lineNumber">266</td>
    <td class="codeline">    case ISD::SETOGT: case ISD::SETUGT: return ISD::SETGT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline">    case ISD::SETOGE: case ISD::SETUGE: return ISD::SETGE;</td>
    <td class="lineNumber">267</td>
    <td class="codeline">    case ISD::SETOGE: case ISD::SETUGE: return ISD::SETGE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">    default: return CC;</td>
    <td class="lineNumber">268</td>
    <td class="codeline">    default: return CC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">269</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">}</td>
    <td class="lineNumber">270</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
    <td class="lineNumber">271</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline">ISD::CondCode llvm::getICmpCondCode(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">272</td>
    <td class="codeline">ISD::CondCode llvm::getICmpCondCode(ICmpInst::Predicate Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  switch (Pred) {</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  switch (Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">  case ICmpInst::ICMP_EQ:  return ISD::SETEQ;</td>
    <td class="lineNumber">274</td>
    <td class="codeline">  case ICmpInst::ICMP_EQ:  return ISD::SETEQ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">  case ICmpInst::ICMP_NE:  return ISD::SETNE;</td>
    <td class="lineNumber">275</td>
    <td class="codeline">  case ICmpInst::ICMP_NE:  return ISD::SETNE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  case ICmpInst::ICMP_SLE: return ISD::SETLE;</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  case ICmpInst::ICMP_SLE: return ISD::SETLE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">  case ICmpInst::ICMP_ULE: return ISD::SETULE;</td>
    <td class="lineNumber">277</td>
    <td class="codeline">  case ICmpInst::ICMP_ULE: return ISD::SETULE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline">  case ICmpInst::ICMP_SGE: return ISD::SETGE;</td>
    <td class="lineNumber">278</td>
    <td class="codeline">  case ICmpInst::ICMP_SGE: return ISD::SETGE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">  case ICmpInst::ICMP_UGE: return ISD::SETUGE;</td>
    <td class="lineNumber">279</td>
    <td class="codeline">  case ICmpInst::ICMP_UGE: return ISD::SETUGE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">  case ICmpInst::ICMP_SLT: return ISD::SETLT;</td>
    <td class="lineNumber">280</td>
    <td class="codeline">  case ICmpInst::ICMP_SLT: return ISD::SETLT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">  case ICmpInst::ICMP_ULT: return ISD::SETULT;</td>
    <td class="lineNumber">281</td>
    <td class="codeline">  case ICmpInst::ICMP_ULT: return ISD::SETULT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">  case ICmpInst::ICMP_SGT: return ISD::SETGT;</td>
    <td class="lineNumber">282</td>
    <td class="codeline">  case ICmpInst::ICMP_SGT: return ISD::SETGT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  case ICmpInst::ICMP_UGT: return ISD::SETUGT;</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  case ICmpInst::ICMP_UGT: return ISD::SETUGT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">    llvm_unreachable("Invalid ICmp predicate opcode!");</td>
    <td class="lineNumber">285</td>
    <td class="codeline">    llvm_unreachable("Invalid ICmp predicate opcode!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">286</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">}</td>
    <td class="lineNumber">287</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
    <td class="lineNumber">288</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">ICmpInst::Predicate llvm::getICmpCondCode(ISD::CondCode Pred) {</td>
    <td class="lineNumber">289</td>
    <td class="codeline">ICmpInst::Predicate llvm::getICmpCondCode(ISD::CondCode Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">  switch (Pred) {</td>
    <td class="lineNumber">290</td>
    <td class="codeline">  switch (Pred) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline">  case ISD::SETEQ:</td>
    <td class="lineNumber">291</td>
    <td class="codeline">  case ISD::SETEQ:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">    return ICmpInst::ICMP_EQ;</td>
    <td class="lineNumber">292</td>
    <td class="codeline">    return ICmpInst::ICMP_EQ;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  case ISD::SETNE:</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  case ISD::SETNE:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">    return ICmpInst::ICMP_NE;</td>
    <td class="lineNumber">294</td>
    <td class="codeline">    return ICmpInst::ICMP_NE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  case ISD::SETLE:</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  case ISD::SETLE:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline">    return ICmpInst::ICMP_SLE;</td>
    <td class="lineNumber">296</td>
    <td class="codeline">    return ICmpInst::ICMP_SLE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">  case ISD::SETULE:</td>
    <td class="lineNumber">297</td>
    <td class="codeline">  case ISD::SETULE:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline">    return ICmpInst::ICMP_ULE;</td>
    <td class="lineNumber">298</td>
    <td class="codeline">    return ICmpInst::ICMP_ULE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">  case ISD::SETGE:</td>
    <td class="lineNumber">299</td>
    <td class="codeline">  case ISD::SETGE:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">    return ICmpInst::ICMP_SGE;</td>
    <td class="lineNumber">300</td>
    <td class="codeline">    return ICmpInst::ICMP_SGE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline">  case ISD::SETUGE:</td>
    <td class="lineNumber">301</td>
    <td class="codeline">  case ISD::SETUGE:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">    return ICmpInst::ICMP_UGE;</td>
    <td class="lineNumber">302</td>
    <td class="codeline">    return ICmpInst::ICMP_UGE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">  case ISD::SETLT:</td>
    <td class="lineNumber">303</td>
    <td class="codeline">  case ISD::SETLT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline">    return ICmpInst::ICMP_SLT;</td>
    <td class="lineNumber">304</td>
    <td class="codeline">    return ICmpInst::ICMP_SLT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">  case ISD::SETULT:</td>
    <td class="lineNumber">305</td>
    <td class="codeline">  case ISD::SETULT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">    return ICmpInst::ICMP_ULT;</td>
    <td class="lineNumber">306</td>
    <td class="codeline">    return ICmpInst::ICMP_ULT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">  case ISD::SETGT:</td>
    <td class="lineNumber">307</td>
    <td class="codeline">  case ISD::SETGT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">    return ICmpInst::ICMP_SGT;</td>
    <td class="lineNumber">308</td>
    <td class="codeline">    return ICmpInst::ICMP_SGT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">  case ISD::SETUGT:</td>
    <td class="lineNumber">309</td>
    <td class="codeline">  case ISD::SETUGT:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline">    return ICmpInst::ICMP_UGT;</td>
    <td class="lineNumber">310</td>
    <td class="codeline">    return ICmpInst::ICMP_UGT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">  default:</td>
    <td class="lineNumber">311</td>
    <td class="codeline">  default:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">    llvm_unreachable("Invalid ISD integer condition code!");</td>
    <td class="lineNumber">312</td>
    <td class="codeline">    llvm_unreachable("Invalid ISD integer condition code!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">313</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">}</td>
    <td class="lineNumber">314</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
    <td class="lineNumber">315</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">static bool isNoopBitcast(Type *T1, Type *T2,</td>
    <td class="lineNumber">316</td>
    <td class="codeline">static bool isNoopBitcast(Type *T1, Type *T2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">                          const TargetLoweringBase& TLI) {</td>
    <td class="lineNumber">317</td>
    <td class="codeline">                          const TargetLoweringBase& TLI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">  return T1 == T2 || (T1->isPointerTy() && T2->isPointerTy()) ||</td>
    <td class="lineNumber">318</td>
    <td class="codeline">  return T1 == T2 || (T1->isPointerTy() && T2->isPointerTy()) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">         (isa<VectorType>(T1) && isa<VectorType>(T2) &&</td>
    <td class="lineNumber">319</td>
    <td class="codeline">         (isa<VectorType>(T1) && isa<VectorType>(T2) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">          TLI.isTypeLegal(EVT::getEVT(T1)) && TLI.isTypeLegal(EVT::getEVT(T2)));</td>
    <td class="lineNumber">320</td>
    <td class="codeline">          TLI.isTypeLegal(EVT::getEVT(T1)) && TLI.isTypeLegal(EVT::getEVT(T2)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">}</td>
    <td class="lineNumber">321</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline"></td>
    <td class="lineNumber">322</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">/// Look through operations that will be free to find the earliest source of</td>
    <td class="lineNumber">323</td>
    <td class="codeline">/// Look through operations that will be free to find the earliest source of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">/// this value.</td>
    <td class="lineNumber">324</td>
    <td class="codeline">/// this value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">///</td>
    <td class="lineNumber">325</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">/// @param ValLoc If V has aggregate type, we will be interested in a particular</td>
    <td class="lineNumber">326</td>
    <td class="codeline">/// @param ValLoc If V has aggregate type, we will be interested in a particular</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">/// scalar component. This records its address; the reverse of this list gives a</td>
    <td class="lineNumber">327</td>
    <td class="codeline">/// scalar component. This records its address; the reverse of this list gives a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">/// sequence of indices appropriate for an extractvalue to locate the important</td>
    <td class="lineNumber">328</td>
    <td class="codeline">/// sequence of indices appropriate for an extractvalue to locate the important</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">/// value. This value is updated during the function and on exit will indicate</td>
    <td class="lineNumber">329</td>
    <td class="codeline">/// value. This value is updated during the function and on exit will indicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">/// similar information for the Value returned.</td>
    <td class="lineNumber">330</td>
    <td class="codeline">/// similar information for the Value returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">///</td>
    <td class="lineNumber">331</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">/// @param DataBits If this function looks through truncate instructions, this</td>
    <td class="lineNumber">332</td>
    <td class="codeline">/// @param DataBits If this function looks through truncate instructions, this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">/// will record the smallest size attained.</td>
    <td class="lineNumber">333</td>
    <td class="codeline">/// will record the smallest size attained.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">static const Value *getNoopInput(const Value *V,</td>
    <td class="lineNumber">334</td>
    <td class="codeline">static const Value *getNoopInput(const Value *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">                                 SmallVectorImpl<unsigned> &ValLoc,</td>
    <td class="lineNumber">335</td>
    <td class="codeline">                                 SmallVectorImpl<unsigned> &ValLoc,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">                                 unsigned &DataBits,</td>
    <td class="lineNumber">336</td>
    <td class="codeline">                                 unsigned &DataBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">                                 const TargetLoweringBase &TLI,</td>
    <td class="lineNumber">337</td>
    <td class="codeline">                                 const TargetLoweringBase &TLI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">                                 const DataLayout &DL) {</td>
    <td class="lineNumber">338</td>
    <td class="codeline">                                 const DataLayout &DL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">  while (true) {</td>
    <td class="lineNumber">339</td>
    <td class="codeline">  while (true) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">    // Try to look through V1; if V1 is not an instruction, it can't be looked</td>
    <td class="lineNumber">340</td>
    <td class="codeline">    // Try to look through V1; if V1 is not an instruction, it can't be looked</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">    // through.</td>
    <td class="lineNumber">341</td>
    <td class="codeline">    // through.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">    const Instruction *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">342</td>
    <td class="codeline">    const Instruction *I = dyn_cast<Instruction>(V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">    if (!I || I->getNumOperands() == 0) return V;</td>
    <td class="lineNumber">343</td>
    <td class="codeline">    if (!I || I->getNumOperands() == 0) return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">    const Value *NoopInput = nullptr;</td>
    <td class="lineNumber">344</td>
    <td class="codeline">    const Value *NoopInput = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline"></td>
    <td class="lineNumber">345</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">    Value *Op = I->getOperand(0);</td>
    <td class="lineNumber">346</td>
    <td class="codeline">    Value *Op = I->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">    if (isa<BitCastInst>(I)) {</td>
    <td class="lineNumber">347</td>
    <td class="codeline">    if (isa<BitCastInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">      // Look through truly no-op bitcasts.</td>
    <td class="lineNumber">348</td>
    <td class="codeline">      // Look through truly no-op bitcasts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">      if (isNoopBitcast(Op->getType(), I->getType(), TLI))</td>
    <td class="lineNumber">349</td>
    <td class="codeline">      if (isNoopBitcast(Op->getType(), I->getType(), TLI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">        NoopInput = Op;</td>
    <td class="lineNumber">350</td>
    <td class="codeline">        NoopInput = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">    } else if (isa<GetElementPtrInst>(I)) {</td>
    <td class="lineNumber">351</td>
    <td class="codeline">    } else if (isa<GetElementPtrInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline">      // Look through getelementptr</td>
    <td class="lineNumber">352</td>
    <td class="codeline">      // Look through getelementptr</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">      if (cast<GetElementPtrInst>(I)->hasAllZeroIndices())</td>
    <td class="lineNumber">353</td>
    <td class="codeline">      if (cast<GetElementPtrInst>(I)->hasAllZeroIndices())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">        NoopInput = Op;</td>
    <td class="lineNumber">354</td>
    <td class="codeline">        NoopInput = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">    } else if (isa<IntToPtrInst>(I)) {</td>
    <td class="lineNumber">355</td>
    <td class="codeline">    } else if (isa<IntToPtrInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">      // Look through inttoptr.</td>
    <td class="lineNumber">356</td>
    <td class="codeline">      // Look through inttoptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">      // Make sure this isn't a truncating or extending cast.  We could</td>
    <td class="lineNumber">357</td>
    <td class="codeline">      // Make sure this isn't a truncating or extending cast.  We could</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">      // support this eventually, but don't bother for now.</td>
    <td class="lineNumber">358</td>
    <td class="codeline">      // support this eventually, but don't bother for now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">      if (!isa<VectorType>(I->getType()) &&</td>
    <td class="lineNumber">359</td>
    <td class="codeline">      if (!isa<VectorType>(I->getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">          DL.getPointerSizeInBits() ==</td>
    <td class="lineNumber">360</td>
    <td class="codeline">          DL.getPointerSizeInBits() ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">              cast<IntegerType>(Op->getType())->getBitWidth())</td>
    <td class="lineNumber">361</td>
    <td class="codeline">              cast<IntegerType>(Op->getType())->getBitWidth())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline">        NoopInput = Op;</td>
    <td class="lineNumber">362</td>
    <td class="codeline">        NoopInput = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">    } else if (isa<PtrToIntInst>(I)) {</td>
    <td class="lineNumber">363</td>
    <td class="codeline">    } else if (isa<PtrToIntInst>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">      // Look through ptrtoint.</td>
    <td class="lineNumber">364</td>
    <td class="codeline">      // Look through ptrtoint.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">      // Make sure this isn't a truncating or extending cast.  We could</td>
    <td class="lineNumber">365</td>
    <td class="codeline">      // Make sure this isn't a truncating or extending cast.  We could</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">      // support this eventually, but don't bother for now.</td>
    <td class="lineNumber">366</td>
    <td class="codeline">      // support this eventually, but don't bother for now.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline">      if (!isa<VectorType>(I->getType()) &&</td>
    <td class="lineNumber">367</td>
    <td class="codeline">      if (!isa<VectorType>(I->getType()) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">          DL.getPointerSizeInBits() ==</td>
    <td class="lineNumber">368</td>
    <td class="codeline">          DL.getPointerSizeInBits() ==</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">              cast<IntegerType>(I->getType())->getBitWidth())</td>
    <td class="lineNumber">369</td>
    <td class="codeline">              cast<IntegerType>(I->getType())->getBitWidth())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline">        NoopInput = Op;</td>
    <td class="lineNumber">370</td>
    <td class="codeline">        NoopInput = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">    } else if (isa<TruncInst>(I) &&</td>
    <td class="lineNumber">371</td>
    <td class="codeline">    } else if (isa<TruncInst>(I) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">               TLI.allowTruncateForTailCall(Op->getType(), I->getType())) {</td>
    <td class="lineNumber">372</td>
    <td class="codeline">               TLI.allowTruncateForTailCall(Op->getType(), I->getType())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">      DataBits =</td>
    <td class="lineNumber">373</td>
    <td class="codeline">      DataBits =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">          std::min((uint64_t)DataBits,</td>
    <td class="lineNumber">374</td>
    <td class="codeline">          std::min((uint64_t)DataBits,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">                   I->getType()->getPrimitiveSizeInBits().getFixedValue());</td>
    <td class="lineNumber">375</td>
    <td class="codeline">                   I->getType()->getPrimitiveSizeInBits().getFixedValue());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">      NoopInput = Op;</td>
    <td class="lineNumber">376</td>
    <td class="codeline">      NoopInput = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline">    } else if (auto *CB = dyn_cast<CallBase>(I)) {</td>
    <td class="lineNumber">377</td>
    <td class="codeline">    } else if (auto *CB = dyn_cast<CallBase>(I)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">      const Value *ReturnedOp = CB->getReturnedArgOperand();</td>
    <td class="lineNumber">378</td>
    <td class="codeline">      const Value *ReturnedOp = CB->getReturnedArgOperand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">      if (ReturnedOp && isNoopBitcast(ReturnedOp->getType(), I->getType(), TLI))</td>
    <td class="lineNumber">379</td>
    <td class="codeline">      if (ReturnedOp && isNoopBitcast(ReturnedOp->getType(), I->getType(), TLI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline">        NoopInput = ReturnedOp;</td>
    <td class="lineNumber">380</td>
    <td class="codeline">        NoopInput = ReturnedOp;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">    } else if (const InsertValueInst *IVI = dyn_cast<InsertValueInst>(V)) {</td>
    <td class="lineNumber">381</td>
    <td class="codeline">    } else if (const InsertValueInst *IVI = dyn_cast<InsertValueInst>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">      // Value may come from either the aggregate or the scalar</td>
    <td class="lineNumber">382</td>
    <td class="codeline">      // Value may come from either the aggregate or the scalar</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">      ArrayRef<unsigned> InsertLoc = IVI->getIndices();</td>
    <td class="lineNumber">383</td>
    <td class="codeline">      ArrayRef<unsigned> InsertLoc = IVI->getIndices();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">      if (ValLoc.size() >= InsertLoc.size() &&</td>
    <td class="lineNumber">384</td>
    <td class="codeline">      if (ValLoc.size() >= InsertLoc.size() &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline">          std::equal(InsertLoc.begin(), InsertLoc.end(), ValLoc.rbegin())) {</td>
    <td class="lineNumber">385</td>
    <td class="codeline">          std::equal(InsertLoc.begin(), InsertLoc.end(), ValLoc.rbegin())) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">        // The type being inserted is a nested sub-type of the aggregate; we</td>
    <td class="lineNumber">386</td>
    <td class="codeline">        // The type being inserted is a nested sub-type of the aggregate; we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">        // have to remove those initial indices to get the location we're</td>
    <td class="lineNumber">387</td>
    <td class="codeline">        // have to remove those initial indices to get the location we're</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">        // interested in for the operand.</td>
    <td class="lineNumber">388</td>
    <td class="codeline">        // interested in for the operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline">        ValLoc.resize(ValLoc.size() - InsertLoc.size());</td>
    <td class="lineNumber">389</td>
    <td class="codeline">        ValLoc.resize(ValLoc.size() - InsertLoc.size());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">        NoopInput = IVI->getInsertedValueOperand();</td>
    <td class="lineNumber">390</td>
    <td class="codeline">        NoopInput = IVI->getInsertedValueOperand();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">      } else {</td>
    <td class="lineNumber">391</td>
    <td class="codeline">      } else {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">        // The struct we're inserting into has the value we're interested in, no</td>
    <td class="lineNumber">392</td>
    <td class="codeline">        // The struct we're inserting into has the value we're interested in, no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">        // change of address.</td>
    <td class="lineNumber">393</td>
    <td class="codeline">        // change of address.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline">        NoopInput = Op;</td>
    <td class="lineNumber">394</td>
    <td class="codeline">        NoopInput = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">      }</td>
    <td class="lineNumber">395</td>
    <td class="codeline">      }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">    } else if (const ExtractValueInst *EVI = dyn_cast<ExtractValueInst>(V)) {</td>
    <td class="lineNumber">396</td>
    <td class="codeline">    } else if (const ExtractValueInst *EVI = dyn_cast<ExtractValueInst>(V)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline">      // The part we're interested in will inevitably be some sub-section of the</td>
    <td class="lineNumber">397</td>
    <td class="codeline">      // The part we're interested in will inevitably be some sub-section of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">      // previous aggregate. Combine the two paths to obtain the true address of</td>
    <td class="lineNumber">398</td>
    <td class="codeline">      // previous aggregate. Combine the two paths to obtain the true address of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">      // our element.</td>
    <td class="lineNumber">399</td>
    <td class="codeline">      // our element.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">      ArrayRef<unsigned> ExtractLoc = EVI->getIndices();</td>
    <td class="lineNumber">400</td>
    <td class="codeline">      ArrayRef<unsigned> ExtractLoc = EVI->getIndices();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">      ValLoc.append(ExtractLoc.rbegin(), ExtractLoc.rend());</td>
    <td class="lineNumber">401</td>
    <td class="codeline">      ValLoc.append(ExtractLoc.rbegin(), ExtractLoc.rend());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">      NoopInput = Op;</td>
    <td class="lineNumber">402</td>
    <td class="codeline">      NoopInput = Op;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">403</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">    // Terminate if we couldn't find anything to look through.</td>
    <td class="lineNumber">404</td>
    <td class="codeline">    // Terminate if we couldn't find anything to look through.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">    if (!NoopInput)</td>
    <td class="lineNumber">405</td>
    <td class="codeline">    if (!NoopInput)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">      return V;</td>
    <td class="lineNumber">406</td>
    <td class="codeline">      return V;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline"></td>
    <td class="lineNumber">407</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">    V = NoopInput;</td>
    <td class="lineNumber">408</td>
    <td class="codeline">    V = NoopInput;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">409</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">}</td>
    <td class="lineNumber">410</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline"></td>
    <td class="lineNumber">411</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">/// Return true if this scalar return value only has bits discarded on its path</td>
    <td class="lineNumber">412</td>
    <td class="codeline">/// Return true if this scalar return value only has bits discarded on its path</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">/// from the "tail call" to the "ret". This includes the obvious noop</td>
    <td class="lineNumber">413</td>
    <td class="codeline">/// from the "tail call" to the "ret". This includes the obvious noop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">/// instructions handled by getNoopInput above as well as free truncations (or</td>
    <td class="lineNumber">414</td>
    <td class="codeline">/// instructions handled by getNoopInput above as well as free truncations (or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">/// extensions prior to the call).</td>
    <td class="lineNumber">415</td>
    <td class="codeline">/// extensions prior to the call).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">static bool slotOnlyDiscardsData(const Value *RetVal, const Value *CallVal,</td>
    <td class="lineNumber">416</td>
    <td class="codeline">static bool slotOnlyDiscardsData(const Value *RetVal, const Value *CallVal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">                                 SmallVectorImpl<unsigned> &RetIndices,</td>
    <td class="lineNumber">417</td>
    <td class="codeline">                                 SmallVectorImpl<unsigned> &RetIndices,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">                                 SmallVectorImpl<unsigned> &CallIndices,</td>
    <td class="lineNumber">418</td>
    <td class="codeline">                                 SmallVectorImpl<unsigned> &CallIndices,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">                                 bool AllowDifferingSizes,</td>
    <td class="lineNumber">419</td>
    <td class="codeline">                                 bool AllowDifferingSizes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline">                                 const TargetLoweringBase &TLI,</td>
    <td class="lineNumber">420</td>
    <td class="codeline">                                 const TargetLoweringBase &TLI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">                                 const DataLayout &DL) {</td>
    <td class="lineNumber">421</td>
    <td class="codeline">                                 const DataLayout &DL) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline"></td>
    <td class="lineNumber">422</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline">  // Trace the sub-value needed by the return value as far back up the graph as</td>
    <td class="lineNumber">423</td>
    <td class="codeline">  // Trace the sub-value needed by the return value as far back up the graph as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">  // possible, in the hope that it will intersect with the value produced by the</td>
    <td class="lineNumber">424</td>
    <td class="codeline">  // possible, in the hope that it will intersect with the value produced by the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">  // call. In the simple case with no "returned" attribute, the hope is actually</td>
    <td class="lineNumber">425</td>
    <td class="codeline">  // call. In the simple case with no "returned" attribute, the hope is actually</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline">  // that we end up back at the tail call instruction itself.</td>
    <td class="lineNumber">426</td>
    <td class="codeline">  // that we end up back at the tail call instruction itself.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">  unsigned BitsRequired = UINT_MAX;</td>
    <td class="lineNumber">427</td>
    <td class="codeline">  unsigned BitsRequired = UINT_MAX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  RetVal = getNoopInput(RetVal, RetIndices, BitsRequired, TLI, DL);</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  RetVal = getNoopInput(RetVal, RetIndices, BitsRequired, TLI, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  // If this slot in the value returned is undef, it doesn't matter what the</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  // If this slot in the value returned is undef, it doesn't matter what the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">  // call puts there, it'll be fine.</td>
    <td class="lineNumber">431</td>
    <td class="codeline">  // call puts there, it'll be fine.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  if (isa<UndefValue>(RetVal))</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  if (isa<UndefValue>(RetVal))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">433</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline"></td>
    <td class="lineNumber">434</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">  // Now do a similar search up through the graph to find where the value</td>
    <td class="lineNumber">435</td>
    <td class="codeline">  // Now do a similar search up through the graph to find where the value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">  // actually returned by the "tail call" comes from. In the simple case without</td>
    <td class="lineNumber">436</td>
    <td class="codeline">  // actually returned by the "tail call" comes from. In the simple case without</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">  // a "returned" attribute, the search will be blocked immediately and the loop</td>
    <td class="lineNumber">437</td>
    <td class="codeline">  // a "returned" attribute, the search will be blocked immediately and the loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline">  // a Noop.</td>
    <td class="lineNumber">438</td>
    <td class="codeline">  // a Noop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">  unsigned BitsProvided = UINT_MAX;</td>
    <td class="lineNumber">439</td>
    <td class="codeline">  unsigned BitsProvided = UINT_MAX;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">  CallVal = getNoopInput(CallVal, CallIndices, BitsProvided, TLI, DL);</td>
    <td class="lineNumber">440</td>
    <td class="codeline">  CallVal = getNoopInput(CallVal, CallIndices, BitsProvided, TLI, DL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline"></td>
    <td class="lineNumber">441</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline">  // There's no hope if we can't actually trace them to (the same part of!) the</td>
    <td class="lineNumber">442</td>
    <td class="codeline">  // There's no hope if we can't actually trace them to (the same part of!) the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">  // same value.</td>
    <td class="lineNumber">443</td>
    <td class="codeline">  // same value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">  if (CallVal != RetVal || CallIndices != RetIndices)</td>
    <td class="lineNumber">444</td>
    <td class="codeline">  if (CallVal != RetVal || CallIndices != RetIndices)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">445</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline"></td>
    <td class="lineNumber">446</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">  // However, intervening truncates may have made the call non-tail. Make sure</td>
    <td class="lineNumber">447</td>
    <td class="codeline">  // However, intervening truncates may have made the call non-tail. Make sure</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline">  // all the bits that are needed by the "ret" have been provided by the "tail</td>
    <td class="lineNumber">448</td>
    <td class="codeline">  // all the bits that are needed by the "ret" have been provided by the "tail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">  // call". FIXME: with sufficiently cunning bit-tracking, we could look through</td>
    <td class="lineNumber">449</td>
    <td class="codeline">  // call". FIXME: with sufficiently cunning bit-tracking, we could look through</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">  // extensions too.</td>
    <td class="lineNumber">450</td>
    <td class="codeline">  // extensions too.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">  if (BitsProvided < BitsRequired ||</td>
    <td class="lineNumber">451</td>
    <td class="codeline">  if (BitsProvided < BitsRequired ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">      (!AllowDifferingSizes && BitsProvided != BitsRequired))</td>
    <td class="lineNumber">452</td>
    <td class="codeline">      (!AllowDifferingSizes && BitsProvided != BitsRequired))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">453</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline"></td>
    <td class="lineNumber">454</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">455</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">}</td>
    <td class="lineNumber">456</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline"></td>
    <td class="lineNumber">457</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">/// For an aggregate type, determine whether a given index is within bounds or</td>
    <td class="lineNumber">458</td>
    <td class="codeline">/// For an aggregate type, determine whether a given index is within bounds or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">/// not.</td>
    <td class="lineNumber">459</td>
    <td class="codeline">/// not.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">static bool indexReallyValid(Type *T, unsigned Idx) {</td>
    <td class="lineNumber">460</td>
    <td class="codeline">static bool indexReallyValid(Type *T, unsigned Idx) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">  if (ArrayType *AT = dyn_cast<ArrayType>(T))</td>
    <td class="lineNumber">461</td>
    <td class="codeline">  if (ArrayType *AT = dyn_cast<ArrayType>(T))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline">    return Idx < AT->getNumElements();</td>
    <td class="lineNumber">462</td>
    <td class="codeline">    return Idx < AT->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
    <td class="lineNumber">463</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  return Idx < cast<StructType>(T)->getNumElements();</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  return Idx < cast<StructType>(T)->getNumElements();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">}</td>
    <td class="lineNumber">465</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
    <td class="lineNumber">466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">/// Move the given iterators to the next leaf type in depth first traversal.</td>
    <td class="lineNumber">467</td>
    <td class="codeline">/// Move the given iterators to the next leaf type in depth first traversal.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">///</td>
    <td class="lineNumber">468</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline">/// Performs a depth-first traversal of the type as specified by its arguments,</td>
    <td class="lineNumber">469</td>
    <td class="codeline">/// Performs a depth-first traversal of the type as specified by its arguments,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">/// stopping at the next leaf node (which may be a legitimate scalar type or an</td>
    <td class="lineNumber">470</td>
    <td class="codeline">/// stopping at the next leaf node (which may be a legitimate scalar type or an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">/// empty struct or array).</td>
    <td class="lineNumber">471</td>
    <td class="codeline">/// empty struct or array).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">///</td>
    <td class="lineNumber">472</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">/// @param SubTypes List of the partial components making up the type from</td>
    <td class="lineNumber">473</td>
    <td class="codeline">/// @param SubTypes List of the partial components making up the type from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">/// outermost to innermost non-empty aggregate. The element currently</td>
    <td class="lineNumber">474</td>
    <td class="codeline">/// outermost to innermost non-empty aggregate. The element currently</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">/// represented is SubTypes.back()->getTypeAtIndex(Path.back() - 1).</td>
    <td class="lineNumber">475</td>
    <td class="codeline">/// represented is SubTypes.back()->getTypeAtIndex(Path.back() - 1).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">///</td>
    <td class="lineNumber">476</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">/// @param Path Set of extractvalue indices leading from the outermost type</td>
    <td class="lineNumber">477</td>
    <td class="codeline">/// @param Path Set of extractvalue indices leading from the outermost type</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">/// (SubTypes[0]) to the leaf node currently represented.</td>
    <td class="lineNumber">478</td>
    <td class="codeline">/// (SubTypes[0]) to the leaf node currently represented.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">///</td>
    <td class="lineNumber">479</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">/// @returns true if a new type was found, false otherwise. Calling this</td>
    <td class="lineNumber">480</td>
    <td class="codeline">/// @returns true if a new type was found, false otherwise. Calling this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">/// function again on a finished iterator will repeatedly return</td>
    <td class="lineNumber">481</td>
    <td class="codeline">/// function again on a finished iterator will repeatedly return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">/// false. SubTypes.back()->getTypeAtIndex(Path.back()) is either an empty</td>
    <td class="lineNumber">482</td>
    <td class="codeline">/// false. SubTypes.back()->getTypeAtIndex(Path.back()) is either an empty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">/// aggregate or a non-aggregate</td>
    <td class="lineNumber">483</td>
    <td class="codeline">/// aggregate or a non-aggregate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">static bool advanceToNextLeafType(SmallVectorImpl<Type *> &SubTypes,</td>
    <td class="lineNumber">484</td>
    <td class="codeline">static bool advanceToNextLeafType(SmallVectorImpl<Type *> &SubTypes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">                                  SmallVectorImpl<unsigned> &Path) {</td>
    <td class="lineNumber">485</td>
    <td class="codeline">                                  SmallVectorImpl<unsigned> &Path) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">  // First march back up the tree until we can successfully increment one of the</td>
    <td class="lineNumber">486</td>
    <td class="codeline">  // First march back up the tree until we can successfully increment one of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">  // coordinates in Path.</td>
    <td class="lineNumber">487</td>
    <td class="codeline">  // coordinates in Path.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline">  while (!Path.empty() && !indexReallyValid(SubTypes.back(), Path.back() + 1)) {</td>
    <td class="lineNumber">488</td>
    <td class="codeline">  while (!Path.empty() && !indexReallyValid(SubTypes.back(), Path.back() + 1)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">    Path.pop_back();</td>
    <td class="lineNumber">489</td>
    <td class="codeline">    Path.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">    SubTypes.pop_back();</td>
    <td class="lineNumber">490</td>
    <td class="codeline">    SubTypes.pop_back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline"></td>
    <td class="lineNumber">492</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline">  // If we reached the top, then the iterator is done.</td>
    <td class="lineNumber">493</td>
    <td class="codeline">  // If we reached the top, then the iterator is done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">  if (Path.empty())</td>
    <td class="lineNumber">494</td>
    <td class="codeline">  if (Path.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">495</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline"></td>
    <td class="lineNumber">496</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">  // We know there's *some* valid leaf now, so march back down the tree picking</td>
    <td class="lineNumber">497</td>
    <td class="codeline">  // We know there's *some* valid leaf now, so march back down the tree picking</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">  // out the left-most element at each node.</td>
    <td class="lineNumber">498</td>
    <td class="codeline">  // out the left-most element at each node.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">  ++Path.back();</td>
    <td class="lineNumber">499</td>
    <td class="codeline">  ++Path.back();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">  Type *DeeperType =</td>
    <td class="lineNumber">500</td>
    <td class="codeline">  Type *DeeperType =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline">      ExtractValueInst::getIndexedType(SubTypes.back(), Path.back());</td>
    <td class="lineNumber">501</td>
    <td class="codeline">      ExtractValueInst::getIndexedType(SubTypes.back(), Path.back());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">  while (DeeperType->isAggregateType()) {</td>
    <td class="lineNumber">502</td>
    <td class="codeline">  while (DeeperType->isAggregateType()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">    if (!indexReallyValid(DeeperType, 0))</td>
    <td class="lineNumber">503</td>
    <td class="codeline">    if (!indexReallyValid(DeeperType, 0))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">504</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline"></td>
    <td class="lineNumber">505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">    SubTypes.push_back(DeeperType);</td>
    <td class="lineNumber">506</td>
    <td class="codeline">    SubTypes.push_back(DeeperType);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">    Path.push_back(0);</td>
    <td class="lineNumber">507</td>
    <td class="codeline">    Path.push_back(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline"></td>
    <td class="lineNumber">508</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">    DeeperType = ExtractValueInst::getIndexedType(DeeperType, 0);</td>
    <td class="lineNumber">509</td>
    <td class="codeline">    DeeperType = ExtractValueInst::getIndexedType(DeeperType, 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">510</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline"></td>
    <td class="lineNumber">511</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline">}</td>
    <td class="lineNumber">513</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline"></td>
    <td class="lineNumber">514</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">/// Find the first non-empty, scalar-like type in Next and setup the iterator</td>
    <td class="lineNumber">515</td>
    <td class="codeline">/// Find the first non-empty, scalar-like type in Next and setup the iterator</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">/// components.</td>
    <td class="lineNumber">516</td>
    <td class="codeline">/// components.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">///</td>
    <td class="lineNumber">517</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">/// Assuming Next is an aggregate of some kind, this function will traverse the</td>
    <td class="lineNumber">518</td>
    <td class="codeline">/// Assuming Next is an aggregate of some kind, this function will traverse the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">/// tree from left to right (i.e. depth-first) looking for the first</td>
    <td class="lineNumber">519</td>
    <td class="codeline">/// tree from left to right (i.e. depth-first) looking for the first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">/// non-aggregate type which will play a role in function return.</td>
    <td class="lineNumber">520</td>
    <td class="codeline">/// non-aggregate type which will play a role in function return.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">///</td>
    <td class="lineNumber">521</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">/// For example, if Next was {[0 x i64], {{}, i32, {}}, i32} then we would setup</td>
    <td class="lineNumber">522</td>
    <td class="codeline">/// For example, if Next was {[0 x i64], {{}, i32, {}}, i32} then we would setup</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">/// Path as [1, 1] and SubTypes as [Next, {{}, i32, {}}] to represent the first</td>
    <td class="lineNumber">523</td>
    <td class="codeline">/// Path as [1, 1] and SubTypes as [Next, {{}, i32, {}}] to represent the first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">/// i32 in that type.</td>
    <td class="lineNumber">524</td>
    <td class="codeline">/// i32 in that type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">static bool firstRealType(Type *Next, SmallVectorImpl<Type *> &SubTypes,</td>
    <td class="lineNumber">525</td>
    <td class="codeline">static bool firstRealType(Type *Next, SmallVectorImpl<Type *> &SubTypes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">                          SmallVectorImpl<unsigned> &Path) {</td>
    <td class="lineNumber">526</td>
    <td class="codeline">                          SmallVectorImpl<unsigned> &Path) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  // First initialise the iterator components to the first "leaf" node</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  // First initialise the iterator components to the first "leaf" node</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">  // (i.e. node with no valid sub-type at any index, so {} does count as a leaf</td>
    <td class="lineNumber">528</td>
    <td class="codeline">  // (i.e. node with no valid sub-type at any index, so {} does count as a leaf</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline">  // despite nominally being an aggregate).</td>
    <td class="lineNumber">529</td>
    <td class="codeline">  // despite nominally being an aggregate).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">  while (Type *FirstInner = ExtractValueInst::getIndexedType(Next, 0)) {</td>
    <td class="lineNumber">530</td>
    <td class="codeline">  while (Type *FirstInner = ExtractValueInst::getIndexedType(Next, 0)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">    SubTypes.push_back(Next);</td>
    <td class="lineNumber">531</td>
    <td class="codeline">    SubTypes.push_back(Next);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">    Path.push_back(0);</td>
    <td class="lineNumber">532</td>
    <td class="codeline">    Path.push_back(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline">    Next = FirstInner;</td>
    <td class="lineNumber">533</td>
    <td class="codeline">    Next = FirstInner;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">534</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline"></td>
    <td class="lineNumber">535</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  // If there's no Path now, Next was originally scalar already (or empty</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  // If there's no Path now, Next was originally scalar already (or empty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  // leaf). We're done.</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  // leaf). We're done.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">  if (Path.empty())</td>
    <td class="lineNumber">538</td>
    <td class="codeline">  if (Path.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">539</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  // Otherwise, use normal iteration to keep looking through the tree until we</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  // Otherwise, use normal iteration to keep looking through the tree until we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">  // find a non-aggregate type.</td>
    <td class="lineNumber">542</td>
    <td class="codeline">  // find a non-aggregate type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">  while (ExtractValueInst::getIndexedType(SubTypes.back(), Path.back())</td>
    <td class="lineNumber">543</td>
    <td class="codeline">  while (ExtractValueInst::getIndexedType(SubTypes.back(), Path.back())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">             ->isAggregateType()) {</td>
    <td class="lineNumber">544</td>
    <td class="codeline">             ->isAggregateType()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">    if (!advanceToNextLeafType(SubTypes, Path))</td>
    <td class="lineNumber">545</td>
    <td class="codeline">    if (!advanceToNextLeafType(SubTypes, Path))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">546</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">547</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline"></td>
    <td class="lineNumber">548</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">549</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">}</td>
    <td class="lineNumber">550</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline"></td>
    <td class="lineNumber">551</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">/// Set the iterator data-structures to the next non-empty, non-aggregate</td>
    <td class="lineNumber">552</td>
    <td class="codeline">/// Set the iterator data-structures to the next non-empty, non-aggregate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">/// subtype.</td>
    <td class="lineNumber">553</td>
    <td class="codeline">/// subtype.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline">static bool nextRealType(SmallVectorImpl<Type *> &SubTypes,</td>
    <td class="lineNumber">554</td>
    <td class="codeline">static bool nextRealType(SmallVectorImpl<Type *> &SubTypes,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">                         SmallVectorImpl<unsigned> &Path) {</td>
    <td class="lineNumber">555</td>
    <td class="codeline">                         SmallVectorImpl<unsigned> &Path) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">  do {</td>
    <td class="lineNumber">556</td>
    <td class="codeline">  do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">    if (!advanceToNextLeafType(SubTypes, Path))</td>
    <td class="lineNumber">557</td>
    <td class="codeline">    if (!advanceToNextLeafType(SubTypes, Path))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">558</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline"></td>
    <td class="lineNumber">559</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">    assert(!Path.empty() && "found a leaf but didn't set the path?");</td>
    <td class="lineNumber">560</td>
    <td class="codeline">    assert(!Path.empty() && "found a leaf but didn't set the path?");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">  } while (ExtractValueInst::getIndexedType(SubTypes.back(), Path.back())</td>
    <td class="lineNumber">561</td>
    <td class="codeline">  } while (ExtractValueInst::getIndexedType(SubTypes.back(), Path.back())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline">               ->isAggregateType());</td>
    <td class="lineNumber">562</td>
    <td class="codeline">               ->isAggregateType());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline"></td>
    <td class="lineNumber">563</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">564</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline">}</td>
    <td class="lineNumber">565</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline"></td>
    <td class="lineNumber">566</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline"></td>
    <td class="lineNumber">567</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">/// Test if the given instruction is in a position to be optimized</td>
    <td class="lineNumber">568</td>
    <td class="codeline">/// Test if the given instruction is in a position to be optimized</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">/// with a tail-call. This roughly means that it's in a block with</td>
    <td class="lineNumber">569</td>
    <td class="codeline">/// with a tail-call. This roughly means that it's in a block with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">/// a return and there's nothing that needs to be scheduled</td>
    <td class="lineNumber">570</td>
    <td class="codeline">/// a return and there's nothing that needs to be scheduled</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">/// between it and the return.</td>
    <td class="lineNumber">571</td>
    <td class="codeline">/// between it and the return.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">///</td>
    <td class="lineNumber">572</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">/// This function only tests target-independent requirements.</td>
    <td class="lineNumber">573</td>
    <td class="codeline">/// This function only tests target-independent requirements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">bool llvm::isInTailCallPosition(const CallBase &Call, const TargetMachine &TM) {</td>
    <td class="lineNumber">574</td>
    <td class="codeline">bool llvm::isInTailCallPosition(const CallBase &Call, const TargetMachine &TM) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">  const BasicBlock *ExitBB = Call.getParent();</td>
    <td class="lineNumber">575</td>
    <td class="codeline">  const BasicBlock *ExitBB = Call.getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  const Instruction *Term = ExitBB->getTerminator();</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  const Instruction *Term = ExitBB->getTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  const ReturnInst *Ret = dyn_cast<ReturnInst>(Term);</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  const ReturnInst *Ret = dyn_cast<ReturnInst>(Term);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline"></td>
    <td class="lineNumber">578</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">  // The block must end in a return statement or unreachable.</td>
    <td class="lineNumber">579</td>
    <td class="codeline">  // The block must end in a return statement or unreachable.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">580</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">  // FIXME: Decline tailcall if it's not guaranteed and if the block ends in</td>
    <td class="lineNumber">581</td>
    <td class="codeline">  // FIXME: Decline tailcall if it's not guaranteed and if the block ends in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">  // an unreachable, for now. The way tailcall optimization is currently</td>
    <td class="lineNumber">582</td>
    <td class="codeline">  // an unreachable, for now. The way tailcall optimization is currently</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">  // implemented means it will add an epilogue followed by a jump. That is</td>
    <td class="lineNumber">583</td>
    <td class="codeline">  // implemented means it will add an epilogue followed by a jump. That is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">  // not profitable. Also, if the callee is a special function (e.g.</td>
    <td class="lineNumber">584</td>
    <td class="codeline">  // not profitable. Also, if the callee is a special function (e.g.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">  // longjmp on x86), it can end up causing miscompilation that has not</td>
    <td class="lineNumber">585</td>
    <td class="codeline">  // longjmp on x86), it can end up causing miscompilation that has not</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">  // been fully understood.</td>
    <td class="lineNumber">586</td>
    <td class="codeline">  // been fully understood.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">  if (!Ret && ((!TM.Options.GuaranteedTailCallOpt &&</td>
    <td class="lineNumber">587</td>
    <td class="codeline">  if (!Ret && ((!TM.Options.GuaranteedTailCallOpt &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">                Call.getCallingConv() != CallingConv::Tail &&</td>
    <td class="lineNumber">588</td>
    <td class="codeline">                Call.getCallingConv() != CallingConv::Tail &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">                Call.getCallingConv() != CallingConv::SwiftTail) ||</td>
    <td class="lineNumber">589</td>
    <td class="codeline">                Call.getCallingConv() != CallingConv::SwiftTail) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">               !isa<UnreachableInst>(Term)))</td>
    <td class="lineNumber">590</td>
    <td class="codeline">               !isa<UnreachableInst>(Term)))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">591</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline"></td>
    <td class="lineNumber">592</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">  // If I will have a chain, make sure no other instruction that will have a</td>
    <td class="lineNumber">593</td>
    <td class="codeline">  // If I will have a chain, make sure no other instruction that will have a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">  // chain interposes between I and the return.</td>
    <td class="lineNumber">594</td>
    <td class="codeline">  // chain interposes between I and the return.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">  // Check for all calls including speculatable functions.</td>
    <td class="lineNumber">595</td>
    <td class="codeline">  // Check for all calls including speculatable functions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  for (BasicBlock::const_iterator BBI = std::prev(ExitBB->end(), 2);; --BBI) {</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  for (BasicBlock::const_iterator BBI = std::prev(ExitBB->end(), 2);; --BBI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">    if (&*BBI == &Call)</td>
    <td class="lineNumber">597</td>
    <td class="codeline">    if (&*BBI == &Call)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">      break;</td>
    <td class="lineNumber">598</td>
    <td class="codeline">      break;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">    // Debug info intrinsics do not get in the way of tail call optimization.</td>
    <td class="lineNumber">599</td>
    <td class="codeline">    // Debug info intrinsics do not get in the way of tail call optimization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">    // Pseudo probe intrinsics do not block tail call optimization either.</td>
    <td class="lineNumber">600</td>
    <td class="codeline">    // Pseudo probe intrinsics do not block tail call optimization either.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">    if (BBI->isDebugOrPseudoInst())</td>
    <td class="lineNumber">601</td>
    <td class="codeline">    if (BBI->isDebugOrPseudoInst())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">602</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">    // A lifetime end, assume or noalias.decl intrinsic should not stop tail</td>
    <td class="lineNumber">603</td>
    <td class="codeline">    // A lifetime end, assume or noalias.decl intrinsic should not stop tail</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">    // call optimization.</td>
    <td class="lineNumber">604</td>
    <td class="codeline">    // call optimization.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">    if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(BBI))</td>
    <td class="lineNumber">605</td>
    <td class="codeline">    if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(BBI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">      if (II->getIntrinsicID() == Intrinsic::lifetime_end ||</td>
    <td class="lineNumber">606</td>
    <td class="codeline">      if (II->getIntrinsicID() == Intrinsic::lifetime_end ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">          II->getIntrinsicID() == Intrinsic::assume ||</td>
    <td class="lineNumber">607</td>
    <td class="codeline">          II->getIntrinsicID() == Intrinsic::assume ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">          II->getIntrinsicID() == Intrinsic::experimental_noalias_scope_decl)</td>
    <td class="lineNumber">608</td>
    <td class="codeline">          II->getIntrinsicID() == Intrinsic::experimental_noalias_scope_decl)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">        continue;</td>
    <td class="lineNumber">609</td>
    <td class="codeline">        continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">    if (BBI->mayHaveSideEffects() || BBI->mayReadFromMemory() ||</td>
    <td class="lineNumber">610</td>
    <td class="codeline">    if (BBI->mayHaveSideEffects() || BBI->mayReadFromMemory() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">        !isSafeToSpeculativelyExecute(&*BBI))</td>
    <td class="lineNumber">611</td>
    <td class="codeline">        !isSafeToSpeculativelyExecute(&*BBI))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">612</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">613</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
    <td class="lineNumber">614</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">  const Function *F = ExitBB->getParent();</td>
    <td class="lineNumber">615</td>
    <td class="codeline">  const Function *F = ExitBB->getParent();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  return returnTypeIsEligibleForTailCall(</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  return returnTypeIsEligibleForTailCall(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">      F, &Call, Ret, *TM.getSubtargetImpl(*F)->getTargetLowering());</td>
    <td class="lineNumber">617</td>
    <td class="codeline">      F, &Call, Ret, *TM.getSubtargetImpl(*F)->getTargetLowering());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">}</td>
    <td class="lineNumber">618</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline"></td>
    <td class="lineNumber">619</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">bool llvm::attributesPermitTailCall(const Function *F, const Instruction *I,</td>
    <td class="lineNumber">620</td>
    <td class="codeline">bool llvm::attributesPermitTailCall(const Function *F, const Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">                                    const ReturnInst *Ret,</td>
    <td class="lineNumber">621</td>
    <td class="codeline">                                    const ReturnInst *Ret,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">                                    const TargetLoweringBase &TLI,</td>
    <td class="lineNumber">622</td>
    <td class="codeline">                                    const TargetLoweringBase &TLI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline">                                    bool *AllowDifferingSizes) {</td>
    <td class="lineNumber">623</td>
    <td class="codeline">                                    bool *AllowDifferingSizes) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">  // ADS may be null, so don't write to it directly.</td>
    <td class="lineNumber">624</td>
    <td class="codeline">  // ADS may be null, so don't write to it directly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">  bool DummyADS;</td>
    <td class="lineNumber">625</td>
    <td class="codeline">  bool DummyADS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  bool &ADS = AllowDifferingSizes ? *AllowDifferingSizes : DummyADS;</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  bool &ADS = AllowDifferingSizes ? *AllowDifferingSizes : DummyADS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">  ADS = true;</td>
    <td class="lineNumber">627</td>
    <td class="codeline">  ADS = true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
    <td class="lineNumber">628</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">  AttrBuilder CallerAttrs(F->getContext(), F->getAttributes().getRetAttrs());</td>
    <td class="lineNumber">629</td>
    <td class="codeline">  AttrBuilder CallerAttrs(F->getContext(), F->getAttributes().getRetAttrs());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline">  AttrBuilder CalleeAttrs(F->getContext(),</td>
    <td class="lineNumber">630</td>
    <td class="codeline">  AttrBuilder CalleeAttrs(F->getContext(),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">                          cast<CallInst>(I)->getAttributes().getRetAttrs());</td>
    <td class="lineNumber">631</td>
    <td class="codeline">                          cast<CallInst>(I)->getAttributes().getRetAttrs());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline"></td>
    <td class="lineNumber">632</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  // Following attributes are completely benign as far as calling convention</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  // Following attributes are completely benign as far as calling convention</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">  // goes, they shouldn't affect whether the call is a tail call.</td>
    <td class="lineNumber">634</td>
    <td class="codeline">  // goes, they shouldn't affect whether the call is a tail call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">  for (const auto &Attr : {Attribute::Alignment, Attribute::Dereferenceable,</td>
    <td class="lineNumber">635</td>
    <td class="codeline">  for (const auto &Attr : {Attribute::Alignment, Attribute::Dereferenceable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">                           Attribute::DereferenceableOrNull, Attribute::NoAlias,</td>
    <td class="lineNumber">636</td>
    <td class="codeline">                           Attribute::DereferenceableOrNull, Attribute::NoAlias,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">                           Attribute::NonNull, Attribute::NoUndef}) {</td>
    <td class="lineNumber">637</td>
    <td class="codeline">                           Attribute::NonNull, Attribute::NoUndef}) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">    CallerAttrs.removeAttribute(Attr);</td>
    <td class="lineNumber">638</td>
    <td class="codeline">    CallerAttrs.removeAttribute(Attr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">    CalleeAttrs.removeAttribute(Attr);</td>
    <td class="lineNumber">639</td>
    <td class="codeline">    CalleeAttrs.removeAttribute(Attr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">640</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline"></td>
    <td class="lineNumber">641</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">  if (CallerAttrs.contains(Attribute::ZExt)) {</td>
    <td class="lineNumber">642</td>
    <td class="codeline">  if (CallerAttrs.contains(Attribute::ZExt)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">    if (!CalleeAttrs.contains(Attribute::ZExt))</td>
    <td class="lineNumber">643</td>
    <td class="codeline">    if (!CalleeAttrs.contains(Attribute::ZExt))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">644</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline"></td>
    <td class="lineNumber">645</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">    ADS = false;</td>
    <td class="lineNumber">646</td>
    <td class="codeline">    ADS = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">    CallerAttrs.removeAttribute(Attribute::ZExt);</td>
    <td class="lineNumber">647</td>
    <td class="codeline">    CallerAttrs.removeAttribute(Attribute::ZExt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">    CalleeAttrs.removeAttribute(Attribute::ZExt);</td>
    <td class="lineNumber">648</td>
    <td class="codeline">    CalleeAttrs.removeAttribute(Attribute::ZExt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  } else if (CallerAttrs.contains(Attribute::SExt)) {</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  } else if (CallerAttrs.contains(Attribute::SExt)) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">    if (!CalleeAttrs.contains(Attribute::SExt))</td>
    <td class="lineNumber">650</td>
    <td class="codeline">    if (!CalleeAttrs.contains(Attribute::SExt))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">651</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline"></td>
    <td class="lineNumber">652</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">    ADS = false;</td>
    <td class="lineNumber">653</td>
    <td class="codeline">    ADS = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">    CallerAttrs.removeAttribute(Attribute::SExt);</td>
    <td class="lineNumber">654</td>
    <td class="codeline">    CallerAttrs.removeAttribute(Attribute::SExt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline">    CalleeAttrs.removeAttribute(Attribute::SExt);</td>
    <td class="lineNumber">655</td>
    <td class="codeline">    CalleeAttrs.removeAttribute(Attribute::SExt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
    <td class="lineNumber">657</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline">  // Drop sext and zext return attributes if the result is not used.</td>
    <td class="lineNumber">658</td>
    <td class="codeline">  // Drop sext and zext return attributes if the result is not used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">  // This enables tail calls for code like:</td>
    <td class="lineNumber">659</td>
    <td class="codeline">  // This enables tail calls for code like:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">660</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline">  // define void @caller() {</td>
    <td class="lineNumber">661</td>
    <td class="codeline">  // define void @caller() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">  // entry:</td>
    <td class="lineNumber">662</td>
    <td class="codeline">  // entry:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">  //   %unused_result = tail call zeroext i1 @callee()</td>
    <td class="lineNumber">663</td>
    <td class="codeline">  //   %unused_result = tail call zeroext i1 @callee()</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">  //   br label %retlabel</td>
    <td class="lineNumber">664</td>
    <td class="codeline">  //   br label %retlabel</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">  // retlabel:</td>
    <td class="lineNumber">665</td>
    <td class="codeline">  // retlabel:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">  //   ret void</td>
    <td class="lineNumber">666</td>
    <td class="codeline">  //   ret void</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline">  // }</td>
    <td class="lineNumber">667</td>
    <td class="codeline">  // }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">  if (I->use_empty()) {</td>
    <td class="lineNumber">668</td>
    <td class="codeline">  if (I->use_empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">    CalleeAttrs.removeAttribute(Attribute::SExt);</td>
    <td class="lineNumber">669</td>
    <td class="codeline">    CalleeAttrs.removeAttribute(Attribute::SExt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">    CalleeAttrs.removeAttribute(Attribute::ZExt);</td>
    <td class="lineNumber">670</td>
    <td class="codeline">    CalleeAttrs.removeAttribute(Attribute::ZExt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">671</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">  // If they're still different, there's some facet we don't understand</td>
    <td class="lineNumber">673</td>
    <td class="codeline">  // If they're still different, there's some facet we don't understand</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  // (currently only "inreg", but in future who knows). It may be OK but the</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  // (currently only "inreg", but in future who knows). It may be OK but the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline">  // only safe option is to reject the tail call.</td>
    <td class="lineNumber">675</td>
    <td class="codeline">  // only safe option is to reject the tail call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">  return CallerAttrs == CalleeAttrs;</td>
    <td class="lineNumber">676</td>
    <td class="codeline">  return CallerAttrs == CalleeAttrs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">}</td>
    <td class="lineNumber">677</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline"></td>
    <td class="lineNumber">678</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">/// Check whether B is a bitcast of a pointer type to another pointer type,</td>
    <td class="lineNumber">679</td>
    <td class="codeline">/// Check whether B is a bitcast of a pointer type to another pointer type,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">/// which is equal to A.</td>
    <td class="lineNumber">680</td>
    <td class="codeline">/// which is equal to A.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline">static bool isPointerBitcastEqualTo(const Value *A, const Value *B) {</td>
    <td class="lineNumber">681</td>
    <td class="codeline">static bool isPointerBitcastEqualTo(const Value *A, const Value *B) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">  assert(A && B && "Expected non-null inputs!");</td>
    <td class="lineNumber">682</td>
    <td class="codeline">  assert(A && B && "Expected non-null inputs!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
    <td class="lineNumber">683</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline">  auto *BitCastIn = dyn_cast<BitCastInst>(B);</td>
    <td class="lineNumber">684</td>
    <td class="codeline">  auto *BitCastIn = dyn_cast<BitCastInst>(B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
    <td class="lineNumber">685</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  if (!BitCastIn)</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  if (!BitCastIn)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">687</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline"></td>
    <td class="lineNumber">688</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">  if (!A->getType()->isPointerTy() || !B->getType()->isPointerTy())</td>
    <td class="lineNumber">689</td>
    <td class="codeline">  if (!A->getType()->isPointerTy() || !B->getType()->isPointerTy())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">690</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  return A == BitCastIn->getOperand(0);</td>
    <td class="lineNumber">692</td>
    <td class="codeline">  return A == BitCastIn->getOperand(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">}</td>
    <td class="lineNumber">693</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline"></td>
    <td class="lineNumber">694</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">bool llvm::returnTypeIsEligibleForTailCall(const Function *F,</td>
    <td class="lineNumber">695</td>
    <td class="codeline">bool llvm::returnTypeIsEligibleForTailCall(const Function *F,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">                                           const Instruction *I,</td>
    <td class="lineNumber">696</td>
    <td class="codeline">                                           const Instruction *I,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">                                           const ReturnInst *Ret,</td>
    <td class="lineNumber">697</td>
    <td class="codeline">                                           const ReturnInst *Ret,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">                                           const TargetLoweringBase &TLI) {</td>
    <td class="lineNumber">698</td>
    <td class="codeline">                                           const TargetLoweringBase &TLI) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">  // If the block ends with a void return or unreachable, it doesn't matter</td>
    <td class="lineNumber">699</td>
    <td class="codeline">  // If the block ends with a void return or unreachable, it doesn't matter</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">  // what the call's return type is.</td>
    <td class="lineNumber">700</td>
    <td class="codeline">  // what the call's return type is.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">  if (!Ret || Ret->getNumOperands() == 0) return true;</td>
    <td class="lineNumber">701</td>
    <td class="codeline">  if (!Ret || Ret->getNumOperands() == 0) return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline"></td>
    <td class="lineNumber">702</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">  // If the return value is undef, it doesn't matter what the call's</td>
    <td class="lineNumber">703</td>
    <td class="codeline">  // If the return value is undef, it doesn't matter what the call's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">  // return type is.</td>
    <td class="lineNumber">704</td>
    <td class="codeline">  // return type is.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">  if (isa<UndefValue>(Ret->getOperand(0))) return true;</td>
    <td class="lineNumber">705</td>
    <td class="codeline">  if (isa<UndefValue>(Ret->getOperand(0))) return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline"></td>
    <td class="lineNumber">706</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">  // Make sure the attributes attached to each return are compatible.</td>
    <td class="lineNumber">707</td>
    <td class="codeline">  // Make sure the attributes attached to each return are compatible.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">  bool AllowDifferingSizes;</td>
    <td class="lineNumber">708</td>
    <td class="codeline">  bool AllowDifferingSizes;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">  if (!attributesPermitTailCall(F, I, Ret, TLI, &AllowDifferingSizes))</td>
    <td class="lineNumber">709</td>
    <td class="codeline">  if (!attributesPermitTailCall(F, I, Ret, TLI, &AllowDifferingSizes))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">    return false;</td>
    <td class="lineNumber">710</td>
    <td class="codeline">    return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
    <td class="lineNumber">711</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline">  const Value *RetVal = Ret->getOperand(0), *CallVal = I;</td>
    <td class="lineNumber">712</td>
    <td class="codeline">  const Value *RetVal = Ret->getOperand(0), *CallVal = I;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">  // Intrinsic like llvm.memcpy has no return value, but the expanded</td>
    <td class="lineNumber">713</td>
    <td class="codeline">  // Intrinsic like llvm.memcpy has no return value, but the expanded</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">  // libcall may or may not have return value. On most platforms, it</td>
    <td class="lineNumber">714</td>
    <td class="codeline">  // libcall may or may not have return value. On most platforms, it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">  // will be expanded as memcpy in libc, which returns the first</td>
    <td class="lineNumber">715</td>
    <td class="codeline">  // will be expanded as memcpy in libc, which returns the first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">  // argument. On other platforms like arm-none-eabi, memcpy may be</td>
    <td class="lineNumber">716</td>
    <td class="codeline">  // argument. On other platforms like arm-none-eabi, memcpy may be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline">  // expanded as library call without return value, like __aeabi_memcpy.</td>
    <td class="lineNumber">717</td>
    <td class="codeline">  // expanded as library call without return value, like __aeabi_memcpy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">  const CallInst *Call = cast<CallInst>(I);</td>
    <td class="lineNumber">718</td>
    <td class="codeline">  const CallInst *Call = cast<CallInst>(I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">  if (Function *F = Call->getCalledFunction()) {</td>
    <td class="lineNumber">719</td>
    <td class="codeline">  if (Function *F = Call->getCalledFunction()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">    Intrinsic::ID IID = F->getIntrinsicID();</td>
    <td class="lineNumber">720</td>
    <td class="codeline">    Intrinsic::ID IID = F->getIntrinsicID();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">    if (((IID == Intrinsic::memcpy &&</td>
    <td class="lineNumber">721</td>
    <td class="codeline">    if (((IID == Intrinsic::memcpy &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline">          TLI.getLibcallName(RTLIB::MEMCPY) == StringRef("memcpy")) ||</td>
    <td class="lineNumber">722</td>
    <td class="codeline">          TLI.getLibcallName(RTLIB::MEMCPY) == StringRef("memcpy")) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">         (IID == Intrinsic::memmove &&</td>
    <td class="lineNumber">723</td>
    <td class="codeline">         (IID == Intrinsic::memmove &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">          TLI.getLibcallName(RTLIB::MEMMOVE) == StringRef("memmove")) ||</td>
    <td class="lineNumber">724</td>
    <td class="codeline">          TLI.getLibcallName(RTLIB::MEMMOVE) == StringRef("memmove")) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">         (IID == Intrinsic::memset &&</td>
    <td class="lineNumber">725</td>
    <td class="codeline">         (IID == Intrinsic::memset &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">          TLI.getLibcallName(RTLIB::MEMSET) == StringRef("memset"))) &&</td>
    <td class="lineNumber">726</td>
    <td class="codeline">          TLI.getLibcallName(RTLIB::MEMSET) == StringRef("memset"))) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline">        (RetVal == Call->getArgOperand(0) ||</td>
    <td class="lineNumber">727</td>
    <td class="codeline">        (RetVal == Call->getArgOperand(0) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">         isPointerBitcastEqualTo(RetVal, Call->getArgOperand(0))))</td>
    <td class="lineNumber">728</td>
    <td class="codeline">         isPointerBitcastEqualTo(RetVal, Call->getArgOperand(0))))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">      return true;</td>
    <td class="lineNumber">729</td>
    <td class="codeline">      return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">730</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline"></td>
    <td class="lineNumber">731</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline">  SmallVector<unsigned, 4> RetPath, CallPath;</td>
    <td class="lineNumber">732</td>
    <td class="codeline">  SmallVector<unsigned, 4> RetPath, CallPath;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">  SmallVector<Type *, 4> RetSubTypes, CallSubTypes;</td>
    <td class="lineNumber">733</td>
    <td class="codeline">  SmallVector<Type *, 4> RetSubTypes, CallSubTypes;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline"></td>
    <td class="lineNumber">734</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">  bool RetEmpty = !firstRealType(RetVal->getType(), RetSubTypes, RetPath);</td>
    <td class="lineNumber">735</td>
    <td class="codeline">  bool RetEmpty = !firstRealType(RetVal->getType(), RetSubTypes, RetPath);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">  bool CallEmpty = !firstRealType(CallVal->getType(), CallSubTypes, CallPath);</td>
    <td class="lineNumber">736</td>
    <td class="codeline">  bool CallEmpty = !firstRealType(CallVal->getType(), CallSubTypes, CallPath);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  // Nothing's actually returned, it doesn't matter what the callee put there</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  // Nothing's actually returned, it doesn't matter what the callee put there</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">  // it's a valid tail call.</td>
    <td class="lineNumber">739</td>
    <td class="codeline">  // it's a valid tail call.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">  if (RetEmpty)</td>
    <td class="lineNumber">740</td>
    <td class="codeline">  if (RetEmpty)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline">    return true;</td>
    <td class="lineNumber">741</td>
    <td class="codeline">    return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline"></td>
    <td class="lineNumber">742</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">  // Iterate pairwise through each of the value types making up the tail call</td>
    <td class="lineNumber">743</td>
    <td class="codeline">  // Iterate pairwise through each of the value types making up the tail call</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">  // and the corresponding return. For each one we want to know whether it's</td>
    <td class="lineNumber">744</td>
    <td class="codeline">  // and the corresponding return. For each one we want to know whether it's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline">  // essentially going directly from the tail call to the ret, via operations</td>
    <td class="lineNumber">745</td>
    <td class="codeline">  // essentially going directly from the tail call to the ret, via operations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  // that end up not generating any code.</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  // that end up not generating any code.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">  //</td>
    <td class="lineNumber">747</td>
    <td class="codeline">  //</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">  // We allow a certain amount of covariance here. For example it's permitted</td>
    <td class="lineNumber">748</td>
    <td class="codeline">  // We allow a certain amount of covariance here. For example it's permitted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">  // for the tail call to define more bits than the ret actually cares about</td>
    <td class="lineNumber">749</td>
    <td class="codeline">  // for the tail call to define more bits than the ret actually cares about</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline">  // (e.g. via a truncate).</td>
    <td class="lineNumber">750</td>
    <td class="codeline">  // (e.g. via a truncate).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">  do {</td>
    <td class="lineNumber">751</td>
    <td class="codeline">  do {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">    if (CallEmpty) {</td>
    <td class="lineNumber">752</td>
    <td class="codeline">    if (CallEmpty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">      // We've exhausted the values produced by the tail call instruction, the</td>
    <td class="lineNumber">753</td>
    <td class="codeline">      // We've exhausted the values produced by the tail call instruction, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">      // rest are essentially undef. The type doesn't really matter, but we need</td>
    <td class="lineNumber">754</td>
    <td class="codeline">      // rest are essentially undef. The type doesn't really matter, but we need</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline">      // *something*.</td>
    <td class="lineNumber">755</td>
    <td class="codeline">      // *something*.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">      Type *SlotType =</td>
    <td class="lineNumber">756</td>
    <td class="codeline">      Type *SlotType =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">          ExtractValueInst::getIndexedType(RetSubTypes.back(), RetPath.back());</td>
    <td class="lineNumber">757</td>
    <td class="codeline">          ExtractValueInst::getIndexedType(RetSubTypes.back(), RetPath.back());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">      CallVal = UndefValue::get(SlotType);</td>
    <td class="lineNumber">758</td>
    <td class="codeline">      CallVal = UndefValue::get(SlotType);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">759</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline"></td>
    <td class="lineNumber">760</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline">    // The manipulations performed when we're looking through an insertvalue or</td>
    <td class="lineNumber">761</td>
    <td class="codeline">    // The manipulations performed when we're looking through an insertvalue or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">    // an extractvalue would happen at the front of the RetPath list, so since</td>
    <td class="lineNumber">762</td>
    <td class="codeline">    // an extractvalue would happen at the front of the RetPath list, so since</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">    // we have to copy it anyway it's more efficient to create a reversed copy.</td>
    <td class="lineNumber">763</td>
    <td class="codeline">    // we have to copy it anyway it's more efficient to create a reversed copy.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline">    SmallVector<unsigned, 4> TmpRetPath(llvm::reverse(RetPath));</td>
    <td class="lineNumber">764</td>
    <td class="codeline">    SmallVector<unsigned, 4> TmpRetPath(llvm::reverse(RetPath));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">    SmallVector<unsigned, 4> TmpCallPath(llvm::reverse(CallPath));</td>
    <td class="lineNumber">765</td>
    <td class="codeline">    SmallVector<unsigned, 4> TmpCallPath(llvm::reverse(CallPath));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
    <td class="lineNumber">766</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">    // Finally, we can check whether the value produced by the tail call at this</td>
    <td class="lineNumber">767</td>
    <td class="codeline">    // Finally, we can check whether the value produced by the tail call at this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">    // index is compatible with the value we return.</td>
    <td class="lineNumber">768</td>
    <td class="codeline">    // index is compatible with the value we return.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">    if (!slotOnlyDiscardsData(RetVal, CallVal, TmpRetPath, TmpCallPath,</td>
    <td class="lineNumber">769</td>
    <td class="codeline">    if (!slotOnlyDiscardsData(RetVal, CallVal, TmpRetPath, TmpCallPath,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">                              AllowDifferingSizes, TLI,</td>
    <td class="lineNumber">770</td>
    <td class="codeline">                              AllowDifferingSizes, TLI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">                              F->getParent()->getDataLayout()))</td>
    <td class="lineNumber">771</td>
    <td class="codeline">                              F->getParent()->getDataLayout()))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">      return false;</td>
    <td class="lineNumber">772</td>
    <td class="codeline">      return false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline"></td>
    <td class="lineNumber">773</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">    CallEmpty  = !nextRealType(CallSubTypes, CallPath);</td>
    <td class="lineNumber">774</td>
    <td class="codeline">    CallEmpty  = !nextRealType(CallSubTypes, CallPath);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">  } while(nextRealType(RetSubTypes, RetPath));</td>
    <td class="lineNumber">775</td>
    <td class="codeline">  } while(nextRealType(RetSubTypes, RetPath));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline"></td>
    <td class="lineNumber">776</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">  return true;</td>
    <td class="lineNumber">777</td>
    <td class="codeline">  return true;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">}</td>
    <td class="lineNumber">778</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline"></td>
    <td class="lineNumber">779</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">static void collectEHScopeMembers(</td>
    <td class="lineNumber">780</td>
    <td class="codeline">static void collectEHScopeMembers(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">    DenseMap<const MachineBasicBlock *, int> &EHScopeMembership, int EHScope,</td>
    <td class="lineNumber">781</td>
    <td class="codeline">    DenseMap<const MachineBasicBlock *, int> &EHScopeMembership, int EHScope,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">    const MachineBasicBlock *MBB) {</td>
    <td class="lineNumber">782</td>
    <td class="codeline">    const MachineBasicBlock *MBB) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">  SmallVector<const MachineBasicBlock *, 16> Worklist = {MBB};</td>
    <td class="lineNumber">783</td>
    <td class="codeline">  SmallVector<const MachineBasicBlock *, 16> Worklist = {MBB};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">784</td>
    <td class="codeline">  while (!Worklist.empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline">    const MachineBasicBlock *Visiting = Worklist.pop_back_val();</td>
    <td class="lineNumber">785</td>
    <td class="codeline">    const MachineBasicBlock *Visiting = Worklist.pop_back_val();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">    // Don't follow blocks which start new scopes.</td>
    <td class="lineNumber">786</td>
    <td class="codeline">    // Don't follow blocks which start new scopes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">    if (Visiting->isEHPad() && Visiting != MBB)</td>
    <td class="lineNumber">787</td>
    <td class="codeline">    if (Visiting->isEHPad() && Visiting != MBB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">788</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline"></td>
    <td class="lineNumber">789</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">    // Add this MBB to our scope.</td>
    <td class="lineNumber">790</td>
    <td class="codeline">    // Add this MBB to our scope.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline">    auto P = EHScopeMembership.insert(std::make_pair(Visiting, EHScope));</td>
    <td class="lineNumber">791</td>
    <td class="codeline">    auto P = EHScopeMembership.insert(std::make_pair(Visiting, EHScope));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline"></td>
    <td class="lineNumber">792</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">    // Don't revisit blocks.</td>
    <td class="lineNumber">793</td>
    <td class="codeline">    // Don't revisit blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">    if (!P.second) {</td>
    <td class="lineNumber">794</td>
    <td class="codeline">    if (!P.second) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">      assert(P.first->second == EHScope && "MBB is part of two scopes!");</td>
    <td class="lineNumber">795</td>
    <td class="codeline">      assert(P.first->second == EHScope && "MBB is part of two scopes!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">796</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">797</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline"></td>
    <td class="lineNumber">798</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">    // Returns are boundaries where scope transfer can occur, don't follow</td>
    <td class="lineNumber">799</td>
    <td class="codeline">    // Returns are boundaries where scope transfer can occur, don't follow</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline">    // successors.</td>
    <td class="lineNumber">800</td>
    <td class="codeline">    // successors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">    if (Visiting->isEHScopeReturnBlock())</td>
    <td class="lineNumber">801</td>
    <td class="codeline">    if (Visiting->isEHScopeReturnBlock())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">802</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline"></td>
    <td class="lineNumber">803</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">    append_range(Worklist, Visiting->successors());</td>
    <td class="lineNumber">804</td>
    <td class="codeline">    append_range(Worklist, Visiting->successors());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">805</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">}</td>
    <td class="lineNumber">806</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
    <td class="lineNumber">807</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">DenseMap<const MachineBasicBlock *, int></td>
    <td class="lineNumber">808</td>
    <td class="codeline">DenseMap<const MachineBasicBlock *, int></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">llvm::getEHScopeMembership(const MachineFunction &MF) {</td>
    <td class="lineNumber">809</td>
    <td class="codeline">llvm::getEHScopeMembership(const MachineFunction &MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline">  DenseMap<const MachineBasicBlock *, int> EHScopeMembership;</td>
    <td class="lineNumber">810</td>
    <td class="codeline">  DenseMap<const MachineBasicBlock *, int> EHScopeMembership;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline"></td>
    <td class="lineNumber">811</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">  // We don't have anything to do if there aren't any EH pads.</td>
    <td class="lineNumber">812</td>
    <td class="codeline">  // We don't have anything to do if there aren't any EH pads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">  if (!MF.hasEHScopes())</td>
    <td class="lineNumber">813</td>
    <td class="codeline">  if (!MF.hasEHScopes())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">    return EHScopeMembership;</td>
    <td class="lineNumber">814</td>
    <td class="codeline">    return EHScopeMembership;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline"></td>
    <td class="lineNumber">815</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline">  int EntryBBNumber = MF.front().getNumber();</td>
    <td class="lineNumber">816</td>
    <td class="codeline">  int EntryBBNumber = MF.front().getNumber();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  bool IsSEH = isAsynchronousEHPersonality(</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  bool IsSEH = isAsynchronousEHPersonality(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">      classifyEHPersonality(MF.getFunction().getPersonalityFn()));</td>
    <td class="lineNumber">818</td>
    <td class="codeline">      classifyEHPersonality(MF.getFunction().getPersonalityFn()));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline"></td>
    <td class="lineNumber">819</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">  const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();</td>
    <td class="lineNumber">820</td>
    <td class="codeline">  const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">  SmallVector<const MachineBasicBlock *, 16> EHScopeBlocks;</td>
    <td class="lineNumber">821</td>
    <td class="codeline">  SmallVector<const MachineBasicBlock *, 16> EHScopeBlocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">  SmallVector<const MachineBasicBlock *, 16> UnreachableBlocks;</td>
    <td class="lineNumber">822</td>
    <td class="codeline">  SmallVector<const MachineBasicBlock *, 16> UnreachableBlocks;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">  SmallVector<const MachineBasicBlock *, 16> SEHCatchPads;</td>
    <td class="lineNumber">823</td>
    <td class="codeline">  SmallVector<const MachineBasicBlock *, 16> SEHCatchPads;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">  SmallVector<std::pair<const MachineBasicBlock *, int>, 16> CatchRetSuccessors;</td>
    <td class="lineNumber">824</td>
    <td class="codeline">  SmallVector<std::pair<const MachineBasicBlock *, int>, 16> CatchRetSuccessors;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">  for (const MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">825</td>
    <td class="codeline">  for (const MachineBasicBlock &MBB : MF) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">    if (MBB.isEHScopeEntry()) {</td>
    <td class="lineNumber">826</td>
    <td class="codeline">    if (MBB.isEHScopeEntry()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">      EHScopeBlocks.push_back(&MBB);</td>
    <td class="lineNumber">827</td>
    <td class="codeline">      EHScopeBlocks.push_back(&MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline">    } else if (IsSEH && MBB.isEHPad()) {</td>
    <td class="lineNumber">828</td>
    <td class="codeline">    } else if (IsSEH && MBB.isEHPad()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">      SEHCatchPads.push_back(&MBB);</td>
    <td class="lineNumber">829</td>
    <td class="codeline">      SEHCatchPads.push_back(&MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">    } else if (MBB.pred_empty()) {</td>
    <td class="lineNumber">830</td>
    <td class="codeline">    } else if (MBB.pred_empty()) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">      UnreachableBlocks.push_back(&MBB);</td>
    <td class="lineNumber">831</td>
    <td class="codeline">      UnreachableBlocks.push_back(&MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">832</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">    MachineBasicBlock::const_iterator MBBI = MBB.getFirstTerminator();</td>
    <td class="lineNumber">834</td>
    <td class="codeline">    MachineBasicBlock::const_iterator MBBI = MBB.getFirstTerminator();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
    <td class="lineNumber">835</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">    // CatchPads are not scopes for SEH so do not consider CatchRet to</td>
    <td class="lineNumber">836</td>
    <td class="codeline">    // CatchPads are not scopes for SEH so do not consider CatchRet to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">    // transfer control to another scope.</td>
    <td class="lineNumber">837</td>
    <td class="codeline">    // transfer control to another scope.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">    if (MBBI == MBB.end() || MBBI->getOpcode() != TII->getCatchReturnOpcode())</td>
    <td class="lineNumber">838</td>
    <td class="codeline">    if (MBBI == MBB.end() || MBBI->getOpcode() != TII->getCatchReturnOpcode())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">      continue;</td>
    <td class="lineNumber">839</td>
    <td class="codeline">      continue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline"></td>
    <td class="lineNumber">840</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">    // FIXME: SEH CatchPads are not necessarily in the parent function:</td>
    <td class="lineNumber">841</td>
    <td class="codeline">    // FIXME: SEH CatchPads are not necessarily in the parent function:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline">    // they could be inside a finally block.</td>
    <td class="lineNumber">842</td>
    <td class="codeline">    // they could be inside a finally block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">    const MachineBasicBlock *Successor = MBBI->getOperand(0).getMBB();</td>
    <td class="lineNumber">843</td>
    <td class="codeline">    const MachineBasicBlock *Successor = MBBI->getOperand(0).getMBB();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">    const MachineBasicBlock *SuccessorColor = MBBI->getOperand(1).getMBB();</td>
    <td class="lineNumber">844</td>
    <td class="codeline">    const MachineBasicBlock *SuccessorColor = MBBI->getOperand(1).getMBB();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">    CatchRetSuccessors.push_back(</td>
    <td class="lineNumber">845</td>
    <td class="codeline">    CatchRetSuccessors.push_back(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">        {Successor, IsSEH ? EntryBBNumber : SuccessorColor->getNumber()});</td>
    <td class="lineNumber">846</td>
    <td class="codeline">        {Successor, IsSEH ? EntryBBNumber : SuccessorColor->getNumber()});</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">847</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline"></td>
    <td class="lineNumber">848</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">  // We don't have anything to do if there aren't any EH pads.</td>
    <td class="lineNumber">849</td>
    <td class="codeline">  // We don't have anything to do if there aren't any EH pads.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">  if (EHScopeBlocks.empty())</td>
    <td class="lineNumber">850</td>
    <td class="codeline">  if (EHScopeBlocks.empty())</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">    return EHScopeMembership;</td>
    <td class="lineNumber">851</td>
    <td class="codeline">    return EHScopeMembership;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline"></td>
    <td class="lineNumber">852</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  // Identify all the basic blocks reachable from the function entry.</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  // Identify all the basic blocks reachable from the function entry.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">  collectEHScopeMembers(EHScopeMembership, EntryBBNumber, &MF.front());</td>
    <td class="lineNumber">854</td>
    <td class="codeline">  collectEHScopeMembers(EHScopeMembership, EntryBBNumber, &MF.front());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">  // All blocks not part of a scope are in the parent function.</td>
    <td class="lineNumber">855</td>
    <td class="codeline">  // All blocks not part of a scope are in the parent function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline">  for (const MachineBasicBlock *MBB : UnreachableBlocks)</td>
    <td class="lineNumber">856</td>
    <td class="codeline">  for (const MachineBasicBlock *MBB : UnreachableBlocks)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">    collectEHScopeMembers(EHScopeMembership, EntryBBNumber, MBB);</td>
    <td class="lineNumber">857</td>
    <td class="codeline">    collectEHScopeMembers(EHScopeMembership, EntryBBNumber, MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">  // Next, identify all the blocks inside the scopes.</td>
    <td class="lineNumber">858</td>
    <td class="codeline">  // Next, identify all the blocks inside the scopes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">  for (const MachineBasicBlock *MBB : EHScopeBlocks)</td>
    <td class="lineNumber">859</td>
    <td class="codeline">  for (const MachineBasicBlock *MBB : EHScopeBlocks)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">    collectEHScopeMembers(EHScopeMembership, MBB->getNumber(), MBB);</td>
    <td class="lineNumber">860</td>
    <td class="codeline">    collectEHScopeMembers(EHScopeMembership, MBB->getNumber(), MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">  // SEH CatchPads aren't really scopes, handle them separately.</td>
    <td class="lineNumber">861</td>
    <td class="codeline">  // SEH CatchPads aren't really scopes, handle them separately.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">  for (const MachineBasicBlock *MBB : SEHCatchPads)</td>
    <td class="lineNumber">862</td>
    <td class="codeline">  for (const MachineBasicBlock *MBB : SEHCatchPads)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">    collectEHScopeMembers(EHScopeMembership, EntryBBNumber, MBB);</td>
    <td class="lineNumber">863</td>
    <td class="codeline">    collectEHScopeMembers(EHScopeMembership, EntryBBNumber, MBB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">  // Finally, identify all the targets of a catchret.</td>
    <td class="lineNumber">864</td>
    <td class="codeline">  // Finally, identify all the targets of a catchret.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">  for (std::pair<const MachineBasicBlock *, int> CatchRetPair :</td>
    <td class="lineNumber">865</td>
    <td class="codeline">  for (std::pair<const MachineBasicBlock *, int> CatchRetPair :</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">       CatchRetSuccessors)</td>
    <td class="lineNumber">866</td>
    <td class="codeline">       CatchRetSuccessors)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">    collectEHScopeMembers(EHScopeMembership, CatchRetPair.second,</td>
    <td class="lineNumber">867</td>
    <td class="codeline">    collectEHScopeMembers(EHScopeMembership, CatchRetPair.second,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">                          CatchRetPair.first);</td>
    <td class="lineNumber">868</td>
    <td class="codeline">                          CatchRetPair.first);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline">  return EHScopeMembership;</td>
    <td class="lineNumber">869</td>
    <td class="codeline">  return EHScopeMembership;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">}</td>
    <td class="lineNumber">870</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline"></td>
    <td class="lineNumber">871</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- Analysis.cpp - CodeGen LLVM IR Analysis Utilities -----------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===-- Analysis.cpp - CodeGen LLVM IR Analysis Utilities -----------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file defines several CodeGen-specific LLVM IR analysis utilities.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// This file defines several CodeGen-specific LLVM IR analysis utilities.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">#include "llvm/CodeGen/Analysis.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">#include "llvm/CodeGen/Analysis.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">#include "llvm/Analysis/ValueTracking.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">#include "llvm/CodeGen/MachineFunction.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetInstrInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetLowering.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">#include "llvm/CodeGen/TargetSubtargetInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine">#include "llvm/IR/DataLayout.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#include "llvm/IR/DerivedTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#include "llvm/IR/Function.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/IR/IntrinsicInst.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/IR/Module.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/Support/ErrorHandling.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/Target/TargetMachine.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">using namespace llvm;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">/// Compute the linearized index of a member in a nested aggregate/struct/array</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">/// Compute the linearized index of a member in a nested aggregate/struct/array</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">/// by recursing and accumulating CurIndex as long as there are indices in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">/// by recursing and accumulating CurIndex as long as there are indices in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">/// index list.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">/// index list.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">unsigned llvm::ComputeLinearIndex(Type *Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">unsigned llvm::ComputeLinearIndex(Type *Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">                                  const unsigned *Indices,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">                                  const unsigned *Indices,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">                                  const unsigned *IndicesEnd,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">                                  const unsigned *IndicesEnd,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">                                  unsigned CurIndex) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">                                  unsigned CurIndex) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">  // Base case: We're done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">  // Base case: We're done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">  if (Indices && Indices == IndicesEnd)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">  if (Indices && Indices == IndicesEnd)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">    return CurIndex;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">    return CurIndex;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">  // Given a struct type, recursively traverse the elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">  // Given a struct type, recursively traverse the elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">  if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">  if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">    for (auto I : llvm::enumerate(STy->elements())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">    for (auto I : llvm::enumerate(STy->elements())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine">      Type *ET = I.value();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">44</td>
    <td class="codeLine">      Type *ET = I.value();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">      if (Indices && *Indices == I.index())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">      if (Indices && *Indices == I.index())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine">        return ComputeLinearIndex(ET, Indices + 1, IndicesEnd, CurIndex);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">46</td>
    <td class="codeLine">        return ComputeLinearIndex(ET, Indices + 1, IndicesEnd, CurIndex);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">      CurIndex = ComputeLinearIndex(ET, nullptr, nullptr, CurIndex);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">      CurIndex = ComputeLinearIndex(ET, nullptr, nullptr, CurIndex);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">    assert(!Indices && "Unexpected out of bound");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">    assert(!Indices && "Unexpected out of bound");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">    return CurIndex;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">    return CurIndex;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">  // Given an array type, recursively traverse the elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">  // Given an array type, recursively traverse the elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">  else if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">  else if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">    Type *EltTy = ATy->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">    Type *EltTy = ATy->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">    unsigned NumElts = ATy->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">    unsigned NumElts = ATy->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">    // Compute the Linear offset when jumping one element of the array</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">    // Compute the Linear offset when jumping one element of the array</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">    unsigned EltLinearOffset = ComputeLinearIndex(EltTy, nullptr, nullptr, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">    unsigned EltLinearOffset = ComputeLinearIndex(EltTy, nullptr, nullptr, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">    if (Indices) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">    if (Indices) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">      assert(*Indices < NumElts && "Unexpected out of bound");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">      assert(*Indices < NumElts && "Unexpected out of bound");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">      // If the indice is inside the array, compute the index to the requested</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">      // If the indice is inside the array, compute the index to the requested</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">      // elt and recurse inside the element with the end of the indices list</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">      // elt and recurse inside the element with the end of the indices list</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">      CurIndex += EltLinearOffset* *Indices;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">      CurIndex += EltLinearOffset* *Indices;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">      return ComputeLinearIndex(EltTy, Indices+1, IndicesEnd, CurIndex);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">      return ComputeLinearIndex(EltTy, Indices+1, IndicesEnd, CurIndex);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">    CurIndex += EltLinearOffset*NumElts;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">    CurIndex += EltLinearOffset*NumElts;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">    return CurIndex;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">    return CurIndex;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">  // We haven't found the type we're looking for, so keep searching.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">  // We haven't found the type we're looking for, so keep searching.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine">  return CurIndex + 1;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">69</td>
    <td class="codeLine">  return CurIndex + 1;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">/// ComputeValueVTs - Given an LLVM IR type, compute a sequence of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">/// ComputeValueVTs - Given an LLVM IR type, compute a sequence of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">/// EVTs that represent all the individual underlying</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">/// EVTs that represent all the individual underlying</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">/// non-aggregate types that comprise it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">/// non-aggregate types that comprise it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">/// If Offsets is non-null, it points to a vector to be filled in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">/// If Offsets is non-null, it points to a vector to be filled in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine">/// with the in-memory offsets of each of the individual values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine">/// with the in-memory offsets of each of the individual values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine coveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">15</td>
    <td class="lineNumber">79</td>
    <td class="codeLine coveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">15</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine">                           SmallVectorImpl<EVT> *MemVTs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine">                           SmallVectorImpl<EVT> *MemVTs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">                           TypeSize StartingOffset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">                           TypeSize StartingOffset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine">  // Given a struct type, recursively traverse the elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine">  // Given a struct type, recursively traverse the elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine coveredLine">  if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td class="lineNumber">15</td>
    <td class="lineNumber">85</td>
    <td class="codeLine coveredLine">  if (StructType *STy = dyn_cast<StructType>(Ty)) {</td>
    <td class="lineNumber">15</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">    // If the Offsets aren't needed, don't query the struct layout. This allows</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">    // If the Offsets aren't needed, don't query the struct layout. This allows</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">    // us to support structs with scalable vectors for operations that don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">    // us to support structs with scalable vectors for operations that don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine">    // need offsets.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine">    // need offsets.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">    const StructLayout *SL = Offsets ? DL.getStructLayout(STy) : nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">    const StructLayout *SL = Offsets ? DL.getStructLayout(STy) : nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">    for (StructType::element_iterator EB = STy->element_begin(),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">    for (StructType::element_iterator EB = STy->element_begin(),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">                                      EI = EB,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">                                      EI = EB,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine">                                      EE = STy->element_end();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">92</td>
    <td class="codeLine">                                      EE = STy->element_end();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">         EI != EE; ++EI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">         EI != EE; ++EI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">      // Don't compute the element offset if we didn't get a StructLayout above.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">      // Don't compute the element offset if we didn't get a StructLayout above.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">      TypeSize EltOffset = SL ? SL->getElementOffset(EI - EB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">      TypeSize EltOffset = SL ? SL->getElementOffset(EI - EB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">                              : TypeSize::get(0, StartingOffset.isScalable());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">                              : TypeSize::get(0, StartingOffset.isScalable());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">      ComputeValueVTs(TLI, DL, *EI, ValueVTs, MemVTs, Offsets,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">      ComputeValueVTs(TLI, DL, *EI, ValueVTs, MemVTs, Offsets,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">                      StartingOffset + EltOffset);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">                      StartingOffset + EltOffset);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  // Given an array type, recursively traverse the elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  // Given an array type, recursively traverse the elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine coveredLine">  if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">15</td>
    <td class="lineNumber">103</td>
    <td class="codeLine coveredLine">  if (ArrayType *ATy = dyn_cast<ArrayType>(Ty)) {</td>
    <td class="lineNumber">15</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">    Type *EltTy = ATy->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">    Type *EltTy = ATy->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">    TypeSize EltSize = DL.getTypeAllocSize(EltTy);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">    TypeSize EltSize = DL.getTypeAllocSize(EltTy);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">    for (unsigned i = 0, e = ATy->getNumElements(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">    for (unsigned i = 0, e = ATy->getNumElements(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">      ComputeValueVTs(TLI, DL, EltTy, ValueVTs, MemVTs, Offsets,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">      ComputeValueVTs(TLI, DL, EltTy, ValueVTs, MemVTs, Offsets,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">                      StartingOffset + i * EltSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">                      StartingOffset + i * EltSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">  // Interpret void as zero return values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">  // Interpret void as zero return values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine coveredLine">  if (Ty->isVoidTy())</td>
    <td class="lineNumber">15</td>
    <td class="lineNumber">112</td>
    <td class="codeLine coveredLine">  if (Ty->isVoidTy())</td>
    <td class="lineNumber">15</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">  // Base case: we can get an EVT for this LLVM IR type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">  // Base case: we can get an EVT for this LLVM IR type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine coveredLine">  ValueVTs.push_back(TLI.getValueType(DL, Ty));</td>
    <td class="lineNumber">15</td>
    <td class="lineNumber">115</td>
    <td class="codeLine coveredLine">  ValueVTs.push_back(TLI.getValueType(DL, Ty));</td>
    <td class="lineNumber">15</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine coveredLine">  if (MemVTs)</td>
    <td class="lineNumber">15</td>
    <td class="lineNumber">116</td>
    <td class="codeLine coveredLine">  if (MemVTs)</td>
    <td class="lineNumber">15</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine coveredLine">    MemVTs->push_back(TLI.getMemValueType(DL, Ty));</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">117</td>
    <td class="codeLine coveredLine">    MemVTs->push_back(TLI.getMemValueType(DL, Ty));</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine coveredLine">  if (Offsets)</td>
    <td class="lineNumber">15</td>
    <td class="lineNumber">118</td>
    <td class="codeLine coveredLine">  if (Offsets)</td>
    <td class="lineNumber">15</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine coveredLine">    Offsets->push_back(StartingOffset);</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">119</td>
    <td class="codeLine coveredLine">    Offsets->push_back(StartingOffset);</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine coveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">122</td>
    <td class="codeLine coveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">                           TypeSize StartingOffset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">                           TypeSize StartingOffset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine coveredLine">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, /*MemVTs=*/nullptr, Offsets,</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">126</td>
    <td class="codeLine coveredLine">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, /*MemVTs=*/nullptr, Offsets,</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine coveredLine">                         StartingOffset);</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">127</td>
    <td class="codeLine coveredLine">                         StartingOffset);</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine coveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">130</td>
    <td class="codeLine coveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">                           uint64_t StartingOffset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">                           uint64_t StartingOffset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine coveredLine">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">134</td>
    <td class="codeLine coveredLine">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine coveredLine">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, Offsets, Offset);</td>
    <td class="lineNumber">6</td>
    <td class="lineNumber">135</td>
    <td class="codeLine coveredLine">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, Offsets, Offset);</td>
    <td class="lineNumber">6</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">138</td>
    <td class="codeLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine">                           SmallVectorImpl<uint64_t> *FixedOffsets,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">140</td>
    <td class="codeLine">                           SmallVectorImpl<uint64_t> *FixedOffsets,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">                           uint64_t StartingOffset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">                           uint64_t StartingOffset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine">  SmallVector<TypeSize, 4> Offsets;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">143</td>
    <td class="codeLine">  SmallVector<TypeSize, 4> Offsets;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  if (FixedOffsets)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  if (FixedOffsets)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, &Offsets, Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">145</td>
    <td class="codeLine">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, &Offsets, Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, nullptr, Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, nullptr, Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">  if (FixedOffsets)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">  if (FixedOffsets)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">    for (TypeSize Offset : Offsets)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">    for (TypeSize Offset : Offsets)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine">      FixedOffsets->push_back(Offset.getKnownMinValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">151</td>
    <td class="codeLine">      FixedOffsets->push_back(Offset.getKnownMinValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">154</td>
    <td class="codeLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">                           SmallVectorImpl<EVT> *MemVTs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">                           SmallVectorImpl<EVT> *MemVTs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine">                           SmallVectorImpl<TypeSize> *Offsets,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">                           uint64_t StartingOffset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">                           uint64_t StartingOffset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, Offsets, Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">160</td>
    <td class="codeLine">  return ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, Offsets, Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine coveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">163</td>
    <td class="codeLine coveredLine">void llvm::ComputeValueVTs(const TargetLowering &TLI, const DataLayout &DL,</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">                           Type *Ty, SmallVectorImpl<EVT> &ValueVTs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">                           SmallVectorImpl<EVT> *MemVTs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">                           SmallVectorImpl<EVT> *MemVTs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">                           SmallVectorImpl<uint64_t> *FixedOffsets,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">                           SmallVectorImpl<uint64_t> *FixedOffsets,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">                           uint64_t StartingOffset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">                           uint64_t StartingOffset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine coveredLine">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">168</td>
    <td class="codeLine coveredLine">  TypeSize Offset = TypeSize::get(StartingOffset, Ty->isScalableTy());</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine coveredLine">  SmallVector<TypeSize, 4> Offsets;</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">169</td>
    <td class="codeLine coveredLine">  SmallVector<TypeSize, 4> Offsets;</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine coveredLine">  if (FixedOffsets)</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">170</td>
    <td class="codeLine coveredLine">  if (FixedOffsets)</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine coveredLine">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, &Offsets, Offset);</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">171</td>
    <td class="codeLine coveredLine">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, &Offsets, Offset);</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, nullptr, Offset);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">    ComputeValueVTs(TLI, DL, Ty, ValueVTs, MemVTs, nullptr, Offset);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">174</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine coveredLine">  if (FixedOffsets)</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">175</td>
    <td class="codeLine coveredLine">  if (FixedOffsets)</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine coveredLine">    for (TypeSize Offset : Offsets)</td>
    <td class="lineNumber">18</td>
    <td class="lineNumber">176</td>
    <td class="codeLine coveredLine">    for (TypeSize Offset : Offsets)</td>
    <td class="lineNumber">18</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine coveredLine">      FixedOffsets->push_back(Offset.getKnownMinValue());</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">177</td>
    <td class="codeLine coveredLine">      FixedOffsets->push_back(Offset.getKnownMinValue());</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">9</td>
    <td class="lineNumber">178</td>
    <td class="codeLine coveredLine">}</td>
    <td class="lineNumber">9</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine">void llvm::computeValueLLTs(const DataLayout &DL, Type &Ty,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">180</td>
    <td class="codeLine">void llvm::computeValueLLTs(const DataLayout &DL, Type &Ty,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">                            SmallVectorImpl<LLT> &ValueTys,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">                            SmallVectorImpl<LLT> &ValueTys,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">                            SmallVectorImpl<uint64_t> *Offsets,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">                            SmallVectorImpl<uint64_t> *Offsets,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">                            uint64_t StartingOffset) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">                            uint64_t StartingOffset) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine">  // Given a struct type, recursively traverse the elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine">  // Given a struct type, recursively traverse the elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">  if (StructType *STy = dyn_cast<StructType>(&Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">  if (StructType *STy = dyn_cast<StructType>(&Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">    // If the Offsets aren't needed, don't query the struct layout. This allows</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">    // If the Offsets aren't needed, don't query the struct layout. This allows</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">    // us to support structs with scalable vectors for operations that don't</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">    // us to support structs with scalable vectors for operations that don't</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">    // need offsets.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">    // need offsets.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine">    const StructLayout *SL = Offsets ? DL.getStructLayout(STy) : nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">189</td>
    <td class="codeLine">    const StructLayout *SL = Offsets ? DL.getStructLayout(STy) : nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">    for (unsigned I = 0, E = STy->getNumElements(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">    for (unsigned I = 0, E = STy->getNumElements(); I != E; ++I) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">      uint64_t EltOffset = SL ? SL->getElementOffset(I) : 0;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">      uint64_t EltOffset = SL ? SL->getElementOffset(I) : 0;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">      computeValueLLTs(DL, *STy->getElementType(I), ValueTys, Offsets,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">      computeValueLLTs(DL, *STy->getElementType(I), ValueTys, Offsets,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">                       StartingOffset + EltOffset);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">                       StartingOffset + EltOffset);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">  // Given an array type, recursively traverse the elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">  // Given an array type, recursively traverse the elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">  if (ArrayType *ATy = dyn_cast<ArrayType>(&Ty)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">  if (ArrayType *ATy = dyn_cast<ArrayType>(&Ty)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine">    Type *EltTy = ATy->getElementType();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">199</td>
    <td class="codeLine">    Type *EltTy = ATy->getElementType();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">    uint64_t EltSize = DL.getTypeAllocSize(EltTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">    uint64_t EltSize = DL.getTypeAllocSize(EltTy).getFixedValue();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">    for (unsigned i = 0, e = ATy->getNumElements(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">    for (unsigned i = 0, e = ATy->getNumElements(); i != e; ++i)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">      computeValueLLTs(DL, *EltTy, ValueTys, Offsets,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">      computeValueLLTs(DL, *EltTy, ValueTys, Offsets,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">                       StartingOffset + i * EltSize);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">                       StartingOffset + i * EltSize);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">204</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">  // Interpret void as zero return values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">  // Interpret void as zero return values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">  if (Ty.isVoidTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">  if (Ty.isVoidTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">    return;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">  // Base case: we can get an LLT for this LLVM IR type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">  // Base case: we can get an LLT for this LLVM IR type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">  ValueTys.push_back(getLLTForType(Ty, DL));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">  ValueTys.push_back(getLLTForType(Ty, DL));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine">  if (Offsets != nullptr)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">211</td>
    <td class="codeLine">  if (Offsets != nullptr)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">    Offsets->push_back(StartingOffset * 8);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">    Offsets->push_back(StartingOffset * 8);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine">/// ExtractTypeInfo - Returns the type info, possibly bitcast, encoded in V.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine">/// ExtractTypeInfo - Returns the type info, possibly bitcast, encoded in V.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">GlobalValue *llvm::ExtractTypeInfo(Value *V) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">GlobalValue *llvm::ExtractTypeInfo(Value *V) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">  V = V->stripPointerCasts();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">  V = V->stripPointerCasts();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">  GlobalValue *GV = dyn_cast<GlobalValue>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">  GlobalValue *GV = dyn_cast<GlobalValue>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  GlobalVariable *Var = dyn_cast<GlobalVariable>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  GlobalVariable *Var = dyn_cast<GlobalVariable>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">  if (Var && Var->getName() == "llvm.eh.catch.all.value") {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">  if (Var && Var->getName() == "llvm.eh.catch.all.value") {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">    assert(Var->hasInitializer() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">    assert(Var->hasInitializer() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">           "The EH catch-all value must have an initializer");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">           "The EH catch-all value must have an initializer");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine">    Value *Init = Var->getInitializer();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">224</td>
    <td class="codeLine">    Value *Init = Var->getInitializer();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">    GV = dyn_cast<GlobalValue>(Init);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">    GV = dyn_cast<GlobalValue>(Init);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">    if (!GV) V = cast<ConstantPointerNull>(Init);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">    if (!GV) V = cast<ConstantPointerNull>(Init);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">  assert((GV || isa<ConstantPointerNull>(V)) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">  assert((GV || isa<ConstantPointerNull>(V)) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">         "TypeInfo must be a global variable or NULL");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">         "TypeInfo must be a global variable or NULL");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  return GV;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  return GV;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">/// getFCmpCondCode - Return the ISD condition code corresponding to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">/// getFCmpCondCode - Return the ISD condition code corresponding to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">/// the given LLVM IR floating-point condition code.  This includes</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">/// the given LLVM IR floating-point condition code.  This includes</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine">/// consideration of global floating-point math flags.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine">/// consideration of global floating-point math flags.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine">ISD::CondCode llvm::getFCmpCondCode(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">238</td>
    <td class="codeLine">ISD::CondCode llvm::getFCmpCondCode(FCmpInst::Predicate Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  switch (Pred) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  switch (Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  case FCmpInst::FCMP_FALSE: return ISD::SETFALSE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  case FCmpInst::FCMP_FALSE: return ISD::SETFALSE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  case FCmpInst::FCMP_OEQ:   return ISD::SETOEQ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  case FCmpInst::FCMP_OEQ:   return ISD::SETOEQ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine">  case FCmpInst::FCMP_OGT:   return ISD::SETOGT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">242</td>
    <td class="codeLine">  case FCmpInst::FCMP_OGT:   return ISD::SETOGT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">  case FCmpInst::FCMP_OGE:   return ISD::SETOGE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">  case FCmpInst::FCMP_OGE:   return ISD::SETOGE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  case FCmpInst::FCMP_OLT:   return ISD::SETOLT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  case FCmpInst::FCMP_OLT:   return ISD::SETOLT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">  case FCmpInst::FCMP_OLE:   return ISD::SETOLE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">  case FCmpInst::FCMP_OLE:   return ISD::SETOLE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine">  case FCmpInst::FCMP_ONE:   return ISD::SETONE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">246</td>
    <td class="codeLine">  case FCmpInst::FCMP_ONE:   return ISD::SETONE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">  case FCmpInst::FCMP_ORD:   return ISD::SETO;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">  case FCmpInst::FCMP_ORD:   return ISD::SETO;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">  case FCmpInst::FCMP_UNO:   return ISD::SETUO;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">  case FCmpInst::FCMP_UNO:   return ISD::SETUO;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine">  case FCmpInst::FCMP_UEQ:   return ISD::SETUEQ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">249</td>
    <td class="codeLine">  case FCmpInst::FCMP_UEQ:   return ISD::SETUEQ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  case FCmpInst::FCMP_UGT:   return ISD::SETUGT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  case FCmpInst::FCMP_UGT:   return ISD::SETUGT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">  case FCmpInst::FCMP_UGE:   return ISD::SETUGE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">  case FCmpInst::FCMP_UGE:   return ISD::SETUGE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  case FCmpInst::FCMP_ULT:   return ISD::SETULT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  case FCmpInst::FCMP_ULT:   return ISD::SETULT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">  case FCmpInst::FCMP_ULE:   return ISD::SETULE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">  case FCmpInst::FCMP_ULE:   return ISD::SETULE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine">  case FCmpInst::FCMP_UNE:   return ISD::SETUNE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">254</td>
    <td class="codeLine">  case FCmpInst::FCMP_UNE:   return ISD::SETUNE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">  case FCmpInst::FCMP_TRUE:  return ISD::SETTRUE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">  case FCmpInst::FCMP_TRUE:  return ISD::SETTRUE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">  default: llvm_unreachable("Invalid FCmp predicate opcode!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">  default: llvm_unreachable("Invalid FCmp predicate opcode!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">ISD::CondCode llvm::getFCmpCodeWithoutNaN(ISD::CondCode CC) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">ISD::CondCode llvm::getFCmpCodeWithoutNaN(ISD::CondCode CC) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">  switch (CC) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">  switch (CC) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">    case ISD::SETOEQ: case ISD::SETUEQ: return ISD::SETEQ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">    case ISD::SETOEQ: case ISD::SETUEQ: return ISD::SETEQ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">    case ISD::SETONE: case ISD::SETUNE: return ISD::SETNE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">    case ISD::SETONE: case ISD::SETUNE: return ISD::SETNE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">    case ISD::SETOLT: case ISD::SETULT: return ISD::SETLT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">    case ISD::SETOLT: case ISD::SETULT: return ISD::SETLT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">    case ISD::SETOLE: case ISD::SETULE: return ISD::SETLE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">    case ISD::SETOLE: case ISD::SETULE: return ISD::SETLE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">    case ISD::SETOGT: case ISD::SETUGT: return ISD::SETGT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">    case ISD::SETOGT: case ISD::SETUGT: return ISD::SETGT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine">    case ISD::SETOGE: case ISD::SETUGE: return ISD::SETGE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">267</td>
    <td class="codeLine">    case ISD::SETOGE: case ISD::SETUGE: return ISD::SETGE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">    default: return CC;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">    default: return CC;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine coveredLine">ISD::CondCode llvm::getICmpCondCode(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">272</td>
    <td class="codeLine coveredLine">ISD::CondCode llvm::getICmpCondCode(ICmpInst::Predicate Pred) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine coveredLine">  switch (Pred) {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">273</td>
    <td class="codeLine coveredLine">  switch (Pred) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">  case ICmpInst::ICMP_EQ:  return ISD::SETEQ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">  case ICmpInst::ICMP_EQ:  return ISD::SETEQ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">  case ICmpInst::ICMP_NE:  return ISD::SETNE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">  case ICmpInst::ICMP_NE:  return ISD::SETNE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">  case ICmpInst::ICMP_SLE: return ISD::SETLE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">  case ICmpInst::ICMP_SLE: return ISD::SETLE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">  case ICmpInst::ICMP_ULE: return ISD::SETULE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">  case ICmpInst::ICMP_ULE: return ISD::SETULE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine">  case ICmpInst::ICMP_SGE: return ISD::SETGE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">278</td>
    <td class="codeLine">  case ICmpInst::ICMP_SGE: return ISD::SETGE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">  case ICmpInst::ICMP_UGE: return ISD::SETUGE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">  case ICmpInst::ICMP_UGE: return ISD::SETUGE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">  case ICmpInst::ICMP_SLT: return ISD::SETLT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">  case ICmpInst::ICMP_SLT: return ISD::SETLT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">  case ICmpInst::ICMP_ULT: return ISD::SETULT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">  case ICmpInst::ICMP_ULT: return ISD::SETULT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine coveredLine">  case ICmpInst::ICMP_SGT: return ISD::SETGT;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">282</td>
    <td class="codeLine coveredLine">  case ICmpInst::ICMP_SGT: return ISD::SETGT;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">  case ICmpInst::ICMP_UGT: return ISD::SETUGT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">  case ICmpInst::ICMP_UGT: return ISD::SETUGT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">    llvm_unreachable("Invalid ICmp predicate opcode!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">    llvm_unreachable("Invalid ICmp predicate opcode!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">ICmpInst::Predicate llvm::getICmpCondCode(ISD::CondCode Pred) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">ICmpInst::Predicate llvm::getICmpCondCode(ISD::CondCode Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">  switch (Pred) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">  switch (Pred) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine">  case ISD::SETEQ:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">291</td>
    <td class="codeLine">  case ISD::SETEQ:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">    return ICmpInst::ICMP_EQ;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">    return ICmpInst::ICMP_EQ;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  case ISD::SETNE:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  case ISD::SETNE:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">    return ICmpInst::ICMP_NE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">    return ICmpInst::ICMP_NE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  case ISD::SETLE:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  case ISD::SETLE:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine">    return ICmpInst::ICMP_SLE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">296</td>
    <td class="codeLine">    return ICmpInst::ICMP_SLE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">  case ISD::SETULE:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">  case ISD::SETULE:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine">    return ICmpInst::ICMP_ULE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">298</td>
    <td class="codeLine">    return ICmpInst::ICMP_ULE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">  case ISD::SETGE:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">  case ISD::SETGE:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">    return ICmpInst::ICMP_SGE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">    return ICmpInst::ICMP_SGE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine">  case ISD::SETUGE:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">301</td>
    <td class="codeLine">  case ISD::SETUGE:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">    return ICmpInst::ICMP_UGE;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">    return ICmpInst::ICMP_UGE;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">  case ISD::SETLT:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">  case ISD::SETLT:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine">    return ICmpInst::ICMP_SLT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">304</td>
    <td class="codeLine">    return ICmpInst::ICMP_SLT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">  case ISD::SETULT:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">  case ISD::SETULT:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">    return ICmpInst::ICMP_ULT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">    return ICmpInst::ICMP_ULT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">  case ISD::SETGT:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">  case ISD::SETGT:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">    return ICmpInst::ICMP_SGT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">    return ICmpInst::ICMP_SGT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">  case ISD::SETUGT:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">  case ISD::SETUGT:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine">    return ICmpInst::ICMP_UGT;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">310</td>
    <td class="codeLine">    return ICmpInst::ICMP_UGT;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">  default:</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">    llvm_unreachable("Invalid ISD integer condition code!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">    llvm_unreachable("Invalid ISD integer condition code!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">static bool isNoopBitcast(Type *T1, Type *T2,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">static bool isNoopBitcast(Type *T1, Type *T2,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">                          const TargetLoweringBase& TLI) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">                          const TargetLoweringBase& TLI) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">  return T1 == T2 || (T1->isPointerTy() && T2->isPointerTy()) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">  return T1 == T2 || (T1->isPointerTy() && T2->isPointerTy()) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">         (isa<VectorType>(T1) && isa<VectorType>(T2) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">         (isa<VectorType>(T1) && isa<VectorType>(T2) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">          TLI.isTypeLegal(EVT::getEVT(T1)) && TLI.isTypeLegal(EVT::getEVT(T2)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">          TLI.isTypeLegal(EVT::getEVT(T1)) && TLI.isTypeLegal(EVT::getEVT(T2)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">/// Look through operations that will be free to find the earliest source of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">/// Look through operations that will be free to find the earliest source of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">/// this value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">/// this value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">/// @param ValLoc If V has aggregate type, we will be interested in a particular</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">/// @param ValLoc If V has aggregate type, we will be interested in a particular</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">/// scalar component. This records its address; the reverse of this list gives a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">/// scalar component. This records its address; the reverse of this list gives a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">/// sequence of indices appropriate for an extractvalue to locate the important</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">/// sequence of indices appropriate for an extractvalue to locate the important</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">/// value. This value is updated during the function and on exit will indicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">/// value. This value is updated during the function and on exit will indicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">/// similar information for the Value returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">/// similar information for the Value returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">/// @param DataBits If this function looks through truncate instructions, this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">/// @param DataBits If this function looks through truncate instructions, this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">/// will record the smallest size attained.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">/// will record the smallest size attained.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">static const Value *getNoopInput(const Value *V,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">static const Value *getNoopInput(const Value *V,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">                                 SmallVectorImpl<unsigned> &ValLoc,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">                                 SmallVectorImpl<unsigned> &ValLoc,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">                                 unsigned &DataBits,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">                                 unsigned &DataBits,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">                                 const TargetLoweringBase &TLI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">                                 const TargetLoweringBase &TLI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">                                 const DataLayout &DL) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">                                 const DataLayout &DL) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">  while (true) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">  while (true) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">    // Try to look through V1; if V1 is not an instruction, it can't be looked</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">    // Try to look through V1; if V1 is not an instruction, it can't be looked</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">    // through.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">    // through.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">    const Instruction *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">    const Instruction *I = dyn_cast<Instruction>(V);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">    if (!I || I->getNumOperands() == 0) return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">    if (!I || I->getNumOperands() == 0) return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">    const Value *NoopInput = nullptr;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">    const Value *NoopInput = nullptr;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">    Value *Op = I->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">    Value *Op = I->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">    if (isa<BitCastInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">    if (isa<BitCastInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">      // Look through truly no-op bitcasts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">      // Look through truly no-op bitcasts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">      if (isNoopBitcast(Op->getType(), I->getType(), TLI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">      if (isNoopBitcast(Op->getType(), I->getType(), TLI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">        NoopInput = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">        NoopInput = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">    } else if (isa<GetElementPtrInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">    } else if (isa<GetElementPtrInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine">      // Look through getelementptr</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine">      // Look through getelementptr</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">      if (cast<GetElementPtrInst>(I)->hasAllZeroIndices())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">      if (cast<GetElementPtrInst>(I)->hasAllZeroIndices())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">        NoopInput = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">        NoopInput = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">    } else if (isa<IntToPtrInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">    } else if (isa<IntToPtrInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">      // Look through inttoptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">      // Look through inttoptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">      // Make sure this isn't a truncating or extending cast.  We could</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">      // Make sure this isn't a truncating or extending cast.  We could</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">      // support this eventually, but don't bother for now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">      // support this eventually, but don't bother for now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">      if (!isa<VectorType>(I->getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">      if (!isa<VectorType>(I->getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">          DL.getPointerSizeInBits() ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">          DL.getPointerSizeInBits() ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">              cast<IntegerType>(Op->getType())->getBitWidth())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">              cast<IntegerType>(Op->getType())->getBitWidth())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine">        NoopInput = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">362</td>
    <td class="codeLine">        NoopInput = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">    } else if (isa<PtrToIntInst>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">    } else if (isa<PtrToIntInst>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">      // Look through ptrtoint.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">      // Look through ptrtoint.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">      // Make sure this isn't a truncating or extending cast.  We could</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">      // Make sure this isn't a truncating or extending cast.  We could</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">      // support this eventually, but don't bother for now.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">      // support this eventually, but don't bother for now.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine">      if (!isa<VectorType>(I->getType()) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">367</td>
    <td class="codeLine">      if (!isa<VectorType>(I->getType()) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">          DL.getPointerSizeInBits() ==</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">          DL.getPointerSizeInBits() ==</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">              cast<IntegerType>(I->getType())->getBitWidth())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">              cast<IntegerType>(I->getType())->getBitWidth())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine">        NoopInput = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">370</td>
    <td class="codeLine">        NoopInput = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">    } else if (isa<TruncInst>(I) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">    } else if (isa<TruncInst>(I) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">               TLI.allowTruncateForTailCall(Op->getType(), I->getType())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">               TLI.allowTruncateForTailCall(Op->getType(), I->getType())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">      DataBits =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">      DataBits =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">          std::min((uint64_t)DataBits,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">          std::min((uint64_t)DataBits,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">                   I->getType()->getPrimitiveSizeInBits().getFixedValue());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">                   I->getType()->getPrimitiveSizeInBits().getFixedValue());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">      NoopInput = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">      NoopInput = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine">    } else if (auto *CB = dyn_cast<CallBase>(I)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">377</td>
    <td class="codeLine">    } else if (auto *CB = dyn_cast<CallBase>(I)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">      const Value *ReturnedOp = CB->getReturnedArgOperand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">      const Value *ReturnedOp = CB->getReturnedArgOperand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">      if (ReturnedOp && isNoopBitcast(ReturnedOp->getType(), I->getType(), TLI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">      if (ReturnedOp && isNoopBitcast(ReturnedOp->getType(), I->getType(), TLI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine">        NoopInput = ReturnedOp;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">380</td>
    <td class="codeLine">        NoopInput = ReturnedOp;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">    } else if (const InsertValueInst *IVI = dyn_cast<InsertValueInst>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">    } else if (const InsertValueInst *IVI = dyn_cast<InsertValueInst>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">      // Value may come from either the aggregate or the scalar</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">      // Value may come from either the aggregate or the scalar</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">      ArrayRef<unsigned> InsertLoc = IVI->getIndices();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">      ArrayRef<unsigned> InsertLoc = IVI->getIndices();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">      if (ValLoc.size() >= InsertLoc.size() &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">      if (ValLoc.size() >= InsertLoc.size() &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine">          std::equal(InsertLoc.begin(), InsertLoc.end(), ValLoc.rbegin())) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">385</td>
    <td class="codeLine">          std::equal(InsertLoc.begin(), InsertLoc.end(), ValLoc.rbegin())) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">        // The type being inserted is a nested sub-type of the aggregate; we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">        // The type being inserted is a nested sub-type of the aggregate; we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">        // have to remove those initial indices to get the location we're</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">        // have to remove those initial indices to get the location we're</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">        // interested in for the operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">        // interested in for the operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine">        ValLoc.resize(ValLoc.size() - InsertLoc.size());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">389</td>
    <td class="codeLine">        ValLoc.resize(ValLoc.size() - InsertLoc.size());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">        NoopInput = IVI->getInsertedValueOperand();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">        NoopInput = IVI->getInsertedValueOperand();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">      } else {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">        // The struct we're inserting into has the value we're interested in, no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">        // The struct we're inserting into has the value we're interested in, no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">        // change of address.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">        // change of address.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine">        NoopInput = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">394</td>
    <td class="codeLine">        NoopInput = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">      }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">    } else if (const ExtractValueInst *EVI = dyn_cast<ExtractValueInst>(V)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">    } else if (const ExtractValueInst *EVI = dyn_cast<ExtractValueInst>(V)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine">      // The part we're interested in will inevitably be some sub-section of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine">      // The part we're interested in will inevitably be some sub-section of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">      // previous aggregate. Combine the two paths to obtain the true address of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">      // previous aggregate. Combine the two paths to obtain the true address of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">      // our element.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">      // our element.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">      ArrayRef<unsigned> ExtractLoc = EVI->getIndices();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">      ArrayRef<unsigned> ExtractLoc = EVI->getIndices();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">      ValLoc.append(ExtractLoc.rbegin(), ExtractLoc.rend());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">      ValLoc.append(ExtractLoc.rbegin(), ExtractLoc.rend());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">      NoopInput = Op;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">      NoopInput = Op;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">    // Terminate if we couldn't find anything to look through.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">    // Terminate if we couldn't find anything to look through.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">    if (!NoopInput)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">    if (!NoopInput)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">      return V;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">      return V;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">    V = NoopInput;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">    V = NoopInput;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">409</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">/// Return true if this scalar return value only has bits discarded on its path</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">/// Return true if this scalar return value only has bits discarded on its path</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">/// from the "tail call" to the "ret". This includes the obvious noop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">/// from the "tail call" to the "ret". This includes the obvious noop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">/// instructions handled by getNoopInput above as well as free truncations (or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">/// instructions handled by getNoopInput above as well as free truncations (or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">/// extensions prior to the call).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">/// extensions prior to the call).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">static bool slotOnlyDiscardsData(const Value *RetVal, const Value *CallVal,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">static bool slotOnlyDiscardsData(const Value *RetVal, const Value *CallVal,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">                                 SmallVectorImpl<unsigned> &RetIndices,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">                                 SmallVectorImpl<unsigned> &RetIndices,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">                                 SmallVectorImpl<unsigned> &CallIndices,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">                                 SmallVectorImpl<unsigned> &CallIndices,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">                                 bool AllowDifferingSizes,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">                                 bool AllowDifferingSizes,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine">                                 const TargetLoweringBase &TLI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine">                                 const TargetLoweringBase &TLI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">                                 const DataLayout &DL) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">                                 const DataLayout &DL) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine">  // Trace the sub-value needed by the return value as far back up the graph as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine">  // Trace the sub-value needed by the return value as far back up the graph as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">  // possible, in the hope that it will intersect with the value produced by the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">  // possible, in the hope that it will intersect with the value produced by the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">  // call. In the simple case with no "returned" attribute, the hope is actually</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">  // call. In the simple case with no "returned" attribute, the hope is actually</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine">  // that we end up back at the tail call instruction itself.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine">  // that we end up back at the tail call instruction itself.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">  unsigned BitsRequired = UINT_MAX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">  unsigned BitsRequired = UINT_MAX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  RetVal = getNoopInput(RetVal, RetIndices, BitsRequired, TLI, DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  RetVal = getNoopInput(RetVal, RetIndices, BitsRequired, TLI, DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  // If this slot in the value returned is undef, it doesn't matter what the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  // If this slot in the value returned is undef, it doesn't matter what the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">  // call puts there, it'll be fine.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">  // call puts there, it'll be fine.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  if (isa<UndefValue>(RetVal))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  if (isa<UndefValue>(RetVal))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">433</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">  // Now do a similar search up through the graph to find where the value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">  // Now do a similar search up through the graph to find where the value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">  // actually returned by the "tail call" comes from. In the simple case without</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">  // actually returned by the "tail call" comes from. In the simple case without</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">  // a "returned" attribute, the search will be blocked immediately and the loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">  // a "returned" attribute, the search will be blocked immediately and the loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine">  // a Noop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine">  // a Noop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">  unsigned BitsProvided = UINT_MAX;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">  unsigned BitsProvided = UINT_MAX;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">  CallVal = getNoopInput(CallVal, CallIndices, BitsProvided, TLI, DL);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">  CallVal = getNoopInput(CallVal, CallIndices, BitsProvided, TLI, DL);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">441</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine">  // There's no hope if we can't actually trace them to (the same part of!) the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine">  // There's no hope if we can't actually trace them to (the same part of!) the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">  // same value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">  // same value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">  if (CallVal != RetVal || CallIndices != RetIndices)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">  if (CallVal != RetVal || CallIndices != RetIndices)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">  // However, intervening truncates may have made the call non-tail. Make sure</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">  // However, intervening truncates may have made the call non-tail. Make sure</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine">  // all the bits that are needed by the "ret" have been provided by the "tail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine">  // all the bits that are needed by the "ret" have been provided by the "tail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">  // call". FIXME: with sufficiently cunning bit-tracking, we could look through</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">  // call". FIXME: with sufficiently cunning bit-tracking, we could look through</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">  // extensions too.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">  // extensions too.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">  if (BitsProvided < BitsRequired ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">  if (BitsProvided < BitsRequired ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">      (!AllowDifferingSizes && BitsProvided != BitsRequired))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">      (!AllowDifferingSizes && BitsProvided != BitsRequired))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">/// For an aggregate type, determine whether a given index is within bounds or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">/// For an aggregate type, determine whether a given index is within bounds or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">/// not.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">/// not.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">static bool indexReallyValid(Type *T, unsigned Idx) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">static bool indexReallyValid(Type *T, unsigned Idx) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">  if (ArrayType *AT = dyn_cast<ArrayType>(T))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">  if (ArrayType *AT = dyn_cast<ArrayType>(T))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine">    return Idx < AT->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">462</td>
    <td class="codeLine">    return Idx < AT->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  return Idx < cast<StructType>(T)->getNumElements();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  return Idx < cast<StructType>(T)->getNumElements();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">/// Move the given iterators to the next leaf type in depth first traversal.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">/// Move the given iterators to the next leaf type in depth first traversal.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine">/// Performs a depth-first traversal of the type as specified by its arguments,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine">/// Performs a depth-first traversal of the type as specified by its arguments,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">/// stopping at the next leaf node (which may be a legitimate scalar type or an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">/// stopping at the next leaf node (which may be a legitimate scalar type or an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">/// empty struct or array).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">/// empty struct or array).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">/// @param SubTypes List of the partial components making up the type from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">/// @param SubTypes List of the partial components making up the type from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">/// outermost to innermost non-empty aggregate. The element currently</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">/// outermost to innermost non-empty aggregate. The element currently</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">/// represented is SubTypes.back()->getTypeAtIndex(Path.back() - 1).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">/// represented is SubTypes.back()->getTypeAtIndex(Path.back() - 1).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">/// @param Path Set of extractvalue indices leading from the outermost type</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">/// @param Path Set of extractvalue indices leading from the outermost type</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">/// (SubTypes[0]) to the leaf node currently represented.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">/// (SubTypes[0]) to the leaf node currently represented.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">/// @returns true if a new type was found, false otherwise. Calling this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">/// @returns true if a new type was found, false otherwise. Calling this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">/// function again on a finished iterator will repeatedly return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">/// function again on a finished iterator will repeatedly return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">/// false. SubTypes.back()->getTypeAtIndex(Path.back()) is either an empty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">/// false. SubTypes.back()->getTypeAtIndex(Path.back()) is either an empty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">/// aggregate or a non-aggregate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">/// aggregate or a non-aggregate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">static bool advanceToNextLeafType(SmallVectorImpl<Type *> &SubTypes,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">static bool advanceToNextLeafType(SmallVectorImpl<Type *> &SubTypes,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">                                  SmallVectorImpl<unsigned> &Path) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">                                  SmallVectorImpl<unsigned> &Path) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">  // First march back up the tree until we can successfully increment one of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">  // First march back up the tree until we can successfully increment one of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">  // coordinates in Path.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">  // coordinates in Path.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine">  while (!Path.empty() && !indexReallyValid(SubTypes.back(), Path.back() + 1)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">488</td>
    <td class="codeLine">  while (!Path.empty() && !indexReallyValid(SubTypes.back(), Path.back() + 1)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">    Path.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">    Path.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">    SubTypes.pop_back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">    SubTypes.pop_back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine">  // If we reached the top, then the iterator is done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine">  // If we reached the top, then the iterator is done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">  if (Path.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">  if (Path.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">495</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">  // We know there's *some* valid leaf now, so march back down the tree picking</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">  // We know there's *some* valid leaf now, so march back down the tree picking</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">  // out the left-most element at each node.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">  // out the left-most element at each node.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">  ++Path.back();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">  ++Path.back();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">  Type *DeeperType =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">  Type *DeeperType =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine">      ExtractValueInst::getIndexedType(SubTypes.back(), Path.back());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">501</td>
    <td class="codeLine">      ExtractValueInst::getIndexedType(SubTypes.back(), Path.back());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">  while (DeeperType->isAggregateType()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">  while (DeeperType->isAggregateType()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">    if (!indexReallyValid(DeeperType, 0))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">    if (!indexReallyValid(DeeperType, 0))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">    SubTypes.push_back(DeeperType);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">    SubTypes.push_back(DeeperType);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">    Path.push_back(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">    Path.push_back(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">    DeeperType = ExtractValueInst::getIndexedType(DeeperType, 0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">    DeeperType = ExtractValueInst::getIndexedType(DeeperType, 0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">/// Find the first non-empty, scalar-like type in Next and setup the iterator</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">/// Find the first non-empty, scalar-like type in Next and setup the iterator</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">/// components.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">/// components.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">/// Assuming Next is an aggregate of some kind, this function will traverse the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">/// Assuming Next is an aggregate of some kind, this function will traverse the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">/// tree from left to right (i.e. depth-first) looking for the first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">/// tree from left to right (i.e. depth-first) looking for the first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">/// non-aggregate type which will play a role in function return.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">/// non-aggregate type which will play a role in function return.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">/// For example, if Next was {[0 x i64], {{}, i32, {}}, i32} then we would setup</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">/// For example, if Next was {[0 x i64], {{}, i32, {}}, i32} then we would setup</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">/// Path as [1, 1] and SubTypes as [Next, {{}, i32, {}}] to represent the first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">/// Path as [1, 1] and SubTypes as [Next, {{}, i32, {}}] to represent the first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">/// i32 in that type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">/// i32 in that type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">static bool firstRealType(Type *Next, SmallVectorImpl<Type *> &SubTypes,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">static bool firstRealType(Type *Next, SmallVectorImpl<Type *> &SubTypes,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">                          SmallVectorImpl<unsigned> &Path) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">                          SmallVectorImpl<unsigned> &Path) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  // First initialise the iterator components to the first "leaf" node</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  // First initialise the iterator components to the first "leaf" node</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">  // (i.e. node with no valid sub-type at any index, so {} does count as a leaf</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">  // (i.e. node with no valid sub-type at any index, so {} does count as a leaf</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine">  // despite nominally being an aggregate).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine">  // despite nominally being an aggregate).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">  while (Type *FirstInner = ExtractValueInst::getIndexedType(Next, 0)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">  while (Type *FirstInner = ExtractValueInst::getIndexedType(Next, 0)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">    SubTypes.push_back(Next);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">    SubTypes.push_back(Next);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">    Path.push_back(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">    Path.push_back(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine">    Next = FirstInner;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">533</td>
    <td class="codeLine">    Next = FirstInner;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  // If there's no Path now, Next was originally scalar already (or empty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  // If there's no Path now, Next was originally scalar already (or empty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  // leaf). We're done.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  // leaf). We're done.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">  if (Path.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">  if (Path.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  // Otherwise, use normal iteration to keep looking through the tree until we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  // Otherwise, use normal iteration to keep looking through the tree until we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">  // find a non-aggregate type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">  // find a non-aggregate type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">  while (ExtractValueInst::getIndexedType(SubTypes.back(), Path.back())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">  while (ExtractValueInst::getIndexedType(SubTypes.back(), Path.back())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">             ->isAggregateType()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">             ->isAggregateType()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">    if (!advanceToNextLeafType(SubTypes, Path))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">    if (!advanceToNextLeafType(SubTypes, Path))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">/// Set the iterator data-structures to the next non-empty, non-aggregate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">/// Set the iterator data-structures to the next non-empty, non-aggregate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">/// subtype.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">/// subtype.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine">static bool nextRealType(SmallVectorImpl<Type *> &SubTypes,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">554</td>
    <td class="codeLine">static bool nextRealType(SmallVectorImpl<Type *> &SubTypes,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">                         SmallVectorImpl<unsigned> &Path) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">                         SmallVectorImpl<unsigned> &Path) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">    if (!advanceToNextLeafType(SubTypes, Path))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">    if (!advanceToNextLeafType(SubTypes, Path))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">558</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">    assert(!Path.empty() && "found a leaf but didn't set the path?");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">    assert(!Path.empty() && "found a leaf but didn't set the path?");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">  } while (ExtractValueInst::getIndexedType(SubTypes.back(), Path.back())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">  } while (ExtractValueInst::getIndexedType(SubTypes.back(), Path.back())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine">               ->isAggregateType());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">562</td>
    <td class="codeLine">               ->isAggregateType());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">/// Test if the given instruction is in a position to be optimized</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">/// Test if the given instruction is in a position to be optimized</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">/// with a tail-call. This roughly means that it's in a block with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">/// with a tail-call. This roughly means that it's in a block with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">/// a return and there's nothing that needs to be scheduled</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">/// a return and there's nothing that needs to be scheduled</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">/// between it and the return.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">/// between it and the return.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">/// This function only tests target-independent requirements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">/// This function only tests target-independent requirements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">bool llvm::isInTailCallPosition(const CallBase &Call, const TargetMachine &TM) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">bool llvm::isInTailCallPosition(const CallBase &Call, const TargetMachine &TM) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">  const BasicBlock *ExitBB = Call.getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">  const BasicBlock *ExitBB = Call.getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  const Instruction *Term = ExitBB->getTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  const Instruction *Term = ExitBB->getTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  const ReturnInst *Ret = dyn_cast<ReturnInst>(Term);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  const ReturnInst *Ret = dyn_cast<ReturnInst>(Term);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">  // The block must end in a return statement or unreachable.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">  // The block must end in a return statement or unreachable.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">  // FIXME: Decline tailcall if it's not guaranteed and if the block ends in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">  // FIXME: Decline tailcall if it's not guaranteed and if the block ends in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">  // an unreachable, for now. The way tailcall optimization is currently</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">  // an unreachable, for now. The way tailcall optimization is currently</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">  // implemented means it will add an epilogue followed by a jump. That is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">  // implemented means it will add an epilogue followed by a jump. That is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">  // not profitable. Also, if the callee is a special function (e.g.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">  // not profitable. Also, if the callee is a special function (e.g.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">  // longjmp on x86), it can end up causing miscompilation that has not</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">  // longjmp on x86), it can end up causing miscompilation that has not</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">  // been fully understood.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">  // been fully understood.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">  if (!Ret && ((!TM.Options.GuaranteedTailCallOpt &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">  if (!Ret && ((!TM.Options.GuaranteedTailCallOpt &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">                Call.getCallingConv() != CallingConv::Tail &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">                Call.getCallingConv() != CallingConv::Tail &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">                Call.getCallingConv() != CallingConv::SwiftTail) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">                Call.getCallingConv() != CallingConv::SwiftTail) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">               !isa<UnreachableInst>(Term)))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">               !isa<UnreachableInst>(Term)))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">  // If I will have a chain, make sure no other instruction that will have a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">  // If I will have a chain, make sure no other instruction that will have a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">  // chain interposes between I and the return.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">  // chain interposes between I and the return.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">  // Check for all calls including speculatable functions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">  // Check for all calls including speculatable functions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  for (BasicBlock::const_iterator BBI = std::prev(ExitBB->end(), 2);; --BBI) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  for (BasicBlock::const_iterator BBI = std::prev(ExitBB->end(), 2);; --BBI) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">    if (&*BBI == &Call)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">    if (&*BBI == &Call)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">      break;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">    // Debug info intrinsics do not get in the way of tail call optimization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">    // Debug info intrinsics do not get in the way of tail call optimization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">    // Pseudo probe intrinsics do not block tail call optimization either.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">    // Pseudo probe intrinsics do not block tail call optimization either.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">    if (BBI->isDebugOrPseudoInst())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">    if (BBI->isDebugOrPseudoInst())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">    // A lifetime end, assume or noalias.decl intrinsic should not stop tail</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">    // A lifetime end, assume or noalias.decl intrinsic should not stop tail</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">    // call optimization.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">    // call optimization.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">    if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(BBI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">    if (const IntrinsicInst *II = dyn_cast<IntrinsicInst>(BBI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">      if (II->getIntrinsicID() == Intrinsic::lifetime_end ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">      if (II->getIntrinsicID() == Intrinsic::lifetime_end ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">          II->getIntrinsicID() == Intrinsic::assume ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">          II->getIntrinsicID() == Intrinsic::assume ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">          II->getIntrinsicID() == Intrinsic::experimental_noalias_scope_decl)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">          II->getIntrinsicID() == Intrinsic::experimental_noalias_scope_decl)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">        continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">    if (BBI->mayHaveSideEffects() || BBI->mayReadFromMemory() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">    if (BBI->mayHaveSideEffects() || BBI->mayReadFromMemory() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">        !isSafeToSpeculativelyExecute(&*BBI))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">        !isSafeToSpeculativelyExecute(&*BBI))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">  const Function *F = ExitBB->getParent();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">  const Function *F = ExitBB->getParent();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">  return returnTypeIsEligibleForTailCall(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">  return returnTypeIsEligibleForTailCall(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">      F, &Call, Ret, *TM.getSubtargetImpl(*F)->getTargetLowering());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">      F, &Call, Ret, *TM.getSubtargetImpl(*F)->getTargetLowering());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">bool llvm::attributesPermitTailCall(const Function *F, const Instruction *I,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">bool llvm::attributesPermitTailCall(const Function *F, const Instruction *I,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">                                    const ReturnInst *Ret,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">                                    const ReturnInst *Ret,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">                                    const TargetLoweringBase &TLI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">                                    const TargetLoweringBase &TLI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine">                                    bool *AllowDifferingSizes) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine">                                    bool *AllowDifferingSizes) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">  // ADS may be null, so don't write to it directly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">  // ADS may be null, so don't write to it directly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">  bool DummyADS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">  bool DummyADS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  bool &ADS = AllowDifferingSizes ? *AllowDifferingSizes : DummyADS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  bool &ADS = AllowDifferingSizes ? *AllowDifferingSizes : DummyADS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">  ADS = true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">  ADS = true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">  AttrBuilder CallerAttrs(F->getContext(), F->getAttributes().getRetAttrs());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">  AttrBuilder CallerAttrs(F->getContext(), F->getAttributes().getRetAttrs());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine">  AttrBuilder CalleeAttrs(F->getContext(),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine">  AttrBuilder CalleeAttrs(F->getContext(),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">                          cast<CallInst>(I)->getAttributes().getRetAttrs());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">                          cast<CallInst>(I)->getAttributes().getRetAttrs());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  // Following attributes are completely benign as far as calling convention</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  // Following attributes are completely benign as far as calling convention</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">  // goes, they shouldn't affect whether the call is a tail call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">  // goes, they shouldn't affect whether the call is a tail call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">  for (const auto &Attr : {Attribute::Alignment, Attribute::Dereferenceable,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">  for (const auto &Attr : {Attribute::Alignment, Attribute::Dereferenceable,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">                           Attribute::DereferenceableOrNull, Attribute::NoAlias,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">                           Attribute::DereferenceableOrNull, Attribute::NoAlias,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">                           Attribute::NonNull, Attribute::NoUndef}) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">                           Attribute::NonNull, Attribute::NoUndef}) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">    CallerAttrs.removeAttribute(Attr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">    CallerAttrs.removeAttribute(Attr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">    CalleeAttrs.removeAttribute(Attr);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">    CalleeAttrs.removeAttribute(Attr);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">  if (CallerAttrs.contains(Attribute::ZExt)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">  if (CallerAttrs.contains(Attribute::ZExt)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">    if (!CalleeAttrs.contains(Attribute::ZExt))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">    if (!CalleeAttrs.contains(Attribute::ZExt))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">    ADS = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">    ADS = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">    CallerAttrs.removeAttribute(Attribute::ZExt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">    CallerAttrs.removeAttribute(Attribute::ZExt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">    CalleeAttrs.removeAttribute(Attribute::ZExt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">    CalleeAttrs.removeAttribute(Attribute::ZExt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  } else if (CallerAttrs.contains(Attribute::SExt)) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  } else if (CallerAttrs.contains(Attribute::SExt)) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">    if (!CalleeAttrs.contains(Attribute::SExt))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">    if (!CalleeAttrs.contains(Attribute::SExt))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">    ADS = false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">    ADS = false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">    CallerAttrs.removeAttribute(Attribute::SExt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">    CallerAttrs.removeAttribute(Attribute::SExt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine">    CalleeAttrs.removeAttribute(Attribute::SExt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">655</td>
    <td class="codeLine">    CalleeAttrs.removeAttribute(Attribute::SExt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">657</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine">  // Drop sext and zext return attributes if the result is not used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine">  // Drop sext and zext return attributes if the result is not used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">  // This enables tail calls for code like:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">  // This enables tail calls for code like:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine">  // define void @caller() {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine">  // define void @caller() {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">  // entry:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">  // entry:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">  //   %unused_result = tail call zeroext i1 @callee()</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">  //   %unused_result = tail call zeroext i1 @callee()</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">  //   br label %retlabel</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">  //   br label %retlabel</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">  // retlabel:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">  // retlabel:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">  //   ret void</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">  //   ret void</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine">  // }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine">  // }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">  if (I->use_empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">  if (I->use_empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">    CalleeAttrs.removeAttribute(Attribute::SExt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">    CalleeAttrs.removeAttribute(Attribute::SExt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">    CalleeAttrs.removeAttribute(Attribute::ZExt);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">    CalleeAttrs.removeAttribute(Attribute::ZExt);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">  // If they're still different, there's some facet we don't understand</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">  // If they're still different, there's some facet we don't understand</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  // (currently only "inreg", but in future who knows). It may be OK but the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  // (currently only "inreg", but in future who knows). It may be OK but the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine">  // only safe option is to reject the tail call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine">  // only safe option is to reject the tail call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">  return CallerAttrs == CalleeAttrs;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">  return CallerAttrs == CalleeAttrs;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">/// Check whether B is a bitcast of a pointer type to another pointer type,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">/// Check whether B is a bitcast of a pointer type to another pointer type,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">/// which is equal to A.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">/// which is equal to A.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine">static bool isPointerBitcastEqualTo(const Value *A, const Value *B) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">681</td>
    <td class="codeLine">static bool isPointerBitcastEqualTo(const Value *A, const Value *B) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">  assert(A && B && "Expected non-null inputs!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">  assert(A && B && "Expected non-null inputs!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine">  auto *BitCastIn = dyn_cast<BitCastInst>(B);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">684</td>
    <td class="codeLine">  auto *BitCastIn = dyn_cast<BitCastInst>(B);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  if (!BitCastIn)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  if (!BitCastIn)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">  if (!A->getType()->isPointerTy() || !B->getType()->isPointerTy())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">  if (!A->getType()->isPointerTy() || !B->getType()->isPointerTy())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  return A == BitCastIn->getOperand(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  return A == BitCastIn->getOperand(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">bool llvm::returnTypeIsEligibleForTailCall(const Function *F,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">bool llvm::returnTypeIsEligibleForTailCall(const Function *F,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">                                           const Instruction *I,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">                                           const Instruction *I,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">                                           const ReturnInst *Ret,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">                                           const ReturnInst *Ret,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">                                           const TargetLoweringBase &TLI) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">                                           const TargetLoweringBase &TLI) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">  // If the block ends with a void return or unreachable, it doesn't matter</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">  // If the block ends with a void return or unreachable, it doesn't matter</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">  // what the call's return type is.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">  // what the call's return type is.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">  if (!Ret || Ret->getNumOperands() == 0) return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">  if (!Ret || Ret->getNumOperands() == 0) return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">  // If the return value is undef, it doesn't matter what the call's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">  // If the return value is undef, it doesn't matter what the call's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">  // return type is.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">  // return type is.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">  if (isa<UndefValue>(Ret->getOperand(0))) return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">  if (isa<UndefValue>(Ret->getOperand(0))) return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">  // Make sure the attributes attached to each return are compatible.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">  // Make sure the attributes attached to each return are compatible.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">  bool AllowDifferingSizes;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">  bool AllowDifferingSizes;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">  if (!attributesPermitTailCall(F, I, Ret, TLI, &AllowDifferingSizes))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">  if (!attributesPermitTailCall(F, I, Ret, TLI, &AllowDifferingSizes))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">    return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine">  const Value *RetVal = Ret->getOperand(0), *CallVal = I;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">712</td>
    <td class="codeLine">  const Value *RetVal = Ret->getOperand(0), *CallVal = I;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">  // Intrinsic like llvm.memcpy has no return value, but the expanded</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">  // Intrinsic like llvm.memcpy has no return value, but the expanded</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">  // libcall may or may not have return value. On most platforms, it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">  // libcall may or may not have return value. On most platforms, it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">  // will be expanded as memcpy in libc, which returns the first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">  // will be expanded as memcpy in libc, which returns the first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">  // argument. On other platforms like arm-none-eabi, memcpy may be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">  // argument. On other platforms like arm-none-eabi, memcpy may be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine">  // expanded as library call without return value, like __aeabi_memcpy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine">  // expanded as library call without return value, like __aeabi_memcpy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">  const CallInst *Call = cast<CallInst>(I);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">  const CallInst *Call = cast<CallInst>(I);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">  if (Function *F = Call->getCalledFunction()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">  if (Function *F = Call->getCalledFunction()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">    Intrinsic::ID IID = F->getIntrinsicID();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">    Intrinsic::ID IID = F->getIntrinsicID();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">    if (((IID == Intrinsic::memcpy &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">    if (((IID == Intrinsic::memcpy &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine">          TLI.getLibcallName(RTLIB::MEMCPY) == StringRef("memcpy")) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">722</td>
    <td class="codeLine">          TLI.getLibcallName(RTLIB::MEMCPY) == StringRef("memcpy")) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">         (IID == Intrinsic::memmove &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">         (IID == Intrinsic::memmove &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">          TLI.getLibcallName(RTLIB::MEMMOVE) == StringRef("memmove")) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">          TLI.getLibcallName(RTLIB::MEMMOVE) == StringRef("memmove")) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">         (IID == Intrinsic::memset &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">         (IID == Intrinsic::memset &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">          TLI.getLibcallName(RTLIB::MEMSET) == StringRef("memset"))) &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">          TLI.getLibcallName(RTLIB::MEMSET) == StringRef("memset"))) &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine">        (RetVal == Call->getArgOperand(0) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">727</td>
    <td class="codeLine">        (RetVal == Call->getArgOperand(0) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">         isPointerBitcastEqualTo(RetVal, Call->getArgOperand(0))))</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">         isPointerBitcastEqualTo(RetVal, Call->getArgOperand(0))))</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">      return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine">  SmallVector<unsigned, 4> RetPath, CallPath;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">732</td>
    <td class="codeLine">  SmallVector<unsigned, 4> RetPath, CallPath;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">  SmallVector<Type *, 4> RetSubTypes, CallSubTypes;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">  SmallVector<Type *, 4> RetSubTypes, CallSubTypes;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">  bool RetEmpty = !firstRealType(RetVal->getType(), RetSubTypes, RetPath);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">  bool RetEmpty = !firstRealType(RetVal->getType(), RetSubTypes, RetPath);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">  bool CallEmpty = !firstRealType(CallVal->getType(), CallSubTypes, CallPath);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">  bool CallEmpty = !firstRealType(CallVal->getType(), CallSubTypes, CallPath);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">  // Nothing's actually returned, it doesn't matter what the callee put there</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">  // Nothing's actually returned, it doesn't matter what the callee put there</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">  // it's a valid tail call.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">  // it's a valid tail call.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">  if (RetEmpty)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">  if (RetEmpty)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">741</td>
    <td class="codeLine">    return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">  // Iterate pairwise through each of the value types making up the tail call</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">  // Iterate pairwise through each of the value types making up the tail call</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">  // and the corresponding return. For each one we want to know whether it's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">  // and the corresponding return. For each one we want to know whether it's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine">  // essentially going directly from the tail call to the ret, via operations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine">  // essentially going directly from the tail call to the ret, via operations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  // that end up not generating any code.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  // that end up not generating any code.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">  //</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">  // We allow a certain amount of covariance here. For example it's permitted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">  // We allow a certain amount of covariance here. For example it's permitted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">  // for the tail call to define more bits than the ret actually cares about</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">  // for the tail call to define more bits than the ret actually cares about</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine">  // (e.g. via a truncate).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine">  // (e.g. via a truncate).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">  do {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">    if (CallEmpty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">    if (CallEmpty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">      // We've exhausted the values produced by the tail call instruction, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">      // We've exhausted the values produced by the tail call instruction, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">      // rest are essentially undef. The type doesn't really matter, but we need</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">      // rest are essentially undef. The type doesn't really matter, but we need</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine">      // *something*.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine">      // *something*.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">      Type *SlotType =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">      Type *SlotType =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">          ExtractValueInst::getIndexedType(RetSubTypes.back(), RetPath.back());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">          ExtractValueInst::getIndexedType(RetSubTypes.back(), RetPath.back());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">      CallVal = UndefValue::get(SlotType);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">      CallVal = UndefValue::get(SlotType);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine">    // The manipulations performed when we're looking through an insertvalue or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine">    // The manipulations performed when we're looking through an insertvalue or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">    // an extractvalue would happen at the front of the RetPath list, so since</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">    // an extractvalue would happen at the front of the RetPath list, so since</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">    // we have to copy it anyway it's more efficient to create a reversed copy.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">    // we have to copy it anyway it's more efficient to create a reversed copy.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine">    SmallVector<unsigned, 4> TmpRetPath(llvm::reverse(RetPath));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">764</td>
    <td class="codeLine">    SmallVector<unsigned, 4> TmpRetPath(llvm::reverse(RetPath));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">    SmallVector<unsigned, 4> TmpCallPath(llvm::reverse(CallPath));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">    SmallVector<unsigned, 4> TmpCallPath(llvm::reverse(CallPath));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">    // Finally, we can check whether the value produced by the tail call at this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">    // Finally, we can check whether the value produced by the tail call at this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">    // index is compatible with the value we return.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">    // index is compatible with the value we return.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">    if (!slotOnlyDiscardsData(RetVal, CallVal, TmpRetPath, TmpCallPath,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">    if (!slotOnlyDiscardsData(RetVal, CallVal, TmpRetPath, TmpCallPath,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">                              AllowDifferingSizes, TLI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">                              AllowDifferingSizes, TLI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">                              F->getParent()->getDataLayout()))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">                              F->getParent()->getDataLayout()))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">      return false;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">    CallEmpty  = !nextRealType(CallSubTypes, CallPath);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">    CallEmpty  = !nextRealType(CallSubTypes, CallPath);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">  } while(nextRealType(RetSubTypes, RetPath));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">  } while(nextRealType(RetSubTypes, RetPath));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">  return true;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">static void collectEHScopeMembers(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">static void collectEHScopeMembers(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">    DenseMap<const MachineBasicBlock *, int> &EHScopeMembership, int EHScope,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">    DenseMap<const MachineBasicBlock *, int> &EHScopeMembership, int EHScope,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">    const MachineBasicBlock *MBB) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">    const MachineBasicBlock *MBB) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">  SmallVector<const MachineBasicBlock *, 16> Worklist = {MBB};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">  SmallVector<const MachineBasicBlock *, 16> Worklist = {MBB};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">  while (!Worklist.empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine">    const MachineBasicBlock *Visiting = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">785</td>
    <td class="codeLine">    const MachineBasicBlock *Visiting = Worklist.pop_back_val();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">    // Don't follow blocks which start new scopes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">    // Don't follow blocks which start new scopes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">    if (Visiting->isEHPad() && Visiting != MBB)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">    if (Visiting->isEHPad() && Visiting != MBB)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">    // Add this MBB to our scope.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">    // Add this MBB to our scope.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine">    auto P = EHScopeMembership.insert(std::make_pair(Visiting, EHScope));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">791</td>
    <td class="codeLine">    auto P = EHScopeMembership.insert(std::make_pair(Visiting, EHScope));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">    // Don't revisit blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">    // Don't revisit blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">    if (!P.second) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">    if (!P.second) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">      assert(P.first->second == EHScope && "MBB is part of two scopes!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">      assert(P.first->second == EHScope && "MBB is part of two scopes!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">796</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">    // Returns are boundaries where scope transfer can occur, don't follow</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">    // Returns are boundaries where scope transfer can occur, don't follow</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine">    // successors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine">    // successors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">    if (Visiting->isEHScopeReturnBlock())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">    if (Visiting->isEHScopeReturnBlock())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">    append_range(Worklist, Visiting->successors());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">    append_range(Worklist, Visiting->successors());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">DenseMap<const MachineBasicBlock *, int></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">DenseMap<const MachineBasicBlock *, int></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine coveredLine">llvm::getEHScopeMembership(const MachineFunction &MF) {</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">809</td>
    <td class="codeLine coveredLine">llvm::getEHScopeMembership(const MachineFunction &MF) {</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine coveredLine">  DenseMap<const MachineBasicBlock *, int> EHScopeMembership;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">810</td>
    <td class="codeLine coveredLine">  DenseMap<const MachineBasicBlock *, int> EHScopeMembership;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">  // We don't have anything to do if there aren't any EH pads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">  // We don't have anything to do if there aren't any EH pads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine coveredLine">  if (!MF.hasEHScopes())</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">813</td>
    <td class="codeLine coveredLine">  if (!MF.hasEHScopes())</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine coveredLine">    return EHScopeMembership;</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">814</td>
    <td class="codeLine coveredLine">    return EHScopeMembership;</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine">  int EntryBBNumber = MF.front().getNumber();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">816</td>
    <td class="codeLine">  int EntryBBNumber = MF.front().getNumber();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  bool IsSEH = isAsynchronousEHPersonality(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  bool IsSEH = isAsynchronousEHPersonality(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">      classifyEHPersonality(MF.getFunction().getPersonalityFn()));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">      classifyEHPersonality(MF.getFunction().getPersonalityFn()));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">  const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">  const TargetInstrInfo *TII = MF.getSubtarget().getInstrInfo();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">  SmallVector<const MachineBasicBlock *, 16> EHScopeBlocks;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">  SmallVector<const MachineBasicBlock *, 16> EHScopeBlocks;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">  SmallVector<const MachineBasicBlock *, 16> UnreachableBlocks;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">  SmallVector<const MachineBasicBlock *, 16> UnreachableBlocks;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">  SmallVector<const MachineBasicBlock *, 16> SEHCatchPads;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">  SmallVector<const MachineBasicBlock *, 16> SEHCatchPads;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">  SmallVector<std::pair<const MachineBasicBlock *, int>, 16> CatchRetSuccessors;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">  SmallVector<std::pair<const MachineBasicBlock *, int>, 16> CatchRetSuccessors;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">  for (const MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">  for (const MachineBasicBlock &MBB : MF) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">    if (MBB.isEHScopeEntry()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">    if (MBB.isEHScopeEntry()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">      EHScopeBlocks.push_back(&MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">      EHScopeBlocks.push_back(&MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine">    } else if (IsSEH && MBB.isEHPad()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">828</td>
    <td class="codeLine">    } else if (IsSEH && MBB.isEHPad()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">      SEHCatchPads.push_back(&MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">      SEHCatchPads.push_back(&MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">    } else if (MBB.pred_empty()) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">    } else if (MBB.pred_empty()) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">      UnreachableBlocks.push_back(&MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">      UnreachableBlocks.push_back(&MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">    MachineBasicBlock::const_iterator MBBI = MBB.getFirstTerminator();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">    MachineBasicBlock::const_iterator MBBI = MBB.getFirstTerminator();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">    // CatchPads are not scopes for SEH so do not consider CatchRet to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">    // CatchPads are not scopes for SEH so do not consider CatchRet to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">    // transfer control to another scope.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">    // transfer control to another scope.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">    if (MBBI == MBB.end() || MBBI->getOpcode() != TII->getCatchReturnOpcode())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">    if (MBBI == MBB.end() || MBBI->getOpcode() != TII->getCatchReturnOpcode())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">      continue;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">    // FIXME: SEH CatchPads are not necessarily in the parent function:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">    // FIXME: SEH CatchPads are not necessarily in the parent function:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine">    // they could be inside a finally block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine">    // they could be inside a finally block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">    const MachineBasicBlock *Successor = MBBI->getOperand(0).getMBB();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">    const MachineBasicBlock *Successor = MBBI->getOperand(0).getMBB();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">    const MachineBasicBlock *SuccessorColor = MBBI->getOperand(1).getMBB();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">    const MachineBasicBlock *SuccessorColor = MBBI->getOperand(1).getMBB();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">    CatchRetSuccessors.push_back(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">    CatchRetSuccessors.push_back(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">        {Successor, IsSEH ? EntryBBNumber : SuccessorColor->getNumber()});</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">        {Successor, IsSEH ? EntryBBNumber : SuccessorColor->getNumber()});</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">  // We don't have anything to do if there aren't any EH pads.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">  // We don't have anything to do if there aren't any EH pads.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">  if (EHScopeBlocks.empty())</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">  if (EHScopeBlocks.empty())</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">    return EHScopeMembership;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">    return EHScopeMembership;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">  // Identify all the basic blocks reachable from the function entry.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">  // Identify all the basic blocks reachable from the function entry.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">  collectEHScopeMembers(EHScopeMembership, EntryBBNumber, &MF.front());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">  collectEHScopeMembers(EHScopeMembership, EntryBBNumber, &MF.front());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">  // All blocks not part of a scope are in the parent function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">  // All blocks not part of a scope are in the parent function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine">  for (const MachineBasicBlock *MBB : UnreachableBlocks)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">856</td>
    <td class="codeLine">  for (const MachineBasicBlock *MBB : UnreachableBlocks)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">    collectEHScopeMembers(EHScopeMembership, EntryBBNumber, MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">    collectEHScopeMembers(EHScopeMembership, EntryBBNumber, MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">  // Next, identify all the blocks inside the scopes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">  // Next, identify all the blocks inside the scopes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">  for (const MachineBasicBlock *MBB : EHScopeBlocks)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">  for (const MachineBasicBlock *MBB : EHScopeBlocks)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">    collectEHScopeMembers(EHScopeMembership, MBB->getNumber(), MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">    collectEHScopeMembers(EHScopeMembership, MBB->getNumber(), MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">  // SEH CatchPads aren't really scopes, handle them separately.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">  // SEH CatchPads aren't really scopes, handle them separately.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">  for (const MachineBasicBlock *MBB : SEHCatchPads)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">  for (const MachineBasicBlock *MBB : SEHCatchPads)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">    collectEHScopeMembers(EHScopeMembership, EntryBBNumber, MBB);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">    collectEHScopeMembers(EHScopeMembership, EntryBBNumber, MBB);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">  // Finally, identify all the targets of a catchret.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">  // Finally, identify all the targets of a catchret.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">  for (std::pair<const MachineBasicBlock *, int> CatchRetPair :</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">  for (std::pair<const MachineBasicBlock *, int> CatchRetPair :</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">       CatchRetSuccessors)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">       CatchRetSuccessors)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">    collectEHScopeMembers(EHScopeMembership, CatchRetPair.second,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">    collectEHScopeMembers(EHScopeMembership, CatchRetPair.second,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">                          CatchRetPair.first);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">                          CatchRetPair.first);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine">  return EHScopeMembership;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">869</td>
    <td class="codeLine">  return EHScopeMembership;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>