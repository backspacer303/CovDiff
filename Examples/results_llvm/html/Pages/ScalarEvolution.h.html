<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ScalarEvolution.h</title>
    <link rel="stylesheet" href="../Style/style.css" />
  </head>
  <body>
    <div class="headerDiv">
      <h1>
        Code Coverage
      </h1>
      <p>
        Source file: /home/nikola/Desktop/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
      </p>
    </div>
    <button class="collapsible" type="button">Open Summary Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Summary Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line number</th>
    <th class="mainTh">Line</th>
    <th class="mainTh">Number of hits</th>
    <th class="mainTh">Tests that cover line</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="">//===- llvm/Analysis/ScalarEvolution.h - Scalar Evolution -------*- C++ -*-===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="">// The ScalarEvolution class is an LLVM pass which can be used to analyze and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="">// categorize scalar expressions in loops.  It specializes in recognizing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="">// general induction variables, representing them with the abstract and opaque</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="">// SCEV class.  Given this analysis, trip counts of loops and other important</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="">// properties can be obtained.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="">// This analysis is primarily useful for induction variable substitution and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="">// strength reduction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="">//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="">//===----------------------------------------------------------------------===//</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="">#ifndef LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="">#define LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="">#include "llvm/ADT/APInt.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="">#include "llvm/ADT/ArrayRef.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="">#include "llvm/ADT/DenseMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="">#include "llvm/ADT/FoldingSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="">#include "llvm/ADT/PointerIntPair.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="">#include "llvm/ADT/SetVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="">#include "llvm/ADT/SmallVector.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="">#include "llvm/IR/ConstantRange.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="">#include "llvm/IR/InstrTypes.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="">#include "llvm/IR/Instructions.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="">#include "llvm/IR/PassManager.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="">#include "llvm/IR/ValueHandle.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="">#include "llvm/IR/ValueMap.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="">#include "llvm/Pass.h"</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="">#include <cassert></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="">#include <cstdint></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="">#include <memory></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="">#include <optional></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="">#include <utility></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="">namespace llvm {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="">class OverflowingBinaryOperator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="">class AssumptionCache;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="">class BasicBlock;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="">class Constant;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="">class ConstantInt;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="">class DataLayout;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="">class DominatorTree;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="">class Function;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="">class GEPOperator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="">class Instruction;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="">class LLVMContext;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="">class Loop;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="">class LoopInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="">class raw_ostream;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="">class ScalarEvolution;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="">class SCEVAddRecExpr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="">class SCEVUnknown;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="">class StructType;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="">class TargetLibraryInfo;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="">class Type;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="">class Value;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="">enum SCEVTypes : unsigned short;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="">extern bool VerifySCEV;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="">/// This class represents an analyzed expression in the program.  These are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="">/// opaque objects that the client is not allowed to do much with directly.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="">class SCEV : public FoldingSetNode {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="">  friend struct FoldingSetTrait<SCEV>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="">  /// A reference to an Interned FoldingSetNodeID for this node.  The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="">  /// ScalarEvolution's BumpPtrAllocator holds the data.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="">  FoldingSetNodeIDRef FastID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="">  // The SCEV baseclass this node corresponds to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="">  const SCEVTypes SCEVType;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="">  // Estimated complexity of this node's expression tree size.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="">  const unsigned short ExpressionSize;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="">  /// This field is initialized to zero and may be used in subclasses to store</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="">  /// miscellaneous information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="">  unsigned short SubclassData = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="">  /// NoWrapFlags are bitfield indices into SubclassData.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="">  /// Add and Mul expressions may have no-unsigned-wrap <NUW> or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="">  /// no-signed-wrap <NSW> properties, which are derived from the IR</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="">  /// operator. NSW is a misnomer that we use to mean no signed overflow or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="">  /// underflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="">  /// AddRec expressions may have a no-self-wraparound <NW> property if, in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="">  /// the integer domain, abs(step) * max-iteration(loop) <=</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="">  /// unsigned-max(bitwidth).  This means that the recurrence will never reach</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="">  /// its start value if the step is non-zero.  Computing the same value on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="">  /// each iteration is not considered wrapping, and recurrences with step = 0</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="">  /// are trivially <NW>.  <NW> is independent of the sign of step and the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="">  /// value the add recurrence starts with.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="">  /// Note that NUW and NSW are also valid properties of a recurrence, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="">  /// either implies NW. For convenience, NW will be set for a recurrence</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="">  /// whenever either NUW or NSW are set.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="">  /// We require that the flag on a SCEV apply to the entire scope in which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="">  /// that SCEV is defined.  A SCEV's scope is set of locations dominated by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="">  /// a defining location, which is in turn described by the following rules:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="">  /// * A SCEVUnknown is at the point of definition of the Value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="">  /// * A SCEVConstant is defined at all points.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="">  /// * A SCEVAddRec is defined starting with the header of the associated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="">  ///   loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="">  /// * All other SCEVs are defined at the earlest point all operands are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="">  ///   defined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="">  /// The above rules describe a maximally hoisted form (without regards to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="">  /// potential control dependence).  A SCEV is defined anywhere a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="">  /// corresponding instruction could be defined in said maximally hoisted</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="">  /// form.  Note that SCEVUDivExpr (currently the only expression type which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="">  /// can trap) can be defined per these rules in regions where it would trap</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="">  /// at runtime.  A SCEV being defined does not require the existence of any</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="">  /// instruction within the defined scope.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="">  enum NoWrapFlags {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="">    FlagAnyWrap = 0,    // No guarantee.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="">    FlagNW = (1 << 0),  // No self-wrap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="">    FlagNUW = (1 << 1), // No unsigned wrap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="">    FlagNSW = (1 << 2), // No signed wrap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="">    NoWrapMask = (1 << 3) - 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="coveredLine">  explicit SCEV(const FoldingSetNodeIDRef ID, SCEVTypes SCEVTy,</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="">                unsigned short ExpressionSize)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="coveredLine">      : FastID(ID), SCEVType(SCEVTy), ExpressionSize(ExpressionSize) {}</td>
    <td>2</td>
    <td class="testName">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="">  SCEV(const SCEV &) = delete;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="">  SCEV &operator=(const SCEV &) = delete;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="uncoveredLine">  SCEVTypes getSCEVType() const { return SCEVType; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="">  /// Return the LLVM type of this SCEV expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="">  Type *getType() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="">  /// Return operands of this SCEV expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="">  ArrayRef<const SCEV *> operands() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="">  /// Return true if the expression is a constant zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="">  bool isZero() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="">  /// Return true if the expression is a constant one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="">  bool isOne() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="">  /// Return true if the expression is a constant all-ones value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="">  bool isAllOnesValue() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="">  /// Return true if the specified scev is negated, but not a constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="">  bool isNonConstantNegative() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="">  // Returns estimated size of the mathematical expression represented by this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="">  // SCEV. The rules of its calculation are following:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="">  // 1) Size of a SCEV without operands (like constants and SCEVUnknown) is 1;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="">  // 2) Size SCEV with operands Op1, Op2, ..., OpN is calculated by formula:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="">  //    (1 + Size(Op1) + ... + Size(OpN)).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="">  // This value gives us an estimation of time we need to traverse through this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="">  // SCEV and all its operands recursively. We may use it to avoid performing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="">  // heavy transformations on SCEVs of excessive size for sake of saving the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="">  // compilation time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="uncoveredLine">  unsigned short getExpressionSize() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="uncoveredLine">    return ExpressionSize;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="">  /// Print out the internal representation of this scalar to the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="">  /// stream.  This should really only be used for debugging purposes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="">  void print(raw_ostream &OS) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="">  /// This method is used for debugging.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="">  void dump() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="">// Specialize FoldingSetTrait for SCEV to avoid needing to compute</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="">// temporary FoldingSetNodeID values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="">template <> struct FoldingSetTrait<SCEV> : DefaultFoldingSetTrait<SCEV> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="uncoveredLine">  static void Profile(const SCEV &X, FoldingSetNodeID &ID) { ID = X.FastID; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="uncoveredLine">  static bool Equals(const SCEV &X, const FoldingSetNodeID &ID, unsigned IDHash,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="">                     FoldingSetNodeID &TempID) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="uncoveredLine">    return ID == X.FastID;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="uncoveredLine">  static unsigned ComputeHash(const SCEV &X, FoldingSetNodeID &TempID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="uncoveredLine">    return X.FastID.ComputeHash();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="uncoveredLine">inline raw_ostream &operator<<(raw_ostream &OS, const SCEV &S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="uncoveredLine">  S.print(OS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="uncoveredLine">  return OS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="">/// An object of this class is returned by queries that could not be answered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="">/// For example, if you ask for the number of iterations of a linked-list</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="">/// traversal loop, you will get one of these.  None of the standard SCEV</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="">/// operations are valid on this class, it is just a marker.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="">struct SCEVCouldNotCompute : public SCEV {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="">  SCEVCouldNotCompute();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="">  static bool classof(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="">/// This class represents an assumption made using SCEV expressions which can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="">/// be checked at run-time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="">class SCEVPredicate : public FoldingSetNode {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="">  friend struct FoldingSetTrait<SCEVPredicate>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="">  /// A reference to an Interned FoldingSetNodeID for this node.  The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="">  /// ScalarEvolution's BumpPtrAllocator holds the data.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="">  FoldingSetNodeIDRef FastID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="">  enum SCEVPredicateKind { P_Union, P_Compare, P_Wrap };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="">protected:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="">  SCEVPredicateKind Kind;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="">  ~SCEVPredicate() = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="">  SCEVPredicate(const SCEVPredicate &) = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="">  SCEVPredicate &operator=(const SCEVPredicate &) = default;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="">  SCEVPredicate(const FoldingSetNodeIDRef ID, SCEVPredicateKind Kind);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="uncoveredLine">  SCEVPredicateKind getKind() const { return Kind; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="">  /// Returns the estimated complexity of this predicate.  This is roughly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="">  /// measured in the number of run-time checks required.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="uncoveredLine">  virtual unsigned getComplexity() const { return 1; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="">  /// Returns true if the predicate is always true. This means that no</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="">  /// assumptions were made and nothing needs to be checked at run-time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="">  virtual bool isAlwaysTrue() const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="">  /// Returns true if this predicate implies \p N.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="">  virtual bool implies(const SCEVPredicate *N) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="">  /// Prints a textual representation of this predicate with an indentation of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="">  /// \p Depth.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="">  virtual void print(raw_ostream &OS, unsigned Depth = 0) const = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="uncoveredLine">inline raw_ostream &operator<<(raw_ostream &OS, const SCEVPredicate &P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="uncoveredLine">  P.print(OS);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="uncoveredLine">  return OS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="">}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="">// Specialize FoldingSetTrait for SCEVPredicate to avoid needing to compute</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="">// temporary FoldingSetNodeID values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="">template <></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="">struct FoldingSetTrait<SCEVPredicate> : DefaultFoldingSetTrait<SCEVPredicate> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="uncoveredLine">  static void Profile(const SCEVPredicate &X, FoldingSetNodeID &ID) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="uncoveredLine">    ID = X.FastID;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="uncoveredLine">  static bool Equals(const SCEVPredicate &X, const FoldingSetNodeID &ID,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="">                     unsigned IDHash, FoldingSetNodeID &TempID) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="uncoveredLine">    return ID == X.FastID;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="uncoveredLine">  static unsigned ComputeHash(const SCEVPredicate &X,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="">                              FoldingSetNodeID &TempID) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="uncoveredLine">    return X.FastID.ComputeHash();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="">/// This class represents an assumption that the expression LHS Pred RHS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="">/// evaluates to true, and this can be checked at run-time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="">class SCEVComparePredicate final : public SCEVPredicate {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="">  /// We assume that LHS Pred RHS is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="">  const ICmpInst::Predicate Pred;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="">  const SCEV *LHS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="">  const SCEV *RHS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="">  SCEVComparePredicate(const FoldingSetNodeIDRef ID,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="">                       const ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="">                       const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="">  /// Implementation of the SCEVPredicate interface</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="">  bool implies(const SCEVPredicate *N) const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="">  void print(raw_ostream &OS, unsigned Depth = 0) const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="">  bool isAlwaysTrue() const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="uncoveredLine">  ICmpInst::Predicate getPredicate() const { return Pred; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="">  /// Returns the left hand side of the predicate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="uncoveredLine">  const SCEV *getLHS() const { return LHS; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="">  /// Returns the right hand side of the predicate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="uncoveredLine">  const SCEV *getRHS() const { return RHS; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="uncoveredLine">  static bool classof(const SCEVPredicate *P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="uncoveredLine">    return P->getKind() == P_Compare;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="">/// This class represents an assumption made on an AddRec expression. Given an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="">/// affine AddRec expression {a,+,b}, we assume that it has the nssw or nusw</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="">/// flags (defined below) in the first X iterations of the loop, where X is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="">/// SCEV expression returned by getPredicatedBackedgeTakenCount).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="">/// Note that this does not imply that X is equal to the backedge taken</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="">/// count. This means that if we have a nusw predicate for i32 {0,+,1} with a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="">/// predicated backedge taken count of X, we only guarantee that {0,+,1} has</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="">/// nusw in the first X iterations. {0,+,1} may still wrap in the loop if we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="">/// have more than X iterations.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="">class SCEVWrapPredicate final : public SCEVPredicate {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="">  /// Similar to SCEV::NoWrapFlags, but with slightly different semantics</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="">  /// for FlagNUSW. The increment is considered to be signed, and a + b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="">  /// (where b is the increment) is considered to wrap if:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="">  ///    zext(a + b) != zext(a) + sext(b)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="">  /// If Signed is a function that takes an n-bit tuple and maps to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="">  /// integer domain as the tuples value interpreted as twos complement,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="">  /// and Unsigned a function that takes an n-bit tuple and maps to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="">  /// integer domain as as the base two value of input tuple, then a + b</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="">  /// has IncrementNUSW iff:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="">  /// 0 <= Unsigned(a) + Signed(b) < 2^n</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="">  /// The IncrementNSSW flag has identical semantics with SCEV::FlagNSW.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="">  /// Note that the IncrementNUSW flag is not commutative: if base + inc</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="">  /// has IncrementNUSW, then inc + base doesn't neccessarily have this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="">  /// property. The reason for this is that this is used for sign/zero</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="">  /// extending affine AddRec SCEV expressions when a SCEVWrapPredicate is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="">  /// assumed. A {base,+,inc} expression is already non-commutative with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="">  /// regards to base and inc, since it is interpreted as:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="">  ///     (((base + inc) + inc) + inc) ...</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="">  enum IncrementWrapFlags {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="">    IncrementAnyWrap = 0,     // No guarantee.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="">    IncrementNUSW = (1 << 0), // No unsigned with signed increment wrap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="">    IncrementNSSW = (1 << 1), // No signed with signed increment wrap</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="">                              // (equivalent with SCEV::NSW)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="">    IncrementNoWrapMask = (1 << 2) - 1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="">  /// Convenient IncrementWrapFlags manipulation methods.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="uncoveredLine">  clearFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="">             SCEVWrapPredicate::IncrementWrapFlags OffFlags) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="uncoveredLine">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="uncoveredLine">    assert((OffFlags & IncrementNoWrapMask) == OffFlags &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="">           "Invalid flags value!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="uncoveredLine">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & ~OffFlags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="">  maskFlags(SCEVWrapPredicate::IncrementWrapFlags Flags, int Mask) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="">    assert((Mask & IncrementNoWrapMask) == Mask && "Invalid mask value!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & Mask);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="uncoveredLine">  setFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="">           SCEVWrapPredicate::IncrementWrapFlags OnFlags) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="uncoveredLine">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="uncoveredLine">    assert((OnFlags & IncrementNoWrapMask) == OnFlags &&</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="">           "Invalid flags value!");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="uncoveredLine">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags | OnFlags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="">  /// Returns the set of SCEVWrapPredicate no wrap flags implied by a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="">  /// SCEVAddRecExpr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="">  getImpliedFlags(const SCEVAddRecExpr *AR, ScalarEvolution &SE);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="">  const SCEVAddRecExpr *AR;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="">  IncrementWrapFlags Flags;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="">  explicit SCEVWrapPredicate(const FoldingSetNodeIDRef ID,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="">                             const SCEVAddRecExpr *AR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="">                             IncrementWrapFlags Flags);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="">  /// Returns the set assumed no overflow flags.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="uncoveredLine">  IncrementWrapFlags getFlags() const { return Flags; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="">  /// Implementation of the SCEVPredicate interface</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="">  const SCEVAddRecExpr *getExpr() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="">  bool implies(const SCEVPredicate *N) const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="">  void print(raw_ostream &OS, unsigned Depth = 0) const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="">  bool isAlwaysTrue() const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="uncoveredLine">  static bool classof(const SCEVPredicate *P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="uncoveredLine">    return P->getKind() == P_Wrap;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="">/// This class represents a composition of other SCEV predicates, and is the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="">/// class that most clients will interact with.  This is equivalent to a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="">/// logical "AND" of all the predicates in the union.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="">/// NB! Unlike other SCEVPredicate sub-classes this class does not live in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="">/// ScalarEvolution::Preds folding set.  This is why the \c add function is sound.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="">class SCEVUnionPredicate final : public SCEVPredicate {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="">  using PredicateMap =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="">      DenseMap<const SCEV *, SmallVector<const SCEVPredicate *, 4>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="">  /// Vector with references to all predicates in this union.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="">  SmallVector<const SCEVPredicate *, 16> Preds;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="">  /// Adds a predicate to this union.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="">  void add(const SCEVPredicate *N);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="">  SCEVUnionPredicate(ArrayRef<const SCEVPredicate *> Preds);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="uncoveredLine">  const SmallVectorImpl<const SCEVPredicate *> &getPredicates() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="uncoveredLine">    return Preds;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="">  /// Implementation of the SCEVPredicate interface</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="">  bool isAlwaysTrue() const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="">  bool implies(const SCEVPredicate *N) const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="">  void print(raw_ostream &OS, unsigned Depth) const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="">  /// We estimate the complexity of a union predicate as the size number of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="">  /// predicates in the union.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="uncoveredLine">  unsigned getComplexity() const override { return Preds.size(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="uncoveredLine">  static bool classof(const SCEVPredicate *P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="uncoveredLine">    return P->getKind() == P_Union;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="">/// The main scalar evolution driver. Because client code (intentionally)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="">/// can't do much with the SCEV objects directly, they must ask this class</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="">/// for services.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="">class ScalarEvolution {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="">  friend class ScalarEvolutionsTest;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="">  /// An enum describing the relationship between a SCEV and a loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="">  enum LoopDisposition {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="">    LoopVariant,   ///< The SCEV is loop-variant (unknown).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="">    LoopInvariant, ///< The SCEV is loop-invariant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="">    LoopComputable ///< The SCEV varies predictably with the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="">  /// An enum describing the relationship between a SCEV and a basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="">  enum BlockDisposition {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="">    DoesNotDominateBlock,  ///< The SCEV does not dominate the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="">    DominatesBlock,        ///< The SCEV dominates the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="">    ProperlyDominatesBlock ///< The SCEV properly dominates the block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="">  /// Convenient NoWrapFlags manipulation that hides enum casts and is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="">  /// visible in the ScalarEvolution name space.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="uncoveredLine">  [[nodiscard]] static SCEV::NoWrapFlags maskFlags(SCEV::NoWrapFlags Flags,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="">                                                   int Mask) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="uncoveredLine">    return (SCEV::NoWrapFlags)(Flags & Mask);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="uncoveredLine">  [[nodiscard]] static SCEV::NoWrapFlags setFlags(SCEV::NoWrapFlags Flags,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="">                                                  SCEV::NoWrapFlags OnFlags) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="uncoveredLine">    return (SCEV::NoWrapFlags)(Flags | OnFlags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="">  [[nodiscard]] static SCEV::NoWrapFlags</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="">  clearFlags(SCEV::NoWrapFlags Flags, SCEV::NoWrapFlags OffFlags) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="">    return (SCEV::NoWrapFlags)(Flags & ~OffFlags);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="uncoveredLine">  [[nodiscard]] static bool hasFlags(SCEV::NoWrapFlags Flags,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="">                                     SCEV::NoWrapFlags TestFlags) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="uncoveredLine">    return TestFlags == maskFlags(Flags, TestFlags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="">  ScalarEvolution(Function &F, TargetLibraryInfo &TLI, AssumptionCache &AC,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="">                  DominatorTree &DT, LoopInfo &LI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="">  ScalarEvolution(ScalarEvolution &&Arg);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="">  ~ScalarEvolution();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="uncoveredLine">  LLVMContext &getContext() const { return F.getContext(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="">  /// Test if values of the given type are analyzable within the SCEV</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="">  /// framework. This primarily includes integer types, and it can optionally</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="">  /// include pointer types if the ScalarEvolution class has access to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="">  /// target-specific information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="">  bool isSCEVable(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="">  /// Return the size in bits of the specified type, for which isSCEVable must</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="">  /// return true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="">  uint64_t getTypeSizeInBits(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="">  /// Return a type with the same bitwidth as the given type and which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="">  /// represents how SCEV will treat the given type, for which isSCEVable must</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="">  /// return true. For pointer types, this is the pointer-sized integer type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="">  Type *getEffectiveSCEVType(Type *Ty) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="">  // Returns a wider type among {Ty1, Ty2}.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="">  Type *getWiderType(Type *Ty1, Type *Ty2) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="">  /// Return true if there exists a point in the program at which both</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="">  /// A and B could be operands to the same instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="">  /// SCEV expressions are generally assumed to correspond to instructions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="">  /// which could exists in IR.  In general, this requires that there exists</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="">  /// a use point in the program where all operands dominate the use.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="">  /// Example:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="">  /// loop {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="">  ///   if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="">  ///     loop { v1 = load @global1; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="">  ///   else</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="">  ///     loop { v2 = load @global2; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="">  /// }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="">  /// No SCEV with operand V1, and v2 can exist in this program.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="">  bool instructionCouldExistWitthOperands(const SCEV *A, const SCEV *B);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="">  /// Return true if the SCEV is a scAddRecExpr or it contains</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="">  /// scAddRecExpr. The result will be cached in HasRecMap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="">  bool containsAddRecurrence(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="">  /// Is operation \p BinOp between \p LHS and \p RHS provably does not have</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="">  /// a signed/unsigned overflow (\p Signed)? If \p CtxI is specified, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="">  /// no-overflow fact should be true in the context of this instruction.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="">  bool willNotOverflow(Instruction::BinaryOps BinOp, bool Signed,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="">                       const SCEV *LHS, const SCEV *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="">                       const Instruction *CtxI = nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="">  /// Parse NSW/NUW flags from add/sub/mul IR binary operation \p Op into</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="">  /// SCEV no-wrap flags, and deduce flag[s] that aren't known yet.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="">  /// Does not mutate the original instruction. Returns std::nullopt if it could</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="">  /// not deduce more precise flags than the instruction already has, otherwise</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="">  /// returns proven flags.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="">  std::optional<SCEV::NoWrapFlags></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="">  getStrengthenedNoWrapFlagsFromBinOp(const OverflowingBinaryOperator *OBO);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="">  /// Notify this ScalarEvolution that \p User directly uses SCEVs in \p Ops.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="">  void registerUser(const SCEV *User, ArrayRef<const SCEV *> Ops);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="">  /// Return true if the SCEV expression contains an undef value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="">  bool containsUndefs(const SCEV *S) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="">  /// Return true if the SCEV expression contains a Value that has been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="">  /// optimised out and is now a nullptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="">  bool containsErasedValue(const SCEV *S) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="">  /// Return a SCEV expression for the full generality of the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="">  /// expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="">  const SCEV *getSCEV(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="">  /// Return an existing SCEV for V if there is one, otherwise return nullptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="">  const SCEV *getExistingSCEV(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="">  const SCEV *getConstant(ConstantInt *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="">  const SCEV *getConstant(const APInt &Val);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="">  const SCEV *getConstant(Type *Ty, uint64_t V, bool isSigned = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="">  const SCEV *getLosslessPtrToIntExpr(const SCEV *Op, unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="">  const SCEV *getPtrToIntExpr(const SCEV *Op, Type *Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="">  const SCEV *getTruncateExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="">  const SCEV *getVScale(Type *Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="">  const SCEV *getZeroExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="">  const SCEV *getZeroExtendExprImpl(const SCEV *Op, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="">                                    unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="">  const SCEV *getSignExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="">  const SCEV *getSignExtendExprImpl(const SCEV *Op, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="">                                    unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="">  const SCEV *getCastExpr(SCEVTypes Kind, const SCEV *Op, Type *Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="">  const SCEV *getAnyExtendExpr(const SCEV *Op, Type *Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="">  const SCEV *getAddExpr(SmallVectorImpl<const SCEV *> &Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="">                         unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="uncoveredLine">  const SCEV *getAddExpr(const SCEV *LHS, const SCEV *RHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="">                         unsigned Depth = 0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="uncoveredLine">    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="uncoveredLine">    return getAddExpr(Ops, Flags, Depth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="">  const SCEV *getAddExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="">                         unsigned Depth = 0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="">    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="">    return getAddExpr(Ops, Flags, Depth);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="">  const SCEV *getMulExpr(SmallVectorImpl<const SCEV *> &Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="">                         unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="uncoveredLine">  const SCEV *getMulExpr(const SCEV *LHS, const SCEV *RHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="">                         unsigned Depth = 0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="uncoveredLine">    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="uncoveredLine">    return getMulExpr(Ops, Flags, Depth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="uncoveredLine">  const SCEV *getMulExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="">                         unsigned Depth = 0) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="uncoveredLine">    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="uncoveredLine">    return getMulExpr(Ops, Flags, Depth);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="">  const SCEV *getUDivExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="">  const SCEV *getUDivExactExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="">  const SCEV *getURemExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="">  const SCEV *getAddRecExpr(const SCEV *Start, const SCEV *Step, const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="">                            SCEV::NoWrapFlags Flags);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="">  const SCEV *getAddRecExpr(SmallVectorImpl<const SCEV *> &Operands,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="">                            const Loop *L, SCEV::NoWrapFlags Flags);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="uncoveredLine">  const SCEV *getAddRecExpr(const SmallVectorImpl<const SCEV *> &Operands,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="">                            const Loop *L, SCEV::NoWrapFlags Flags) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="uncoveredLine">    SmallVector<const SCEV *, 4> NewOp(Operands.begin(), Operands.end());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="uncoveredLine">    return getAddRecExpr(NewOp, L, Flags);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="uncoveredLine">  }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="">  /// Checks if \p SymbolicPHI can be rewritten as an AddRecExpr under some</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="">  /// Predicates. If successful return these <AddRecExpr, Predicates>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="">  /// The function is intended to be called from PSCEV (the caller will decide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="">  /// whether to actually add the predicates and carry out the rewrites).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="">  std::optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="">  createAddRecFromPHIWithCasts(const SCEVUnknown *SymbolicPHI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="">  /// Returns an expression for a GEP</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="">  /// \p GEP The GEP. The indices contained in the GEP itself are ignored,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="">  /// instead we use IndexExprs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="">  /// \p IndexExprs The expressions for the indices.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="">  const SCEV *getGEPExpr(GEPOperator *GEP,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="">                         const SmallVectorImpl<const SCEV *> &IndexExprs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="">  const SCEV *getAbsExpr(const SCEV *Op, bool IsNSW);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="">  const SCEV *getMinMaxExpr(SCEVTypes Kind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="">                            SmallVectorImpl<const SCEV *> &Operands);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="">  const SCEV *getSequentialMinMaxExpr(SCEVTypes Kind,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="">                                      SmallVectorImpl<const SCEV *> &Operands);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="">  const SCEV *getSMaxExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="">  const SCEV *getSMaxExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="">  const SCEV *getUMaxExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="">  const SCEV *getUMaxExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="">  const SCEV *getSMinExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="">  const SCEV *getSMinExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="">  const SCEV *getUMinExpr(const SCEV *LHS, const SCEV *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="">                          bool Sequential = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="">  const SCEV *getUMinExpr(SmallVectorImpl<const SCEV *> &Operands,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="">                          bool Sequential = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="">  const SCEV *getUnknown(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="">  const SCEV *getCouldNotCompute();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="">  /// Return a SCEV for the constant 0 of a specific type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="uncoveredLine">  const SCEV *getZero(Type *Ty) { return getConstant(Ty, 0); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="">  /// Return a SCEV for the constant 1 of a specific type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="uncoveredLine">  const SCEV *getOne(Type *Ty) { return getConstant(Ty, 1); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="">  /// Return a SCEV for the constant \p Power of two.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="">  const SCEV *getPowerOfTwo(Type *Ty, unsigned Power) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="">    assert(Power < getTypeSizeInBits(Ty) && "Power out of range");</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="">    return getConstant(APInt::getOneBitSet(getTypeSizeInBits(Ty), Power));</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="">  /// Return a SCEV for the constant -1 of a specific type.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="uncoveredLine">  const SCEV *getMinusOne(Type *Ty) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="uncoveredLine">    return getConstant(Ty, -1, /*isSigned=*/true);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="">  /// Return an expression for a TypeSize.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="">  const SCEV *getSizeOfExpr(Type *IntTy, TypeSize Size);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="">  /// Return an expression for the alloc size of AllocTy that is type IntTy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="">  const SCEV *getSizeOfExpr(Type *IntTy, Type *AllocTy);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="">  /// Return an expression for the store size of StoreTy that is type IntTy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="">  const SCEV *getStoreSizeOfExpr(Type *IntTy, Type *StoreTy);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="">  /// Return an expression for offsetof on the given field with type IntTy</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="">  const SCEV *getOffsetOfExpr(Type *IntTy, StructType *STy, unsigned FieldNo);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="">  /// Return the SCEV object corresponding to -V.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="">  const SCEV *getNegativeSCEV(const SCEV *V,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="">                              SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="">  /// Return the SCEV object corresponding to ~V.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="">  const SCEV *getNotSCEV(const SCEV *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="">  /// Return LHS-RHS.  Minus is represented in SCEV as A+B*-1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="">  /// If the LHS and RHS are pointers which don't share a common base</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="">  /// (according to getPointerBase()), this returns a SCEVCouldNotCompute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="">  /// To compute the difference between two unrelated pointers, you can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="">  /// explicitly convert the arguments using getPtrToIntExpr(), for pointer</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="">  /// types that support it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="">  const SCEV *getMinusSCEV(const SCEV *LHS, const SCEV *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="">                           SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="">                           unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="">  /// Compute ceil(N / D). N and D are treated as unsigned values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="">  /// Since SCEV doesn't have native ceiling division, this generates a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="">  /// SCEV expression of the following form:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="">  /// umin(N, 1) + floor((N - umin(N, 1)) / D)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="">  /// A denominator of zero or poison is handled the same way as getUDivExpr().</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="">  const SCEV *getUDivCeilSCEV(const SCEV *N, const SCEV *D);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="">  /// specified type.  If the type must be extended, it is zero extended.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="">  const SCEV *getTruncateOrZeroExtend(const SCEV *V, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="">                                      unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="">  /// specified type.  If the type must be extended, it is sign extended.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="">  const SCEV *getTruncateOrSignExtend(const SCEV *V, Type *Ty,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="">                                      unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="">  /// specified type.  If the type must be extended, it is zero extended.  The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="">  /// conversion must not be narrowing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="">  const SCEV *getNoopOrZeroExtend(const SCEV *V, Type *Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="">  /// specified type.  If the type must be extended, it is sign extended.  The</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="">  /// conversion must not be narrowing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="">  const SCEV *getNoopOrSignExtend(const SCEV *V, Type *Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="">  /// specified type. If the type must be extended, it is extended with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="">  /// unspecified bits. The conversion must not be narrowing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="">  const SCEV *getNoopOrAnyExtend(const SCEV *V, Type *Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="">  /// specified type.  The conversion must not be widening.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="">  const SCEV *getTruncateOrNoop(const SCEV *V, Type *Ty);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="">  /// Promote the operands to the wider of the types using zero-extension, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="">  /// then perform a umax operation with them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="">  const SCEV *getUMaxFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="">  /// Promote the operands to the wider of the types using zero-extension, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="">  /// then perform a umin operation with them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="">  const SCEV *getUMinFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="">                                         bool Sequential = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="">  /// Promote the operands to the wider of the types using zero-extension, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="">  /// then perform a umin operation with them. N-ary function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="">  const SCEV *getUMinFromMismatchedTypes(SmallVectorImpl<const SCEV *> &Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="">                                         bool Sequential = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="">  /// Transitively follow the chain of pointer-type operands until reaching a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="">  /// SCEV that does not have a single pointer operand. This returns a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="">  /// SCEVUnknown pointer for well-formed pointer-type expressions, but corner</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="">  /// cases do exist.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="">  const SCEV *getPointerBase(const SCEV *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="">  /// Compute an expression equivalent to S - getPointerBase(S).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="">  const SCEV *removePointerBase(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="">  /// Return a SCEV expression for the specified value at the specified scope</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="">  /// in the program.  The L value specifies a loop nest to evaluate the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="">  /// expression at, where null is the top-level or a specified loop is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="">  /// immediately inside of the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="">  /// This method can be used to compute the exit value for a variable defined</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="">  /// in a loop by querying what the value will hold in the parent loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="">  /// In the case that a relevant loop exit value cannot be computed, the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="">  /// original value V is returned.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="">  const SCEV *getSCEVAtScope(const SCEV *S, const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="">  /// This is a convenience function which does getSCEVAtScope(getSCEV(V), L).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="">  const SCEV *getSCEVAtScope(Value *V, const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="">  /// Test whether entry to the loop is protected by a conditional between LHS</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="">  /// and RHS.  This is used to help avoid max expressions in loop trip</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="">  /// counts, and to eliminate casts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="">  bool isLoopEntryGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="">                                const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="">  /// Test whether entry to the basic block is protected by a conditional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="">  /// between LHS and RHS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="">  bool isBasicBlockEntryGuardedByCond(const BasicBlock *BB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="">                                      ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="">                                      const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="">  /// Test whether the backedge of the loop is protected by a conditional</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="">  /// between LHS and RHS.  This is used to eliminate casts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="">  bool isLoopBackedgeGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="">                                   const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="">  /// A version of getTripCountFromExitCount below which always picks an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="">  /// evaluation type which can not result in overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="">  const SCEV *getTripCountFromExitCount(const SCEV *ExitCount);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="">  /// Convert from an "exit count" (i.e. "backedge taken count") to a "trip</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="">  /// count".  A "trip count" is the number of times the header of the loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="">  /// will execute if an exit is taken after the specified number of backedges</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="">  /// have been taken.  (e.g. TripCount = ExitCount + 1).  Note that the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="">  /// expression can overflow if ExitCount = UINT_MAX.  If EvalTy is not wide</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="">  /// enough to hold the result without overflow, result unsigned wraps with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="">  /// 2s-complement semantics.  ex: EC = 255 (i8), TC = 0 (i8)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="">  const SCEV *getTripCountFromExitCount(const SCEV *ExitCount, Type *EvalTy,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="">                                        const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="">  /// Returns the exact trip count of the loop if we can compute it, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="">  /// the result is a small constant.  '0' is used to represent an unknown</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="">  /// or non-constant trip count.  Note that a trip count is simply one more</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="">  /// than the backedge taken count for the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="">  unsigned getSmallConstantTripCount(const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="">  /// Return the exact trip count for this loop if we exit through ExitingBlock.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="">  /// '0' is used to represent an unknown or non-constant trip count.  Note</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="">  /// that a trip count is simply one more than the backedge taken count for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="">  /// the same exit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="">  /// This "trip count" assumes that control exits via ExitingBlock. More</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="">  /// precisely, it is the number of times that control will reach ExitingBlock</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="">  /// before taking the branch. For loops with multiple exits, it may not be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="">  /// the number times that the loop header executes if the loop exits</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="">  /// prematurely via another branch.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="">  unsigned getSmallConstantTripCount(const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="">                                     const BasicBlock *ExitingBlock);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="">  /// Returns the upper bound of the loop trip count as a normal unsigned</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="">  /// value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="">  /// Returns 0 if the trip count is unknown or not constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="">  unsigned getSmallConstantMaxTripCount(const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="">  /// Returns the largest constant divisor of the trip count as a normal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="">  /// unsigned value, if possible. This means that the actual trip count is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="">  /// always a multiple of the returned value. Returns 1 if the trip count is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="">  /// unknown or not guaranteed to be the multiple of a constant., Will also</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="">  /// return 1 if the trip count is very large (>= 2^32).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="">  /// Note that the argument is an exit count for loop L, NOT a trip count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="">  unsigned getSmallConstantTripMultiple(const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="">                                        const SCEV *ExitCount);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="">  /// Returns the largest constant divisor of the trip count of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="">  /// loop.  Will return 1 if no trip count could be computed, or if a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="">  /// divisor could not be found.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="">  unsigned getSmallConstantTripMultiple(const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="">  /// Returns the largest constant divisor of the trip count of this loop as a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="">  /// normal unsigned value, if possible. This means that the actual trip</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="">  /// count is always a multiple of the returned value (don't forget the trip</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="">  /// count could very well be zero as well!). As explained in the comments</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="">  /// for getSmallConstantTripCount, this assumes that control exits the loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="">  /// via ExitingBlock.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="">  unsigned getSmallConstantTripMultiple(const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="">                                        const BasicBlock *ExitingBlock);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="">  /// The terms "backedge taken count" and "exit count" are used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="">  /// interchangeably to refer to the number of times the backedge of a loop </td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="">  /// has executed before the loop is exited.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="">  enum ExitCountKind {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="">    /// An expression exactly describing the number of times the backedge has</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="">    /// executed when a loop is exited.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="">    Exact,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="">    /// A constant which provides an upper bound on the exact trip count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="">    ConstantMaximum,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="">    /// An expression which provides an upper bound on the exact trip count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="">    SymbolicMaximum,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="">  /// Return the number of times the backedge executes before the given exit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="">  /// would be taken; if not exactly computable, return SCEVCouldNotCompute. </td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="">  /// For a single exit loop, this value is equivelent to the result of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="">  /// getBackedgeTakenCount.  The loop is guaranteed to exit (via *some* exit)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="">  /// before the backedge is executed (ExitCount + 1) times.  Note that there</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="">  /// is no guarantee about *which* exit is taken on the exiting iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="">  const SCEV *getExitCount(const Loop *L, const BasicBlock *ExitingBlock,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="">                           ExitCountKind Kind = Exact);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="">  /// If the specified loop has a predictable backedge-taken count, return it,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="">  /// otherwise return a SCEVCouldNotCompute object. The backedge-taken count is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="">  /// the number of times the loop header will be branched to from within the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="">  /// loop, assuming there are no abnormal exists like exception throws. This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="">  /// one less than the trip count of the loop, since it doesn't count the first</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="">  /// iteration, when the header is branched to from outside the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="">  /// Note that it is not valid to call this method on a loop without a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="">  /// loop-invariant backedge-taken count (see</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="">  /// hasLoopInvariantBackedgeTakenCount).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="">  const SCEV *getBackedgeTakenCount(const Loop *L, ExitCountKind Kind = Exact);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="">  /// Similar to getBackedgeTakenCount, except it will add a set of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="">  /// SCEV predicates to Predicates that are required to be true in order for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="">  /// the answer to be correct. Predicates can be checked with run-time</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="">  /// checks and can be used to perform loop versioning.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="">  const SCEV *getPredicatedBackedgeTakenCount(const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="">                                              SmallVector<const SCEVPredicate *, 4> &Predicates);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="">  /// When successful, this returns a SCEVConstant that is greater than or equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="">  /// to (i.e. a "conservative over-approximation") of the value returend by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="">  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="">  /// SCEVCouldNotCompute object.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="uncoveredLine">  const SCEV *getConstantMaxBackedgeTakenCount(const Loop *L) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="uncoveredLine">    return getBackedgeTakenCount(L, ConstantMaximum);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="">  /// When successful, this returns a SCEV that is greater than or equal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="">  /// to (i.e. a "conservative over-approximation") of the value returend by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="">  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="">  /// SCEVCouldNotCompute object.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="uncoveredLine">  const SCEV *getSymbolicMaxBackedgeTakenCount(const Loop *L) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="uncoveredLine">    return getBackedgeTakenCount(L, SymbolicMaximum);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="">  /// Return true if the backedge taken count is either the value returned by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="">  /// getConstantMaxBackedgeTakenCount or zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="">  bool isBackedgeTakenCountMaxOrZero(const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="">  /// Return true if the specified loop has an analyzable loop-invariant</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="">  /// backedge-taken count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="">  bool hasLoopInvariantBackedgeTakenCount(const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="">  // This method should be called by the client when it made any change that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="">  // would invalidate SCEV's answers, and the client wants to remove all loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="">  // information held internally by ScalarEvolution. This is intended to be used</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="">  // when the alternative to forget a loop is too expensive (i.e. large loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="">  // bodies).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="">  void forgetAllLoops();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="">  /// This method should be called by the client when it has changed a loop in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="">  /// a way that may effect ScalarEvolution's ability to compute a trip count,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="">  /// or if the loop is deleted.  This call is potentially expensive for large</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="">  /// loop bodies.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="">  void forgetLoop(const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="">  // This method invokes forgetLoop for the outermost loop of the given loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="">  // \p L, making ScalarEvolution forget about all this subtree. This needs to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="">  // be done whenever we make a transform that may affect the parameters of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="">  // outer loop, such as exit counts for branches.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="">  void forgetTopmostLoop(const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="">  /// This method should be called by the client when it has changed a value</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="">  /// in a way that may effect its value, or which may disconnect it from a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="">  /// def-use chain linking it to a loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="">  void forgetValue(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="">  /// Called when the client has changed the disposition of values in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="">  /// this loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="">  /// We don't have a way to invalidate per-loop dispositions. Clear and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="">  /// recompute is simpler.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="">  void forgetLoopDispositions();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="">  /// Called when the client has changed the disposition of values in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="">  /// a loop or block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="">  /// We don't have a way to invalidate per-loop/per-block dispositions. Clear</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="">  /// and recompute is simpler.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="">  void forgetBlockAndLoopDispositions(Value *V = nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="">  /// Determine the minimum number of zero bits that S is guaranteed to end in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="">  /// (at every loop iteration).  It is, at the same time, the minimum number</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="">  /// of times S is divisible by 2.  For example, given {4,+,8} it returns 2.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="">  /// If S is guaranteed to be 0, it returns the bitwidth of S.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="">  uint32_t getMinTrailingZeros(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="">  /// Returns the max constant multiple of S.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="">  APInt getConstantMultiple(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="">  // Returns the max constant multiple of S. If S is exactly 0, return 1.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="">  APInt getNonZeroConstantMultiple(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="">  /// Determine the unsigned range for a particular SCEV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="">  /// NOTE: This returns a copy of the reference returned by getRangeRef.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="uncoveredLine">  ConstantRange getUnsignedRange(const SCEV *S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="uncoveredLine">    return getRangeRef(S, HINT_RANGE_UNSIGNED);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="">  /// Determine the min of the unsigned range for a particular SCEV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="uncoveredLine">  APInt getUnsignedRangeMin(const SCEV *S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="uncoveredLine">    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="">  /// Determine the max of the unsigned range for a particular SCEV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="uncoveredLine">  APInt getUnsignedRangeMax(const SCEV *S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="uncoveredLine">    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMax();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="">  /// Determine the signed range for a particular SCEV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="">  /// NOTE: This returns a copy of the reference returned by getRangeRef.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="uncoveredLine">  ConstantRange getSignedRange(const SCEV *S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="uncoveredLine">    return getRangeRef(S, HINT_RANGE_SIGNED);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="">  /// Determine the min of the signed range for a particular SCEV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="uncoveredLine">  APInt getSignedRangeMin(const SCEV *S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="uncoveredLine">    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMin();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="">  /// Determine the max of the signed range for a particular SCEV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="uncoveredLine">  APInt getSignedRangeMax(const SCEV *S) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="uncoveredLine">    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMax();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="">  /// Test if the given expression is known to be negative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="">  bool isKnownNegative(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="">  /// Test if the given expression is known to be positive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="">  bool isKnownPositive(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="">  /// Test if the given expression is known to be non-negative.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="">  bool isKnownNonNegative(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="">  /// Test if the given expression is known to be non-positive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="">  bool isKnownNonPositive(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="">  /// Test if the given expression is known to be non-zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="">  bool isKnownNonZero(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="">  /// Splits SCEV expression \p S into two SCEVs. One of them is obtained from</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="">  /// \p S by substitution of all AddRec sub-expression related to loop \p L</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="">  /// with initial value of that SCEV. The second is obtained from \p S by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="">  /// substitution of all AddRec sub-expressions related to loop \p L with post</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="">  /// increment of this AddRec in the loop \p L. In both cases all other AddRec</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="">  /// sub-expressions (not related to \p L) remain the same.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="">  /// If the \p S contains non-invariant unknown SCEV the function returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="">  /// CouldNotCompute SCEV in both values of std::pair.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="">  /// For example, for SCEV S={0, +, 1}<L1> + {0, +, 1}<L2> and loop L=L1</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="">  /// the function returns pair:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="">  /// first = {0, +, 1}<L2></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="">  /// second = {1, +, 1}<L1> + {0, +, 1}<L2></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="">  /// We can see that for the first AddRec sub-expression it was replaced with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="">  /// 0 (initial value) for the first element and to {1, +, 1}<L1> (post</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="">  /// increment value) for the second one. In both cases AddRec expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="">  /// related to L2 remains the same.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="">  std::pair<const SCEV *, const SCEV *> SplitIntoInitAndPostInc(const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="">                                                                const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="">  /// We'd like to check the predicate on every iteration of the most dominated</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="">  /// loop between loops used in LHS and RHS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="">  /// To do this we use the following list of steps:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="">  /// 1. Collect set S all loops on which either LHS or RHS depend.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="">  /// 2. If S is non-empty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="">  /// a. Let PD be the element of S which is dominated by all other elements.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="">  /// b. Let E(LHS) be value of LHS on entry of PD.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="">  ///    To get E(LHS), we should just take LHS and replace all AddRecs that are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="">  ///    attached to PD on with their entry values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="">  ///    Define E(RHS) in the same way.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="">  /// c. Let B(LHS) be value of L on backedge of PD.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="">  ///    To get B(LHS), we should just take LHS and replace all AddRecs that are</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="">  ///    attached to PD on with their backedge values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="">  ///    Define B(RHS) in the same way.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="">  /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="">  ///    so we can assert on that.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="">  /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="">  ///                   isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="">  bool isKnownViaInduction(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="">                           const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="">  /// Test if the given expression is known to satisfy the condition described</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="">  /// by Pred, LHS, and RHS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="">  bool isKnownPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="">                        const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="">  /// Check whether the condition described by Pred, LHS, and RHS is true or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="">  /// false. If we know it, return the evaluation of this condition. If neither</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="">  /// is proved, return std::nullopt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="">  std::optional<bool> evaluatePredicate(ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="">                                        const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="">  /// Test if the given expression is known to satisfy the condition described</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="">  /// by Pred, LHS, and RHS in the given Context.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="">  bool isKnownPredicateAt(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="">                          const SCEV *RHS, const Instruction *CtxI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="">  /// Check whether the condition described by Pred, LHS, and RHS is true or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="">  /// false in the given \p Context. If we know it, return the evaluation of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="">  /// this condition. If neither is proved, return std::nullopt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="">  std::optional<bool> evaluatePredicateAt(ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="">                                          const SCEV *LHS, const SCEV *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="">                                          const Instruction *CtxI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="">  /// Test if the condition described by Pred, LHS, RHS is known to be true on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="">  /// every iteration of the loop of the recurrency LHS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="">  bool isKnownOnEveryIteration(ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="">                               const SCEVAddRecExpr *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="">  /// Information about the number of loop iterations for which a loop exit's</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="">  /// branch condition evaluates to the not-taken path.  This is a temporary</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="">  /// pair of exact and max expressions that are eventually summarized in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="">  /// ExitNotTakenInfo and BackedgeTakenInfo.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="">  struct ExitLimit {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="">    const SCEV *ExactNotTaken; // The exit is not taken exactly this many times</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="">    const SCEV *ConstantMaxNotTaken; // The exit is not taken at most this many</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="">                                     // times</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="">    const SCEV *SymbolicMaxNotTaken;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="">    // Not taken either exactly ConstantMaxNotTaken or zero times</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="">    bool MaxOrZero = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="">    /// A set of predicate guards for this ExitLimit. The result is only valid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="">    /// if all of the predicates in \c Predicates evaluate to 'true' at</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="">    /// run-time.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="">    SmallPtrSet<const SCEVPredicate *, 4> Predicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="uncoveredLine">    void addPredicate(const SCEVPredicate *P) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="uncoveredLine">      assert(!isa<SCEVUnionPredicate>(P) && "Only add leaf predicates here!");</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="uncoveredLine">      Predicates.insert(P);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="">    /// Construct either an exact exit limit from a constant, or an unknown</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="">    /// one from a SCEVCouldNotCompute.  No other types of SCEVs are allowed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="">    /// as arguments and asserts enforce that internally.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="">    /*implicit*/ ExitLimit(const SCEV *E);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="">    ExitLimit(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="">        const SCEV *E, const SCEV *ConstantMaxNotTaken,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="">        const SCEV *SymbolicMaxNotTaken, bool MaxOrZero,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="">        ArrayRef<const SmallPtrSetImpl<const SCEVPredicate *> *> PredSetList =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="">            std::nullopt);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="">    ExitLimit(const SCEV *E, const SCEV *ConstantMaxNotTaken,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="">              const SCEV *SymbolicMaxNotTaken, bool MaxOrZero,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="">              const SmallPtrSetImpl<const SCEVPredicate *> &PredSet);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="">    /// Test whether this ExitLimit contains any computed information, or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="">    /// whether it's all SCEVCouldNotCompute values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="uncoveredLine">    bool hasAnyInfo() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="uncoveredLine">      return !isa<SCEVCouldNotCompute>(ExactNotTaken) ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="uncoveredLine">             !isa<SCEVCouldNotCompute>(ConstantMaxNotTaken);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="">    /// Test whether this ExitLimit contains all information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="uncoveredLine">    bool hasFullInfo() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="uncoveredLine">      return !isa<SCEVCouldNotCompute>(ExactNotTaken);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="">  /// Compute the number of times the backedge of the specified loop will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="">  /// execute if its exit condition were a conditional branch of ExitCond.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="">  /// \p ControlsOnlyExit is true if ExitCond directly controls the only exit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="">  /// branch. In this case, we can assume that the loop exits only if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="">  /// condition is true and can infer that failing to meet the condition prior</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="">  /// to integer wraparound results in undefined behavior.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="">  /// If \p AllowPredicates is set, this call will try to use a minimal set of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="">  /// SCEV predicates in order to return an exact answer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="">  ExitLimit computeExitLimitFromCond(const Loop *L, Value *ExitCond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="">                                     bool ExitIfTrue, bool ControlsOnlyExit,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="">                                     bool AllowPredicates = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="">  /// A predicate is said to be monotonically increasing if may go from being</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="">  /// false to being true as the loop iterates, but never the other way</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="">  /// around.  A predicate is said to be monotonically decreasing if may go</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="">  /// from being true to being false as the loop iterates, but never the other</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="">  /// way around.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="">  enum MonotonicPredicateType {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="">    MonotonicallyIncreasing,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="">    MonotonicallyDecreasing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="">  /// If, for all loop invariant X, the predicate "LHS `Pred` X" is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="">  /// monotonically increasing or decreasing, returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="">  /// Some(MonotonicallyIncreasing) and Some(MonotonicallyDecreasing)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="">  /// respectively. If we could not prove either of these facts, returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="">  /// std::nullopt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="">  std::optional<MonotonicPredicateType></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="">  getMonotonicPredicateType(const SCEVAddRecExpr *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="">                            ICmpInst::Predicate Pred);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="">  struct LoopInvariantPredicate {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="">    ICmpInst::Predicate Pred;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="">    const SCEV *LHS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="">    const SCEV *RHS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="uncoveredLine">    LoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="">                           const SCEV *RHS)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="uncoveredLine">        : Pred(Pred), LHS(LHS), RHS(RHS) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="">  /// If the result of the predicate LHS `Pred` RHS is loop invariant with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="">  /// respect to L, return a LoopInvariantPredicate with LHS and RHS being</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="">  /// invariants, available at L's entry. Otherwise, return std::nullopt.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="">  std::optional<LoopInvariantPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="">  getLoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="">                            const SCEV *RHS, const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="">                            const Instruction *CtxI = nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="">  /// If the result of the predicate LHS `Pred` RHS is loop invariant with</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="">  /// respect to L at given Context during at least first MaxIter iterations,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="">  /// return a LoopInvariantPredicate with LHS and RHS being invariants,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="">  /// available at L's entry. Otherwise, return std::nullopt. The predicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="">  /// should be the loop's exit condition.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="">  std::optional<LoopInvariantPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="">  getLoopInvariantExitCondDuringFirstIterations(ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="">                                                const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="">                                                const SCEV *RHS, const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="">                                                const Instruction *CtxI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="">                                                const SCEV *MaxIter);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="">  std::optional<LoopInvariantPredicate></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="">  getLoopInvariantExitCondDuringFirstIterationsImpl(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="">      ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="">      const Instruction *CtxI, const SCEV *MaxIter);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="">  /// Simplify LHS and RHS in a comparison with predicate Pred. Return true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="">  /// iff any changes were made. If the operands are provably equal or</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="">  /// unequal, LHS and RHS are set to the same value and Pred is set to either</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="">  /// ICMP_EQ or ICMP_NE.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="">  bool SimplifyICmpOperands(ICmpInst::Predicate &Pred, const SCEV *&LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="">                            const SCEV *&RHS, unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="">  /// Return the "disposition" of the given SCEV with respect to the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="">  /// loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="">  LoopDisposition getLoopDisposition(const SCEV *S, const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="">  /// Return true if the value of the given SCEV is unchanging in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="">  /// specified loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="">  bool isLoopInvariant(const SCEV *S, const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="">  /// Determine if the SCEV can be evaluated at loop's entry. It is true if it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="">  /// doesn't depend on a SCEVUnknown of an instruction which is dominated by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="">  /// the header of loop L.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="">  bool isAvailableAtLoopEntry(const SCEV *S, const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="">  /// Return true if the given SCEV changes value in a known way in the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="">  /// specified loop.  This property being true implies that the value is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="">  /// variant in the loop AND that we can emit an expression to compute the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="">  /// value of the expression at any particular loop iteration.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="">  bool hasComputableLoopEvolution(const SCEV *S, const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="">  /// Return the "disposition" of the given SCEV with respect to the given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="">  /// block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="">  BlockDisposition getBlockDisposition(const SCEV *S, const BasicBlock *BB);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="">  /// Return true if elements that makes up the given SCEV dominate the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="">  /// specified basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="">  bool dominates(const SCEV *S, const BasicBlock *BB);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="">  /// Return true if elements that makes up the given SCEV properly dominate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="">  /// the specified basic block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="">  bool properlyDominates(const SCEV *S, const BasicBlock *BB);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="">  /// Test whether the given SCEV has Op as a direct or indirect operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="">  bool hasOperand(const SCEV *S, const SCEV *Op) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="">  /// Return the size of an element read or written by Inst.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="">  const SCEV *getElementSize(Instruction *Inst);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="">  void print(raw_ostream &OS) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="">  void verify() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="">  bool invalidate(Function &F, const PreservedAnalyses &PA,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="">                  FunctionAnalysisManager::Invalidator &Inv);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="">  /// Return the DataLayout associated with the module this SCEV instance is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="">  /// operating on.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="uncoveredLine">  const DataLayout &getDataLayout() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="uncoveredLine">    return F.getParent()->getDataLayout();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="">  const SCEVPredicate *getEqualPredicate(const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="">  const SCEVPredicate *getComparePredicate(ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="">                                           const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="">  const SCEVPredicate *</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="">  getWrapPredicate(const SCEVAddRecExpr *AR,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="">                   SCEVWrapPredicate::IncrementWrapFlags AddedFlags);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="">  /// Re-writes the SCEV according to the Predicates in \p A.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="">  const SCEV *rewriteUsingPredicate(const SCEV *S, const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="">                                    const SCEVPredicate &A);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="">  /// Tries to convert the \p S expression to an AddRec expression,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="">  /// adding additional predicates to \p Preds as required.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="">  const SCEVAddRecExpr *convertSCEVToAddRecWithPredicates(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="">      const SCEV *S, const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="">      SmallPtrSetImpl<const SCEVPredicate *> &Preds);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="">  /// Compute \p LHS - \p RHS and returns the result as an APInt if it is a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="">  /// constant, and std::nullopt if it isn't.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="">  /// This is intended to be a cheaper version of getMinusSCEV.  We can be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="">  /// frugal here since we just bail out of actually constructing and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="">  /// canonicalizing an expression in the cases where the result isn't going</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="">  /// to be a constant.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="">  std::optional<APInt> computeConstantDifference(const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="">                                                 const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="">  /// Update no-wrap flags of an AddRec. This may drop the cached info about</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="">  /// this AddRec (such as range info) in case if new flags may potentially</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="">  /// sharpen it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="">  void setNoWrapFlags(SCEVAddRecExpr *AddRec, SCEV::NoWrapFlags Flags);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="">  /// Try to apply information from loop guards for \p L to \p Expr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="">  const SCEV *applyLoopGuards(const SCEV *Expr, const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="">  /// Return true if the loop has no abnormal exits. That is, if the loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="">  /// is not infinite, it must exit through an explicit edge in the CFG.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="">  /// (As opposed to either a) throwing out of the function or b) entering a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="">  /// well defined infinite loop in some callee.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="uncoveredLine">  bool loopHasNoAbnormalExits(const Loop *L) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="uncoveredLine">    return getLoopProperties(L).HasNoAbnormalExits;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="">  /// Return true if this loop is finite by assumption.  That is,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="">  /// to be infinite, it must also be undefined.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="">  bool loopIsFiniteByAssumption(const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="">  class FoldID {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="">    const SCEV *Op = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="">    const Type *Ty = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="">    unsigned short C;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="uncoveredLine">    FoldID(SCEVTypes C, const SCEV *Op, const Type *Ty) : Op(Op), Ty(Ty), C(C) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="uncoveredLine">      assert(Op);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="uncoveredLine">      assert(Ty);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="uncoveredLine">    }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="uncoveredLine">    FoldID(unsigned short C) : C(C) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="uncoveredLine">    unsigned computeHash() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="uncoveredLine">      return detail::combineHashValue(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="uncoveredLine">          C, detail::combineHashValue(reinterpret_cast<uintptr_t>(Op),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="uncoveredLine">                                      reinterpret_cast<uintptr_t>(Ty)));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="uncoveredLine">    bool operator==(const FoldID &RHS) const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="uncoveredLine">      return std::tie(Op, Ty, C) == std::tie(RHS.Op, RHS.Ty, RHS.C);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="">  /// A CallbackVH to arrange for ScalarEvolution to be notified whenever a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="">  /// Value is deleted.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="">  class SCEVCallbackVH final : public CallbackVH {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="">    ScalarEvolution *SE;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="">    void deleted() override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="">    void allUsesReplacedWith(Value *New) override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="">    SCEVCallbackVH(Value *V, ScalarEvolution *SE = nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="">  friend class SCEVCallbackVH;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="">  friend class SCEVExpander;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="">  friend class SCEVUnknown;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="">  /// The function we are analyzing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="">  Function &F;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="">  /// Does the module have any calls to the llvm.experimental.guard intrinsic</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="">  /// at all?  If this is false, we avoid doing work that will only help if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="">  /// thare are guards present in the IR.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="">  bool HasGuards;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="">  /// The target library information for the target we are targeting.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="">  TargetLibraryInfo &TLI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="">  /// The tracker for \@llvm.assume intrinsics in this function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="">  AssumptionCache &AC;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="">  /// The dominator tree.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="">  DominatorTree &DT;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="">  /// The loop information for the function we are currently analyzing.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="">  LoopInfo &LI;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="">  /// This SCEV is used to represent unknown trip counts and things.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="">  std::unique_ptr<SCEVCouldNotCompute> CouldNotCompute;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="">  /// The type for HasRecMap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="">  using HasRecMapType = DenseMap<const SCEV *, bool>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="">  /// This is a cache to record whether a SCEV contains any scAddRecExpr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="">  HasRecMapType HasRecMap;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="">  /// The type for ExprValueMap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="">  using ValueSetVector = SmallSetVector<Value *, 4>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="">  using ExprValueMapType = DenseMap<const SCEV *, ValueSetVector>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="">  /// ExprValueMap -- This map records the original values from which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="">  /// the SCEV expr is generated from.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="">  ExprValueMapType ExprValueMap;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="">  /// The type for ValueExprMap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="">  using ValueExprMapType =</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="">      DenseMap<SCEVCallbackVH, const SCEV *, DenseMapInfo<Value *>>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="">  /// This is a cache of the values we have analyzed so far.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="">  ValueExprMapType ValueExprMap;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="">  /// This is a cache for expressions that got folded to a different existing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="">  /// SCEV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="">  DenseMap<FoldID, const SCEV *> FoldCache;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="">  DenseMap<const SCEV *, SmallVector<FoldID, 2>> FoldCacheUser;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="">  /// Mark predicate values currently being processed by isImpliedCond.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="">  SmallPtrSet<const Value *, 6> PendingLoopPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="">  /// Mark SCEVUnknown Phis currently being processed by getRangeRef.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="">  SmallPtrSet<const PHINode *, 6> PendingPhiRanges;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="">  /// Mark SCEVUnknown Phis currently being processed by getRangeRefIter.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="">  SmallPtrSet<const PHINode *, 6> PendingPhiRangesIter;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="">  // Mark SCEVUnknown Phis currently being processed by isImpliedViaMerge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="">  SmallPtrSet<const PHINode *, 6> PendingMerges;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="">  /// Set to true by isLoopBackedgeGuardedByCond when we're walking the set of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="">  /// conditions dominating the backedge of a loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="">  bool WalkingBEDominatingConds = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="">  /// Set to true by isKnownPredicateViaSplitting when we're trying to prove a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="">  /// predicate by splitting it into a set of independent predicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="">  bool ProvingSplitPredicate = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="">  /// Memoized values for the getConstantMultiple</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="">  DenseMap<const SCEV *, APInt> ConstantMultipleCache;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="">  /// Return the Value set from which the SCEV expr is generated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="">  ArrayRef<Value *> getSCEVValues(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="">  /// Private helper method for the getConstantMultiple method.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="">  APInt getConstantMultipleImpl(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="">  /// Information about the number of times a particular loop exit may be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="">  /// reached before exiting the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="">  struct ExitNotTakenInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="">    PoisoningVH<BasicBlock> ExitingBlock;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="">    const SCEV *ExactNotTaken;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="">    const SCEV *ConstantMaxNotTaken;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="">    const SCEV *SymbolicMaxNotTaken;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="">    SmallPtrSet<const SCEVPredicate *, 4> Predicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="uncoveredLine">    explicit ExitNotTakenInfo(</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="">        PoisoningVH<BasicBlock> ExitingBlock, const SCEV *ExactNotTaken,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="">        const SCEV *ConstantMaxNotTaken, const SCEV *SymbolicMaxNotTaken,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="">        const SmallPtrSet<const SCEVPredicate *, 4> &Predicates)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="uncoveredLine">        : ExitingBlock(ExitingBlock), ExactNotTaken(ExactNotTaken),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="uncoveredLine">          ConstantMaxNotTaken(ConstantMaxNotTaken),</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="uncoveredLine">          SymbolicMaxNotTaken(SymbolicMaxNotTaken), Predicates(Predicates) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="uncoveredLine">    bool hasAlwaysTruePredicate() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="uncoveredLine">      return Predicates.empty();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="">  /// Information about the backedge-taken count of a loop. This currently</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="">  /// includes an exact count and a maximum count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="">  class BackedgeTakenInfo {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="">    friend class ScalarEvolution;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="">    /// A list of computable exits and their not-taken counts.  Loops almost</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="">    /// never have more than one computable exit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="">    SmallVector<ExitNotTakenInfo, 1> ExitNotTaken;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="">    /// Expression indicating the least constant maximum backedge-taken count of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="">    /// the loop that is known, or a SCEVCouldNotCompute. This expression is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="">    /// only valid if the redicates associated with all loop exits are true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="">    const SCEV *ConstantMax = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="">    /// Indicating if \c ExitNotTaken has an element for every exiting block in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="">    /// the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="">    bool IsComplete = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="">    /// Expression indicating the least maximum backedge-taken count of the loop</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="">    /// that is known, or a SCEVCouldNotCompute. Lazily computed on first query.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="">    const SCEV *SymbolicMax = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="">    /// True iff the backedge is taken either exactly Max or zero times.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="">    bool MaxOrZero = false;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="uncoveredLine">    bool isComplete() const { return IsComplete; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="uncoveredLine">    const SCEV *getConstantMax() const { return ConstantMax; }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="uncoveredLine">    BackedgeTakenInfo() = default;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="uncoveredLine">    BackedgeTakenInfo(BackedgeTakenInfo &&) = default;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="uncoveredLine">    BackedgeTakenInfo &operator=(BackedgeTakenInfo &&) = default;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="">    using EdgeExitInfo = std::pair<BasicBlock *, ExitLimit>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="">    /// Initialize BackedgeTakenInfo from a list of exact exit counts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="">    BackedgeTakenInfo(ArrayRef<EdgeExitInfo> ExitCounts, bool IsComplete,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="">                      const SCEV *ConstantMax, bool MaxOrZero);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="">    /// Test whether this BackedgeTakenInfo contains any computed information,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="">    /// or whether it's all SCEVCouldNotCompute values.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="uncoveredLine">    bool hasAnyInfo() const {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="uncoveredLine">      return !ExitNotTaken.empty() ||</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="uncoveredLine">             !isa<SCEVCouldNotCompute>(getConstantMax());</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="">    }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="">    /// Test whether this BackedgeTakenInfo contains complete information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="uncoveredLine">    bool hasFullInfo() const { return isComplete(); }</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="">    /// Return an expression indicating the exact *backedge-taken*</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="">    /// count of the loop if it is known or SCEVCouldNotCompute</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="">    /// otherwise.  If execution makes it to the backedge on every</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="">    /// iteration (i.e. there are no abnormal exists like exception</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="">    /// throws and thread exits) then this is the number of times the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="">    /// loop header will execute minus one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="">    ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="">    /// If the SCEV predicate associated with the answer can be different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="">    /// from AlwaysTrue, we must add a (non null) Predicates argument.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="">    /// The SCEV predicate associated with the answer will be added to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="">    /// Predicates. A run-time check needs to be emitted for the SCEV</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="">    /// predicate in order for the answer to be valid.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="">    ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="">    /// Note that we should always know if we need to pass a predicate</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="">    /// argument or not from the way the ExitCounts vector was computed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="">    /// If we allowed SCEV predicates to be generated when populating this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="">    /// vector, this information can contain them and therefore a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="">    /// SCEVPredicate argument should be added to getExact.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="">    const SCEV *getExact(const Loop *L, ScalarEvolution *SE,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="">                         SmallVector<const SCEVPredicate *, 4> *Predicates = nullptr) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="">    /// Return the number of times this loop exit may fall through to the back</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="">    /// edge, or SCEVCouldNotCompute. The loop is guaranteed not to exit via</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="">    /// this block before this number of iterations, but may exit via another</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="">    /// block.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="">    const SCEV *getExact(const BasicBlock *ExitingBlock,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="">                         ScalarEvolution *SE) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="">    /// Get the constant max backedge taken count for the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="">    const SCEV *getConstantMax(ScalarEvolution *SE) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="">    /// Get the constant max backedge taken count for the particular loop exit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="">    const SCEV *getConstantMax(const BasicBlock *ExitingBlock,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="">                               ScalarEvolution *SE) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="">    /// Get the symbolic max backedge taken count for the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="">    const SCEV *getSymbolicMax(const Loop *L, ScalarEvolution *SE);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="">    /// Get the symbolic max backedge taken count for the particular loop exit.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="">    const SCEV *getSymbolicMax(const BasicBlock *ExitingBlock,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="">                               ScalarEvolution *SE) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="">    /// Return true if the number of times this backedge is taken is either the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="">    /// value returned by getConstantMax or zero.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="">    bool isConstantMaxOrZero(ScalarEvolution *SE) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="">  /// Cache the backedge-taken count of the loops for this function as they</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="">  /// are computed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="">  DenseMap<const Loop *, BackedgeTakenInfo> BackedgeTakenCounts;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="">  /// Cache the predicated backedge-taken count of the loops for this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="">  /// function as they are computed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="">  DenseMap<const Loop *, BackedgeTakenInfo> PredicatedBackedgeTakenCounts;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="">  /// Loops whose backedge taken counts directly use this non-constant SCEV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="">  DenseMap<const SCEV *, SmallPtrSet<PointerIntPair<const Loop *, 1, bool>, 4>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="">      BECountUsers;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="">  /// This map contains entries for all of the PHI instructions that we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="">  /// attempt to compute constant evolutions for.  This allows us to avoid</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="">  /// potentially expensive recomputation of these properties.  An instruction</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="">  /// maps to null if we are unable to compute its exit value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="">  DenseMap<PHINode *, Constant *> ConstantEvolutionLoopExitValue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="">  /// This map contains entries for all the expressions that we attempt to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="">  /// compute getSCEVAtScope information for, which can be expensive in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="">  /// extreme cases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="">  DenseMap<const SCEV *, SmallVector<std::pair<const Loop *, const SCEV *>, 2>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="">      ValuesAtScopes;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="">  /// Reverse map for invalidation purposes: Stores of which SCEV and which</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="">  /// loop this is the value-at-scope of.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="">  DenseMap<const SCEV *, SmallVector<std::pair<const Loop *, const SCEV *>, 2>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="">      ValuesAtScopesUsers;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="">  /// Memoized computeLoopDisposition results.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="">  DenseMap<const SCEV *,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="">           SmallVector<PointerIntPair<const Loop *, 2, LoopDisposition>, 2>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="">      LoopDispositions;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="">  struct LoopProperties {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="">    /// Set to true if the loop contains no instruction that can abnormally exit</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="">    /// the loop (i.e. via throwing an exception, by terminating the thread</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="">    /// cleanly or by infinite looping in a called function).  Strictly</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="">    /// speaking, the last one is not leaving the loop, but is identical to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="">    /// leaving the loop for reasoning about undefined behavior.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="">    bool HasNoAbnormalExits;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="">    /// Set to true if the loop contains no instruction that can have side</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="">    /// effects (i.e. via throwing an exception, volatile or atomic access).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="">    bool HasNoSideEffects;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="">  /// Cache for \c getLoopProperties.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="">  DenseMap<const Loop *, LoopProperties> LoopPropertiesCache;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="">  /// Return a \c LoopProperties instance for \p L, creating one if necessary.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="">  LoopProperties getLoopProperties(const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="uncoveredLine">  bool loopHasNoSideEffects(const Loop *L) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="uncoveredLine">    return getLoopProperties(L).HasNoSideEffects;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="">  /// Compute a LoopDisposition value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="">  LoopDisposition computeLoopDisposition(const SCEV *S, const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="">  /// Memoized computeBlockDisposition results.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="">  DenseMap<</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="">      const SCEV *,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="">      SmallVector<PointerIntPair<const BasicBlock *, 2, BlockDisposition>, 2>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="">      BlockDispositions;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="">  /// Compute a BlockDisposition value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="">  BlockDisposition computeBlockDisposition(const SCEV *S, const BasicBlock *BB);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="">  /// Stores all SCEV that use a given SCEV as its direct operand.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="">  DenseMap<const SCEV *, SmallPtrSet<const SCEV *, 8> > SCEVUsers;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="">  /// Memoized results from getRange</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="">  DenseMap<const SCEV *, ConstantRange> UnsignedRanges;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="">  /// Memoized results from getRange</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="">  DenseMap<const SCEV *, ConstantRange> SignedRanges;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="">  /// Used to parameterize getRange</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="">  enum RangeSignHint { HINT_RANGE_UNSIGNED, HINT_RANGE_SIGNED };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="">  /// Set the memoized range for the given SCEV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="uncoveredLine">  const ConstantRange &setRange(const SCEV *S, RangeSignHint Hint,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="">                                ConstantRange CR) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="uncoveredLine">    DenseMap<const SCEV *, ConstantRange> &Cache =</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="">        Hint == HINT_RANGE_UNSIGNED ? UnsignedRanges : SignedRanges;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="uncoveredLine">    auto Pair = Cache.try_emplace(S, std::move(CR));</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="uncoveredLine">    if (!Pair.second)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="uncoveredLine">      Pair.first->second = std::move(CR);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="uncoveredLine">    return Pair.first->second;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="">  /// Determine the range for a particular SCEV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="">  /// NOTE: This returns a reference to an entry in a cache. It must be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="">  /// copied if its needed for longer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="">  const ConstantRange &getRangeRef(const SCEV *S, RangeSignHint Hint,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="">                                   unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="">  /// Determine the range for a particular SCEV, but evaluates ranges for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="">  /// operands iteratively first.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="">  const ConstantRange &getRangeRefIter(const SCEV *S, RangeSignHint Hint);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="">  /// Determines the range for the affine SCEVAddRecExpr {\p Start,+,\p Step}.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="">  /// Helper for \c getRange.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="">  ConstantRange getRangeForAffineAR(const SCEV *Start, const SCEV *Step,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="">                                    const APInt &MaxBECount);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="">  /// Determines the range for the affine non-self-wrapping SCEVAddRecExpr {\p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="">  /// Start,+,\p Step}<nw>.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="">  ConstantRange getRangeForAffineNoSelfWrappingAR(const SCEVAddRecExpr *AddRec,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="">                                                  const SCEV *MaxBECount,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="">                                                  unsigned BitWidth,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="">                                                  RangeSignHint SignHint);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="">  /// Try to compute a range for the affine SCEVAddRecExpr {\p Start,+,\p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="">  /// Step} by "factoring out" a ternary expression from the add recurrence.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="">  /// Helper called by \c getRange.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="">  ConstantRange getRangeViaFactoring(const SCEV *Start, const SCEV *Step,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="">                                     const APInt &MaxBECount);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="">  /// If the unknown expression U corresponds to a simple recurrence, return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="">  /// a constant range which represents the entire recurrence.  Note that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="">  /// *add* recurrences with loop invariant steps aren't represented by</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="">  /// SCEVUnknowns and thus don't use this mechanism.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="">  ConstantRange getRangeForUnknownRecurrence(const SCEVUnknown *U);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="">  /// We know that there is no SCEV for the specified value.  Analyze the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="">  /// expression recursively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="">  const SCEV *createSCEV(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="">  /// We know that there is no SCEV for the specified value. Create a new SCEV</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="">  /// for \p V iteratively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="">  const SCEV *createSCEVIter(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="">  /// Collect operands of \p V for which SCEV expressions should be constructed</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="">  /// first. Returns a SCEV directly if it can be constructed trivially for \p</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="">  /// V.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="">  const SCEV *getOperandsToCreate(Value *V, SmallVectorImpl<Value *> &Ops);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="">  /// Provide the special handling we need to analyze PHI SCEVs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="">  const SCEV *createNodeForPHI(PHINode *PN);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="">  /// Helper function called from createNodeForPHI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="">  const SCEV *createAddRecFromPHI(PHINode *PN);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="">  /// A helper function for createAddRecFromPHI to handle simple cases.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="">  const SCEV *createSimpleAffineAddRec(PHINode *PN, Value *BEValueV,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="">                                            Value *StartValueV);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="">  /// Helper function called from createNodeForPHI.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="">  const SCEV *createNodeFromSelectLikePHI(PHINode *PN);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="">  /// Provide special handling for a select-like instruction (currently this</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="">  /// is either a select instruction or a phi node).  \p Ty is the type of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="">  /// instruction being processed, that is assumed equivalent to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="">  /// "Cond ? TrueVal : FalseVal".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="">  std::optional<const SCEV *></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="">  createNodeForSelectOrPHIInstWithICmpInstCond(Type *Ty, ICmpInst *Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="">                                               Value *TrueVal, Value *FalseVal);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="">  /// See if we can model this select-like instruction via umin_seq expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="">  const SCEV *createNodeForSelectOrPHIViaUMinSeq(Value *I, Value *Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="">                                                 Value *TrueVal,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="">                                                 Value *FalseVal);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="">  /// Given a value \p V, which is a select-like instruction (currently this is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="">  /// either a select instruction or a phi node), which is assumed equivalent to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="">  ///   Cond ? TrueVal : FalseVal</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="">  /// see if we can model it as a SCEV expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="">  const SCEV *createNodeForSelectOrPHI(Value *V, Value *Cond, Value *TrueVal,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="">                                       Value *FalseVal);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="">  /// Provide the special handling we need to analyze GEP SCEVs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="">  const SCEV *createNodeForGEP(GEPOperator *GEP);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="">  /// Implementation code for getSCEVAtScope; called at most once for each</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="">  /// SCEV+Loop pair.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="">  const SCEV *computeSCEVAtScope(const SCEV *S, const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="">  /// Return the BackedgeTakenInfo for the given loop, lazily computing new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="">  /// values if the loop hasn't been analyzed yet. The returned result is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="">  /// guaranteed not to be predicated.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="">  BackedgeTakenInfo &getBackedgeTakenInfo(const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="">  /// Similar to getBackedgeTakenInfo, but will add predicates as required</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="">  /// with the purpose of returning complete information.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="">  const BackedgeTakenInfo &getPredicatedBackedgeTakenInfo(const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="">  /// Compute the number of times the specified loop will iterate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="">  /// If AllowPredicates is set, we will create new SCEV predicates as</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="">  /// necessary in order to return an exact answer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="">  BackedgeTakenInfo computeBackedgeTakenCount(const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="">                                              bool AllowPredicates = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="">  /// Compute the number of times the backedge of the specified loop will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="">  /// execute if it exits via the specified block. If AllowPredicates is set,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="">  /// this call will try to use a minimal set of SCEV predicates in order to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="">  /// return an exact answer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="">  ExitLimit computeExitLimit(const Loop *L, BasicBlock *ExitingBlock,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="">                             bool AllowPredicates = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="">  /// Return a symbolic upper bound for the backedge taken count of the loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="">  /// This is more general than getConstantMaxBackedgeTakenCount as it returns</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="">  /// an arbitrary expression as opposed to only constants.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="">  const SCEV *computeSymbolicMaxBackedgeTakenCount(const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="">  // Helper functions for computeExitLimitFromCond to avoid exponential time</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="">  // complexity.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="">  class ExitLimitCache {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="">    // It may look like we need key on the whole (L, ExitIfTrue,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="">    // ControlsOnlyExit, AllowPredicates) tuple, but recursive calls to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="">    // computeExitLimitFromCondCached from computeExitLimitFromCondImpl only</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="">    // vary the in \c ExitCond and \c ControlsOnlyExit parameters.  We remember</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="">    // the initial values of the other values to assert our assumption.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="">    SmallDenseMap<PointerIntPair<Value *, 1>, ExitLimit> TripCountMap;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="">    const Loop *L;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="">    bool ExitIfTrue;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="">    bool AllowPredicates;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="">  public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="uncoveredLine">    ExitLimitCache(const Loop *L, bool ExitIfTrue, bool AllowPredicates)</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="uncoveredLine">        : L(L), ExitIfTrue(ExitIfTrue), AllowPredicates(AllowPredicates) {}</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="">    std::optional<ExitLimit> find(const Loop *L, Value *ExitCond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="">                                  bool ExitIfTrue, bool ControlsOnlyExit,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="">                                  bool AllowPredicates);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="">    void insert(const Loop *L, Value *ExitCond, bool ExitIfTrue,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="">                bool ControlsOnlyExit, bool AllowPredicates,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="">                const ExitLimit &EL);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="">  };</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="">  using ExitLimitCacheTy = ExitLimitCache;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="">  ExitLimit computeExitLimitFromCondCached(ExitLimitCacheTy &Cache,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="">                                           const Loop *L, Value *ExitCond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="">                                           bool ExitIfTrue,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="">                                           bool ControlsOnlyExit,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="">                                           bool AllowPredicates);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="">  ExitLimit computeExitLimitFromCondImpl(ExitLimitCacheTy &Cache, const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="">                                         Value *ExitCond, bool ExitIfTrue,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="">                                         bool ControlsOnlyExit,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="">                                         bool AllowPredicates);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="">  std::optional<ScalarEvolution::ExitLimit> computeExitLimitFromCondFromBinOp(</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="">      ExitLimitCacheTy &Cache, const Loop *L, Value *ExitCond, bool ExitIfTrue,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="">      bool ControlsOnlyExit, bool AllowPredicates);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="">  /// Compute the number of times the backedge of the specified loop will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="">  /// execute if its exit condition were a conditional branch of the ICmpInst</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="">  /// ExitCond and ExitIfTrue. If AllowPredicates is set, this call will try</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="">  /// to use a minimal set of SCEV predicates in order to return an exact</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="">  /// answer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="">  ExitLimit computeExitLimitFromICmp(const Loop *L, ICmpInst *ExitCond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="">                                     bool ExitIfTrue,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="">                                     bool IsSubExpr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="">                                     bool AllowPredicates = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="">  /// Variant of previous which takes the components representing an ICmp</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="">  /// as opposed to the ICmpInst itself.  Note that the prior version can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="">  /// return more precise results in some cases and is preferred when caller</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="">  /// has a materialized ICmp.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="">  ExitLimit computeExitLimitFromICmp(const Loop *L, ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="">                                     const SCEV *LHS, const SCEV *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="">                                     bool IsSubExpr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="">                                     bool AllowPredicates = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="">  /// Compute the number of times the backedge of the specified loop will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="">  /// execute if its exit condition were a switch with a single exiting case</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="">  /// to ExitingBB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="">  ExitLimit computeExitLimitFromSingleExitSwitch(const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="">                                                 SwitchInst *Switch,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="">                                                 BasicBlock *ExitingBB,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="">                                                 bool IsSubExpr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="">  /// Compute the exit limit of a loop that is controlled by a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="">  /// "(IV >> 1) != 0" type comparison.  We cannot compute the exact trip</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="">  /// count in these cases (since SCEV has no way of expressing them), but we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="">  /// can still sometimes compute an upper bound.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="">  /// Return an ExitLimit for a loop whose backedge is guarded by `LHS Pred</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="">  /// RHS`.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="">  ExitLimit computeShiftCompareExitLimit(Value *LHS, Value *RHS, const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="">                                         ICmpInst::Predicate Pred);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="">  /// If the loop is known to execute a constant number of times (the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="">  /// condition evolves only from constants), try to evaluate a few iterations</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="">  /// of the loop until we get the exit condition gets a value of ExitWhen</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="">  /// (true or false).  If we cannot evaluate the exit count of the loop,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="">  /// return CouldNotCompute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="">  const SCEV *computeExitCountExhaustively(const Loop *L, Value *Cond,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="">                                           bool ExitWhen);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="">  /// Return the number of times an exit condition comparing the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="">  /// value to zero will execute.  If not computable, return CouldNotCompute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="">  /// If AllowPredicates is set, this call will try to use a minimal set of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="">  /// SCEV predicates in order to return an exact answer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="">  ExitLimit howFarToZero(const SCEV *V, const Loop *L, bool IsSubExpr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="">                         bool AllowPredicates = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="">  /// Return the number of times an exit condition checking the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="">  /// value for nonzero will execute.  If not computable, return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="">  /// CouldNotCompute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="">  ExitLimit howFarToNonZero(const SCEV *V, const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="">  /// Return the number of times an exit condition containing the specified</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="">  /// less-than comparison will execute.  If not computable, return</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="">  /// CouldNotCompute.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="">  /// \p isSigned specifies whether the less-than is signed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="">  /// \p ControlsOnlyExit is true when the LHS < RHS condition directly controls</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="">  /// the branch (loops exits only if condition is true). In this case, we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="">  /// use NoWrapFlags to skip overflow checks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="">  /// If \p AllowPredicates is set, this call will try to use a minimal set of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="">  /// SCEV predicates in order to return an exact answer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="">  ExitLimit howManyLessThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="">                             bool isSigned, bool ControlsOnlyExit,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="">                             bool AllowPredicates = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="">  ExitLimit howManyGreaterThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="">                                bool isSigned, bool IsSubExpr,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="">                                bool AllowPredicates = false);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="">  /// Return a predecessor of BB (which may not be an immediate predecessor)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="">  /// which has exactly one successor from which BB is reachable, or null if</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="">  /// no such block is found.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="">  std::pair<const BasicBlock *, const BasicBlock *></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="">  getPredecessorWithUniqueSuccessorForBB(const BasicBlock *BB) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="">  /// whenever the given FoundCondValue value evaluates to true in given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="">  /// Context. If Context is nullptr, then the found predicate is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="">  /// everywhere. LHS and FoundLHS may have different type width.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="">  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="">                     const Value *FoundCondValue, bool Inverse,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="">                     const Instruction *Context = nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="">  /// whenever the given FoundCondValue value evaluates to true in given</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="">  /// Context. If Context is nullptr, then the found predicate is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="">  /// everywhere. LHS and FoundLHS must have same type width.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="">  bool isImpliedCondBalancedTypes(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="">                                  const SCEV *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="">                                  ICmpInst::Predicate FoundPred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="">                                  const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="">                                  const Instruction *CtxI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="">  /// whenever the condition described by FoundPred, FoundLHS, FoundRHS is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="">  /// true in given Context. If Context is nullptr, then the found predicate is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="">  /// true everywhere.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="">  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="">                     ICmpInst::Predicate FoundPred, const SCEV *FoundLHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="">                     const SCEV *FoundRHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="">                     const Instruction *Context = nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="">  /// true in given Context. If Context is nullptr, then the found predicate is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="">  /// true everywhere.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="">  bool isImpliedCondOperands(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="">                             const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="">                             const SCEV *FoundRHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="">                             const Instruction *Context = nullptr);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="">  /// true. Here LHS is an operation that includes FoundLHS as one of its</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="">  /// arguments.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="">  bool isImpliedViaOperations(ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="">                              const SCEV *LHS, const SCEV *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="">                              const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="">                              unsigned Depth = 0);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="">  /// Test whether the condition described by Pred, LHS, and RHS is true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="">  /// Use only simple non-recursive types of checks, such as range analysis etc.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="">  bool isKnownViaNonRecursiveReasoning(ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="">                                       const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="">  /// true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="">  bool isImpliedCondOperandsHelper(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="">                                   const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="">                                   const SCEV *FoundRHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="">  /// true.  Utility function used by isImpliedCondOperands.  Tries to get</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="">  /// cases like "X `sgt` 0 => X - 1 `sgt` -1".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="">  bool isImpliedCondOperandsViaRanges(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="">                                      const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="">                                      const SCEV *FoundRHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="">  /// Return true if the condition denoted by \p LHS \p Pred \p RHS is implied</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="">  /// by a call to @llvm.experimental.guard in \p BB.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="">  bool isImpliedViaGuard(const BasicBlock *BB, ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="">                         const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="">  /// true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="">  /// This routine tries to rule out certain kinds of integer overflow, and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="">  /// then tries to reason about arithmetic properties of the predicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="">  bool isImpliedCondOperandsViaNoOverflow(ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="">                                          const SCEV *LHS, const SCEV *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="">                                          const SCEV *FoundLHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="">                                          const SCEV *FoundRHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="">  /// true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="">  /// This routine tries to weaken the known condition basing on fact that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="">  /// FoundLHS is an AddRec.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="">  bool isImpliedCondOperandsViaAddRecStart(ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="">                                           const SCEV *LHS, const SCEV *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="">                                           const SCEV *FoundLHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="">                                           const SCEV *FoundRHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="">                                           const Instruction *CtxI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="">  /// true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="">  /// This routine tries to figure out predicate for Phis which are SCEVUnknown</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="">  /// if it is true for every possible incoming value from their respective</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="">  /// basic blocks.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="">  bool isImpliedViaMerge(ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="">                         const SCEV *LHS, const SCEV *RHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="">                         const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="">                         unsigned Depth);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="">  /// true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="">  /// This routine tries to reason about shifts.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="">  bool isImpliedCondOperandsViaShift(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="">                                     const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="">                                     const SCEV *FoundRHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="">  /// If we know that the specified Phi is in the header of its containing</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="">  /// loop, we know the loop executes a constant number of times, and the PHI</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="">  /// node is just a recurrence involving constants, fold it.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="">  Constant *getConstantEvolutionLoopExitValue(PHINode *PN, const APInt &BEs,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="">                                              const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="">  /// Test if the given expression is known to satisfy the condition described</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="">  /// by Pred and the known constant ranges of LHS and RHS.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="">  bool isKnownPredicateViaConstantRanges(ICmpInst::Predicate Pred,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="">                                         const SCEV *LHS, const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="">  /// Try to prove the condition described by "LHS Pred RHS" by ruling out</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="">  /// integer overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="">  /// For instance, this will return true for "A s< (A + C)<nsw>" if C is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="">  /// positive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="">  bool isKnownPredicateViaNoOverflow(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="">                                     const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="">  /// Try to split Pred LHS RHS into logical conjunctions (and's) and try to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="">  /// prove them individually.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="">  bool isKnownPredicateViaSplitting(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="">                                    const SCEV *RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="">  /// Try to match the Expr as "(L + R)<Flags>".</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="">  bool splitBinaryAdd(const SCEV *Expr, const SCEV *&L, const SCEV *&R,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="">                      SCEV::NoWrapFlags &Flags);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="">  /// Forget predicated/non-predicated backedge taken counts for the given loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="">  void forgetBackedgeTakenCounts(const Loop *L, bool Predicated);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="">  /// Drop memoized information for all \p SCEVs.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="">  void forgetMemoizedResults(ArrayRef<const SCEV *> SCEVs);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="">  /// Helper for forgetMemoizedResults.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="">  void forgetMemoizedResultsImpl(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="">  /// Iterate over instructions in \p Worklist and their users. Erase entries</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="">  /// from ValueExprMap and collect SCEV expressions in \p ToForget</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="">  void visitAndClearUsers(SmallVectorImpl<Instruction *> &Worklist,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="">                          SmallPtrSetImpl<Instruction *> &Visited,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="">                          SmallVectorImpl<const SCEV *> &ToForget);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="">  /// Erase Value from ValueExprMap and ExprValueMap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="">  void eraseValueFromMap(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="">  /// Insert V to S mapping into ValueExprMap and ExprValueMap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="">  void insertValueToMap(Value *V, const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="">  /// Return false iff given SCEV contains a SCEVUnknown with NULL value-</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="">  /// pointer.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="">  bool checkValidity(const SCEV *S) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="">  /// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="">  /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}.  This is</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="">  /// equivalent to proving no signed (resp. unsigned) wrap in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="">  /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="">  /// (resp. `SCEVZeroExtendExpr`).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="">  template <typename ExtendOpTy></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="">  bool proveNoWrapByVaryingStart(const SCEV *Start, const SCEV *Step,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="">                                 const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="">  /// Try to prove NSW or NUW on \p AR relying on ConstantRange manipulation.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="">  SCEV::NoWrapFlags proveNoWrapViaConstantRanges(const SCEVAddRecExpr *AR);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="">  /// Try to prove NSW on \p AR by proving facts about conditions known  on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="">  /// entry and backedge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="">  SCEV::NoWrapFlags proveNoSignedWrapViaInduction(const SCEVAddRecExpr *AR);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="">  /// Try to prove NUW on \p AR by proving facts about conditions known on</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="">  /// entry and backedge.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="">  SCEV::NoWrapFlags proveNoUnsignedWrapViaInduction(const SCEVAddRecExpr *AR);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="">  std::optional<MonotonicPredicateType></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="">  getMonotonicPredicateTypeImpl(const SCEVAddRecExpr *LHS,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="">                                ICmpInst::Predicate Pred);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="">  /// Return SCEV no-wrap flags that can be proven based on reasoning about</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="">  /// how poison produced from no-wrap flags on this value (e.g. a nuw add)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="">  /// would trigger undefined behavior on overflow.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="">  SCEV::NoWrapFlags getNoWrapFlagsFromUB(const Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="">  /// Return a scope which provides an upper bound on the defining scope of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="">  /// 'S'. Specifically, return the first instruction in said bounding scope.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="">  /// Return nullptr if the scope is trivial (function entry).</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="">  /// (See scope definition rules associated with flag discussion above)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="">  const Instruction *getNonTrivialDefiningScopeBound(const SCEV *S);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="">  /// Return a scope which provides an upper bound on the defining scope for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="">  /// a SCEV with the operands in Ops.  The outparam Precise is set if the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="">  /// bound found is a precise bound (i.e. must be the defining scope.)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="">  const Instruction *getDefiningScopeBound(ArrayRef<const SCEV *> Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="">                                           bool &Precise);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="">  /// Wrapper around the above for cases which don't care if the bound</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="">  /// is precise.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="">  const Instruction *getDefiningScopeBound(ArrayRef<const SCEV *> Ops);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="">  /// Given two instructions in the same function, return true if we can</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="">  /// prove B must execute given A executes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="">  bool isGuaranteedToTransferExecutionTo(const Instruction *A,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="">                                         const Instruction *B);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="">  /// Return true if the SCEV corresponding to \p I is never poison.  Proving</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="">  /// this is more complex than proving that just \p I is never poison, since</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="">  /// SCEV commons expressions across control flow, and you can have cases</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="">  /// like:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="">  ///   idx0 = a + b;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="">  ///   ptr[idx0] = 100;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="">  ///   if (<condition>) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="">  ///     idx1 = a +nsw b;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="">  ///     ptr[idx1] = 200;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="">  ///   }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="">  /// where the SCEV expression (+ a b) is guaranteed to not be poison (and</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="">  /// hence not sign-overflow) only if "<condition>" is true.  Since both</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="">  /// `idx0` and `idx1` will be mapped to the same SCEV expression, (+ a b),</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="">  /// it is not okay to annotate (+ a b) with <nsw> in the above example.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="">  bool isSCEVExprNeverPoison(const Instruction *I);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="">  /// This is like \c isSCEVExprNeverPoison but it specifically works for</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="">  /// instructions that will get mapped to SCEV add recurrences.  Return true</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="">  /// if \p I will never generate poison under the assumption that \p I is an</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="">  /// add recurrence on the loop \p L.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="">  bool isAddRecNeverPoison(const Instruction *I, const Loop *L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="">  /// Similar to createAddRecFromPHI, but with the additional flexibility of</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="">  /// suggesting runtime overflow checks in case casts are encountered.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="">  /// If successful, the analysis records that for this loop, \p SymbolicPHI,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="">  /// which is the UnknownSCEV currently representing the PHI, can be rewritten</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="">  /// into an AddRec, assuming some predicates; The function then returns the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="">  /// AddRec and the predicates as a pair, and caches this pair in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="">  /// PredicatedSCEVRewrites.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="">  /// If the analysis is not successful, a mapping from the \p SymbolicPHI to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="">  /// itself (with no predicates) is recorded, and a nullptr with an empty</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="">  /// predicates vector is returned as a pair.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="">  std::optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="">  createAddRecFromPHIWithCastsImpl(const SCEVUnknown *SymbolicPHI);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="">  /// Compute the maximum backedge count based on the range of values</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="">  /// permitted by Start, End, and Stride. This is for loops of the form</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="">  /// {Start, +, Stride} LT End.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="">  ///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="">  /// Preconditions:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="">  /// * the induction variable is known to be positive.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="">  /// * the induction variable is assumed not to overflow (i.e. either it</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="">  ///   actually doesn't, or we'd have to immediately execute UB)</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="">  /// We *don't* assert these preconditions so please be careful.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="">  const SCEV *computeMaxBECountForLT(const SCEV *Start, const SCEV *Stride,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="">                                     const SCEV *End, unsigned BitWidth,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="">                                     bool IsSigned);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="">  /// Verify if an linear IV with positive stride can overflow when in a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="">  /// less-than comparison, knowing the invariant term of the comparison,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="">  /// the stride.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="">  bool canIVOverflowOnLT(const SCEV *RHS, const SCEV *Stride, bool IsSigned);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="">  /// Verify if an linear IV with negative stride can overflow when in a</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="">  /// greater-than comparison, knowing the invariant term of the comparison,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="">  /// the stride.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="">  bool canIVOverflowOnGT(const SCEV *RHS, const SCEV *Stride, bool IsSigned);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="">  /// Get add expr already created or create a new one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="">  const SCEV *getOrCreateAddExpr(ArrayRef<const SCEV *> Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="">                                 SCEV::NoWrapFlags Flags);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="">  /// Get mul expr already created or create a new one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="">  const SCEV *getOrCreateMulExpr(ArrayRef<const SCEV *> Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="">                                 SCEV::NoWrapFlags Flags);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="">  // Get addrec expr already created or create a new one.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="">  const SCEV *getOrCreateAddRecExpr(ArrayRef<const SCEV *> Ops,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="">                                    const Loop *L, SCEV::NoWrapFlags Flags);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="">  /// Return x if \p Val is f(x) where f is a 1-1 function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="">  const SCEV *stripInjectiveFunctions(const SCEV *Val) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="">  /// Find all of the loops transitively used in \p S, and fill \p LoopsUsed.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="">  /// A loop is considered "used" by an expression if it contains</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="">  /// an add rec on said loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="">  void getUsedLoops(const SCEV *S, SmallPtrSetImpl<const Loop *> &LoopsUsed);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="">  /// Try to match the pattern generated by getURemExpr(A, B). If successful,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="">  /// Assign A and B to LHS and RHS, respectively.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="">  bool matchURem(const SCEV *Expr, const SCEV *&LHS, const SCEV *&RHS);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="">  /// Look for a SCEV expression with type `SCEVType` and operands `Ops` in</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="">  /// `UniqueSCEVs`.  Return if found, else nullptr.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="">  SCEV *findExistingSCEVInCache(SCEVTypes SCEVType, ArrayRef<const SCEV *> Ops);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="">  /// Get reachable blocks in this function, making limited use of SCEV</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="">  /// reasoning about conditions.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="">  void getReachableBlocks(SmallPtrSetImpl<BasicBlock *> &Reachable,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="">                          Function &F);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="">  /// Return the given SCEV expression with a new set of operands.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="">  /// This preserves the origial nowrap flags.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="">  const SCEV *getWithOperands(const SCEV *S,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="">                              SmallVectorImpl<const SCEV *> &NewOps);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="">  FoldingSet<SCEV> UniqueSCEVs;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="">  FoldingSet<SCEVPredicate> UniquePreds;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="">  BumpPtrAllocator SCEVAllocator;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="">  /// This maps loops to a list of addrecs that directly use said loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="">  DenseMap<const Loop *, SmallVector<const SCEVAddRecExpr *, 4>> LoopUsers;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="">  /// Cache tentative mappings from UnknownSCEVs in a Loop, to a SCEV expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="">  /// they can be rewritten into under certain predicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="">  DenseMap<std::pair<const SCEVUnknown *, const Loop *>,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="">           std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="">      PredicatedSCEVRewrites;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="">  /// Set of AddRecs for which proving NUW via an induction has already been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="">  /// tried.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="">  SmallPtrSet<const SCEVAddRecExpr *, 16> UnsignedWrapViaInductionTried;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="">  /// Set of AddRecs for which proving NSW via an induction has already been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="">  /// tried.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="">  SmallPtrSet<const SCEVAddRecExpr *, 16> SignedWrapViaInductionTried;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="">  /// The head of a linked list of all SCEVUnknown values that have been</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="">  /// allocated. This is used by releaseMemory to locate them all and call</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="">  /// their destructors.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="">  SCEVUnknown *FirstUnknown = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="">/// Analysis pass that exposes the \c ScalarEvolution for a function.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="">class ScalarEvolutionAnalysis</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="">    : public AnalysisInfoMixin<ScalarEvolutionAnalysis> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="">  friend AnalysisInfoMixin<ScalarEvolutionAnalysis>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="">  static AnalysisKey Key;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="">  using Result = ScalarEvolution;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="">  ScalarEvolution run(Function &F, FunctionAnalysisManager &AM);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="">/// Verifier pass for the \c ScalarEvolutionAnalysis results.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="">class ScalarEvolutionVerifierPass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="">    : public PassInfoMixin<ScalarEvolutionVerifierPass> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="">  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="">/// Printer pass for the \c ScalarEvolutionAnalysis results.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="">class ScalarEvolutionPrinterPass</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="">    : public PassInfoMixin<ScalarEvolutionPrinterPass> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="">  raw_ostream &OS;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="">  explicit ScalarEvolutionPrinterPass(raw_ostream &OS) : OS(OS) {}</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="">  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="">class ScalarEvolutionWrapperPass : public FunctionPass {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="">  std::unique_ptr<ScalarEvolution> SE;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="">  static char ID;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="">  ScalarEvolutionWrapperPass();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="">  ScalarEvolution &getSE() { return *SE; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="">  const ScalarEvolution &getSE() const { return *SE; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="">  bool runOnFunction(Function &F) override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="">  void releaseMemory() override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="">  void print(raw_ostream &OS, const Module * = nullptr) const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="">  void verifyAnalysis() const override;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="">/// An interface layer with SCEV used to manage how we see SCEV expressions</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="">/// for values in the context of existing predicates. We can add new</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="">/// predicates, but we cannot remove them.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="">///</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="">/// This layer has multiple purposes:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="">///   - provides a simple interface for SCEV versioning.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="">///   - guarantees that the order of transformations applied on a SCEV</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="">///     expression for a single Value is consistent across two different</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="">///     getSCEV calls. This means that, for example, once we've obtained</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="">///     an AddRec expression for a certain value through expression</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="">///     rewriting, we will continue to get an AddRec expression for that</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="">///     Value.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="">///   - lowers the number of expression rewrites.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="">class PredicatedScalarEvolution {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="">public:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="">  PredicatedScalarEvolution(ScalarEvolution &SE, Loop &L);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="">  const SCEVPredicate &getPredicate() const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="">  /// Returns the SCEV expression of V, in the context of the current SCEV</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="">  /// predicate.  The order of transformations applied on the expression of V</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="">  /// returned by ScalarEvolution is guaranteed to be preserved, even when</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="">  /// adding new predicates.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="">  const SCEV *getSCEV(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="">  /// Get the (predicated) backedge count for the analyzed loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="">  const SCEV *getBackedgeTakenCount();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="">  /// Adds a new predicate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="">  void addPredicate(const SCEVPredicate &Pred);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="">  /// Attempts to produce an AddRecExpr for V by adding additional SCEV</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="">  /// predicates. If we can't transform the expression into an AddRecExpr we</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="">  /// return nullptr and not add additional SCEV predicates to the current</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="">  /// context.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="">  const SCEVAddRecExpr *getAsAddRec(Value *V);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="">  /// Proves that V doesn't overflow by adding SCEV predicate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="">  void setNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="">  /// Returns true if we've proved that V doesn't wrap by means of a SCEV</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="">  /// predicate.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="">  bool hasNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="">  /// Returns the ScalarEvolution analysis used.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="">  ScalarEvolution *getSE() const { return &SE; }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="">  /// We need to explicitly define the copy constructor because of FlagsMap.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="">  PredicatedScalarEvolution(const PredicatedScalarEvolution &);</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="">  /// Print the SCEV mappings done by the Predicated Scalar Evolution.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="">  /// The printed text is indented by \p Depth.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="">  void print(raw_ostream &OS, unsigned Depth) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="">  /// Check if \p AR1 and \p AR2 are equal, while taking into account</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="">  /// Equal predicates in Preds.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="">  bool areAddRecsEqualWithPreds(const SCEVAddRecExpr *AR1,</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="">                                const SCEVAddRecExpr *AR2) const;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="">private:</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="">  /// Increments the version number of the predicate.  This needs to be called</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="">  /// every time the SCEV predicate changes.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="">  void updateGeneration();</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="">  /// Holds a SCEV and the version number of the SCEV predicate used to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="">  /// perform the rewrite of the expression.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="">  using RewriteEntry = std::pair<unsigned, const SCEV *>;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="">  /// Maps a SCEV to the rewrite result of that SCEV at a certain version</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="">  /// number. If this number doesn't match the current Generation, we will</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="">  /// need to do a rewrite. To preserve the transformation order of previous</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="">  /// rewrites, we will rewrite the previous result instead of the original</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="">  /// SCEV.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="">  DenseMap<const SCEV *, RewriteEntry> RewriteMap;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="">  /// Records what NoWrap flags we've added to a Value *.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="">  ValueMap<Value *, SCEVWrapPredicate::IncrementWrapFlags> FlagsMap;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="">  /// The ScalarEvolution analysis.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="">  ScalarEvolution &SE;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="">  /// The analyzed Loop.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="">  const Loop &L;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="">  /// The SCEVPredicate that forms our context. We will rewrite all</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="">  /// expressions assuming that this predicate true.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="">  std::unique_ptr<SCEVUnionPredicate> Preds;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="">  /// Marks the version of the SCEV predicate used. When rewriting a SCEV</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="">  /// expression we mark it with the version of the predicate. We use this to</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="">  /// figure out if the predicate has changed from the last rewrite of the</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="">  /// SCEV. If so, we need to perform a new rewrite.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="">  unsigned Generation = 0;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="">  /// The backedge taken count.</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="">  const SCEV *BackedgeCount = nullptr;</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="">template <> struct DenseMapInfo<ScalarEvolution::FoldID> {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="uncoveredLine">  static inline ScalarEvolution::FoldID getEmptyKey() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="uncoveredLine">    ScalarEvolution::FoldID ID(0);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="uncoveredLine">    return ID;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="uncoveredLine">  static inline ScalarEvolution::FoldID getTombstoneKey() {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="uncoveredLine">    ScalarEvolution::FoldID ID(1);</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="uncoveredLine">    return ID;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="uncoveredLine">  static unsigned getHashValue(const ScalarEvolution::FoldID &Val) {</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="uncoveredLine">    return Val.computeHash();</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="uncoveredLine">  static bool isEqual(const ScalarEvolution::FoldID &LHS,</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="">                      const ScalarEvolution::FoldID &RHS) {</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="uncoveredLine">    return LHS == RHS;</td>
    <td>0</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="">  }</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="">};</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="">} // end namespace llvm</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="">#endif // LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class=""></td>
    <td>----</td>
    <td class="testName">
    </td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Functions Report</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Functions Report</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Function name</th>
    <th class="mainTh">Number of hits</th>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm4SCEVC2ENS_19FoldingSetNodeIDRefENS_9SCEVTypesEt</td>
    <td class="numberOfCalls">2</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SCEV11getSCEVTypeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm4SCEV17getExpressionSizeEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15FoldingSetTraitINS_4SCEVEvE7ProfileERKS1_RNS_16FoldingSetNodeIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15FoldingSetTraitINS_4SCEVEvE6EqualsERKS1_RKNS_16FoldingSetNodeIDEjRS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15FoldingSetTraitINS_4SCEVEvE11ComputeHashERKS1_RNS_16FoldingSetNodeIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmlsERNS_11raw_ostreamERKNS_4SCEVE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm13SCEVPredicate7getKindEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm13SCEVPredicate13getComplexityEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvmlsERNS_11raw_ostreamERKNS_13SCEVPredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15FoldingSetTraitINS_13SCEVPredicateEvE7ProfileERKS1_RNS_16FoldingSetNodeIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15FoldingSetTraitINS_13SCEVPredicateEvE6EqualsERKS1_RKNS_16FoldingSetNodeIDEjRS5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15FoldingSetTraitINS_13SCEVPredicateEvE11ComputeHashERKS1_RNS_16FoldingSetNodeIDE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20SCEVComparePredicate12getPredicateEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20SCEVComparePredicate6getLHSEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm20SCEVComparePredicate6getRHSEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm20SCEVComparePredicate7classofEPKNS_13SCEVPredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SCEVWrapPredicate10clearFlagsENS0_18IncrementWrapFlagsES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SCEVWrapPredicate8setFlagsENS0_18IncrementWrapFlagsES1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm17SCEVWrapPredicate8getFlagsEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm17SCEVWrapPredicate7classofEPKNS_13SCEVPredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18SCEVUnionPredicate13getPredicatesEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm18SCEVUnionPredicate13getComplexityEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm18SCEVUnionPredicate7classofEPKNS_13SCEVPredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution9maskFlagsENS_4SCEV11NoWrapFlagsEi</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution8setFlagsENS_4SCEV11NoWrapFlagsES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution8hasFlagsENS_4SCEV11NoWrapFlagsES2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ScalarEvolution10getContextEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution10getAddExprEPKNS_4SCEVES3_NS1_11NoWrapFlagsEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution10getMulExprEPKNS_4SCEVES3_NS1_11NoWrapFlagsEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution10getMulExprEPKNS_4SCEVES3_S3_NS1_11NoWrapFlagsEj</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution13getAddRecExprERKNS_15SmallVectorImplIPKNS_4SCEVEEEPKNS_4LoopENS2_11NoWrapFlagsE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution7getZeroEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution6getOneEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution11getMinusOneEPNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution32getConstantMaxBackedgeTakenCountEPKNS_4LoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution32getSymbolicMaxBackedgeTakenCountEPKNS_4LoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution16getUnsignedRangeEPKNS_4SCEVE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution19getUnsignedRangeMinEPKNS_4SCEVE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution19getUnsignedRangeMaxEPKNS_4SCEVE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution14getSignedRangeEPKNS_4SCEVE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution17getSignedRangeMinEPKNS_4SCEVE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution17getSignedRangeMaxEPKNS_4SCEVE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution9ExitLimit12addPredicateEPKNS_13SCEVPredicateE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ScalarEvolution9ExitLimit10hasAnyInfoEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ScalarEvolution9ExitLimit11hasFullInfoEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution22LoopInvariantPredicateC2ENS_7CmpInst9PredicateEPKNS_4SCEVES6_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ScalarEvolution13getDataLayoutEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution22loopHasNoAbnormalExitsEPKNS_4LoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution6FoldIDC2ENS_9SCEVTypesEPKNS_4SCEVEPKNS_4TypeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution6FoldIDC2Et</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ScalarEvolution6FoldID11computeHashEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ScalarEvolution6FoldIDeqERKS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution16ExitNotTakenInfoC2ENS_11PoisoningVHINS_10BasicBlockEEEPKNS_4SCEVES7_S7_RKNS_11SmallPtrSetIPKNS_13SCEVPredicateELj4EEE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ScalarEvolution16ExitNotTakenInfo22hasAlwaysTruePredicateEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ScalarEvolution17BackedgeTakenInfo10isCompleteEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ScalarEvolution17BackedgeTakenInfo14getConstantMaxEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution17BackedgeTakenInfoC2Ev</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution17BackedgeTakenInfoC2EOS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution17BackedgeTakenInfoaSEOS1_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ScalarEvolution17BackedgeTakenInfo10hasAnyInfoEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZNK4llvm15ScalarEvolution17BackedgeTakenInfo11hasFullInfoEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution20loopHasNoSideEffectsEPKNS_4LoopE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution8setRangeEPKNS_4SCEVENS0_13RangeSignHintENS_13ConstantRangeE</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm15ScalarEvolution14ExitLimitCacheC2EPKNS_4LoopEbb</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12DenseMapInfoINS_15ScalarEvolution6FoldIDEvE11getEmptyKeyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12DenseMapInfoINS_15ScalarEvolution6FoldIDEvE15getTombstoneKeyEv</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12DenseMapInfoINS_15ScalarEvolution6FoldIDEvE12getHashValueERKS2_</td>
    <td class="numberOfCalls">0</td>
  </tr>
  <tr class="mainTr">
    <td class="functionName">_ZN4llvm12DenseMapInfoINS_15ScalarEvolution6FoldIDEvE7isEqualERKS2_S5_</td>
    <td class="numberOfCalls">0</td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Coverage Diff</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Coverage Diff</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
      <span> BUT NOT </span>
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeline">//===- llvm/Analysis/ScalarEvolution.h - Scalar Evolution -------*- C++ -*-===//</td>
    <td class="lineNumber">1</td>
    <td class="codeline">//===- llvm/Analysis/ScalarEvolution.h - Scalar Evolution -------*- C++ -*-===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
    <td class="lineNumber">2</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">3</td>
    <td class="codeline">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">4</td>
    <td class="codeline">// See https://llvm.org/LICENSE.txt for license information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">5</td>
    <td class="codeline">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
    <td class="lineNumber">6</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">7</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
    <td class="lineNumber">8</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeline">// The ScalarEvolution class is an LLVM pass which can be used to analyze and</td>
    <td class="lineNumber">9</td>
    <td class="codeline">// The ScalarEvolution class is an LLVM pass which can be used to analyze and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeline">// categorize scalar expressions in loops.  It specializes in recognizing</td>
    <td class="lineNumber">10</td>
    <td class="codeline">// categorize scalar expressions in loops.  It specializes in recognizing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeline">// general induction variables, representing them with the abstract and opaque</td>
    <td class="lineNumber">11</td>
    <td class="codeline">// general induction variables, representing them with the abstract and opaque</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeline">// SCEV class.  Given this analysis, trip counts of loops and other important</td>
    <td class="lineNumber">12</td>
    <td class="codeline">// SCEV class.  Given this analysis, trip counts of loops and other important</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeline">// properties can be obtained.</td>
    <td class="lineNumber">13</td>
    <td class="codeline">// properties can be obtained.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeline">//</td>
    <td class="lineNumber">14</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeline">// This analysis is primarily useful for induction variable substitution and</td>
    <td class="lineNumber">15</td>
    <td class="codeline">// This analysis is primarily useful for induction variable substitution and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeline">// strength reduction.</td>
    <td class="lineNumber">16</td>
    <td class="codeline">// strength reduction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeline">//</td>
    <td class="lineNumber">17</td>
    <td class="codeline">//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">18</td>
    <td class="codeline">//===----------------------------------------------------------------------===//</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeline"></td>
    <td class="lineNumber">19</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeline">#ifndef LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
    <td class="lineNumber">20</td>
    <td class="codeline">#ifndef LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeline">#define LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
    <td class="lineNumber">21</td>
    <td class="codeline">#define LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeline"></td>
    <td class="lineNumber">22</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">23</td>
    <td class="codeline">#include "llvm/ADT/APInt.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">24</td>
    <td class="codeline">#include "llvm/ADT/ArrayRef.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">25</td>
    <td class="codeline">#include "llvm/ADT/DenseMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td class="lineNumber">26</td>
    <td class="codeline">#include "llvm/ADT/DenseMapInfo.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/ADT/FoldingSet.h"</td>
    <td class="lineNumber">27</td>
    <td class="codeline">#include "llvm/ADT/FoldingSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/ADT/PointerIntPair.h"</td>
    <td class="lineNumber">28</td>
    <td class="codeline">#include "llvm/ADT/PointerIntPair.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">29</td>
    <td class="codeline">#include "llvm/ADT/SetVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">30</td>
    <td class="codeline">#include "llvm/ADT/SmallPtrSet.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">31</td>
    <td class="codeline">#include "llvm/ADT/SmallVector.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/IR/ConstantRange.h"</td>
    <td class="lineNumber">32</td>
    <td class="codeline">#include "llvm/IR/ConstantRange.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">33</td>
    <td class="codeline">#include "llvm/IR/InstrTypes.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">34</td>
    <td class="codeline">#include "llvm/IR/Instructions.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">35</td>
    <td class="codeline">#include "llvm/IR/PassManager.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/ValueHandle.h"</td>
    <td class="lineNumber">36</td>
    <td class="codeline">#include "llvm/IR/ValueHandle.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/ValueMap.h"</td>
    <td class="lineNumber">37</td>
    <td class="codeline">#include "llvm/IR/ValueMap.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
    <td class="lineNumber">38</td>
    <td class="codeline">#include "llvm/Pass.h"</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeline">#include <cassert></td>
    <td class="lineNumber">39</td>
    <td class="codeline">#include <cassert></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeline">#include <cstdint></td>
    <td class="lineNumber">40</td>
    <td class="codeline">#include <cstdint></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeline">#include <memory></td>
    <td class="lineNumber">41</td>
    <td class="codeline">#include <memory></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeline">#include <optional></td>
    <td class="lineNumber">42</td>
    <td class="codeline">#include <optional></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeline">#include <utility></td>
    <td class="lineNumber">43</td>
    <td class="codeline">#include <utility></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeline"></td>
    <td class="lineNumber">44</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeline">namespace llvm {</td>
    <td class="lineNumber">45</td>
    <td class="codeline">namespace llvm {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeline"></td>
    <td class="lineNumber">46</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeline">class OverflowingBinaryOperator;</td>
    <td class="lineNumber">47</td>
    <td class="codeline">class OverflowingBinaryOperator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeline">class AssumptionCache;</td>
    <td class="lineNumber">48</td>
    <td class="codeline">class AssumptionCache;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeline">class BasicBlock;</td>
    <td class="lineNumber">49</td>
    <td class="codeline">class BasicBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeline">class Constant;</td>
    <td class="lineNumber">50</td>
    <td class="codeline">class Constant;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeline">class ConstantInt;</td>
    <td class="lineNumber">51</td>
    <td class="codeline">class ConstantInt;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeline">class DataLayout;</td>
    <td class="lineNumber">52</td>
    <td class="codeline">class DataLayout;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeline">class DominatorTree;</td>
    <td class="lineNumber">53</td>
    <td class="codeline">class DominatorTree;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeline">class Function;</td>
    <td class="lineNumber">54</td>
    <td class="codeline">class Function;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeline">class GEPOperator;</td>
    <td class="lineNumber">55</td>
    <td class="codeline">class GEPOperator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeline">class Instruction;</td>
    <td class="lineNumber">56</td>
    <td class="codeline">class Instruction;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeline">class LLVMContext;</td>
    <td class="lineNumber">57</td>
    <td class="codeline">class LLVMContext;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeline">class Loop;</td>
    <td class="lineNumber">58</td>
    <td class="codeline">class Loop;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeline">class LoopInfo;</td>
    <td class="lineNumber">59</td>
    <td class="codeline">class LoopInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeline">class raw_ostream;</td>
    <td class="lineNumber">60</td>
    <td class="codeline">class raw_ostream;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeline">class ScalarEvolution;</td>
    <td class="lineNumber">61</td>
    <td class="codeline">class ScalarEvolution;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeline">class SCEVAddRecExpr;</td>
    <td class="lineNumber">62</td>
    <td class="codeline">class SCEVAddRecExpr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeline">class SCEVUnknown;</td>
    <td class="lineNumber">63</td>
    <td class="codeline">class SCEVUnknown;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeline">class StructType;</td>
    <td class="lineNumber">64</td>
    <td class="codeline">class StructType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeline">class TargetLibraryInfo;</td>
    <td class="lineNumber">65</td>
    <td class="codeline">class TargetLibraryInfo;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeline">class Type;</td>
    <td class="lineNumber">66</td>
    <td class="codeline">class Type;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeline">class Value;</td>
    <td class="lineNumber">67</td>
    <td class="codeline">class Value;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeline">enum SCEVTypes : unsigned short;</td>
    <td class="lineNumber">68</td>
    <td class="codeline">enum SCEVTypes : unsigned short;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeline"></td>
    <td class="lineNumber">69</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeline">extern bool VerifySCEV;</td>
    <td class="lineNumber">70</td>
    <td class="codeline">extern bool VerifySCEV;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
    <td class="lineNumber">71</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeline">/// This class represents an analyzed expression in the program.  These are</td>
    <td class="lineNumber">72</td>
    <td class="codeline">/// This class represents an analyzed expression in the program.  These are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeline">/// opaque objects that the client is not allowed to do much with directly.</td>
    <td class="lineNumber">73</td>
    <td class="codeline">/// opaque objects that the client is not allowed to do much with directly.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeline">///</td>
    <td class="lineNumber">74</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeline">class SCEV : public FoldingSetNode {</td>
    <td class="lineNumber">75</td>
    <td class="codeline">class SCEV : public FoldingSetNode {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeline">  friend struct FoldingSetTrait<SCEV>;</td>
    <td class="lineNumber">76</td>
    <td class="codeline">  friend struct FoldingSetTrait<SCEV>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
    <td class="lineNumber">77</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeline">  /// A reference to an Interned FoldingSetNodeID for this node.  The</td>
    <td class="lineNumber">78</td>
    <td class="codeline">  /// A reference to an Interned FoldingSetNodeID for this node.  The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeline">  /// ScalarEvolution's BumpPtrAllocator holds the data.</td>
    <td class="lineNumber">79</td>
    <td class="codeline">  /// ScalarEvolution's BumpPtrAllocator holds the data.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeline">  FoldingSetNodeIDRef FastID;</td>
    <td class="lineNumber">80</td>
    <td class="codeline">  FoldingSetNodeIDRef FastID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
    <td class="lineNumber">81</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeline">  // The SCEV baseclass this node corresponds to</td>
    <td class="lineNumber">82</td>
    <td class="codeline">  // The SCEV baseclass this node corresponds to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeline">  const SCEVTypes SCEVType;</td>
    <td class="lineNumber">83</td>
    <td class="codeline">  const SCEVTypes SCEVType;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeline"></td>
    <td class="lineNumber">84</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">85</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeline">  // Estimated complexity of this node's expression tree size.</td>
    <td class="lineNumber">86</td>
    <td class="codeline">  // Estimated complexity of this node's expression tree size.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeline">  const unsigned short ExpressionSize;</td>
    <td class="lineNumber">87</td>
    <td class="codeline">  const unsigned short ExpressionSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
    <td class="lineNumber">88</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeline">  /// This field is initialized to zero and may be used in subclasses to store</td>
    <td class="lineNumber">89</td>
    <td class="codeline">  /// This field is initialized to zero and may be used in subclasses to store</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeline">  /// miscellaneous information.</td>
    <td class="lineNumber">90</td>
    <td class="codeline">  /// miscellaneous information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeline">  unsigned short SubclassData = 0;</td>
    <td class="lineNumber">91</td>
    <td class="codeline">  unsigned short SubclassData = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeline"></td>
    <td class="lineNumber">92</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">93</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeline">  /// NoWrapFlags are bitfield indices into SubclassData.</td>
    <td class="lineNumber">94</td>
    <td class="codeline">  /// NoWrapFlags are bitfield indices into SubclassData.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">95</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeline">  /// Add and Mul expressions may have no-unsigned-wrap <NUW> or</td>
    <td class="lineNumber">96</td>
    <td class="codeline">  /// Add and Mul expressions may have no-unsigned-wrap <NUW> or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeline">  /// no-signed-wrap <NSW> properties, which are derived from the IR</td>
    <td class="lineNumber">97</td>
    <td class="codeline">  /// no-signed-wrap <NSW> properties, which are derived from the IR</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeline">  /// operator. NSW is a misnomer that we use to mean no signed overflow or</td>
    <td class="lineNumber">98</td>
    <td class="codeline">  /// operator. NSW is a misnomer that we use to mean no signed overflow or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeline">  /// underflow.</td>
    <td class="lineNumber">99</td>
    <td class="codeline">  /// underflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">100</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeline">  /// AddRec expressions may have a no-self-wraparound <NW> property if, in</td>
    <td class="lineNumber">101</td>
    <td class="codeline">  /// AddRec expressions may have a no-self-wraparound <NW> property if, in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeline">  /// the integer domain, abs(step) * max-iteration(loop) <=</td>
    <td class="lineNumber">102</td>
    <td class="codeline">  /// the integer domain, abs(step) * max-iteration(loop) <=</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeline">  /// unsigned-max(bitwidth).  This means that the recurrence will never reach</td>
    <td class="lineNumber">103</td>
    <td class="codeline">  /// unsigned-max(bitwidth).  This means that the recurrence will never reach</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeline">  /// its start value if the step is non-zero.  Computing the same value on</td>
    <td class="lineNumber">104</td>
    <td class="codeline">  /// its start value if the step is non-zero.  Computing the same value on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeline">  /// each iteration is not considered wrapping, and recurrences with step = 0</td>
    <td class="lineNumber">105</td>
    <td class="codeline">  /// each iteration is not considered wrapping, and recurrences with step = 0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeline">  /// are trivially <NW>.  <NW> is independent of the sign of step and the</td>
    <td class="lineNumber">106</td>
    <td class="codeline">  /// are trivially <NW>.  <NW> is independent of the sign of step and the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeline">  /// value the add recurrence starts with.</td>
    <td class="lineNumber">107</td>
    <td class="codeline">  /// value the add recurrence starts with.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">108</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeline">  /// Note that NUW and NSW are also valid properties of a recurrence, and</td>
    <td class="lineNumber">109</td>
    <td class="codeline">  /// Note that NUW and NSW are also valid properties of a recurrence, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeline">  /// either implies NW. For convenience, NW will be set for a recurrence</td>
    <td class="lineNumber">110</td>
    <td class="codeline">  /// either implies NW. For convenience, NW will be set for a recurrence</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeline">  /// whenever either NUW or NSW are set.</td>
    <td class="lineNumber">111</td>
    <td class="codeline">  /// whenever either NUW or NSW are set.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">112</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeline">  /// We require that the flag on a SCEV apply to the entire scope in which</td>
    <td class="lineNumber">113</td>
    <td class="codeline">  /// We require that the flag on a SCEV apply to the entire scope in which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeline">  /// that SCEV is defined.  A SCEV's scope is set of locations dominated by</td>
    <td class="lineNumber">114</td>
    <td class="codeline">  /// that SCEV is defined.  A SCEV's scope is set of locations dominated by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeline">  /// a defining location, which is in turn described by the following rules:</td>
    <td class="lineNumber">115</td>
    <td class="codeline">  /// a defining location, which is in turn described by the following rules:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeline">  /// * A SCEVUnknown is at the point of definition of the Value.</td>
    <td class="lineNumber">116</td>
    <td class="codeline">  /// * A SCEVUnknown is at the point of definition of the Value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeline">  /// * A SCEVConstant is defined at all points.</td>
    <td class="lineNumber">117</td>
    <td class="codeline">  /// * A SCEVConstant is defined at all points.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeline">  /// * A SCEVAddRec is defined starting with the header of the associated</td>
    <td class="lineNumber">118</td>
    <td class="codeline">  /// * A SCEVAddRec is defined starting with the header of the associated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeline">  ///   loop.</td>
    <td class="lineNumber">119</td>
    <td class="codeline">  ///   loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeline">  /// * All other SCEVs are defined at the earlest point all operands are</td>
    <td class="lineNumber">120</td>
    <td class="codeline">  /// * All other SCEVs are defined at the earlest point all operands are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeline">  ///   defined.</td>
    <td class="lineNumber">121</td>
    <td class="codeline">  ///   defined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">122</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeline">  /// The above rules describe a maximally hoisted form (without regards to</td>
    <td class="lineNumber">123</td>
    <td class="codeline">  /// The above rules describe a maximally hoisted form (without regards to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeline">  /// potential control dependence).  A SCEV is defined anywhere a</td>
    <td class="lineNumber">124</td>
    <td class="codeline">  /// potential control dependence).  A SCEV is defined anywhere a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeline">  /// corresponding instruction could be defined in said maximally hoisted</td>
    <td class="lineNumber">125</td>
    <td class="codeline">  /// corresponding instruction could be defined in said maximally hoisted</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeline">  /// form.  Note that SCEVUDivExpr (currently the only expression type which</td>
    <td class="lineNumber">126</td>
    <td class="codeline">  /// form.  Note that SCEVUDivExpr (currently the only expression type which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeline">  /// can trap) can be defined per these rules in regions where it would trap</td>
    <td class="lineNumber">127</td>
    <td class="codeline">  /// can trap) can be defined per these rules in regions where it would trap</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeline">  /// at runtime.  A SCEV being defined does not require the existence of any</td>
    <td class="lineNumber">128</td>
    <td class="codeline">  /// at runtime.  A SCEV being defined does not require the existence of any</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeline">  /// instruction within the defined scope.</td>
    <td class="lineNumber">129</td>
    <td class="codeline">  /// instruction within the defined scope.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeline">  enum NoWrapFlags {</td>
    <td class="lineNumber">130</td>
    <td class="codeline">  enum NoWrapFlags {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeline">    FlagAnyWrap = 0,    // No guarantee.</td>
    <td class="lineNumber">131</td>
    <td class="codeline">    FlagAnyWrap = 0,    // No guarantee.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeline">    FlagNW = (1 << 0),  // No self-wrap.</td>
    <td class="lineNumber">132</td>
    <td class="codeline">    FlagNW = (1 << 0),  // No self-wrap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeline">    FlagNUW = (1 << 1), // No unsigned wrap.</td>
    <td class="lineNumber">133</td>
    <td class="codeline">    FlagNUW = (1 << 1), // No unsigned wrap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeline">    FlagNSW = (1 << 2), // No signed wrap.</td>
    <td class="lineNumber">134</td>
    <td class="codeline">    FlagNSW = (1 << 2), // No signed wrap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeline">    NoWrapMask = (1 << 3) - 1</td>
    <td class="lineNumber">135</td>
    <td class="codeline">    NoWrapMask = (1 << 3) - 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">136</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
    <td class="lineNumber">137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeline">  explicit SCEV(const FoldingSetNodeIDRef ID, SCEVTypes SCEVTy,</td>
    <td class="lineNumber">138</td>
    <td class="codeline">  explicit SCEV(const FoldingSetNodeIDRef ID, SCEVTypes SCEVTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeline">                unsigned short ExpressionSize)</td>
    <td class="lineNumber">139</td>
    <td class="codeline">                unsigned short ExpressionSize)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeline">      : FastID(ID), SCEVType(SCEVTy), ExpressionSize(ExpressionSize) {}</td>
    <td class="lineNumber">140</td>
    <td class="codeline">      : FastID(ID), SCEVType(SCEVTy), ExpressionSize(ExpressionSize) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeline">  SCEV(const SCEV &) = delete;</td>
    <td class="lineNumber">141</td>
    <td class="codeline">  SCEV(const SCEV &) = delete;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeline">  SCEV &operator=(const SCEV &) = delete;</td>
    <td class="lineNumber">142</td>
    <td class="codeline">  SCEV &operator=(const SCEV &) = delete;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeline"></td>
    <td class="lineNumber">143</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeline">  SCEVTypes getSCEVType() const { return SCEVType; }</td>
    <td class="lineNumber">144</td>
    <td class="codeline">  SCEVTypes getSCEVType() const { return SCEVType; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
    <td class="lineNumber">145</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeline">  /// Return the LLVM type of this SCEV expression.</td>
    <td class="lineNumber">146</td>
    <td class="codeline">  /// Return the LLVM type of this SCEV expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeline">  Type *getType() const;</td>
    <td class="lineNumber">147</td>
    <td class="codeline">  Type *getType() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeline"></td>
    <td class="lineNumber">148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeline">  /// Return operands of this SCEV expression.</td>
    <td class="lineNumber">149</td>
    <td class="codeline">  /// Return operands of this SCEV expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeline">  ArrayRef<const SCEV *> operands() const;</td>
    <td class="lineNumber">150</td>
    <td class="codeline">  ArrayRef<const SCEV *> operands() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeline"></td>
    <td class="lineNumber">151</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeline">  /// Return true if the expression is a constant zero.</td>
    <td class="lineNumber">152</td>
    <td class="codeline">  /// Return true if the expression is a constant zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeline">  bool isZero() const;</td>
    <td class="lineNumber">153</td>
    <td class="codeline">  bool isZero() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeline"></td>
    <td class="lineNumber">154</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeline">  /// Return true if the expression is a constant one.</td>
    <td class="lineNumber">155</td>
    <td class="codeline">  /// Return true if the expression is a constant one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeline">  bool isOne() const;</td>
    <td class="lineNumber">156</td>
    <td class="codeline">  bool isOne() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeline"></td>
    <td class="lineNumber">157</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeline">  /// Return true if the expression is a constant all-ones value.</td>
    <td class="lineNumber">158</td>
    <td class="codeline">  /// Return true if the expression is a constant all-ones value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeline">  bool isAllOnesValue() const;</td>
    <td class="lineNumber">159</td>
    <td class="codeline">  bool isAllOnesValue() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
    <td class="lineNumber">160</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeline">  /// Return true if the specified scev is negated, but not a constant.</td>
    <td class="lineNumber">161</td>
    <td class="codeline">  /// Return true if the specified scev is negated, but not a constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeline">  bool isNonConstantNegative() const;</td>
    <td class="lineNumber">162</td>
    <td class="codeline">  bool isNonConstantNegative() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeline"></td>
    <td class="lineNumber">163</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeline">  // Returns estimated size of the mathematical expression represented by this</td>
    <td class="lineNumber">164</td>
    <td class="codeline">  // Returns estimated size of the mathematical expression represented by this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeline">  // SCEV. The rules of its calculation are following:</td>
    <td class="lineNumber">165</td>
    <td class="codeline">  // SCEV. The rules of its calculation are following:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeline">  // 1) Size of a SCEV without operands (like constants and SCEVUnknown) is 1;</td>
    <td class="lineNumber">166</td>
    <td class="codeline">  // 1) Size of a SCEV without operands (like constants and SCEVUnknown) is 1;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeline">  // 2) Size SCEV with operands Op1, Op2, ..., OpN is calculated by formula:</td>
    <td class="lineNumber">167</td>
    <td class="codeline">  // 2) Size SCEV with operands Op1, Op2, ..., OpN is calculated by formula:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeline">  //    (1 + Size(Op1) + ... + Size(OpN)).</td>
    <td class="lineNumber">168</td>
    <td class="codeline">  //    (1 + Size(Op1) + ... + Size(OpN)).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeline">  // This value gives us an estimation of time we need to traverse through this</td>
    <td class="lineNumber">169</td>
    <td class="codeline">  // This value gives us an estimation of time we need to traverse through this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeline">  // SCEV and all its operands recursively. We may use it to avoid performing</td>
    <td class="lineNumber">170</td>
    <td class="codeline">  // SCEV and all its operands recursively. We may use it to avoid performing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeline">  // heavy transformations on SCEVs of excessive size for sake of saving the</td>
    <td class="lineNumber">171</td>
    <td class="codeline">  // heavy transformations on SCEVs of excessive size for sake of saving the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeline">  // compilation time.</td>
    <td class="lineNumber">172</td>
    <td class="codeline">  // compilation time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeline">  unsigned short getExpressionSize() const {</td>
    <td class="lineNumber">173</td>
    <td class="codeline">  unsigned short getExpressionSize() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeline">    return ExpressionSize;</td>
    <td class="lineNumber">174</td>
    <td class="codeline">    return ExpressionSize;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">175</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeline"></td>
    <td class="lineNumber">176</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeline">  /// Print out the internal representation of this scalar to the specified</td>
    <td class="lineNumber">177</td>
    <td class="codeline">  /// Print out the internal representation of this scalar to the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeline">  /// stream.  This should really only be used for debugging purposes.</td>
    <td class="lineNumber">178</td>
    <td class="codeline">  /// stream.  This should really only be used for debugging purposes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeline">  void print(raw_ostream &OS) const;</td>
    <td class="lineNumber">179</td>
    <td class="codeline">  void print(raw_ostream &OS) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeline"></td>
    <td class="lineNumber">180</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeline">  /// This method is used for debugging.</td>
    <td class="lineNumber">181</td>
    <td class="codeline">  /// This method is used for debugging.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeline">  void dump() const;</td>
    <td class="lineNumber">182</td>
    <td class="codeline">  void dump() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeline">};</td>
    <td class="lineNumber">183</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeline"></td>
    <td class="lineNumber">184</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeline">// Specialize FoldingSetTrait for SCEV to avoid needing to compute</td>
    <td class="lineNumber">185</td>
    <td class="codeline">// Specialize FoldingSetTrait for SCEV to avoid needing to compute</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeline">// temporary FoldingSetNodeID values.</td>
    <td class="lineNumber">186</td>
    <td class="codeline">// temporary FoldingSetNodeID values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeline">template <> struct FoldingSetTrait<SCEV> : DefaultFoldingSetTrait<SCEV> {</td>
    <td class="lineNumber">187</td>
    <td class="codeline">template <> struct FoldingSetTrait<SCEV> : DefaultFoldingSetTrait<SCEV> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeline">  static void Profile(const SCEV &X, FoldingSetNodeID &ID) { ID = X.FastID; }</td>
    <td class="lineNumber">188</td>
    <td class="codeline">  static void Profile(const SCEV &X, FoldingSetNodeID &ID) { ID = X.FastID; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeline"></td>
    <td class="lineNumber">189</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeline">  static bool Equals(const SCEV &X, const FoldingSetNodeID &ID, unsigned IDHash,</td>
    <td class="lineNumber">190</td>
    <td class="codeline">  static bool Equals(const SCEV &X, const FoldingSetNodeID &ID, unsigned IDHash,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeline">                     FoldingSetNodeID &TempID) {</td>
    <td class="lineNumber">191</td>
    <td class="codeline">                     FoldingSetNodeID &TempID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeline">    return ID == X.FastID;</td>
    <td class="lineNumber">192</td>
    <td class="codeline">    return ID == X.FastID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">193</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeline"></td>
    <td class="lineNumber">194</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeline">  static unsigned ComputeHash(const SCEV &X, FoldingSetNodeID &TempID) {</td>
    <td class="lineNumber">195</td>
    <td class="codeline">  static unsigned ComputeHash(const SCEV &X, FoldingSetNodeID &TempID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeline">    return X.FastID.ComputeHash();</td>
    <td class="lineNumber">196</td>
    <td class="codeline">    return X.FastID.ComputeHash();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">197</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeline">};</td>
    <td class="lineNumber">198</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeline"></td>
    <td class="lineNumber">199</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeline">inline raw_ostream &operator<<(raw_ostream &OS, const SCEV &S) {</td>
    <td class="lineNumber">200</td>
    <td class="codeline">inline raw_ostream &operator<<(raw_ostream &OS, const SCEV &S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeline">  S.print(OS);</td>
    <td class="lineNumber">201</td>
    <td class="codeline">  S.print(OS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeline">  return OS;</td>
    <td class="lineNumber">202</td>
    <td class="codeline">  return OS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeline">}</td>
    <td class="lineNumber">203</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
    <td class="lineNumber">204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeline">/// An object of this class is returned by queries that could not be answered.</td>
    <td class="lineNumber">205</td>
    <td class="codeline">/// An object of this class is returned by queries that could not be answered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeline">/// For example, if you ask for the number of iterations of a linked-list</td>
    <td class="lineNumber">206</td>
    <td class="codeline">/// For example, if you ask for the number of iterations of a linked-list</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeline">/// traversal loop, you will get one of these.  None of the standard SCEV</td>
    <td class="lineNumber">207</td>
    <td class="codeline">/// traversal loop, you will get one of these.  None of the standard SCEV</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeline">/// operations are valid on this class, it is just a marker.</td>
    <td class="lineNumber">208</td>
    <td class="codeline">/// operations are valid on this class, it is just a marker.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeline">struct SCEVCouldNotCompute : public SCEV {</td>
    <td class="lineNumber">209</td>
    <td class="codeline">struct SCEVCouldNotCompute : public SCEV {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeline">  SCEVCouldNotCompute();</td>
    <td class="lineNumber">210</td>
    <td class="codeline">  SCEVCouldNotCompute();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeline"></td>
    <td class="lineNumber">211</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeline">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td class="lineNumber">212</td>
    <td class="codeline">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeline">  static bool classof(const SCEV *S);</td>
    <td class="lineNumber">213</td>
    <td class="codeline">  static bool classof(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeline">};</td>
    <td class="lineNumber">214</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
    <td class="lineNumber">215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeline">/// This class represents an assumption made using SCEV expressions which can</td>
    <td class="lineNumber">216</td>
    <td class="codeline">/// This class represents an assumption made using SCEV expressions which can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeline">/// be checked at run-time.</td>
    <td class="lineNumber">217</td>
    <td class="codeline">/// be checked at run-time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeline">class SCEVPredicate : public FoldingSetNode {</td>
    <td class="lineNumber">218</td>
    <td class="codeline">class SCEVPredicate : public FoldingSetNode {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeline">  friend struct FoldingSetTrait<SCEVPredicate>;</td>
    <td class="lineNumber">219</td>
    <td class="codeline">  friend struct FoldingSetTrait<SCEVPredicate>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
    <td class="lineNumber">220</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeline">  /// A reference to an Interned FoldingSetNodeID for this node.  The</td>
    <td class="lineNumber">221</td>
    <td class="codeline">  /// A reference to an Interned FoldingSetNodeID for this node.  The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeline">  /// ScalarEvolution's BumpPtrAllocator holds the data.</td>
    <td class="lineNumber">222</td>
    <td class="codeline">  /// ScalarEvolution's BumpPtrAllocator holds the data.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeline">  FoldingSetNodeIDRef FastID;</td>
    <td class="lineNumber">223</td>
    <td class="codeline">  FoldingSetNodeIDRef FastID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeline"></td>
    <td class="lineNumber">224</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">225</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeline">  enum SCEVPredicateKind { P_Union, P_Compare, P_Wrap };</td>
    <td class="lineNumber">226</td>
    <td class="codeline">  enum SCEVPredicateKind { P_Union, P_Compare, P_Wrap };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeline"></td>
    <td class="lineNumber">227</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeline">protected:</td>
    <td class="lineNumber">228</td>
    <td class="codeline">protected:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeline">  SCEVPredicateKind Kind;</td>
    <td class="lineNumber">229</td>
    <td class="codeline">  SCEVPredicateKind Kind;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeline">  ~SCEVPredicate() = default;</td>
    <td class="lineNumber">230</td>
    <td class="codeline">  ~SCEVPredicate() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeline">  SCEVPredicate(const SCEVPredicate &) = default;</td>
    <td class="lineNumber">231</td>
    <td class="codeline">  SCEVPredicate(const SCEVPredicate &) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeline">  SCEVPredicate &operator=(const SCEVPredicate &) = default;</td>
    <td class="lineNumber">232</td>
    <td class="codeline">  SCEVPredicate &operator=(const SCEVPredicate &) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
    <td class="lineNumber">233</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">234</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeline">  SCEVPredicate(const FoldingSetNodeIDRef ID, SCEVPredicateKind Kind);</td>
    <td class="lineNumber">235</td>
    <td class="codeline">  SCEVPredicate(const FoldingSetNodeIDRef ID, SCEVPredicateKind Kind);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeline"></td>
    <td class="lineNumber">236</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeline">  SCEVPredicateKind getKind() const { return Kind; }</td>
    <td class="lineNumber">237</td>
    <td class="codeline">  SCEVPredicateKind getKind() const { return Kind; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeline"></td>
    <td class="lineNumber">238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeline">  /// Returns the estimated complexity of this predicate.  This is roughly</td>
    <td class="lineNumber">239</td>
    <td class="codeline">  /// Returns the estimated complexity of this predicate.  This is roughly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeline">  /// measured in the number of run-time checks required.</td>
    <td class="lineNumber">240</td>
    <td class="codeline">  /// measured in the number of run-time checks required.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeline">  virtual unsigned getComplexity() const { return 1; }</td>
    <td class="lineNumber">241</td>
    <td class="codeline">  virtual unsigned getComplexity() const { return 1; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeline"></td>
    <td class="lineNumber">242</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeline">  /// Returns true if the predicate is always true. This means that no</td>
    <td class="lineNumber">243</td>
    <td class="codeline">  /// Returns true if the predicate is always true. This means that no</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeline">  /// assumptions were made and nothing needs to be checked at run-time.</td>
    <td class="lineNumber">244</td>
    <td class="codeline">  /// assumptions were made and nothing needs to be checked at run-time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeline">  virtual bool isAlwaysTrue() const = 0;</td>
    <td class="lineNumber">245</td>
    <td class="codeline">  virtual bool isAlwaysTrue() const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
    <td class="lineNumber">246</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeline">  /// Returns true if this predicate implies \p N.</td>
    <td class="lineNumber">247</td>
    <td class="codeline">  /// Returns true if this predicate implies \p N.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeline">  virtual bool implies(const SCEVPredicate *N) const = 0;</td>
    <td class="lineNumber">248</td>
    <td class="codeline">  virtual bool implies(const SCEVPredicate *N) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeline"></td>
    <td class="lineNumber">249</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeline">  /// Prints a textual representation of this predicate with an indentation of</td>
    <td class="lineNumber">250</td>
    <td class="codeline">  /// Prints a textual representation of this predicate with an indentation of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeline">  /// \p Depth.</td>
    <td class="lineNumber">251</td>
    <td class="codeline">  /// \p Depth.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeline">  virtual void print(raw_ostream &OS, unsigned Depth = 0) const = 0;</td>
    <td class="lineNumber">252</td>
    <td class="codeline">  virtual void print(raw_ostream &OS, unsigned Depth = 0) const = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeline">};</td>
    <td class="lineNumber">253</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeline"></td>
    <td class="lineNumber">254</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeline">inline raw_ostream &operator<<(raw_ostream &OS, const SCEVPredicate &P) {</td>
    <td class="lineNumber">255</td>
    <td class="codeline">inline raw_ostream &operator<<(raw_ostream &OS, const SCEVPredicate &P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeline">  P.print(OS);</td>
    <td class="lineNumber">256</td>
    <td class="codeline">  P.print(OS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeline">  return OS;</td>
    <td class="lineNumber">257</td>
    <td class="codeline">  return OS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeline">}</td>
    <td class="lineNumber">258</td>
    <td class="codeline">}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
    <td class="lineNumber">259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeline">// Specialize FoldingSetTrait for SCEVPredicate to avoid needing to compute</td>
    <td class="lineNumber">260</td>
    <td class="codeline">// Specialize FoldingSetTrait for SCEVPredicate to avoid needing to compute</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeline">// temporary FoldingSetNodeID values.</td>
    <td class="lineNumber">261</td>
    <td class="codeline">// temporary FoldingSetNodeID values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeline">template <></td>
    <td class="lineNumber">262</td>
    <td class="codeline">template <></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeline">struct FoldingSetTrait<SCEVPredicate> : DefaultFoldingSetTrait<SCEVPredicate> {</td>
    <td class="lineNumber">263</td>
    <td class="codeline">struct FoldingSetTrait<SCEVPredicate> : DefaultFoldingSetTrait<SCEVPredicate> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeline">  static void Profile(const SCEVPredicate &X, FoldingSetNodeID &ID) {</td>
    <td class="lineNumber">264</td>
    <td class="codeline">  static void Profile(const SCEVPredicate &X, FoldingSetNodeID &ID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeline">    ID = X.FastID;</td>
    <td class="lineNumber">265</td>
    <td class="codeline">    ID = X.FastID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">266</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeline"></td>
    <td class="lineNumber">267</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeline">  static bool Equals(const SCEVPredicate &X, const FoldingSetNodeID &ID,</td>
    <td class="lineNumber">268</td>
    <td class="codeline">  static bool Equals(const SCEVPredicate &X, const FoldingSetNodeID &ID,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeline">                     unsigned IDHash, FoldingSetNodeID &TempID) {</td>
    <td class="lineNumber">269</td>
    <td class="codeline">                     unsigned IDHash, FoldingSetNodeID &TempID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeline">    return ID == X.FastID;</td>
    <td class="lineNumber">270</td>
    <td class="codeline">    return ID == X.FastID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">271</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeline"></td>
    <td class="lineNumber">272</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeline">  static unsigned ComputeHash(const SCEVPredicate &X,</td>
    <td class="lineNumber">273</td>
    <td class="codeline">  static unsigned ComputeHash(const SCEVPredicate &X,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeline">                              FoldingSetNodeID &TempID) {</td>
    <td class="lineNumber">274</td>
    <td class="codeline">                              FoldingSetNodeID &TempID) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeline">    return X.FastID.ComputeHash();</td>
    <td class="lineNumber">275</td>
    <td class="codeline">    return X.FastID.ComputeHash();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">276</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeline">};</td>
    <td class="lineNumber">277</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeline"></td>
    <td class="lineNumber">278</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeline">/// This class represents an assumption that the expression LHS Pred RHS</td>
    <td class="lineNumber">279</td>
    <td class="codeline">/// This class represents an assumption that the expression LHS Pred RHS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeline">/// evaluates to true, and this can be checked at run-time.</td>
    <td class="lineNumber">280</td>
    <td class="codeline">/// evaluates to true, and this can be checked at run-time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeline">class SCEVComparePredicate final : public SCEVPredicate {</td>
    <td class="lineNumber">281</td>
    <td class="codeline">class SCEVComparePredicate final : public SCEVPredicate {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeline">  /// We assume that LHS Pred RHS is true.</td>
    <td class="lineNumber">282</td>
    <td class="codeline">  /// We assume that LHS Pred RHS is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeline">  const ICmpInst::Predicate Pred;</td>
    <td class="lineNumber">283</td>
    <td class="codeline">  const ICmpInst::Predicate Pred;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeline">  const SCEV *LHS;</td>
    <td class="lineNumber">284</td>
    <td class="codeline">  const SCEV *LHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeline">  const SCEV *RHS;</td>
    <td class="lineNumber">285</td>
    <td class="codeline">  const SCEV *RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
    <td class="lineNumber">286</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">287</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeline">  SCEVComparePredicate(const FoldingSetNodeIDRef ID,</td>
    <td class="lineNumber">288</td>
    <td class="codeline">  SCEVComparePredicate(const FoldingSetNodeIDRef ID,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeline">                       const ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">289</td>
    <td class="codeline">                       const ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeline">                       const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">290</td>
    <td class="codeline">                       const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeline"></td>
    <td class="lineNumber">291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeline">  /// Implementation of the SCEVPredicate interface</td>
    <td class="lineNumber">292</td>
    <td class="codeline">  /// Implementation of the SCEVPredicate interface</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeline">  bool implies(const SCEVPredicate *N) const override;</td>
    <td class="lineNumber">293</td>
    <td class="codeline">  bool implies(const SCEVPredicate *N) const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeline">  void print(raw_ostream &OS, unsigned Depth = 0) const override;</td>
    <td class="lineNumber">294</td>
    <td class="codeline">  void print(raw_ostream &OS, unsigned Depth = 0) const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeline">  bool isAlwaysTrue() const override;</td>
    <td class="lineNumber">295</td>
    <td class="codeline">  bool isAlwaysTrue() const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeline"></td>
    <td class="lineNumber">296</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeline">  ICmpInst::Predicate getPredicate() const { return Pred; }</td>
    <td class="lineNumber">297</td>
    <td class="codeline">  ICmpInst::Predicate getPredicate() const { return Pred; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeline"></td>
    <td class="lineNumber">298</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeline">  /// Returns the left hand side of the predicate.</td>
    <td class="lineNumber">299</td>
    <td class="codeline">  /// Returns the left hand side of the predicate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeline">  const SCEV *getLHS() const { return LHS; }</td>
    <td class="lineNumber">300</td>
    <td class="codeline">  const SCEV *getLHS() const { return LHS; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
    <td class="lineNumber">301</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeline">  /// Returns the right hand side of the predicate.</td>
    <td class="lineNumber">302</td>
    <td class="codeline">  /// Returns the right hand side of the predicate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeline">  const SCEV *getRHS() const { return RHS; }</td>
    <td class="lineNumber">303</td>
    <td class="codeline">  const SCEV *getRHS() const { return RHS; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeline"></td>
    <td class="lineNumber">304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeline">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td class="lineNumber">305</td>
    <td class="codeline">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeline">  static bool classof(const SCEVPredicate *P) {</td>
    <td class="lineNumber">306</td>
    <td class="codeline">  static bool classof(const SCEVPredicate *P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeline">    return P->getKind() == P_Compare;</td>
    <td class="lineNumber">307</td>
    <td class="codeline">    return P->getKind() == P_Compare;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">308</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeline">};</td>
    <td class="lineNumber">309</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeline"></td>
    <td class="lineNumber">310</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeline">/// This class represents an assumption made on an AddRec expression. Given an</td>
    <td class="lineNumber">311</td>
    <td class="codeline">/// This class represents an assumption made on an AddRec expression. Given an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeline">/// affine AddRec expression {a,+,b}, we assume that it has the nssw or nusw</td>
    <td class="lineNumber">312</td>
    <td class="codeline">/// affine AddRec expression {a,+,b}, we assume that it has the nssw or nusw</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeline">/// flags (defined below) in the first X iterations of the loop, where X is a</td>
    <td class="lineNumber">313</td>
    <td class="codeline">/// flags (defined below) in the first X iterations of the loop, where X is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeline">/// SCEV expression returned by getPredicatedBackedgeTakenCount).</td>
    <td class="lineNumber">314</td>
    <td class="codeline">/// SCEV expression returned by getPredicatedBackedgeTakenCount).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeline">///</td>
    <td class="lineNumber">315</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeline">/// Note that this does not imply that X is equal to the backedge taken</td>
    <td class="lineNumber">316</td>
    <td class="codeline">/// Note that this does not imply that X is equal to the backedge taken</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeline">/// count. This means that if we have a nusw predicate for i32 {0,+,1} with a</td>
    <td class="lineNumber">317</td>
    <td class="codeline">/// count. This means that if we have a nusw predicate for i32 {0,+,1} with a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeline">/// predicated backedge taken count of X, we only guarantee that {0,+,1} has</td>
    <td class="lineNumber">318</td>
    <td class="codeline">/// predicated backedge taken count of X, we only guarantee that {0,+,1} has</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeline">/// nusw in the first X iterations. {0,+,1} may still wrap in the loop if we</td>
    <td class="lineNumber">319</td>
    <td class="codeline">/// nusw in the first X iterations. {0,+,1} may still wrap in the loop if we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeline">/// have more than X iterations.</td>
    <td class="lineNumber">320</td>
    <td class="codeline">/// have more than X iterations.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeline">class SCEVWrapPredicate final : public SCEVPredicate {</td>
    <td class="lineNumber">321</td>
    <td class="codeline">class SCEVWrapPredicate final : public SCEVPredicate {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">322</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeline">  /// Similar to SCEV::NoWrapFlags, but with slightly different semantics</td>
    <td class="lineNumber">323</td>
    <td class="codeline">  /// Similar to SCEV::NoWrapFlags, but with slightly different semantics</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeline">  /// for FlagNUSW. The increment is considered to be signed, and a + b</td>
    <td class="lineNumber">324</td>
    <td class="codeline">  /// for FlagNUSW. The increment is considered to be signed, and a + b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeline">  /// (where b is the increment) is considered to wrap if:</td>
    <td class="lineNumber">325</td>
    <td class="codeline">  /// (where b is the increment) is considered to wrap if:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeline">  ///    zext(a + b) != zext(a) + sext(b)</td>
    <td class="lineNumber">326</td>
    <td class="codeline">  ///    zext(a + b) != zext(a) + sext(b)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">327</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeline">  /// If Signed is a function that takes an n-bit tuple and maps to the</td>
    <td class="lineNumber">328</td>
    <td class="codeline">  /// If Signed is a function that takes an n-bit tuple and maps to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeline">  /// integer domain as the tuples value interpreted as twos complement,</td>
    <td class="lineNumber">329</td>
    <td class="codeline">  /// integer domain as the tuples value interpreted as twos complement,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeline">  /// and Unsigned a function that takes an n-bit tuple and maps to the</td>
    <td class="lineNumber">330</td>
    <td class="codeline">  /// and Unsigned a function that takes an n-bit tuple and maps to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeline">  /// integer domain as as the base two value of input tuple, then a + b</td>
    <td class="lineNumber">331</td>
    <td class="codeline">  /// integer domain as as the base two value of input tuple, then a + b</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeline">  /// has IncrementNUSW iff:</td>
    <td class="lineNumber">332</td>
    <td class="codeline">  /// has IncrementNUSW iff:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">333</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeline">  /// 0 <= Unsigned(a) + Signed(b) < 2^n</td>
    <td class="lineNumber">334</td>
    <td class="codeline">  /// 0 <= Unsigned(a) + Signed(b) < 2^n</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">335</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeline">  /// The IncrementNSSW flag has identical semantics with SCEV::FlagNSW.</td>
    <td class="lineNumber">336</td>
    <td class="codeline">  /// The IncrementNSSW flag has identical semantics with SCEV::FlagNSW.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">337</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeline">  /// Note that the IncrementNUSW flag is not commutative: if base + inc</td>
    <td class="lineNumber">338</td>
    <td class="codeline">  /// Note that the IncrementNUSW flag is not commutative: if base + inc</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeline">  /// has IncrementNUSW, then inc + base doesn't neccessarily have this</td>
    <td class="lineNumber">339</td>
    <td class="codeline">  /// has IncrementNUSW, then inc + base doesn't neccessarily have this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeline">  /// property. The reason for this is that this is used for sign/zero</td>
    <td class="lineNumber">340</td>
    <td class="codeline">  /// property. The reason for this is that this is used for sign/zero</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeline">  /// extending affine AddRec SCEV expressions when a SCEVWrapPredicate is</td>
    <td class="lineNumber">341</td>
    <td class="codeline">  /// extending affine AddRec SCEV expressions when a SCEVWrapPredicate is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeline">  /// assumed. A {base,+,inc} expression is already non-commutative with</td>
    <td class="lineNumber">342</td>
    <td class="codeline">  /// assumed. A {base,+,inc} expression is already non-commutative with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeline">  /// regards to base and inc, since it is interpreted as:</td>
    <td class="lineNumber">343</td>
    <td class="codeline">  /// regards to base and inc, since it is interpreted as:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeline">  ///     (((base + inc) + inc) + inc) ...</td>
    <td class="lineNumber">344</td>
    <td class="codeline">  ///     (((base + inc) + inc) + inc) ...</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeline">  enum IncrementWrapFlags {</td>
    <td class="lineNumber">345</td>
    <td class="codeline">  enum IncrementWrapFlags {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeline">    IncrementAnyWrap = 0,     // No guarantee.</td>
    <td class="lineNumber">346</td>
    <td class="codeline">    IncrementAnyWrap = 0,     // No guarantee.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeline">    IncrementNUSW = (1 << 0), // No unsigned with signed increment wrap.</td>
    <td class="lineNumber">347</td>
    <td class="codeline">    IncrementNUSW = (1 << 0), // No unsigned with signed increment wrap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeline">    IncrementNSSW = (1 << 1), // No signed with signed increment wrap</td>
    <td class="lineNumber">348</td>
    <td class="codeline">    IncrementNSSW = (1 << 1), // No signed with signed increment wrap</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeline">                              // (equivalent with SCEV::NSW)</td>
    <td class="lineNumber">349</td>
    <td class="codeline">                              // (equivalent with SCEV::NSW)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeline">    IncrementNoWrapMask = (1 << 2) - 1</td>
    <td class="lineNumber">350</td>
    <td class="codeline">    IncrementNoWrapMask = (1 << 2) - 1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">351</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeline"></td>
    <td class="lineNumber">352</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeline">  /// Convenient IncrementWrapFlags manipulation methods.</td>
    <td class="lineNumber">353</td>
    <td class="codeline">  /// Convenient IncrementWrapFlags manipulation methods.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeline">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td class="lineNumber">354</td>
    <td class="codeline">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeline">  clearFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,</td>
    <td class="lineNumber">355</td>
    <td class="codeline">  clearFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeline">             SCEVWrapPredicate::IncrementWrapFlags OffFlags) {</td>
    <td class="lineNumber">356</td>
    <td class="codeline">             SCEVWrapPredicate::IncrementWrapFlags OffFlags) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeline">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
    <td class="lineNumber">357</td>
    <td class="codeline">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeline">    assert((OffFlags & IncrementNoWrapMask) == OffFlags &&</td>
    <td class="lineNumber">358</td>
    <td class="codeline">    assert((OffFlags & IncrementNoWrapMask) == OffFlags &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeline">           "Invalid flags value!");</td>
    <td class="lineNumber">359</td>
    <td class="codeline">           "Invalid flags value!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeline">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & ~OffFlags);</td>
    <td class="lineNumber">360</td>
    <td class="codeline">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & ~OffFlags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">361</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
    <td class="lineNumber">362</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeline">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td class="lineNumber">363</td>
    <td class="codeline">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeline">  maskFlags(SCEVWrapPredicate::IncrementWrapFlags Flags, int Mask) {</td>
    <td class="lineNumber">364</td>
    <td class="codeline">  maskFlags(SCEVWrapPredicate::IncrementWrapFlags Flags, int Mask) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeline">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
    <td class="lineNumber">365</td>
    <td class="codeline">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeline">    assert((Mask & IncrementNoWrapMask) == Mask && "Invalid mask value!");</td>
    <td class="lineNumber">366</td>
    <td class="codeline">    assert((Mask & IncrementNoWrapMask) == Mask && "Invalid mask value!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
    <td class="lineNumber">367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeline">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & Mask);</td>
    <td class="lineNumber">368</td>
    <td class="codeline">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & Mask);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">369</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeline"></td>
    <td class="lineNumber">370</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeline">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td class="lineNumber">371</td>
    <td class="codeline">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeline">  setFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,</td>
    <td class="lineNumber">372</td>
    <td class="codeline">  setFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeline">           SCEVWrapPredicate::IncrementWrapFlags OnFlags) {</td>
    <td class="lineNumber">373</td>
    <td class="codeline">           SCEVWrapPredicate::IncrementWrapFlags OnFlags) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeline">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
    <td class="lineNumber">374</td>
    <td class="codeline">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeline">    assert((OnFlags & IncrementNoWrapMask) == OnFlags &&</td>
    <td class="lineNumber">375</td>
    <td class="codeline">    assert((OnFlags & IncrementNoWrapMask) == OnFlags &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeline">           "Invalid flags value!");</td>
    <td class="lineNumber">376</td>
    <td class="codeline">           "Invalid flags value!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeline"></td>
    <td class="lineNumber">377</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeline">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags | OnFlags);</td>
    <td class="lineNumber">378</td>
    <td class="codeline">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags | OnFlags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">379</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeline"></td>
    <td class="lineNumber">380</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeline">  /// Returns the set of SCEVWrapPredicate no wrap flags implied by a</td>
    <td class="lineNumber">381</td>
    <td class="codeline">  /// Returns the set of SCEVWrapPredicate no wrap flags implied by a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeline">  /// SCEVAddRecExpr.</td>
    <td class="lineNumber">382</td>
    <td class="codeline">  /// SCEVAddRecExpr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeline">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td class="lineNumber">383</td>
    <td class="codeline">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeline">  getImpliedFlags(const SCEVAddRecExpr *AR, ScalarEvolution &SE);</td>
    <td class="lineNumber">384</td>
    <td class="codeline">  getImpliedFlags(const SCEVAddRecExpr *AR, ScalarEvolution &SE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeline"></td>
    <td class="lineNumber">385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">386</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeline">  const SCEVAddRecExpr *AR;</td>
    <td class="lineNumber">387</td>
    <td class="codeline">  const SCEVAddRecExpr *AR;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeline">  IncrementWrapFlags Flags;</td>
    <td class="lineNumber">388</td>
    <td class="codeline">  IncrementWrapFlags Flags;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
    <td class="lineNumber">389</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">390</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeline">  explicit SCEVWrapPredicate(const FoldingSetNodeIDRef ID,</td>
    <td class="lineNumber">391</td>
    <td class="codeline">  explicit SCEVWrapPredicate(const FoldingSetNodeIDRef ID,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeline">                             const SCEVAddRecExpr *AR,</td>
    <td class="lineNumber">392</td>
    <td class="codeline">                             const SCEVAddRecExpr *AR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeline">                             IncrementWrapFlags Flags);</td>
    <td class="lineNumber">393</td>
    <td class="codeline">                             IncrementWrapFlags Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeline"></td>
    <td class="lineNumber">394</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeline">  /// Returns the set assumed no overflow flags.</td>
    <td class="lineNumber">395</td>
    <td class="codeline">  /// Returns the set assumed no overflow flags.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeline">  IncrementWrapFlags getFlags() const { return Flags; }</td>
    <td class="lineNumber">396</td>
    <td class="codeline">  IncrementWrapFlags getFlags() const { return Flags; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeline"></td>
    <td class="lineNumber">397</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeline">  /// Implementation of the SCEVPredicate interface</td>
    <td class="lineNumber">398</td>
    <td class="codeline">  /// Implementation of the SCEVPredicate interface</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeline">  const SCEVAddRecExpr *getExpr() const;</td>
    <td class="lineNumber">399</td>
    <td class="codeline">  const SCEVAddRecExpr *getExpr() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeline">  bool implies(const SCEVPredicate *N) const override;</td>
    <td class="lineNumber">400</td>
    <td class="codeline">  bool implies(const SCEVPredicate *N) const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeline">  void print(raw_ostream &OS, unsigned Depth = 0) const override;</td>
    <td class="lineNumber">401</td>
    <td class="codeline">  void print(raw_ostream &OS, unsigned Depth = 0) const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeline">  bool isAlwaysTrue() const override;</td>
    <td class="lineNumber">402</td>
    <td class="codeline">  bool isAlwaysTrue() const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeline"></td>
    <td class="lineNumber">403</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeline">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td class="lineNumber">404</td>
    <td class="codeline">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeline">  static bool classof(const SCEVPredicate *P) {</td>
    <td class="lineNumber">405</td>
    <td class="codeline">  static bool classof(const SCEVPredicate *P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeline">    return P->getKind() == P_Wrap;</td>
    <td class="lineNumber">406</td>
    <td class="codeline">    return P->getKind() == P_Wrap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">407</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeline">};</td>
    <td class="lineNumber">408</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
    <td class="lineNumber">409</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeline">/// This class represents a composition of other SCEV predicates, and is the</td>
    <td class="lineNumber">410</td>
    <td class="codeline">/// This class represents a composition of other SCEV predicates, and is the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeline">/// class that most clients will interact with.  This is equivalent to a</td>
    <td class="lineNumber">411</td>
    <td class="codeline">/// class that most clients will interact with.  This is equivalent to a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeline">/// logical "AND" of all the predicates in the union.</td>
    <td class="lineNumber">412</td>
    <td class="codeline">/// logical "AND" of all the predicates in the union.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeline">///</td>
    <td class="lineNumber">413</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeline">/// NB! Unlike other SCEVPredicate sub-classes this class does not live in the</td>
    <td class="lineNumber">414</td>
    <td class="codeline">/// NB! Unlike other SCEVPredicate sub-classes this class does not live in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeline">/// ScalarEvolution::Preds folding set.  This is why the \c add function is sound.</td>
    <td class="lineNumber">415</td>
    <td class="codeline">/// ScalarEvolution::Preds folding set.  This is why the \c add function is sound.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeline">class SCEVUnionPredicate final : public SCEVPredicate {</td>
    <td class="lineNumber">416</td>
    <td class="codeline">class SCEVUnionPredicate final : public SCEVPredicate {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">417</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeline">  using PredicateMap =</td>
    <td class="lineNumber">418</td>
    <td class="codeline">  using PredicateMap =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeline">      DenseMap<const SCEV *, SmallVector<const SCEVPredicate *, 4>>;</td>
    <td class="lineNumber">419</td>
    <td class="codeline">      DenseMap<const SCEV *, SmallVector<const SCEVPredicate *, 4>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeline"></td>
    <td class="lineNumber">420</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeline">  /// Vector with references to all predicates in this union.</td>
    <td class="lineNumber">421</td>
    <td class="codeline">  /// Vector with references to all predicates in this union.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeline">  SmallVector<const SCEVPredicate *, 16> Preds;</td>
    <td class="lineNumber">422</td>
    <td class="codeline">  SmallVector<const SCEVPredicate *, 16> Preds;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeline"></td>
    <td class="lineNumber">423</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeline">  /// Adds a predicate to this union.</td>
    <td class="lineNumber">424</td>
    <td class="codeline">  /// Adds a predicate to this union.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeline">  void add(const SCEVPredicate *N);</td>
    <td class="lineNumber">425</td>
    <td class="codeline">  void add(const SCEVPredicate *N);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeline"></td>
    <td class="lineNumber">426</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">427</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeline">  SCEVUnionPredicate(ArrayRef<const SCEVPredicate *> Preds);</td>
    <td class="lineNumber">428</td>
    <td class="codeline">  SCEVUnionPredicate(ArrayRef<const SCEVPredicate *> Preds);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
    <td class="lineNumber">429</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeline">  const SmallVectorImpl<const SCEVPredicate *> &getPredicates() const {</td>
    <td class="lineNumber">430</td>
    <td class="codeline">  const SmallVectorImpl<const SCEVPredicate *> &getPredicates() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeline">    return Preds;</td>
    <td class="lineNumber">431</td>
    <td class="codeline">    return Preds;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">432</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeline"></td>
    <td class="lineNumber">433</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeline">  /// Implementation of the SCEVPredicate interface</td>
    <td class="lineNumber">434</td>
    <td class="codeline">  /// Implementation of the SCEVPredicate interface</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeline">  bool isAlwaysTrue() const override;</td>
    <td class="lineNumber">435</td>
    <td class="codeline">  bool isAlwaysTrue() const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeline">  bool implies(const SCEVPredicate *N) const override;</td>
    <td class="lineNumber">436</td>
    <td class="codeline">  bool implies(const SCEVPredicate *N) const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeline">  void print(raw_ostream &OS, unsigned Depth) const override;</td>
    <td class="lineNumber">437</td>
    <td class="codeline">  void print(raw_ostream &OS, unsigned Depth) const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
    <td class="lineNumber">438</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeline">  /// We estimate the complexity of a union predicate as the size number of</td>
    <td class="lineNumber">439</td>
    <td class="codeline">  /// We estimate the complexity of a union predicate as the size number of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeline">  /// predicates in the union.</td>
    <td class="lineNumber">440</td>
    <td class="codeline">  /// predicates in the union.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeline">  unsigned getComplexity() const override { return Preds.size(); }</td>
    <td class="lineNumber">441</td>
    <td class="codeline">  unsigned getComplexity() const override { return Preds.size(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeline"></td>
    <td class="lineNumber">442</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeline">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td class="lineNumber">443</td>
    <td class="codeline">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeline">  static bool classof(const SCEVPredicate *P) {</td>
    <td class="lineNumber">444</td>
    <td class="codeline">  static bool classof(const SCEVPredicate *P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeline">    return P->getKind() == P_Union;</td>
    <td class="lineNumber">445</td>
    <td class="codeline">    return P->getKind() == P_Union;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">446</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeline">};</td>
    <td class="lineNumber">447</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeline"></td>
    <td class="lineNumber">448</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeline">/// The main scalar evolution driver. Because client code (intentionally)</td>
    <td class="lineNumber">449</td>
    <td class="codeline">/// The main scalar evolution driver. Because client code (intentionally)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeline">/// can't do much with the SCEV objects directly, they must ask this class</td>
    <td class="lineNumber">450</td>
    <td class="codeline">/// can't do much with the SCEV objects directly, they must ask this class</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeline">/// for services.</td>
    <td class="lineNumber">451</td>
    <td class="codeline">/// for services.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeline">class ScalarEvolution {</td>
    <td class="lineNumber">452</td>
    <td class="codeline">class ScalarEvolution {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeline">  friend class ScalarEvolutionsTest;</td>
    <td class="lineNumber">453</td>
    <td class="codeline">  friend class ScalarEvolutionsTest;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeline"></td>
    <td class="lineNumber">454</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">455</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeline">  /// An enum describing the relationship between a SCEV and a loop.</td>
    <td class="lineNumber">456</td>
    <td class="codeline">  /// An enum describing the relationship between a SCEV and a loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeline">  enum LoopDisposition {</td>
    <td class="lineNumber">457</td>
    <td class="codeline">  enum LoopDisposition {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeline">    LoopVariant,   ///< The SCEV is loop-variant (unknown).</td>
    <td class="lineNumber">458</td>
    <td class="codeline">    LoopVariant,   ///< The SCEV is loop-variant (unknown).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeline">    LoopInvariant, ///< The SCEV is loop-invariant.</td>
    <td class="lineNumber">459</td>
    <td class="codeline">    LoopInvariant, ///< The SCEV is loop-invariant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeline">    LoopComputable ///< The SCEV varies predictably with the loop.</td>
    <td class="lineNumber">460</td>
    <td class="codeline">    LoopComputable ///< The SCEV varies predictably with the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">461</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeline"></td>
    <td class="lineNumber">462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeline">  /// An enum describing the relationship between a SCEV and a basic block.</td>
    <td class="lineNumber">463</td>
    <td class="codeline">  /// An enum describing the relationship between a SCEV and a basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeline">  enum BlockDisposition {</td>
    <td class="lineNumber">464</td>
    <td class="codeline">  enum BlockDisposition {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeline">    DoesNotDominateBlock,  ///< The SCEV does not dominate the block.</td>
    <td class="lineNumber">465</td>
    <td class="codeline">    DoesNotDominateBlock,  ///< The SCEV does not dominate the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeline">    DominatesBlock,        ///< The SCEV dominates the block.</td>
    <td class="lineNumber">466</td>
    <td class="codeline">    DominatesBlock,        ///< The SCEV dominates the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeline">    ProperlyDominatesBlock ///< The SCEV properly dominates the block.</td>
    <td class="lineNumber">467</td>
    <td class="codeline">    ProperlyDominatesBlock ///< The SCEV properly dominates the block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">468</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeline"></td>
    <td class="lineNumber">469</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeline">  /// Convenient NoWrapFlags manipulation that hides enum casts and is</td>
    <td class="lineNumber">470</td>
    <td class="codeline">  /// Convenient NoWrapFlags manipulation that hides enum casts and is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeline">  /// visible in the ScalarEvolution name space.</td>
    <td class="lineNumber">471</td>
    <td class="codeline">  /// visible in the ScalarEvolution name space.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeline">  [[nodiscard]] static SCEV::NoWrapFlags maskFlags(SCEV::NoWrapFlags Flags,</td>
    <td class="lineNumber">472</td>
    <td class="codeline">  [[nodiscard]] static SCEV::NoWrapFlags maskFlags(SCEV::NoWrapFlags Flags,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeline">                                                   int Mask) {</td>
    <td class="lineNumber">473</td>
    <td class="codeline">                                                   int Mask) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeline">    return (SCEV::NoWrapFlags)(Flags & Mask);</td>
    <td class="lineNumber">474</td>
    <td class="codeline">    return (SCEV::NoWrapFlags)(Flags & Mask);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">475</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeline">  [[nodiscard]] static SCEV::NoWrapFlags setFlags(SCEV::NoWrapFlags Flags,</td>
    <td class="lineNumber">476</td>
    <td class="codeline">  [[nodiscard]] static SCEV::NoWrapFlags setFlags(SCEV::NoWrapFlags Flags,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeline">                                                  SCEV::NoWrapFlags OnFlags) {</td>
    <td class="lineNumber">477</td>
    <td class="codeline">                                                  SCEV::NoWrapFlags OnFlags) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeline">    return (SCEV::NoWrapFlags)(Flags | OnFlags);</td>
    <td class="lineNumber">478</td>
    <td class="codeline">    return (SCEV::NoWrapFlags)(Flags | OnFlags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">479</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeline">  [[nodiscard]] static SCEV::NoWrapFlags</td>
    <td class="lineNumber">480</td>
    <td class="codeline">  [[nodiscard]] static SCEV::NoWrapFlags</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeline">  clearFlags(SCEV::NoWrapFlags Flags, SCEV::NoWrapFlags OffFlags) {</td>
    <td class="lineNumber">481</td>
    <td class="codeline">  clearFlags(SCEV::NoWrapFlags Flags, SCEV::NoWrapFlags OffFlags) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeline">    return (SCEV::NoWrapFlags)(Flags & ~OffFlags);</td>
    <td class="lineNumber">482</td>
    <td class="codeline">    return (SCEV::NoWrapFlags)(Flags & ~OffFlags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">483</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeline">  [[nodiscard]] static bool hasFlags(SCEV::NoWrapFlags Flags,</td>
    <td class="lineNumber">484</td>
    <td class="codeline">  [[nodiscard]] static bool hasFlags(SCEV::NoWrapFlags Flags,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeline">                                     SCEV::NoWrapFlags TestFlags) {</td>
    <td class="lineNumber">485</td>
    <td class="codeline">                                     SCEV::NoWrapFlags TestFlags) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeline">    return TestFlags == maskFlags(Flags, TestFlags);</td>
    <td class="lineNumber">486</td>
    <td class="codeline">    return TestFlags == maskFlags(Flags, TestFlags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">487</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
    <td class="lineNumber">488</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeline">  ScalarEvolution(Function &F, TargetLibraryInfo &TLI, AssumptionCache &AC,</td>
    <td class="lineNumber">489</td>
    <td class="codeline">  ScalarEvolution(Function &F, TargetLibraryInfo &TLI, AssumptionCache &AC,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeline">                  DominatorTree &DT, LoopInfo &LI);</td>
    <td class="lineNumber">490</td>
    <td class="codeline">                  DominatorTree &DT, LoopInfo &LI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeline">  ScalarEvolution(ScalarEvolution &&Arg);</td>
    <td class="lineNumber">491</td>
    <td class="codeline">  ScalarEvolution(ScalarEvolution &&Arg);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeline">  ~ScalarEvolution();</td>
    <td class="lineNumber">492</td>
    <td class="codeline">  ~ScalarEvolution();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeline"></td>
    <td class="lineNumber">493</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeline">  LLVMContext &getContext() const { return F.getContext(); }</td>
    <td class="lineNumber">494</td>
    <td class="codeline">  LLVMContext &getContext() const { return F.getContext(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeline"></td>
    <td class="lineNumber">495</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeline">  /// Test if values of the given type are analyzable within the SCEV</td>
    <td class="lineNumber">496</td>
    <td class="codeline">  /// Test if values of the given type are analyzable within the SCEV</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeline">  /// framework. This primarily includes integer types, and it can optionally</td>
    <td class="lineNumber">497</td>
    <td class="codeline">  /// framework. This primarily includes integer types, and it can optionally</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeline">  /// include pointer types if the ScalarEvolution class has access to</td>
    <td class="lineNumber">498</td>
    <td class="codeline">  /// include pointer types if the ScalarEvolution class has access to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeline">  /// target-specific information.</td>
    <td class="lineNumber">499</td>
    <td class="codeline">  /// target-specific information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeline">  bool isSCEVable(Type *Ty) const;</td>
    <td class="lineNumber">500</td>
    <td class="codeline">  bool isSCEVable(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeline"></td>
    <td class="lineNumber">501</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeline">  /// Return the size in bits of the specified type, for which isSCEVable must</td>
    <td class="lineNumber">502</td>
    <td class="codeline">  /// Return the size in bits of the specified type, for which isSCEVable must</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeline">  /// return true.</td>
    <td class="lineNumber">503</td>
    <td class="codeline">  /// return true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeline">  uint64_t getTypeSizeInBits(Type *Ty) const;</td>
    <td class="lineNumber">504</td>
    <td class="codeline">  uint64_t getTypeSizeInBits(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeline"></td>
    <td class="lineNumber">505</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeline">  /// Return a type with the same bitwidth as the given type and which</td>
    <td class="lineNumber">506</td>
    <td class="codeline">  /// Return a type with the same bitwidth as the given type and which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeline">  /// represents how SCEV will treat the given type, for which isSCEVable must</td>
    <td class="lineNumber">507</td>
    <td class="codeline">  /// represents how SCEV will treat the given type, for which isSCEVable must</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeline">  /// return true. For pointer types, this is the pointer-sized integer type.</td>
    <td class="lineNumber">508</td>
    <td class="codeline">  /// return true. For pointer types, this is the pointer-sized integer type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeline">  Type *getEffectiveSCEVType(Type *Ty) const;</td>
    <td class="lineNumber">509</td>
    <td class="codeline">  Type *getEffectiveSCEVType(Type *Ty) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeline"></td>
    <td class="lineNumber">510</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeline">  // Returns a wider type among {Ty1, Ty2}.</td>
    <td class="lineNumber">511</td>
    <td class="codeline">  // Returns a wider type among {Ty1, Ty2}.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeline">  Type *getWiderType(Type *Ty1, Type *Ty2) const;</td>
    <td class="lineNumber">512</td>
    <td class="codeline">  Type *getWiderType(Type *Ty1, Type *Ty2) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
    <td class="lineNumber">513</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeline">  /// Return true if there exists a point in the program at which both</td>
    <td class="lineNumber">514</td>
    <td class="codeline">  /// Return true if there exists a point in the program at which both</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeline">  /// A and B could be operands to the same instruction.</td>
    <td class="lineNumber">515</td>
    <td class="codeline">  /// A and B could be operands to the same instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeline">  /// SCEV expressions are generally assumed to correspond to instructions</td>
    <td class="lineNumber">516</td>
    <td class="codeline">  /// SCEV expressions are generally assumed to correspond to instructions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeline">  /// which could exists in IR.  In general, this requires that there exists</td>
    <td class="lineNumber">517</td>
    <td class="codeline">  /// which could exists in IR.  In general, this requires that there exists</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeline">  /// a use point in the program where all operands dominate the use.</td>
    <td class="lineNumber">518</td>
    <td class="codeline">  /// a use point in the program where all operands dominate the use.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">519</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeline">  /// Example:</td>
    <td class="lineNumber">520</td>
    <td class="codeline">  /// Example:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeline">  /// loop {</td>
    <td class="lineNumber">521</td>
    <td class="codeline">  /// loop {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeline">  ///   if</td>
    <td class="lineNumber">522</td>
    <td class="codeline">  ///   if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeline">  ///     loop { v1 = load @global1; }</td>
    <td class="lineNumber">523</td>
    <td class="codeline">  ///     loop { v1 = load @global1; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeline">  ///   else</td>
    <td class="lineNumber">524</td>
    <td class="codeline">  ///   else</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeline">  ///     loop { v2 = load @global2; }</td>
    <td class="lineNumber">525</td>
    <td class="codeline">  ///     loop { v2 = load @global2; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeline">  /// }</td>
    <td class="lineNumber">526</td>
    <td class="codeline">  /// }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeline">  /// No SCEV with operand V1, and v2 can exist in this program.</td>
    <td class="lineNumber">527</td>
    <td class="codeline">  /// No SCEV with operand V1, and v2 can exist in this program.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeline">  bool instructionCouldExistWitthOperands(const SCEV *A, const SCEV *B);</td>
    <td class="lineNumber">528</td>
    <td class="codeline">  bool instructionCouldExistWitthOperands(const SCEV *A, const SCEV *B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeline"></td>
    <td class="lineNumber">529</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeline">  /// Return true if the SCEV is a scAddRecExpr or it contains</td>
    <td class="lineNumber">530</td>
    <td class="codeline">  /// Return true if the SCEV is a scAddRecExpr or it contains</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeline">  /// scAddRecExpr. The result will be cached in HasRecMap.</td>
    <td class="lineNumber">531</td>
    <td class="codeline">  /// scAddRecExpr. The result will be cached in HasRecMap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeline">  bool containsAddRecurrence(const SCEV *S);</td>
    <td class="lineNumber">532</td>
    <td class="codeline">  bool containsAddRecurrence(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
    <td class="lineNumber">533</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeline">  /// Is operation \p BinOp between \p LHS and \p RHS provably does not have</td>
    <td class="lineNumber">534</td>
    <td class="codeline">  /// Is operation \p BinOp between \p LHS and \p RHS provably does not have</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeline">  /// a signed/unsigned overflow (\p Signed)? If \p CtxI is specified, the</td>
    <td class="lineNumber">535</td>
    <td class="codeline">  /// a signed/unsigned overflow (\p Signed)? If \p CtxI is specified, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeline">  /// no-overflow fact should be true in the context of this instruction.</td>
    <td class="lineNumber">536</td>
    <td class="codeline">  /// no-overflow fact should be true in the context of this instruction.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeline">  bool willNotOverflow(Instruction::BinaryOps BinOp, bool Signed,</td>
    <td class="lineNumber">537</td>
    <td class="codeline">  bool willNotOverflow(Instruction::BinaryOps BinOp, bool Signed,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeline">                       const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">538</td>
    <td class="codeline">                       const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeline">                       const Instruction *CtxI = nullptr);</td>
    <td class="lineNumber">539</td>
    <td class="codeline">                       const Instruction *CtxI = nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
    <td class="lineNumber">540</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeline">  /// Parse NSW/NUW flags from add/sub/mul IR binary operation \p Op into</td>
    <td class="lineNumber">541</td>
    <td class="codeline">  /// Parse NSW/NUW flags from add/sub/mul IR binary operation \p Op into</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeline">  /// SCEV no-wrap flags, and deduce flag[s] that aren't known yet.</td>
    <td class="lineNumber">542</td>
    <td class="codeline">  /// SCEV no-wrap flags, and deduce flag[s] that aren't known yet.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeline">  /// Does not mutate the original instruction. Returns std::nullopt if it could</td>
    <td class="lineNumber">543</td>
    <td class="codeline">  /// Does not mutate the original instruction. Returns std::nullopt if it could</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeline">  /// not deduce more precise flags than the instruction already has, otherwise</td>
    <td class="lineNumber">544</td>
    <td class="codeline">  /// not deduce more precise flags than the instruction already has, otherwise</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeline">  /// returns proven flags.</td>
    <td class="lineNumber">545</td>
    <td class="codeline">  /// returns proven flags.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeline">  std::optional<SCEV::NoWrapFlags></td>
    <td class="lineNumber">546</td>
    <td class="codeline">  std::optional<SCEV::NoWrapFlags></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeline">  getStrengthenedNoWrapFlagsFromBinOp(const OverflowingBinaryOperator *OBO);</td>
    <td class="lineNumber">547</td>
    <td class="codeline">  getStrengthenedNoWrapFlagsFromBinOp(const OverflowingBinaryOperator *OBO);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeline"></td>
    <td class="lineNumber">548</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeline">  /// Notify this ScalarEvolution that \p User directly uses SCEVs in \p Ops.</td>
    <td class="lineNumber">549</td>
    <td class="codeline">  /// Notify this ScalarEvolution that \p User directly uses SCEVs in \p Ops.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeline">  void registerUser(const SCEV *User, ArrayRef<const SCEV *> Ops);</td>
    <td class="lineNumber">550</td>
    <td class="codeline">  void registerUser(const SCEV *User, ArrayRef<const SCEV *> Ops);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeline"></td>
    <td class="lineNumber">551</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeline">  /// Return true if the SCEV expression contains an undef value.</td>
    <td class="lineNumber">552</td>
    <td class="codeline">  /// Return true if the SCEV expression contains an undef value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeline">  bool containsUndefs(const SCEV *S) const;</td>
    <td class="lineNumber">553</td>
    <td class="codeline">  bool containsUndefs(const SCEV *S) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeline"></td>
    <td class="lineNumber">554</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeline">  /// Return true if the SCEV expression contains a Value that has been</td>
    <td class="lineNumber">555</td>
    <td class="codeline">  /// Return true if the SCEV expression contains a Value that has been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeline">  /// optimised out and is now a nullptr.</td>
    <td class="lineNumber">556</td>
    <td class="codeline">  /// optimised out and is now a nullptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeline">  bool containsErasedValue(const SCEV *S) const;</td>
    <td class="lineNumber">557</td>
    <td class="codeline">  bool containsErasedValue(const SCEV *S) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeline"></td>
    <td class="lineNumber">558</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeline">  /// Return a SCEV expression for the full generality of the specified</td>
    <td class="lineNumber">559</td>
    <td class="codeline">  /// Return a SCEV expression for the full generality of the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeline">  /// expression.</td>
    <td class="lineNumber">560</td>
    <td class="codeline">  /// expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeline">  const SCEV *getSCEV(Value *V);</td>
    <td class="lineNumber">561</td>
    <td class="codeline">  const SCEV *getSCEV(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeline"></td>
    <td class="lineNumber">562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeline">  /// Return an existing SCEV for V if there is one, otherwise return nullptr.</td>
    <td class="lineNumber">563</td>
    <td class="codeline">  /// Return an existing SCEV for V if there is one, otherwise return nullptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeline">  const SCEV *getExistingSCEV(Value *V);</td>
    <td class="lineNumber">564</td>
    <td class="codeline">  const SCEV *getExistingSCEV(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
    <td class="lineNumber">565</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeline">  const SCEV *getConstant(ConstantInt *V);</td>
    <td class="lineNumber">566</td>
    <td class="codeline">  const SCEV *getConstant(ConstantInt *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeline">  const SCEV *getConstant(const APInt &Val);</td>
    <td class="lineNumber">567</td>
    <td class="codeline">  const SCEV *getConstant(const APInt &Val);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeline">  const SCEV *getConstant(Type *Ty, uint64_t V, bool isSigned = false);</td>
    <td class="lineNumber">568</td>
    <td class="codeline">  const SCEV *getConstant(Type *Ty, uint64_t V, bool isSigned = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeline">  const SCEV *getLosslessPtrToIntExpr(const SCEV *Op, unsigned Depth = 0);</td>
    <td class="lineNumber">569</td>
    <td class="codeline">  const SCEV *getLosslessPtrToIntExpr(const SCEV *Op, unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeline">  const SCEV *getPtrToIntExpr(const SCEV *Op, Type *Ty);</td>
    <td class="lineNumber">570</td>
    <td class="codeline">  const SCEV *getPtrToIntExpr(const SCEV *Op, Type *Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeline">  const SCEV *getTruncateExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
    <td class="lineNumber">571</td>
    <td class="codeline">  const SCEV *getTruncateExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeline">  const SCEV *getVScale(Type *Ty);</td>
    <td class="lineNumber">572</td>
    <td class="codeline">  const SCEV *getVScale(Type *Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeline">  const SCEV *getZeroExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
    <td class="lineNumber">573</td>
    <td class="codeline">  const SCEV *getZeroExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeline">  const SCEV *getZeroExtendExprImpl(const SCEV *Op, Type *Ty,</td>
    <td class="lineNumber">574</td>
    <td class="codeline">  const SCEV *getZeroExtendExprImpl(const SCEV *Op, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeline">                                    unsigned Depth = 0);</td>
    <td class="lineNumber">575</td>
    <td class="codeline">                                    unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeline">  const SCEV *getSignExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
    <td class="lineNumber">576</td>
    <td class="codeline">  const SCEV *getSignExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeline">  const SCEV *getSignExtendExprImpl(const SCEV *Op, Type *Ty,</td>
    <td class="lineNumber">577</td>
    <td class="codeline">  const SCEV *getSignExtendExprImpl(const SCEV *Op, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeline">                                    unsigned Depth = 0);</td>
    <td class="lineNumber">578</td>
    <td class="codeline">                                    unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeline">  const SCEV *getCastExpr(SCEVTypes Kind, const SCEV *Op, Type *Ty);</td>
    <td class="lineNumber">579</td>
    <td class="codeline">  const SCEV *getCastExpr(SCEVTypes Kind, const SCEV *Op, Type *Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeline">  const SCEV *getAnyExtendExpr(const SCEV *Op, Type *Ty);</td>
    <td class="lineNumber">580</td>
    <td class="codeline">  const SCEV *getAnyExtendExpr(const SCEV *Op, Type *Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeline">  const SCEV *getAddExpr(SmallVectorImpl<const SCEV *> &Ops,</td>
    <td class="lineNumber">581</td>
    <td class="codeline">  const SCEV *getAddExpr(SmallVectorImpl<const SCEV *> &Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeline">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">582</td>
    <td class="codeline">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeline">                         unsigned Depth = 0);</td>
    <td class="lineNumber">583</td>
    <td class="codeline">                         unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeline">  const SCEV *getAddExpr(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">584</td>
    <td class="codeline">  const SCEV *getAddExpr(const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeline">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">585</td>
    <td class="codeline">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeline">                         unsigned Depth = 0) {</td>
    <td class="lineNumber">586</td>
    <td class="codeline">                         unsigned Depth = 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeline">    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};</td>
    <td class="lineNumber">587</td>
    <td class="codeline">    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeline">    return getAddExpr(Ops, Flags, Depth);</td>
    <td class="lineNumber">588</td>
    <td class="codeline">    return getAddExpr(Ops, Flags, Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">589</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeline">  const SCEV *getAddExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,</td>
    <td class="lineNumber">590</td>
    <td class="codeline">  const SCEV *getAddExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeline">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">591</td>
    <td class="codeline">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeline">                         unsigned Depth = 0) {</td>
    <td class="lineNumber">592</td>
    <td class="codeline">                         unsigned Depth = 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeline">    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};</td>
    <td class="lineNumber">593</td>
    <td class="codeline">    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeline">    return getAddExpr(Ops, Flags, Depth);</td>
    <td class="lineNumber">594</td>
    <td class="codeline">    return getAddExpr(Ops, Flags, Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">595</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeline">  const SCEV *getMulExpr(SmallVectorImpl<const SCEV *> &Ops,</td>
    <td class="lineNumber">596</td>
    <td class="codeline">  const SCEV *getMulExpr(SmallVectorImpl<const SCEV *> &Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeline">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">597</td>
    <td class="codeline">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeline">                         unsigned Depth = 0);</td>
    <td class="lineNumber">598</td>
    <td class="codeline">                         unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeline">  const SCEV *getMulExpr(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">599</td>
    <td class="codeline">  const SCEV *getMulExpr(const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeline">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">600</td>
    <td class="codeline">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeline">                         unsigned Depth = 0) {</td>
    <td class="lineNumber">601</td>
    <td class="codeline">                         unsigned Depth = 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeline">    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};</td>
    <td class="lineNumber">602</td>
    <td class="codeline">    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeline">    return getMulExpr(Ops, Flags, Depth);</td>
    <td class="lineNumber">603</td>
    <td class="codeline">    return getMulExpr(Ops, Flags, Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">604</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeline">  const SCEV *getMulExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,</td>
    <td class="lineNumber">605</td>
    <td class="codeline">  const SCEV *getMulExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeline">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">606</td>
    <td class="codeline">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeline">                         unsigned Depth = 0) {</td>
    <td class="lineNumber">607</td>
    <td class="codeline">                         unsigned Depth = 0) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeline">    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};</td>
    <td class="lineNumber">608</td>
    <td class="codeline">    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeline">    return getMulExpr(Ops, Flags, Depth);</td>
    <td class="lineNumber">609</td>
    <td class="codeline">    return getMulExpr(Ops, Flags, Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">610</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeline">  const SCEV *getUDivExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">611</td>
    <td class="codeline">  const SCEV *getUDivExpr(const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeline">  const SCEV *getUDivExactExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">612</td>
    <td class="codeline">  const SCEV *getUDivExactExpr(const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeline">  const SCEV *getURemExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">613</td>
    <td class="codeline">  const SCEV *getURemExpr(const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeline">  const SCEV *getAddRecExpr(const SCEV *Start, const SCEV *Step, const Loop *L,</td>
    <td class="lineNumber">614</td>
    <td class="codeline">  const SCEV *getAddRecExpr(const SCEV *Start, const SCEV *Step, const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeline">                            SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">615</td>
    <td class="codeline">                            SCEV::NoWrapFlags Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeline">  const SCEV *getAddRecExpr(SmallVectorImpl<const SCEV *> &Operands,</td>
    <td class="lineNumber">616</td>
    <td class="codeline">  const SCEV *getAddRecExpr(SmallVectorImpl<const SCEV *> &Operands,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeline">                            const Loop *L, SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">617</td>
    <td class="codeline">                            const Loop *L, SCEV::NoWrapFlags Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeline">  const SCEV *getAddRecExpr(const SmallVectorImpl<const SCEV *> &Operands,</td>
    <td class="lineNumber">618</td>
    <td class="codeline">  const SCEV *getAddRecExpr(const SmallVectorImpl<const SCEV *> &Operands,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeline">                            const Loop *L, SCEV::NoWrapFlags Flags) {</td>
    <td class="lineNumber">619</td>
    <td class="codeline">                            const Loop *L, SCEV::NoWrapFlags Flags) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeline">    SmallVector<const SCEV *, 4> NewOp(Operands.begin(), Operands.end());</td>
    <td class="lineNumber">620</td>
    <td class="codeline">    SmallVector<const SCEV *, 4> NewOp(Operands.begin(), Operands.end());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeline">    return getAddRecExpr(NewOp, L, Flags);</td>
    <td class="lineNumber">621</td>
    <td class="codeline">    return getAddRecExpr(NewOp, L, Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">622</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeline"></td>
    <td class="lineNumber">623</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeline">  /// Checks if \p SymbolicPHI can be rewritten as an AddRecExpr under some</td>
    <td class="lineNumber">624</td>
    <td class="codeline">  /// Checks if \p SymbolicPHI can be rewritten as an AddRecExpr under some</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeline">  /// Predicates. If successful return these <AddRecExpr, Predicates>;</td>
    <td class="lineNumber">625</td>
    <td class="codeline">  /// Predicates. If successful return these <AddRecExpr, Predicates>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeline">  /// The function is intended to be called from PSCEV (the caller will decide</td>
    <td class="lineNumber">626</td>
    <td class="codeline">  /// The function is intended to be called from PSCEV (the caller will decide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeline">  /// whether to actually add the predicates and carry out the rewrites).</td>
    <td class="lineNumber">627</td>
    <td class="codeline">  /// whether to actually add the predicates and carry out the rewrites).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeline">  std::optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
    <td class="lineNumber">628</td>
    <td class="codeline">  std::optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeline">  createAddRecFromPHIWithCasts(const SCEVUnknown *SymbolicPHI);</td>
    <td class="lineNumber">629</td>
    <td class="codeline">  createAddRecFromPHIWithCasts(const SCEVUnknown *SymbolicPHI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
    <td class="lineNumber">630</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeline">  /// Returns an expression for a GEP</td>
    <td class="lineNumber">631</td>
    <td class="codeline">  /// Returns an expression for a GEP</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">632</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeline">  /// \p GEP The GEP. The indices contained in the GEP itself are ignored,</td>
    <td class="lineNumber">633</td>
    <td class="codeline">  /// \p GEP The GEP. The indices contained in the GEP itself are ignored,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeline">  /// instead we use IndexExprs.</td>
    <td class="lineNumber">634</td>
    <td class="codeline">  /// instead we use IndexExprs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeline">  /// \p IndexExprs The expressions for the indices.</td>
    <td class="lineNumber">635</td>
    <td class="codeline">  /// \p IndexExprs The expressions for the indices.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeline">  const SCEV *getGEPExpr(GEPOperator *GEP,</td>
    <td class="lineNumber">636</td>
    <td class="codeline">  const SCEV *getGEPExpr(GEPOperator *GEP,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeline">                         const SmallVectorImpl<const SCEV *> &IndexExprs);</td>
    <td class="lineNumber">637</td>
    <td class="codeline">                         const SmallVectorImpl<const SCEV *> &IndexExprs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeline">  const SCEV *getAbsExpr(const SCEV *Op, bool IsNSW);</td>
    <td class="lineNumber">638</td>
    <td class="codeline">  const SCEV *getAbsExpr(const SCEV *Op, bool IsNSW);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeline">  const SCEV *getMinMaxExpr(SCEVTypes Kind,</td>
    <td class="lineNumber">639</td>
    <td class="codeline">  const SCEV *getMinMaxExpr(SCEVTypes Kind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeline">                            SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">640</td>
    <td class="codeline">                            SmallVectorImpl<const SCEV *> &Operands);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeline">  const SCEV *getSequentialMinMaxExpr(SCEVTypes Kind,</td>
    <td class="lineNumber">641</td>
    <td class="codeline">  const SCEV *getSequentialMinMaxExpr(SCEVTypes Kind,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeline">                                      SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">642</td>
    <td class="codeline">                                      SmallVectorImpl<const SCEV *> &Operands);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeline">  const SCEV *getSMaxExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">643</td>
    <td class="codeline">  const SCEV *getSMaxExpr(const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeline">  const SCEV *getSMaxExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">644</td>
    <td class="codeline">  const SCEV *getSMaxExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeline">  const SCEV *getUMaxExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">645</td>
    <td class="codeline">  const SCEV *getUMaxExpr(const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeline">  const SCEV *getUMaxExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">646</td>
    <td class="codeline">  const SCEV *getUMaxExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeline">  const SCEV *getSMinExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">647</td>
    <td class="codeline">  const SCEV *getSMinExpr(const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeline">  const SCEV *getSMinExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">648</td>
    <td class="codeline">  const SCEV *getSMinExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeline">  const SCEV *getUMinExpr(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">649</td>
    <td class="codeline">  const SCEV *getUMinExpr(const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeline">                          bool Sequential = false);</td>
    <td class="lineNumber">650</td>
    <td class="codeline">                          bool Sequential = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeline">  const SCEV *getUMinExpr(SmallVectorImpl<const SCEV *> &Operands,</td>
    <td class="lineNumber">651</td>
    <td class="codeline">  const SCEV *getUMinExpr(SmallVectorImpl<const SCEV *> &Operands,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeline">                          bool Sequential = false);</td>
    <td class="lineNumber">652</td>
    <td class="codeline">                          bool Sequential = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeline">  const SCEV *getUnknown(Value *V);</td>
    <td class="lineNumber">653</td>
    <td class="codeline">  const SCEV *getUnknown(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeline">  const SCEV *getCouldNotCompute();</td>
    <td class="lineNumber">654</td>
    <td class="codeline">  const SCEV *getCouldNotCompute();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeline"></td>
    <td class="lineNumber">655</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeline">  /// Return a SCEV for the constant 0 of a specific type.</td>
    <td class="lineNumber">656</td>
    <td class="codeline">  /// Return a SCEV for the constant 0 of a specific type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeline">  const SCEV *getZero(Type *Ty) { return getConstant(Ty, 0); }</td>
    <td class="lineNumber">657</td>
    <td class="codeline">  const SCEV *getZero(Type *Ty) { return getConstant(Ty, 0); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeline"></td>
    <td class="lineNumber">658</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeline">  /// Return a SCEV for the constant 1 of a specific type.</td>
    <td class="lineNumber">659</td>
    <td class="codeline">  /// Return a SCEV for the constant 1 of a specific type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeline">  const SCEV *getOne(Type *Ty) { return getConstant(Ty, 1); }</td>
    <td class="lineNumber">660</td>
    <td class="codeline">  const SCEV *getOne(Type *Ty) { return getConstant(Ty, 1); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeline"></td>
    <td class="lineNumber">661</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeline">  /// Return a SCEV for the constant \p Power of two.</td>
    <td class="lineNumber">662</td>
    <td class="codeline">  /// Return a SCEV for the constant \p Power of two.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeline">  const SCEV *getPowerOfTwo(Type *Ty, unsigned Power) {</td>
    <td class="lineNumber">663</td>
    <td class="codeline">  const SCEV *getPowerOfTwo(Type *Ty, unsigned Power) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeline">    assert(Power < getTypeSizeInBits(Ty) && "Power out of range");</td>
    <td class="lineNumber">664</td>
    <td class="codeline">    assert(Power < getTypeSizeInBits(Ty) && "Power out of range");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeline">    return getConstant(APInt::getOneBitSet(getTypeSizeInBits(Ty), Power));</td>
    <td class="lineNumber">665</td>
    <td class="codeline">    return getConstant(APInt::getOneBitSet(getTypeSizeInBits(Ty), Power));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">666</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeline"></td>
    <td class="lineNumber">667</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeline">  /// Return a SCEV for the constant -1 of a specific type.</td>
    <td class="lineNumber">668</td>
    <td class="codeline">  /// Return a SCEV for the constant -1 of a specific type.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeline">  const SCEV *getMinusOne(Type *Ty) {</td>
    <td class="lineNumber">669</td>
    <td class="codeline">  const SCEV *getMinusOne(Type *Ty) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeline">    return getConstant(Ty, -1, /*isSigned=*/true);</td>
    <td class="lineNumber">670</td>
    <td class="codeline">    return getConstant(Ty, -1, /*isSigned=*/true);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">671</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
    <td class="lineNumber">672</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeline">  /// Return an expression for a TypeSize.</td>
    <td class="lineNumber">673</td>
    <td class="codeline">  /// Return an expression for a TypeSize.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeline">  const SCEV *getSizeOfExpr(Type *IntTy, TypeSize Size);</td>
    <td class="lineNumber">674</td>
    <td class="codeline">  const SCEV *getSizeOfExpr(Type *IntTy, TypeSize Size);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
    <td class="lineNumber">675</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeline">  /// Return an expression for the alloc size of AllocTy that is type IntTy</td>
    <td class="lineNumber">676</td>
    <td class="codeline">  /// Return an expression for the alloc size of AllocTy that is type IntTy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeline">  const SCEV *getSizeOfExpr(Type *IntTy, Type *AllocTy);</td>
    <td class="lineNumber">677</td>
    <td class="codeline">  const SCEV *getSizeOfExpr(Type *IntTy, Type *AllocTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeline"></td>
    <td class="lineNumber">678</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeline">  /// Return an expression for the store size of StoreTy that is type IntTy</td>
    <td class="lineNumber">679</td>
    <td class="codeline">  /// Return an expression for the store size of StoreTy that is type IntTy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeline">  const SCEV *getStoreSizeOfExpr(Type *IntTy, Type *StoreTy);</td>
    <td class="lineNumber">680</td>
    <td class="codeline">  const SCEV *getStoreSizeOfExpr(Type *IntTy, Type *StoreTy);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeline"></td>
    <td class="lineNumber">681</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeline">  /// Return an expression for offsetof on the given field with type IntTy</td>
    <td class="lineNumber">682</td>
    <td class="codeline">  /// Return an expression for offsetof on the given field with type IntTy</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeline">  const SCEV *getOffsetOfExpr(Type *IntTy, StructType *STy, unsigned FieldNo);</td>
    <td class="lineNumber">683</td>
    <td class="codeline">  const SCEV *getOffsetOfExpr(Type *IntTy, StructType *STy, unsigned FieldNo);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeline"></td>
    <td class="lineNumber">684</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeline">  /// Return the SCEV object corresponding to -V.</td>
    <td class="lineNumber">685</td>
    <td class="codeline">  /// Return the SCEV object corresponding to -V.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeline">  const SCEV *getNegativeSCEV(const SCEV *V,</td>
    <td class="lineNumber">686</td>
    <td class="codeline">  const SCEV *getNegativeSCEV(const SCEV *V,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeline">                              SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap);</td>
    <td class="lineNumber">687</td>
    <td class="codeline">                              SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeline"></td>
    <td class="lineNumber">688</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeline">  /// Return the SCEV object corresponding to ~V.</td>
    <td class="lineNumber">689</td>
    <td class="codeline">  /// Return the SCEV object corresponding to ~V.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeline">  const SCEV *getNotSCEV(const SCEV *V);</td>
    <td class="lineNumber">690</td>
    <td class="codeline">  const SCEV *getNotSCEV(const SCEV *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
    <td class="lineNumber">691</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeline">  /// Return LHS-RHS.  Minus is represented in SCEV as A+B*-1.</td>
    <td class="lineNumber">692</td>
    <td class="codeline">  /// Return LHS-RHS.  Minus is represented in SCEV as A+B*-1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">693</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeline">  /// If the LHS and RHS are pointers which don't share a common base</td>
    <td class="lineNumber">694</td>
    <td class="codeline">  /// If the LHS and RHS are pointers which don't share a common base</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeline">  /// (according to getPointerBase()), this returns a SCEVCouldNotCompute.</td>
    <td class="lineNumber">695</td>
    <td class="codeline">  /// (according to getPointerBase()), this returns a SCEVCouldNotCompute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeline">  /// To compute the difference between two unrelated pointers, you can</td>
    <td class="lineNumber">696</td>
    <td class="codeline">  /// To compute the difference between two unrelated pointers, you can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeline">  /// explicitly convert the arguments using getPtrToIntExpr(), for pointer</td>
    <td class="lineNumber">697</td>
    <td class="codeline">  /// explicitly convert the arguments using getPtrToIntExpr(), for pointer</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeline">  /// types that support it.</td>
    <td class="lineNumber">698</td>
    <td class="codeline">  /// types that support it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeline">  const SCEV *getMinusSCEV(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">699</td>
    <td class="codeline">  const SCEV *getMinusSCEV(const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeline">                           SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">700</td>
    <td class="codeline">                           SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeline">                           unsigned Depth = 0);</td>
    <td class="lineNumber">701</td>
    <td class="codeline">                           unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeline"></td>
    <td class="lineNumber">702</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeline">  /// Compute ceil(N / D). N and D are treated as unsigned values.</td>
    <td class="lineNumber">703</td>
    <td class="codeline">  /// Compute ceil(N / D). N and D are treated as unsigned values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">704</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeline">  /// Since SCEV doesn't have native ceiling division, this generates a</td>
    <td class="lineNumber">705</td>
    <td class="codeline">  /// Since SCEV doesn't have native ceiling division, this generates a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeline">  /// SCEV expression of the following form:</td>
    <td class="lineNumber">706</td>
    <td class="codeline">  /// SCEV expression of the following form:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">707</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeline">  /// umin(N, 1) + floor((N - umin(N, 1)) / D)</td>
    <td class="lineNumber">708</td>
    <td class="codeline">  /// umin(N, 1) + floor((N - umin(N, 1)) / D)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">709</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeline">  /// A denominator of zero or poison is handled the same way as getUDivExpr().</td>
    <td class="lineNumber">710</td>
    <td class="codeline">  /// A denominator of zero or poison is handled the same way as getUDivExpr().</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeline">  const SCEV *getUDivCeilSCEV(const SCEV *N, const SCEV *D);</td>
    <td class="lineNumber">711</td>
    <td class="codeline">  const SCEV *getUDivCeilSCEV(const SCEV *N, const SCEV *D);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
    <td class="lineNumber">712</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeline">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">713</td>
    <td class="codeline">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeline">  /// specified type.  If the type must be extended, it is zero extended.</td>
    <td class="lineNumber">714</td>
    <td class="codeline">  /// specified type.  If the type must be extended, it is zero extended.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeline">  const SCEV *getTruncateOrZeroExtend(const SCEV *V, Type *Ty,</td>
    <td class="lineNumber">715</td>
    <td class="codeline">  const SCEV *getTruncateOrZeroExtend(const SCEV *V, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeline">                                      unsigned Depth = 0);</td>
    <td class="lineNumber">716</td>
    <td class="codeline">                                      unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeline"></td>
    <td class="lineNumber">717</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeline">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">718</td>
    <td class="codeline">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeline">  /// specified type.  If the type must be extended, it is sign extended.</td>
    <td class="lineNumber">719</td>
    <td class="codeline">  /// specified type.  If the type must be extended, it is sign extended.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeline">  const SCEV *getTruncateOrSignExtend(const SCEV *V, Type *Ty,</td>
    <td class="lineNumber">720</td>
    <td class="codeline">  const SCEV *getTruncateOrSignExtend(const SCEV *V, Type *Ty,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeline">                                      unsigned Depth = 0);</td>
    <td class="lineNumber">721</td>
    <td class="codeline">                                      unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeline"></td>
    <td class="lineNumber">722</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeline">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">723</td>
    <td class="codeline">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeline">  /// specified type.  If the type must be extended, it is zero extended.  The</td>
    <td class="lineNumber">724</td>
    <td class="codeline">  /// specified type.  If the type must be extended, it is zero extended.  The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeline">  /// conversion must not be narrowing.</td>
    <td class="lineNumber">725</td>
    <td class="codeline">  /// conversion must not be narrowing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeline">  const SCEV *getNoopOrZeroExtend(const SCEV *V, Type *Ty);</td>
    <td class="lineNumber">726</td>
    <td class="codeline">  const SCEV *getNoopOrZeroExtend(const SCEV *V, Type *Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeline"></td>
    <td class="lineNumber">727</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeline">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">728</td>
    <td class="codeline">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeline">  /// specified type.  If the type must be extended, it is sign extended.  The</td>
    <td class="lineNumber">729</td>
    <td class="codeline">  /// specified type.  If the type must be extended, it is sign extended.  The</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeline">  /// conversion must not be narrowing.</td>
    <td class="lineNumber">730</td>
    <td class="codeline">  /// conversion must not be narrowing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeline">  const SCEV *getNoopOrSignExtend(const SCEV *V, Type *Ty);</td>
    <td class="lineNumber">731</td>
    <td class="codeline">  const SCEV *getNoopOrSignExtend(const SCEV *V, Type *Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeline"></td>
    <td class="lineNumber">732</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeline">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">733</td>
    <td class="codeline">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeline">  /// specified type. If the type must be extended, it is extended with</td>
    <td class="lineNumber">734</td>
    <td class="codeline">  /// specified type. If the type must be extended, it is extended with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeline">  /// unspecified bits. The conversion must not be narrowing.</td>
    <td class="lineNumber">735</td>
    <td class="codeline">  /// unspecified bits. The conversion must not be narrowing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeline">  const SCEV *getNoopOrAnyExtend(const SCEV *V, Type *Ty);</td>
    <td class="lineNumber">736</td>
    <td class="codeline">  const SCEV *getNoopOrAnyExtend(const SCEV *V, Type *Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
    <td class="lineNumber">737</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeline">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">738</td>
    <td class="codeline">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeline">  /// specified type.  The conversion must not be widening.</td>
    <td class="lineNumber">739</td>
    <td class="codeline">  /// specified type.  The conversion must not be widening.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeline">  const SCEV *getTruncateOrNoop(const SCEV *V, Type *Ty);</td>
    <td class="lineNumber">740</td>
    <td class="codeline">  const SCEV *getTruncateOrNoop(const SCEV *V, Type *Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeline"></td>
    <td class="lineNumber">741</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeline">  /// Promote the operands to the wider of the types using zero-extension, and</td>
    <td class="lineNumber">742</td>
    <td class="codeline">  /// Promote the operands to the wider of the types using zero-extension, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeline">  /// then perform a umax operation with them.</td>
    <td class="lineNumber">743</td>
    <td class="codeline">  /// then perform a umax operation with them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeline">  const SCEV *getUMaxFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">744</td>
    <td class="codeline">  const SCEV *getUMaxFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeline"></td>
    <td class="lineNumber">745</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeline">  /// Promote the operands to the wider of the types using zero-extension, and</td>
    <td class="lineNumber">746</td>
    <td class="codeline">  /// Promote the operands to the wider of the types using zero-extension, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeline">  /// then perform a umin operation with them.</td>
    <td class="lineNumber">747</td>
    <td class="codeline">  /// then perform a umin operation with them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeline">  const SCEV *getUMinFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">748</td>
    <td class="codeline">  const SCEV *getUMinFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeline">                                         bool Sequential = false);</td>
    <td class="lineNumber">749</td>
    <td class="codeline">                                         bool Sequential = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeline"></td>
    <td class="lineNumber">750</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeline">  /// Promote the operands to the wider of the types using zero-extension, and</td>
    <td class="lineNumber">751</td>
    <td class="codeline">  /// Promote the operands to the wider of the types using zero-extension, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeline">  /// then perform a umin operation with them. N-ary function.</td>
    <td class="lineNumber">752</td>
    <td class="codeline">  /// then perform a umin operation with them. N-ary function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeline">  const SCEV *getUMinFromMismatchedTypes(SmallVectorImpl<const SCEV *> &Ops,</td>
    <td class="lineNumber">753</td>
    <td class="codeline">  const SCEV *getUMinFromMismatchedTypes(SmallVectorImpl<const SCEV *> &Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeline">                                         bool Sequential = false);</td>
    <td class="lineNumber">754</td>
    <td class="codeline">                                         bool Sequential = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeline"></td>
    <td class="lineNumber">755</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeline">  /// Transitively follow the chain of pointer-type operands until reaching a</td>
    <td class="lineNumber">756</td>
    <td class="codeline">  /// Transitively follow the chain of pointer-type operands until reaching a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeline">  /// SCEV that does not have a single pointer operand. This returns a</td>
    <td class="lineNumber">757</td>
    <td class="codeline">  /// SCEV that does not have a single pointer operand. This returns a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeline">  /// SCEVUnknown pointer for well-formed pointer-type expressions, but corner</td>
    <td class="lineNumber">758</td>
    <td class="codeline">  /// SCEVUnknown pointer for well-formed pointer-type expressions, but corner</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeline">  /// cases do exist.</td>
    <td class="lineNumber">759</td>
    <td class="codeline">  /// cases do exist.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeline">  const SCEV *getPointerBase(const SCEV *V);</td>
    <td class="lineNumber">760</td>
    <td class="codeline">  const SCEV *getPointerBase(const SCEV *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeline"></td>
    <td class="lineNumber">761</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeline">  /// Compute an expression equivalent to S - getPointerBase(S).</td>
    <td class="lineNumber">762</td>
    <td class="codeline">  /// Compute an expression equivalent to S - getPointerBase(S).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeline">  const SCEV *removePointerBase(const SCEV *S);</td>
    <td class="lineNumber">763</td>
    <td class="codeline">  const SCEV *removePointerBase(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeline"></td>
    <td class="lineNumber">764</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeline">  /// Return a SCEV expression for the specified value at the specified scope</td>
    <td class="lineNumber">765</td>
    <td class="codeline">  /// Return a SCEV expression for the specified value at the specified scope</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeline">  /// in the program.  The L value specifies a loop nest to evaluate the</td>
    <td class="lineNumber">766</td>
    <td class="codeline">  /// in the program.  The L value specifies a loop nest to evaluate the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeline">  /// expression at, where null is the top-level or a specified loop is</td>
    <td class="lineNumber">767</td>
    <td class="codeline">  /// expression at, where null is the top-level or a specified loop is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeline">  /// immediately inside of the loop.</td>
    <td class="lineNumber">768</td>
    <td class="codeline">  /// immediately inside of the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">769</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeline">  /// This method can be used to compute the exit value for a variable defined</td>
    <td class="lineNumber">770</td>
    <td class="codeline">  /// This method can be used to compute the exit value for a variable defined</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeline">  /// in a loop by querying what the value will hold in the parent loop.</td>
    <td class="lineNumber">771</td>
    <td class="codeline">  /// in a loop by querying what the value will hold in the parent loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">772</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeline">  /// In the case that a relevant loop exit value cannot be computed, the</td>
    <td class="lineNumber">773</td>
    <td class="codeline">  /// In the case that a relevant loop exit value cannot be computed, the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeline">  /// original value V is returned.</td>
    <td class="lineNumber">774</td>
    <td class="codeline">  /// original value V is returned.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeline">  const SCEV *getSCEVAtScope(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">775</td>
    <td class="codeline">  const SCEV *getSCEVAtScope(const SCEV *S, const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeline"></td>
    <td class="lineNumber">776</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeline">  /// This is a convenience function which does getSCEVAtScope(getSCEV(V), L).</td>
    <td class="lineNumber">777</td>
    <td class="codeline">  /// This is a convenience function which does getSCEVAtScope(getSCEV(V), L).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeline">  const SCEV *getSCEVAtScope(Value *V, const Loop *L);</td>
    <td class="lineNumber">778</td>
    <td class="codeline">  const SCEV *getSCEVAtScope(Value *V, const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeline"></td>
    <td class="lineNumber">779</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeline">  /// Test whether entry to the loop is protected by a conditional between LHS</td>
    <td class="lineNumber">780</td>
    <td class="codeline">  /// Test whether entry to the loop is protected by a conditional between LHS</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeline">  /// and RHS.  This is used to help avoid max expressions in loop trip</td>
    <td class="lineNumber">781</td>
    <td class="codeline">  /// and RHS.  This is used to help avoid max expressions in loop trip</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeline">  /// counts, and to eliminate casts.</td>
    <td class="lineNumber">782</td>
    <td class="codeline">  /// counts, and to eliminate casts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeline">  bool isLoopEntryGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">783</td>
    <td class="codeline">  bool isLoopEntryGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeline">                                const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">784</td>
    <td class="codeline">                                const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeline"></td>
    <td class="lineNumber">785</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeline">  /// Test whether entry to the basic block is protected by a conditional</td>
    <td class="lineNumber">786</td>
    <td class="codeline">  /// Test whether entry to the basic block is protected by a conditional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeline">  /// between LHS and RHS.</td>
    <td class="lineNumber">787</td>
    <td class="codeline">  /// between LHS and RHS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeline">  bool isBasicBlockEntryGuardedByCond(const BasicBlock *BB,</td>
    <td class="lineNumber">788</td>
    <td class="codeline">  bool isBasicBlockEntryGuardedByCond(const BasicBlock *BB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeline">                                      ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">789</td>
    <td class="codeline">                                      ICmpInst::Predicate Pred, const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeline">                                      const SCEV *RHS);</td>
    <td class="lineNumber">790</td>
    <td class="codeline">                                      const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
    <td class="lineNumber">791</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeline">  /// Test whether the backedge of the loop is protected by a conditional</td>
    <td class="lineNumber">792</td>
    <td class="codeline">  /// Test whether the backedge of the loop is protected by a conditional</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeline">  /// between LHS and RHS.  This is used to eliminate casts.</td>
    <td class="lineNumber">793</td>
    <td class="codeline">  /// between LHS and RHS.  This is used to eliminate casts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeline">  bool isLoopBackedgeGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">794</td>
    <td class="codeline">  bool isLoopBackedgeGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeline">                                   const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">795</td>
    <td class="codeline">                                   const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
    <td class="lineNumber">796</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeline">  /// A version of getTripCountFromExitCount below which always picks an</td>
    <td class="lineNumber">797</td>
    <td class="codeline">  /// A version of getTripCountFromExitCount below which always picks an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeline">  /// evaluation type which can not result in overflow.</td>
    <td class="lineNumber">798</td>
    <td class="codeline">  /// evaluation type which can not result in overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeline">  const SCEV *getTripCountFromExitCount(const SCEV *ExitCount);</td>
    <td class="lineNumber">799</td>
    <td class="codeline">  const SCEV *getTripCountFromExitCount(const SCEV *ExitCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeline"></td>
    <td class="lineNumber">800</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeline">  /// Convert from an "exit count" (i.e. "backedge taken count") to a "trip</td>
    <td class="lineNumber">801</td>
    <td class="codeline">  /// Convert from an "exit count" (i.e. "backedge taken count") to a "trip</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeline">  /// count".  A "trip count" is the number of times the header of the loop</td>
    <td class="lineNumber">802</td>
    <td class="codeline">  /// count".  A "trip count" is the number of times the header of the loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeline">  /// will execute if an exit is taken after the specified number of backedges</td>
    <td class="lineNumber">803</td>
    <td class="codeline">  /// will execute if an exit is taken after the specified number of backedges</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeline">  /// have been taken.  (e.g. TripCount = ExitCount + 1).  Note that the</td>
    <td class="lineNumber">804</td>
    <td class="codeline">  /// have been taken.  (e.g. TripCount = ExitCount + 1).  Note that the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeline">  /// expression can overflow if ExitCount = UINT_MAX.  If EvalTy is not wide</td>
    <td class="lineNumber">805</td>
    <td class="codeline">  /// expression can overflow if ExitCount = UINT_MAX.  If EvalTy is not wide</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeline">  /// enough to hold the result without overflow, result unsigned wraps with</td>
    <td class="lineNumber">806</td>
    <td class="codeline">  /// enough to hold the result without overflow, result unsigned wraps with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeline">  /// 2s-complement semantics.  ex: EC = 255 (i8), TC = 0 (i8)</td>
    <td class="lineNumber">807</td>
    <td class="codeline">  /// 2s-complement semantics.  ex: EC = 255 (i8), TC = 0 (i8)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeline">  const SCEV *getTripCountFromExitCount(const SCEV *ExitCount, Type *EvalTy,</td>
    <td class="lineNumber">808</td>
    <td class="codeline">  const SCEV *getTripCountFromExitCount(const SCEV *ExitCount, Type *EvalTy,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeline">                                        const Loop *L);</td>
    <td class="lineNumber">809</td>
    <td class="codeline">                                        const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeline"></td>
    <td class="lineNumber">810</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeline">  /// Returns the exact trip count of the loop if we can compute it, and</td>
    <td class="lineNumber">811</td>
    <td class="codeline">  /// Returns the exact trip count of the loop if we can compute it, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeline">  /// the result is a small constant.  '0' is used to represent an unknown</td>
    <td class="lineNumber">812</td>
    <td class="codeline">  /// the result is a small constant.  '0' is used to represent an unknown</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeline">  /// or non-constant trip count.  Note that a trip count is simply one more</td>
    <td class="lineNumber">813</td>
    <td class="codeline">  /// or non-constant trip count.  Note that a trip count is simply one more</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeline">  /// than the backedge taken count for the loop.</td>
    <td class="lineNumber">814</td>
    <td class="codeline">  /// than the backedge taken count for the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeline">  unsigned getSmallConstantTripCount(const Loop *L);</td>
    <td class="lineNumber">815</td>
    <td class="codeline">  unsigned getSmallConstantTripCount(const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeline"></td>
    <td class="lineNumber">816</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeline">  /// Return the exact trip count for this loop if we exit through ExitingBlock.</td>
    <td class="lineNumber">817</td>
    <td class="codeline">  /// Return the exact trip count for this loop if we exit through ExitingBlock.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeline">  /// '0' is used to represent an unknown or non-constant trip count.  Note</td>
    <td class="lineNumber">818</td>
    <td class="codeline">  /// '0' is used to represent an unknown or non-constant trip count.  Note</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeline">  /// that a trip count is simply one more than the backedge taken count for</td>
    <td class="lineNumber">819</td>
    <td class="codeline">  /// that a trip count is simply one more than the backedge taken count for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeline">  /// the same exit.</td>
    <td class="lineNumber">820</td>
    <td class="codeline">  /// the same exit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeline">  /// This "trip count" assumes that control exits via ExitingBlock. More</td>
    <td class="lineNumber">821</td>
    <td class="codeline">  /// This "trip count" assumes that control exits via ExitingBlock. More</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeline">  /// precisely, it is the number of times that control will reach ExitingBlock</td>
    <td class="lineNumber">822</td>
    <td class="codeline">  /// precisely, it is the number of times that control will reach ExitingBlock</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeline">  /// before taking the branch. For loops with multiple exits, it may not be</td>
    <td class="lineNumber">823</td>
    <td class="codeline">  /// before taking the branch. For loops with multiple exits, it may not be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeline">  /// the number times that the loop header executes if the loop exits</td>
    <td class="lineNumber">824</td>
    <td class="codeline">  /// the number times that the loop header executes if the loop exits</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeline">  /// prematurely via another branch.</td>
    <td class="lineNumber">825</td>
    <td class="codeline">  /// prematurely via another branch.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeline">  unsigned getSmallConstantTripCount(const Loop *L,</td>
    <td class="lineNumber">826</td>
    <td class="codeline">  unsigned getSmallConstantTripCount(const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeline">                                     const BasicBlock *ExitingBlock);</td>
    <td class="lineNumber">827</td>
    <td class="codeline">                                     const BasicBlock *ExitingBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeline"></td>
    <td class="lineNumber">828</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeline">  /// Returns the upper bound of the loop trip count as a normal unsigned</td>
    <td class="lineNumber">829</td>
    <td class="codeline">  /// Returns the upper bound of the loop trip count as a normal unsigned</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeline">  /// value.</td>
    <td class="lineNumber">830</td>
    <td class="codeline">  /// value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeline">  /// Returns 0 if the trip count is unknown or not constant.</td>
    <td class="lineNumber">831</td>
    <td class="codeline">  /// Returns 0 if the trip count is unknown or not constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeline">  unsigned getSmallConstantMaxTripCount(const Loop *L);</td>
    <td class="lineNumber">832</td>
    <td class="codeline">  unsigned getSmallConstantMaxTripCount(const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
    <td class="lineNumber">833</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeline">  /// Returns the largest constant divisor of the trip count as a normal</td>
    <td class="lineNumber">834</td>
    <td class="codeline">  /// Returns the largest constant divisor of the trip count as a normal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeline">  /// unsigned value, if possible. This means that the actual trip count is</td>
    <td class="lineNumber">835</td>
    <td class="codeline">  /// unsigned value, if possible. This means that the actual trip count is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeline">  /// always a multiple of the returned value. Returns 1 if the trip count is</td>
    <td class="lineNumber">836</td>
    <td class="codeline">  /// always a multiple of the returned value. Returns 1 if the trip count is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeline">  /// unknown or not guaranteed to be the multiple of a constant., Will also</td>
    <td class="lineNumber">837</td>
    <td class="codeline">  /// unknown or not guaranteed to be the multiple of a constant., Will also</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeline">  /// return 1 if the trip count is very large (>= 2^32).</td>
    <td class="lineNumber">838</td>
    <td class="codeline">  /// return 1 if the trip count is very large (>= 2^32).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeline">  /// Note that the argument is an exit count for loop L, NOT a trip count.</td>
    <td class="lineNumber">839</td>
    <td class="codeline">  /// Note that the argument is an exit count for loop L, NOT a trip count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeline">  unsigned getSmallConstantTripMultiple(const Loop *L,</td>
    <td class="lineNumber">840</td>
    <td class="codeline">  unsigned getSmallConstantTripMultiple(const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeline">                                        const SCEV *ExitCount);</td>
    <td class="lineNumber">841</td>
    <td class="codeline">                                        const SCEV *ExitCount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeline"></td>
    <td class="lineNumber">842</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeline">  /// Returns the largest constant divisor of the trip count of the</td>
    <td class="lineNumber">843</td>
    <td class="codeline">  /// Returns the largest constant divisor of the trip count of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeline">  /// loop.  Will return 1 if no trip count could be computed, or if a</td>
    <td class="lineNumber">844</td>
    <td class="codeline">  /// loop.  Will return 1 if no trip count could be computed, or if a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeline">  /// divisor could not be found.</td>
    <td class="lineNumber">845</td>
    <td class="codeline">  /// divisor could not be found.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeline">  unsigned getSmallConstantTripMultiple(const Loop *L);</td>
    <td class="lineNumber">846</td>
    <td class="codeline">  unsigned getSmallConstantTripMultiple(const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeline"></td>
    <td class="lineNumber">847</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeline">  /// Returns the largest constant divisor of the trip count of this loop as a</td>
    <td class="lineNumber">848</td>
    <td class="codeline">  /// Returns the largest constant divisor of the trip count of this loop as a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeline">  /// normal unsigned value, if possible. This means that the actual trip</td>
    <td class="lineNumber">849</td>
    <td class="codeline">  /// normal unsigned value, if possible. This means that the actual trip</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeline">  /// count is always a multiple of the returned value (don't forget the trip</td>
    <td class="lineNumber">850</td>
    <td class="codeline">  /// count is always a multiple of the returned value (don't forget the trip</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeline">  /// count could very well be zero as well!). As explained in the comments</td>
    <td class="lineNumber">851</td>
    <td class="codeline">  /// count could very well be zero as well!). As explained in the comments</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeline">  /// for getSmallConstantTripCount, this assumes that control exits the loop</td>
    <td class="lineNumber">852</td>
    <td class="codeline">  /// for getSmallConstantTripCount, this assumes that control exits the loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeline">  /// via ExitingBlock.</td>
    <td class="lineNumber">853</td>
    <td class="codeline">  /// via ExitingBlock.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeline">  unsigned getSmallConstantTripMultiple(const Loop *L,</td>
    <td class="lineNumber">854</td>
    <td class="codeline">  unsigned getSmallConstantTripMultiple(const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeline">                                        const BasicBlock *ExitingBlock);</td>
    <td class="lineNumber">855</td>
    <td class="codeline">                                        const BasicBlock *ExitingBlock);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeline"></td>
    <td class="lineNumber">856</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeline">  /// The terms "backedge taken count" and "exit count" are used</td>
    <td class="lineNumber">857</td>
    <td class="codeline">  /// The terms "backedge taken count" and "exit count" are used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeline">  /// interchangeably to refer to the number of times the backedge of a loop </td>
    <td class="lineNumber">858</td>
    <td class="codeline">  /// interchangeably to refer to the number of times the backedge of a loop </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeline">  /// has executed before the loop is exited.</td>
    <td class="lineNumber">859</td>
    <td class="codeline">  /// has executed before the loop is exited.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeline">  enum ExitCountKind {</td>
    <td class="lineNumber">860</td>
    <td class="codeline">  enum ExitCountKind {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeline">    /// An expression exactly describing the number of times the backedge has</td>
    <td class="lineNumber">861</td>
    <td class="codeline">    /// An expression exactly describing the number of times the backedge has</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeline">    /// executed when a loop is exited.</td>
    <td class="lineNumber">862</td>
    <td class="codeline">    /// executed when a loop is exited.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeline">    Exact,</td>
    <td class="lineNumber">863</td>
    <td class="codeline">    Exact,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeline">    /// A constant which provides an upper bound on the exact trip count.</td>
    <td class="lineNumber">864</td>
    <td class="codeline">    /// A constant which provides an upper bound on the exact trip count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeline">    ConstantMaximum,</td>
    <td class="lineNumber">865</td>
    <td class="codeline">    ConstantMaximum,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeline">    /// An expression which provides an upper bound on the exact trip count.</td>
    <td class="lineNumber">866</td>
    <td class="codeline">    /// An expression which provides an upper bound on the exact trip count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeline">    SymbolicMaximum,</td>
    <td class="lineNumber">867</td>
    <td class="codeline">    SymbolicMaximum,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">868</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeline"></td>
    <td class="lineNumber">869</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeline">  /// Return the number of times the backedge executes before the given exit</td>
    <td class="lineNumber">870</td>
    <td class="codeline">  /// Return the number of times the backedge executes before the given exit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeline">  /// would be taken; if not exactly computable, return SCEVCouldNotCompute. </td>
    <td class="lineNumber">871</td>
    <td class="codeline">  /// would be taken; if not exactly computable, return SCEVCouldNotCompute. </td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeline">  /// For a single exit loop, this value is equivelent to the result of</td>
    <td class="lineNumber">872</td>
    <td class="codeline">  /// For a single exit loop, this value is equivelent to the result of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeline">  /// getBackedgeTakenCount.  The loop is guaranteed to exit (via *some* exit)</td>
    <td class="lineNumber">873</td>
    <td class="codeline">  /// getBackedgeTakenCount.  The loop is guaranteed to exit (via *some* exit)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeline">  /// before the backedge is executed (ExitCount + 1) times.  Note that there</td>
    <td class="lineNumber">874</td>
    <td class="codeline">  /// before the backedge is executed (ExitCount + 1) times.  Note that there</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeline">  /// is no guarantee about *which* exit is taken on the exiting iteration.</td>
    <td class="lineNumber">875</td>
    <td class="codeline">  /// is no guarantee about *which* exit is taken on the exiting iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeline">  const SCEV *getExitCount(const Loop *L, const BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">876</td>
    <td class="codeline">  const SCEV *getExitCount(const Loop *L, const BasicBlock *ExitingBlock,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeline">                           ExitCountKind Kind = Exact);</td>
    <td class="lineNumber">877</td>
    <td class="codeline">                           ExitCountKind Kind = Exact);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeline"></td>
    <td class="lineNumber">878</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeline">  /// If the specified loop has a predictable backedge-taken count, return it,</td>
    <td class="lineNumber">879</td>
    <td class="codeline">  /// If the specified loop has a predictable backedge-taken count, return it,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeline">  /// otherwise return a SCEVCouldNotCompute object. The backedge-taken count is</td>
    <td class="lineNumber">880</td>
    <td class="codeline">  /// otherwise return a SCEVCouldNotCompute object. The backedge-taken count is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeline">  /// the number of times the loop header will be branched to from within the</td>
    <td class="lineNumber">881</td>
    <td class="codeline">  /// the number of times the loop header will be branched to from within the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeline">  /// loop, assuming there are no abnormal exists like exception throws. This is</td>
    <td class="lineNumber">882</td>
    <td class="codeline">  /// loop, assuming there are no abnormal exists like exception throws. This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeline">  /// one less than the trip count of the loop, since it doesn't count the first</td>
    <td class="lineNumber">883</td>
    <td class="codeline">  /// one less than the trip count of the loop, since it doesn't count the first</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeline">  /// iteration, when the header is branched to from outside the loop.</td>
    <td class="lineNumber">884</td>
    <td class="codeline">  /// iteration, when the header is branched to from outside the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">885</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeline">  /// Note that it is not valid to call this method on a loop without a</td>
    <td class="lineNumber">886</td>
    <td class="codeline">  /// Note that it is not valid to call this method on a loop without a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeline">  /// loop-invariant backedge-taken count (see</td>
    <td class="lineNumber">887</td>
    <td class="codeline">  /// loop-invariant backedge-taken count (see</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeline">  /// hasLoopInvariantBackedgeTakenCount).</td>
    <td class="lineNumber">888</td>
    <td class="codeline">  /// hasLoopInvariantBackedgeTakenCount).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeline">  const SCEV *getBackedgeTakenCount(const Loop *L, ExitCountKind Kind = Exact);</td>
    <td class="lineNumber">889</td>
    <td class="codeline">  const SCEV *getBackedgeTakenCount(const Loop *L, ExitCountKind Kind = Exact);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeline"></td>
    <td class="lineNumber">890</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeline">  /// Similar to getBackedgeTakenCount, except it will add a set of</td>
    <td class="lineNumber">891</td>
    <td class="codeline">  /// Similar to getBackedgeTakenCount, except it will add a set of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeline">  /// SCEV predicates to Predicates that are required to be true in order for</td>
    <td class="lineNumber">892</td>
    <td class="codeline">  /// SCEV predicates to Predicates that are required to be true in order for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeline">  /// the answer to be correct. Predicates can be checked with run-time</td>
    <td class="lineNumber">893</td>
    <td class="codeline">  /// the answer to be correct. Predicates can be checked with run-time</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeline">  /// checks and can be used to perform loop versioning.</td>
    <td class="lineNumber">894</td>
    <td class="codeline">  /// checks and can be used to perform loop versioning.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeline">  const SCEV *getPredicatedBackedgeTakenCount(const Loop *L,</td>
    <td class="lineNumber">895</td>
    <td class="codeline">  const SCEV *getPredicatedBackedgeTakenCount(const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeline">                                              SmallVector<const SCEVPredicate *, 4> &Predicates);</td>
    <td class="lineNumber">896</td>
    <td class="codeline">                                              SmallVector<const SCEVPredicate *, 4> &Predicates);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeline"></td>
    <td class="lineNumber">897</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeline">  /// When successful, this returns a SCEVConstant that is greater than or equal</td>
    <td class="lineNumber">898</td>
    <td class="codeline">  /// When successful, this returns a SCEVConstant that is greater than or equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeline">  /// to (i.e. a "conservative over-approximation") of the value returend by</td>
    <td class="lineNumber">899</td>
    <td class="codeline">  /// to (i.e. a "conservative over-approximation") of the value returend by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeline">  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the</td>
    <td class="lineNumber">900</td>
    <td class="codeline">  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeline">  /// SCEVCouldNotCompute object.</td>
    <td class="lineNumber">901</td>
    <td class="codeline">  /// SCEVCouldNotCompute object.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeline">  const SCEV *getConstantMaxBackedgeTakenCount(const Loop *L) {</td>
    <td class="lineNumber">902</td>
    <td class="codeline">  const SCEV *getConstantMaxBackedgeTakenCount(const Loop *L) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeline">    return getBackedgeTakenCount(L, ConstantMaximum);</td>
    <td class="lineNumber">903</td>
    <td class="codeline">    return getBackedgeTakenCount(L, ConstantMaximum);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">904</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeline"></td>
    <td class="lineNumber">905</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeline">  /// When successful, this returns a SCEV that is greater than or equal</td>
    <td class="lineNumber">906</td>
    <td class="codeline">  /// When successful, this returns a SCEV that is greater than or equal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeline">  /// to (i.e. a "conservative over-approximation") of the value returend by</td>
    <td class="lineNumber">907</td>
    <td class="codeline">  /// to (i.e. a "conservative over-approximation") of the value returend by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeline">  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the</td>
    <td class="lineNumber">908</td>
    <td class="codeline">  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeline">  /// SCEVCouldNotCompute object.</td>
    <td class="lineNumber">909</td>
    <td class="codeline">  /// SCEVCouldNotCompute object.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeline">  const SCEV *getSymbolicMaxBackedgeTakenCount(const Loop *L) {</td>
    <td class="lineNumber">910</td>
    <td class="codeline">  const SCEV *getSymbolicMaxBackedgeTakenCount(const Loop *L) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeline">    return getBackedgeTakenCount(L, SymbolicMaximum);</td>
    <td class="lineNumber">911</td>
    <td class="codeline">    return getBackedgeTakenCount(L, SymbolicMaximum);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">912</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeline"></td>
    <td class="lineNumber">913</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeline">  /// Return true if the backedge taken count is either the value returned by</td>
    <td class="lineNumber">914</td>
    <td class="codeline">  /// Return true if the backedge taken count is either the value returned by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeline">  /// getConstantMaxBackedgeTakenCount or zero.</td>
    <td class="lineNumber">915</td>
    <td class="codeline">  /// getConstantMaxBackedgeTakenCount or zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeline">  bool isBackedgeTakenCountMaxOrZero(const Loop *L);</td>
    <td class="lineNumber">916</td>
    <td class="codeline">  bool isBackedgeTakenCountMaxOrZero(const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeline"></td>
    <td class="lineNumber">917</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeline">  /// Return true if the specified loop has an analyzable loop-invariant</td>
    <td class="lineNumber">918</td>
    <td class="codeline">  /// Return true if the specified loop has an analyzable loop-invariant</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeline">  /// backedge-taken count.</td>
    <td class="lineNumber">919</td>
    <td class="codeline">  /// backedge-taken count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeline">  bool hasLoopInvariantBackedgeTakenCount(const Loop *L);</td>
    <td class="lineNumber">920</td>
    <td class="codeline">  bool hasLoopInvariantBackedgeTakenCount(const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeline"></td>
    <td class="lineNumber">921</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeline">  // This method should be called by the client when it made any change that</td>
    <td class="lineNumber">922</td>
    <td class="codeline">  // This method should be called by the client when it made any change that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeline">  // would invalidate SCEV's answers, and the client wants to remove all loop</td>
    <td class="lineNumber">923</td>
    <td class="codeline">  // would invalidate SCEV's answers, and the client wants to remove all loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeline">  // information held internally by ScalarEvolution. This is intended to be used</td>
    <td class="lineNumber">924</td>
    <td class="codeline">  // information held internally by ScalarEvolution. This is intended to be used</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeline">  // when the alternative to forget a loop is too expensive (i.e. large loop</td>
    <td class="lineNumber">925</td>
    <td class="codeline">  // when the alternative to forget a loop is too expensive (i.e. large loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeline">  // bodies).</td>
    <td class="lineNumber">926</td>
    <td class="codeline">  // bodies).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeline">  void forgetAllLoops();</td>
    <td class="lineNumber">927</td>
    <td class="codeline">  void forgetAllLoops();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeline"></td>
    <td class="lineNumber">928</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeline">  /// This method should be called by the client when it has changed a loop in</td>
    <td class="lineNumber">929</td>
    <td class="codeline">  /// This method should be called by the client when it has changed a loop in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeline">  /// a way that may effect ScalarEvolution's ability to compute a trip count,</td>
    <td class="lineNumber">930</td>
    <td class="codeline">  /// a way that may effect ScalarEvolution's ability to compute a trip count,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeline">  /// or if the loop is deleted.  This call is potentially expensive for large</td>
    <td class="lineNumber">931</td>
    <td class="codeline">  /// or if the loop is deleted.  This call is potentially expensive for large</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeline">  /// loop bodies.</td>
    <td class="lineNumber">932</td>
    <td class="codeline">  /// loop bodies.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeline">  void forgetLoop(const Loop *L);</td>
    <td class="lineNumber">933</td>
    <td class="codeline">  void forgetLoop(const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeline"></td>
    <td class="lineNumber">934</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeline">  // This method invokes forgetLoop for the outermost loop of the given loop</td>
    <td class="lineNumber">935</td>
    <td class="codeline">  // This method invokes forgetLoop for the outermost loop of the given loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeline">  // \p L, making ScalarEvolution forget about all this subtree. This needs to</td>
    <td class="lineNumber">936</td>
    <td class="codeline">  // \p L, making ScalarEvolution forget about all this subtree. This needs to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeline">  // be done whenever we make a transform that may affect the parameters of the</td>
    <td class="lineNumber">937</td>
    <td class="codeline">  // be done whenever we make a transform that may affect the parameters of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeline">  // outer loop, such as exit counts for branches.</td>
    <td class="lineNumber">938</td>
    <td class="codeline">  // outer loop, such as exit counts for branches.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeline">  void forgetTopmostLoop(const Loop *L);</td>
    <td class="lineNumber">939</td>
    <td class="codeline">  void forgetTopmostLoop(const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeline"></td>
    <td class="lineNumber">940</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeline">  /// This method should be called by the client when it has changed a value</td>
    <td class="lineNumber">941</td>
    <td class="codeline">  /// This method should be called by the client when it has changed a value</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeline">  /// in a way that may effect its value, or which may disconnect it from a</td>
    <td class="lineNumber">942</td>
    <td class="codeline">  /// in a way that may effect its value, or which may disconnect it from a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeline">  /// def-use chain linking it to a loop.</td>
    <td class="lineNumber">943</td>
    <td class="codeline">  /// def-use chain linking it to a loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeline">  void forgetValue(Value *V);</td>
    <td class="lineNumber">944</td>
    <td class="codeline">  void forgetValue(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeline"></td>
    <td class="lineNumber">945</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeline">  /// Called when the client has changed the disposition of values in</td>
    <td class="lineNumber">946</td>
    <td class="codeline">  /// Called when the client has changed the disposition of values in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeline">  /// this loop.</td>
    <td class="lineNumber">947</td>
    <td class="codeline">  /// this loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">948</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeline">  /// We don't have a way to invalidate per-loop dispositions. Clear and</td>
    <td class="lineNumber">949</td>
    <td class="codeline">  /// We don't have a way to invalidate per-loop dispositions. Clear and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeline">  /// recompute is simpler.</td>
    <td class="lineNumber">950</td>
    <td class="codeline">  /// recompute is simpler.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeline">  void forgetLoopDispositions();</td>
    <td class="lineNumber">951</td>
    <td class="codeline">  void forgetLoopDispositions();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeline"></td>
    <td class="lineNumber">952</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeline">  /// Called when the client has changed the disposition of values in</td>
    <td class="lineNumber">953</td>
    <td class="codeline">  /// Called when the client has changed the disposition of values in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeline">  /// a loop or block.</td>
    <td class="lineNumber">954</td>
    <td class="codeline">  /// a loop or block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">955</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeline">  /// We don't have a way to invalidate per-loop/per-block dispositions. Clear</td>
    <td class="lineNumber">956</td>
    <td class="codeline">  /// We don't have a way to invalidate per-loop/per-block dispositions. Clear</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeline">  /// and recompute is simpler.</td>
    <td class="lineNumber">957</td>
    <td class="codeline">  /// and recompute is simpler.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeline">  void forgetBlockAndLoopDispositions(Value *V = nullptr);</td>
    <td class="lineNumber">958</td>
    <td class="codeline">  void forgetBlockAndLoopDispositions(Value *V = nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeline"></td>
    <td class="lineNumber">959</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeline">  /// Determine the minimum number of zero bits that S is guaranteed to end in</td>
    <td class="lineNumber">960</td>
    <td class="codeline">  /// Determine the minimum number of zero bits that S is guaranteed to end in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeline">  /// (at every loop iteration).  It is, at the same time, the minimum number</td>
    <td class="lineNumber">961</td>
    <td class="codeline">  /// (at every loop iteration).  It is, at the same time, the minimum number</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeline">  /// of times S is divisible by 2.  For example, given {4,+,8} it returns 2.</td>
    <td class="lineNumber">962</td>
    <td class="codeline">  /// of times S is divisible by 2.  For example, given {4,+,8} it returns 2.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeline">  /// If S is guaranteed to be 0, it returns the bitwidth of S.</td>
    <td class="lineNumber">963</td>
    <td class="codeline">  /// If S is guaranteed to be 0, it returns the bitwidth of S.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeline">  uint32_t getMinTrailingZeros(const SCEV *S);</td>
    <td class="lineNumber">964</td>
    <td class="codeline">  uint32_t getMinTrailingZeros(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeline"></td>
    <td class="lineNumber">965</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeline">  /// Returns the max constant multiple of S.</td>
    <td class="lineNumber">966</td>
    <td class="codeline">  /// Returns the max constant multiple of S.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeline">  APInt getConstantMultiple(const SCEV *S);</td>
    <td class="lineNumber">967</td>
    <td class="codeline">  APInt getConstantMultiple(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeline"></td>
    <td class="lineNumber">968</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeline">  // Returns the max constant multiple of S. If S is exactly 0, return 1.</td>
    <td class="lineNumber">969</td>
    <td class="codeline">  // Returns the max constant multiple of S. If S is exactly 0, return 1.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeline">  APInt getNonZeroConstantMultiple(const SCEV *S);</td>
    <td class="lineNumber">970</td>
    <td class="codeline">  APInt getNonZeroConstantMultiple(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeline"></td>
    <td class="lineNumber">971</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeline">  /// Determine the unsigned range for a particular SCEV.</td>
    <td class="lineNumber">972</td>
    <td class="codeline">  /// Determine the unsigned range for a particular SCEV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeline">  /// NOTE: This returns a copy of the reference returned by getRangeRef.</td>
    <td class="lineNumber">973</td>
    <td class="codeline">  /// NOTE: This returns a copy of the reference returned by getRangeRef.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeline">  ConstantRange getUnsignedRange(const SCEV *S) {</td>
    <td class="lineNumber">974</td>
    <td class="codeline">  ConstantRange getUnsignedRange(const SCEV *S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeline">    return getRangeRef(S, HINT_RANGE_UNSIGNED);</td>
    <td class="lineNumber">975</td>
    <td class="codeline">    return getRangeRef(S, HINT_RANGE_UNSIGNED);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">976</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeline"></td>
    <td class="lineNumber">977</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeline">  /// Determine the min of the unsigned range for a particular SCEV.</td>
    <td class="lineNumber">978</td>
    <td class="codeline">  /// Determine the min of the unsigned range for a particular SCEV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeline">  APInt getUnsignedRangeMin(const SCEV *S) {</td>
    <td class="lineNumber">979</td>
    <td class="codeline">  APInt getUnsignedRangeMin(const SCEV *S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeline">    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMin();</td>
    <td class="lineNumber">980</td>
    <td class="codeline">    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">981</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeline"></td>
    <td class="lineNumber">982</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeline">  /// Determine the max of the unsigned range for a particular SCEV.</td>
    <td class="lineNumber">983</td>
    <td class="codeline">  /// Determine the max of the unsigned range for a particular SCEV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeline">  APInt getUnsignedRangeMax(const SCEV *S) {</td>
    <td class="lineNumber">984</td>
    <td class="codeline">  APInt getUnsignedRangeMax(const SCEV *S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeline">    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMax();</td>
    <td class="lineNumber">985</td>
    <td class="codeline">    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMax();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">986</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeline"></td>
    <td class="lineNumber">987</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeline">  /// Determine the signed range for a particular SCEV.</td>
    <td class="lineNumber">988</td>
    <td class="codeline">  /// Determine the signed range for a particular SCEV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeline">  /// NOTE: This returns a copy of the reference returned by getRangeRef.</td>
    <td class="lineNumber">989</td>
    <td class="codeline">  /// NOTE: This returns a copy of the reference returned by getRangeRef.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeline">  ConstantRange getSignedRange(const SCEV *S) {</td>
    <td class="lineNumber">990</td>
    <td class="codeline">  ConstantRange getSignedRange(const SCEV *S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeline">    return getRangeRef(S, HINT_RANGE_SIGNED);</td>
    <td class="lineNumber">991</td>
    <td class="codeline">    return getRangeRef(S, HINT_RANGE_SIGNED);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">992</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeline"></td>
    <td class="lineNumber">993</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeline">  /// Determine the min of the signed range for a particular SCEV.</td>
    <td class="lineNumber">994</td>
    <td class="codeline">  /// Determine the min of the signed range for a particular SCEV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeline">  APInt getSignedRangeMin(const SCEV *S) {</td>
    <td class="lineNumber">995</td>
    <td class="codeline">  APInt getSignedRangeMin(const SCEV *S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeline">    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMin();</td>
    <td class="lineNumber">996</td>
    <td class="codeline">    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMin();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">997</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeline"></td>
    <td class="lineNumber">998</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeline">  /// Determine the max of the signed range for a particular SCEV.</td>
    <td class="lineNumber">999</td>
    <td class="codeline">  /// Determine the max of the signed range for a particular SCEV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeline">  APInt getSignedRangeMax(const SCEV *S) {</td>
    <td class="lineNumber">1000</td>
    <td class="codeline">  APInt getSignedRangeMax(const SCEV *S) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeline">    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMax();</td>
    <td class="lineNumber">1001</td>
    <td class="codeline">    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMax();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1002</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeline"></td>
    <td class="lineNumber">1003</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeline">  /// Test if the given expression is known to be negative.</td>
    <td class="lineNumber">1004</td>
    <td class="codeline">  /// Test if the given expression is known to be negative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeline">  bool isKnownNegative(const SCEV *S);</td>
    <td class="lineNumber">1005</td>
    <td class="codeline">  bool isKnownNegative(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeline"></td>
    <td class="lineNumber">1006</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeline">  /// Test if the given expression is known to be positive.</td>
    <td class="lineNumber">1007</td>
    <td class="codeline">  /// Test if the given expression is known to be positive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeline">  bool isKnownPositive(const SCEV *S);</td>
    <td class="lineNumber">1008</td>
    <td class="codeline">  bool isKnownPositive(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeline"></td>
    <td class="lineNumber">1009</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeline">  /// Test if the given expression is known to be non-negative.</td>
    <td class="lineNumber">1010</td>
    <td class="codeline">  /// Test if the given expression is known to be non-negative.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeline">  bool isKnownNonNegative(const SCEV *S);</td>
    <td class="lineNumber">1011</td>
    <td class="codeline">  bool isKnownNonNegative(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeline"></td>
    <td class="lineNumber">1012</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeline">  /// Test if the given expression is known to be non-positive.</td>
    <td class="lineNumber">1013</td>
    <td class="codeline">  /// Test if the given expression is known to be non-positive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeline">  bool isKnownNonPositive(const SCEV *S);</td>
    <td class="lineNumber">1014</td>
    <td class="codeline">  bool isKnownNonPositive(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeline"></td>
    <td class="lineNumber">1015</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeline">  /// Test if the given expression is known to be non-zero.</td>
    <td class="lineNumber">1016</td>
    <td class="codeline">  /// Test if the given expression is known to be non-zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeline">  bool isKnownNonZero(const SCEV *S);</td>
    <td class="lineNumber">1017</td>
    <td class="codeline">  bool isKnownNonZero(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
    <td class="lineNumber">1018</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeline">  /// Splits SCEV expression \p S into two SCEVs. One of them is obtained from</td>
    <td class="lineNumber">1019</td>
    <td class="codeline">  /// Splits SCEV expression \p S into two SCEVs. One of them is obtained from</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeline">  /// \p S by substitution of all AddRec sub-expression related to loop \p L</td>
    <td class="lineNumber">1020</td>
    <td class="codeline">  /// \p S by substitution of all AddRec sub-expression related to loop \p L</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeline">  /// with initial value of that SCEV. The second is obtained from \p S by</td>
    <td class="lineNumber">1021</td>
    <td class="codeline">  /// with initial value of that SCEV. The second is obtained from \p S by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeline">  /// substitution of all AddRec sub-expressions related to loop \p L with post</td>
    <td class="lineNumber">1022</td>
    <td class="codeline">  /// substitution of all AddRec sub-expressions related to loop \p L with post</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeline">  /// increment of this AddRec in the loop \p L. In both cases all other AddRec</td>
    <td class="lineNumber">1023</td>
    <td class="codeline">  /// increment of this AddRec in the loop \p L. In both cases all other AddRec</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeline">  /// sub-expressions (not related to \p L) remain the same.</td>
    <td class="lineNumber">1024</td>
    <td class="codeline">  /// sub-expressions (not related to \p L) remain the same.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeline">  /// If the \p S contains non-invariant unknown SCEV the function returns</td>
    <td class="lineNumber">1025</td>
    <td class="codeline">  /// If the \p S contains non-invariant unknown SCEV the function returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeline">  /// CouldNotCompute SCEV in both values of std::pair.</td>
    <td class="lineNumber">1026</td>
    <td class="codeline">  /// CouldNotCompute SCEV in both values of std::pair.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeline">  /// For example, for SCEV S={0, +, 1}<L1> + {0, +, 1}<L2> and loop L=L1</td>
    <td class="lineNumber">1027</td>
    <td class="codeline">  /// For example, for SCEV S={0, +, 1}<L1> + {0, +, 1}<L2> and loop L=L1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeline">  /// the function returns pair:</td>
    <td class="lineNumber">1028</td>
    <td class="codeline">  /// the function returns pair:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeline">  /// first = {0, +, 1}<L2></td>
    <td class="lineNumber">1029</td>
    <td class="codeline">  /// first = {0, +, 1}<L2></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeline">  /// second = {1, +, 1}<L1> + {0, +, 1}<L2></td>
    <td class="lineNumber">1030</td>
    <td class="codeline">  /// second = {1, +, 1}<L1> + {0, +, 1}<L2></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeline">  /// We can see that for the first AddRec sub-expression it was replaced with</td>
    <td class="lineNumber">1031</td>
    <td class="codeline">  /// We can see that for the first AddRec sub-expression it was replaced with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeline">  /// 0 (initial value) for the first element and to {1, +, 1}<L1> (post</td>
    <td class="lineNumber">1032</td>
    <td class="codeline">  /// 0 (initial value) for the first element and to {1, +, 1}<L1> (post</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeline">  /// increment value) for the second one. In both cases AddRec expression</td>
    <td class="lineNumber">1033</td>
    <td class="codeline">  /// increment value) for the second one. In both cases AddRec expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeline">  /// related to L2 remains the same.</td>
    <td class="lineNumber">1034</td>
    <td class="codeline">  /// related to L2 remains the same.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeline">  std::pair<const SCEV *, const SCEV *> SplitIntoInitAndPostInc(const Loop *L,</td>
    <td class="lineNumber">1035</td>
    <td class="codeline">  std::pair<const SCEV *, const SCEV *> SplitIntoInitAndPostInc(const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeline">                                                                const SCEV *S);</td>
    <td class="lineNumber">1036</td>
    <td class="codeline">                                                                const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeline"></td>
    <td class="lineNumber">1037</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeline">  /// We'd like to check the predicate on every iteration of the most dominated</td>
    <td class="lineNumber">1038</td>
    <td class="codeline">  /// We'd like to check the predicate on every iteration of the most dominated</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeline">  /// loop between loops used in LHS and RHS.</td>
    <td class="lineNumber">1039</td>
    <td class="codeline">  /// loop between loops used in LHS and RHS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeline">  /// To do this we use the following list of steps:</td>
    <td class="lineNumber">1040</td>
    <td class="codeline">  /// To do this we use the following list of steps:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeline">  /// 1. Collect set S all loops on which either LHS or RHS depend.</td>
    <td class="lineNumber">1041</td>
    <td class="codeline">  /// 1. Collect set S all loops on which either LHS or RHS depend.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeline">  /// 2. If S is non-empty</td>
    <td class="lineNumber">1042</td>
    <td class="codeline">  /// 2. If S is non-empty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeline">  /// a. Let PD be the element of S which is dominated by all other elements.</td>
    <td class="lineNumber">1043</td>
    <td class="codeline">  /// a. Let PD be the element of S which is dominated by all other elements.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeline">  /// b. Let E(LHS) be value of LHS on entry of PD.</td>
    <td class="lineNumber">1044</td>
    <td class="codeline">  /// b. Let E(LHS) be value of LHS on entry of PD.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeline">  ///    To get E(LHS), we should just take LHS and replace all AddRecs that are</td>
    <td class="lineNumber">1045</td>
    <td class="codeline">  ///    To get E(LHS), we should just take LHS and replace all AddRecs that are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeline">  ///    attached to PD on with their entry values.</td>
    <td class="lineNumber">1046</td>
    <td class="codeline">  ///    attached to PD on with their entry values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeline">  ///    Define E(RHS) in the same way.</td>
    <td class="lineNumber">1047</td>
    <td class="codeline">  ///    Define E(RHS) in the same way.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeline">  /// c. Let B(LHS) be value of L on backedge of PD.</td>
    <td class="lineNumber">1048</td>
    <td class="codeline">  /// c. Let B(LHS) be value of L on backedge of PD.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeline">  ///    To get B(LHS), we should just take LHS and replace all AddRecs that are</td>
    <td class="lineNumber">1049</td>
    <td class="codeline">  ///    To get B(LHS), we should just take LHS and replace all AddRecs that are</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeline">  ///    attached to PD on with their backedge values.</td>
    <td class="lineNumber">1050</td>
    <td class="codeline">  ///    attached to PD on with their backedge values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeline">  ///    Define B(RHS) in the same way.</td>
    <td class="lineNumber">1051</td>
    <td class="codeline">  ///    Define B(RHS) in the same way.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeline">  /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,</td>
    <td class="lineNumber">1052</td>
    <td class="codeline">  /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeline">  ///    so we can assert on that.</td>
    <td class="lineNumber">1053</td>
    <td class="codeline">  ///    so we can assert on that.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeline">  /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&</td>
    <td class="lineNumber">1054</td>
    <td class="codeline">  /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeline">  ///                   isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))</td>
    <td class="lineNumber">1055</td>
    <td class="codeline">  ///                   isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeline">  bool isKnownViaInduction(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">1056</td>
    <td class="codeline">  bool isKnownViaInduction(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeline">                           const SCEV *RHS);</td>
    <td class="lineNumber">1057</td>
    <td class="codeline">                           const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeline"></td>
    <td class="lineNumber">1058</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeline">  /// Test if the given expression is known to satisfy the condition described</td>
    <td class="lineNumber">1059</td>
    <td class="codeline">  /// Test if the given expression is known to satisfy the condition described</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeline">  /// by Pred, LHS, and RHS.</td>
    <td class="lineNumber">1060</td>
    <td class="codeline">  /// by Pred, LHS, and RHS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeline">  bool isKnownPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">1061</td>
    <td class="codeline">  bool isKnownPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeline">                        const SCEV *RHS);</td>
    <td class="lineNumber">1062</td>
    <td class="codeline">                        const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeline"></td>
    <td class="lineNumber">1063</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeline">  /// Check whether the condition described by Pred, LHS, and RHS is true or</td>
    <td class="lineNumber">1064</td>
    <td class="codeline">  /// Check whether the condition described by Pred, LHS, and RHS is true or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeline">  /// false. If we know it, return the evaluation of this condition. If neither</td>
    <td class="lineNumber">1065</td>
    <td class="codeline">  /// false. If we know it, return the evaluation of this condition. If neither</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeline">  /// is proved, return std::nullopt.</td>
    <td class="lineNumber">1066</td>
    <td class="codeline">  /// is proved, return std::nullopt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeline">  std::optional<bool> evaluatePredicate(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">1067</td>
    <td class="codeline">  std::optional<bool> evaluatePredicate(ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeline">                                        const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">1068</td>
    <td class="codeline">                                        const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeline"></td>
    <td class="lineNumber">1069</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeline">  /// Test if the given expression is known to satisfy the condition described</td>
    <td class="lineNumber">1070</td>
    <td class="codeline">  /// Test if the given expression is known to satisfy the condition described</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeline">  /// by Pred, LHS, and RHS in the given Context.</td>
    <td class="lineNumber">1071</td>
    <td class="codeline">  /// by Pred, LHS, and RHS in the given Context.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeline">  bool isKnownPredicateAt(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">1072</td>
    <td class="codeline">  bool isKnownPredicateAt(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeline">                          const SCEV *RHS, const Instruction *CtxI);</td>
    <td class="lineNumber">1073</td>
    <td class="codeline">                          const SCEV *RHS, const Instruction *CtxI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeline"></td>
    <td class="lineNumber">1074</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeline">  /// Check whether the condition described by Pred, LHS, and RHS is true or</td>
    <td class="lineNumber">1075</td>
    <td class="codeline">  /// Check whether the condition described by Pred, LHS, and RHS is true or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeline">  /// false in the given \p Context. If we know it, return the evaluation of</td>
    <td class="lineNumber">1076</td>
    <td class="codeline">  /// false in the given \p Context. If we know it, return the evaluation of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeline">  /// this condition. If neither is proved, return std::nullopt.</td>
    <td class="lineNumber">1077</td>
    <td class="codeline">  /// this condition. If neither is proved, return std::nullopt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeline">  std::optional<bool> evaluatePredicateAt(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">1078</td>
    <td class="codeline">  std::optional<bool> evaluatePredicateAt(ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeline">                                          const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">1079</td>
    <td class="codeline">                                          const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeline">                                          const Instruction *CtxI);</td>
    <td class="lineNumber">1080</td>
    <td class="codeline">                                          const Instruction *CtxI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeline"></td>
    <td class="lineNumber">1081</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeline">  /// Test if the condition described by Pred, LHS, RHS is known to be true on</td>
    <td class="lineNumber">1082</td>
    <td class="codeline">  /// Test if the condition described by Pred, LHS, RHS is known to be true on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeline">  /// every iteration of the loop of the recurrency LHS.</td>
    <td class="lineNumber">1083</td>
    <td class="codeline">  /// every iteration of the loop of the recurrency LHS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeline">  bool isKnownOnEveryIteration(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">1084</td>
    <td class="codeline">  bool isKnownOnEveryIteration(ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeline">                               const SCEVAddRecExpr *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">1085</td>
    <td class="codeline">                               const SCEVAddRecExpr *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeline"></td>
    <td class="lineNumber">1086</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeline">  /// Information about the number of loop iterations for which a loop exit's</td>
    <td class="lineNumber">1087</td>
    <td class="codeline">  /// Information about the number of loop iterations for which a loop exit's</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeline">  /// branch condition evaluates to the not-taken path.  This is a temporary</td>
    <td class="lineNumber">1088</td>
    <td class="codeline">  /// branch condition evaluates to the not-taken path.  This is a temporary</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeline">  /// pair of exact and max expressions that are eventually summarized in</td>
    <td class="lineNumber">1089</td>
    <td class="codeline">  /// pair of exact and max expressions that are eventually summarized in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeline">  /// ExitNotTakenInfo and BackedgeTakenInfo.</td>
    <td class="lineNumber">1090</td>
    <td class="codeline">  /// ExitNotTakenInfo and BackedgeTakenInfo.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeline">  struct ExitLimit {</td>
    <td class="lineNumber">1091</td>
    <td class="codeline">  struct ExitLimit {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeline">    const SCEV *ExactNotTaken; // The exit is not taken exactly this many times</td>
    <td class="lineNumber">1092</td>
    <td class="codeline">    const SCEV *ExactNotTaken; // The exit is not taken exactly this many times</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeline">    const SCEV *ConstantMaxNotTaken; // The exit is not taken at most this many</td>
    <td class="lineNumber">1093</td>
    <td class="codeline">    const SCEV *ConstantMaxNotTaken; // The exit is not taken at most this many</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeline">                                     // times</td>
    <td class="lineNumber">1094</td>
    <td class="codeline">                                     // times</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeline">    const SCEV *SymbolicMaxNotTaken;</td>
    <td class="lineNumber">1095</td>
    <td class="codeline">    const SCEV *SymbolicMaxNotTaken;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
    <td class="lineNumber">1096</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeline">    // Not taken either exactly ConstantMaxNotTaken or zero times</td>
    <td class="lineNumber">1097</td>
    <td class="codeline">    // Not taken either exactly ConstantMaxNotTaken or zero times</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeline">    bool MaxOrZero = false;</td>
    <td class="lineNumber">1098</td>
    <td class="codeline">    bool MaxOrZero = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeline"></td>
    <td class="lineNumber">1099</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeline">    /// A set of predicate guards for this ExitLimit. The result is only valid</td>
    <td class="lineNumber">1100</td>
    <td class="codeline">    /// A set of predicate guards for this ExitLimit. The result is only valid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeline">    /// if all of the predicates in \c Predicates evaluate to 'true' at</td>
    <td class="lineNumber">1101</td>
    <td class="codeline">    /// if all of the predicates in \c Predicates evaluate to 'true' at</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeline">    /// run-time.</td>
    <td class="lineNumber">1102</td>
    <td class="codeline">    /// run-time.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeline">    SmallPtrSet<const SCEVPredicate *, 4> Predicates;</td>
    <td class="lineNumber">1103</td>
    <td class="codeline">    SmallPtrSet<const SCEVPredicate *, 4> Predicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeline"></td>
    <td class="lineNumber">1104</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeline">    void addPredicate(const SCEVPredicate *P) {</td>
    <td class="lineNumber">1105</td>
    <td class="codeline">    void addPredicate(const SCEVPredicate *P) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeline">      assert(!isa<SCEVUnionPredicate>(P) && "Only add leaf predicates here!");</td>
    <td class="lineNumber">1106</td>
    <td class="codeline">      assert(!isa<SCEVUnionPredicate>(P) && "Only add leaf predicates here!");</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeline">      Predicates.insert(P);</td>
    <td class="lineNumber">1107</td>
    <td class="codeline">      Predicates.insert(P);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1108</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeline"></td>
    <td class="lineNumber">1109</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeline">    /// Construct either an exact exit limit from a constant, or an unknown</td>
    <td class="lineNumber">1110</td>
    <td class="codeline">    /// Construct either an exact exit limit from a constant, or an unknown</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeline">    /// one from a SCEVCouldNotCompute.  No other types of SCEVs are allowed</td>
    <td class="lineNumber">1111</td>
    <td class="codeline">    /// one from a SCEVCouldNotCompute.  No other types of SCEVs are allowed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeline">    /// as arguments and asserts enforce that internally.</td>
    <td class="lineNumber">1112</td>
    <td class="codeline">    /// as arguments and asserts enforce that internally.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeline">    /*implicit*/ ExitLimit(const SCEV *E);</td>
    <td class="lineNumber">1113</td>
    <td class="codeline">    /*implicit*/ ExitLimit(const SCEV *E);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeline"></td>
    <td class="lineNumber">1114</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeline">    ExitLimit(</td>
    <td class="lineNumber">1115</td>
    <td class="codeline">    ExitLimit(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeline">        const SCEV *E, const SCEV *ConstantMaxNotTaken,</td>
    <td class="lineNumber">1116</td>
    <td class="codeline">        const SCEV *E, const SCEV *ConstantMaxNotTaken,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeline">        const SCEV *SymbolicMaxNotTaken, bool MaxOrZero,</td>
    <td class="lineNumber">1117</td>
    <td class="codeline">        const SCEV *SymbolicMaxNotTaken, bool MaxOrZero,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeline">        ArrayRef<const SmallPtrSetImpl<const SCEVPredicate *> *> PredSetList =</td>
    <td class="lineNumber">1118</td>
    <td class="codeline">        ArrayRef<const SmallPtrSetImpl<const SCEVPredicate *> *> PredSetList =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeline">            std::nullopt);</td>
    <td class="lineNumber">1119</td>
    <td class="codeline">            std::nullopt);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeline"></td>
    <td class="lineNumber">1120</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeline">    ExitLimit(const SCEV *E, const SCEV *ConstantMaxNotTaken,</td>
    <td class="lineNumber">1121</td>
    <td class="codeline">    ExitLimit(const SCEV *E, const SCEV *ConstantMaxNotTaken,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeline">              const SCEV *SymbolicMaxNotTaken, bool MaxOrZero,</td>
    <td class="lineNumber">1122</td>
    <td class="codeline">              const SCEV *SymbolicMaxNotTaken, bool MaxOrZero,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeline">              const SmallPtrSetImpl<const SCEVPredicate *> &PredSet);</td>
    <td class="lineNumber">1123</td>
    <td class="codeline">              const SmallPtrSetImpl<const SCEVPredicate *> &PredSet);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeline"></td>
    <td class="lineNumber">1124</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeline">    /// Test whether this ExitLimit contains any computed information, or</td>
    <td class="lineNumber">1125</td>
    <td class="codeline">    /// Test whether this ExitLimit contains any computed information, or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeline">    /// whether it's all SCEVCouldNotCompute values.</td>
    <td class="lineNumber">1126</td>
    <td class="codeline">    /// whether it's all SCEVCouldNotCompute values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeline">    bool hasAnyInfo() const {</td>
    <td class="lineNumber">1127</td>
    <td class="codeline">    bool hasAnyInfo() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeline">      return !isa<SCEVCouldNotCompute>(ExactNotTaken) ||</td>
    <td class="lineNumber">1128</td>
    <td class="codeline">      return !isa<SCEVCouldNotCompute>(ExactNotTaken) ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeline">             !isa<SCEVCouldNotCompute>(ConstantMaxNotTaken);</td>
    <td class="lineNumber">1129</td>
    <td class="codeline">             !isa<SCEVCouldNotCompute>(ConstantMaxNotTaken);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1130</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeline"></td>
    <td class="lineNumber">1131</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeline">    /// Test whether this ExitLimit contains all information.</td>
    <td class="lineNumber">1132</td>
    <td class="codeline">    /// Test whether this ExitLimit contains all information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeline">    bool hasFullInfo() const {</td>
    <td class="lineNumber">1133</td>
    <td class="codeline">    bool hasFullInfo() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeline">      return !isa<SCEVCouldNotCompute>(ExactNotTaken);</td>
    <td class="lineNumber">1134</td>
    <td class="codeline">      return !isa<SCEVCouldNotCompute>(ExactNotTaken);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1135</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1136</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeline"></td>
    <td class="lineNumber">1137</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeline">  /// Compute the number of times the backedge of the specified loop will</td>
    <td class="lineNumber">1138</td>
    <td class="codeline">  /// Compute the number of times the backedge of the specified loop will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeline">  /// execute if its exit condition were a conditional branch of ExitCond.</td>
    <td class="lineNumber">1139</td>
    <td class="codeline">  /// execute if its exit condition were a conditional branch of ExitCond.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1140</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeline">  /// \p ControlsOnlyExit is true if ExitCond directly controls the only exit</td>
    <td class="lineNumber">1141</td>
    <td class="codeline">  /// \p ControlsOnlyExit is true if ExitCond directly controls the only exit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeline">  /// branch. In this case, we can assume that the loop exits only if the</td>
    <td class="lineNumber">1142</td>
    <td class="codeline">  /// branch. In this case, we can assume that the loop exits only if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeline">  /// condition is true and can infer that failing to meet the condition prior</td>
    <td class="lineNumber">1143</td>
    <td class="codeline">  /// condition is true and can infer that failing to meet the condition prior</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeline">  /// to integer wraparound results in undefined behavior.</td>
    <td class="lineNumber">1144</td>
    <td class="codeline">  /// to integer wraparound results in undefined behavior.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1145</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeline">  /// If \p AllowPredicates is set, this call will try to use a minimal set of</td>
    <td class="lineNumber">1146</td>
    <td class="codeline">  /// If \p AllowPredicates is set, this call will try to use a minimal set of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeline">  /// SCEV predicates in order to return an exact answer.</td>
    <td class="lineNumber">1147</td>
    <td class="codeline">  /// SCEV predicates in order to return an exact answer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeline">  ExitLimit computeExitLimitFromCond(const Loop *L, Value *ExitCond,</td>
    <td class="lineNumber">1148</td>
    <td class="codeline">  ExitLimit computeExitLimitFromCond(const Loop *L, Value *ExitCond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeline">                                     bool ExitIfTrue, bool ControlsOnlyExit,</td>
    <td class="lineNumber">1149</td>
    <td class="codeline">                                     bool ExitIfTrue, bool ControlsOnlyExit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeline">                                     bool AllowPredicates = false);</td>
    <td class="lineNumber">1150</td>
    <td class="codeline">                                     bool AllowPredicates = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeline"></td>
    <td class="lineNumber">1151</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeline">  /// A predicate is said to be monotonically increasing if may go from being</td>
    <td class="lineNumber">1152</td>
    <td class="codeline">  /// A predicate is said to be monotonically increasing if may go from being</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeline">  /// false to being true as the loop iterates, but never the other way</td>
    <td class="lineNumber">1153</td>
    <td class="codeline">  /// false to being true as the loop iterates, but never the other way</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeline">  /// around.  A predicate is said to be monotonically decreasing if may go</td>
    <td class="lineNumber">1154</td>
    <td class="codeline">  /// around.  A predicate is said to be monotonically decreasing if may go</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeline">  /// from being true to being false as the loop iterates, but never the other</td>
    <td class="lineNumber">1155</td>
    <td class="codeline">  /// from being true to being false as the loop iterates, but never the other</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeline">  /// way around.</td>
    <td class="lineNumber">1156</td>
    <td class="codeline">  /// way around.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeline">  enum MonotonicPredicateType {</td>
    <td class="lineNumber">1157</td>
    <td class="codeline">  enum MonotonicPredicateType {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeline">    MonotonicallyIncreasing,</td>
    <td class="lineNumber">1158</td>
    <td class="codeline">    MonotonicallyIncreasing,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeline">    MonotonicallyDecreasing</td>
    <td class="lineNumber">1159</td>
    <td class="codeline">    MonotonicallyDecreasing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1160</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeline"></td>
    <td class="lineNumber">1161</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeline">  /// If, for all loop invariant X, the predicate "LHS `Pred` X" is</td>
    <td class="lineNumber">1162</td>
    <td class="codeline">  /// If, for all loop invariant X, the predicate "LHS `Pred` X" is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeline">  /// monotonically increasing or decreasing, returns</td>
    <td class="lineNumber">1163</td>
    <td class="codeline">  /// monotonically increasing or decreasing, returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeline">  /// Some(MonotonicallyIncreasing) and Some(MonotonicallyDecreasing)</td>
    <td class="lineNumber">1164</td>
    <td class="codeline">  /// Some(MonotonicallyIncreasing) and Some(MonotonicallyDecreasing)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeline">  /// respectively. If we could not prove either of these facts, returns</td>
    <td class="lineNumber">1165</td>
    <td class="codeline">  /// respectively. If we could not prove either of these facts, returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeline">  /// std::nullopt.</td>
    <td class="lineNumber">1166</td>
    <td class="codeline">  /// std::nullopt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeline">  std::optional<MonotonicPredicateType></td>
    <td class="lineNumber">1167</td>
    <td class="codeline">  std::optional<MonotonicPredicateType></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeline">  getMonotonicPredicateType(const SCEVAddRecExpr *LHS,</td>
    <td class="lineNumber">1168</td>
    <td class="codeline">  getMonotonicPredicateType(const SCEVAddRecExpr *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeline">                            ICmpInst::Predicate Pred);</td>
    <td class="lineNumber">1169</td>
    <td class="codeline">                            ICmpInst::Predicate Pred);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeline"></td>
    <td class="lineNumber">1170</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeline">  struct LoopInvariantPredicate {</td>
    <td class="lineNumber">1171</td>
    <td class="codeline">  struct LoopInvariantPredicate {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeline">    ICmpInst::Predicate Pred;</td>
    <td class="lineNumber">1172</td>
    <td class="codeline">    ICmpInst::Predicate Pred;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeline">    const SCEV *LHS;</td>
    <td class="lineNumber">1173</td>
    <td class="codeline">    const SCEV *LHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeline">    const SCEV *RHS;</td>
    <td class="lineNumber">1174</td>
    <td class="codeline">    const SCEV *RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeline"></td>
    <td class="lineNumber">1175</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeline">    LoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">1176</td>
    <td class="codeline">    LoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeline">                           const SCEV *RHS)</td>
    <td class="lineNumber">1177</td>
    <td class="codeline">                           const SCEV *RHS)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeline">        : Pred(Pred), LHS(LHS), RHS(RHS) {}</td>
    <td class="lineNumber">1178</td>
    <td class="codeline">        : Pred(Pred), LHS(LHS), RHS(RHS) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1179</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeline">  /// If the result of the predicate LHS `Pred` RHS is loop invariant with</td>
    <td class="lineNumber">1180</td>
    <td class="codeline">  /// If the result of the predicate LHS `Pred` RHS is loop invariant with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeline">  /// respect to L, return a LoopInvariantPredicate with LHS and RHS being</td>
    <td class="lineNumber">1181</td>
    <td class="codeline">  /// respect to L, return a LoopInvariantPredicate with LHS and RHS being</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeline">  /// invariants, available at L's entry. Otherwise, return std::nullopt.</td>
    <td class="lineNumber">1182</td>
    <td class="codeline">  /// invariants, available at L's entry. Otherwise, return std::nullopt.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeline">  std::optional<LoopInvariantPredicate></td>
    <td class="lineNumber">1183</td>
    <td class="codeline">  std::optional<LoopInvariantPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeline">  getLoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">1184</td>
    <td class="codeline">  getLoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeline">                            const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">1185</td>
    <td class="codeline">                            const SCEV *RHS, const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeline">                            const Instruction *CtxI = nullptr);</td>
    <td class="lineNumber">1186</td>
    <td class="codeline">                            const Instruction *CtxI = nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeline"></td>
    <td class="lineNumber">1187</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeline">  /// If the result of the predicate LHS `Pred` RHS is loop invariant with</td>
    <td class="lineNumber">1188</td>
    <td class="codeline">  /// If the result of the predicate LHS `Pred` RHS is loop invariant with</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeline">  /// respect to L at given Context during at least first MaxIter iterations,</td>
    <td class="lineNumber">1189</td>
    <td class="codeline">  /// respect to L at given Context during at least first MaxIter iterations,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeline">  /// return a LoopInvariantPredicate with LHS and RHS being invariants,</td>
    <td class="lineNumber">1190</td>
    <td class="codeline">  /// return a LoopInvariantPredicate with LHS and RHS being invariants,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeline">  /// available at L's entry. Otherwise, return std::nullopt. The predicate</td>
    <td class="lineNumber">1191</td>
    <td class="codeline">  /// available at L's entry. Otherwise, return std::nullopt. The predicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeline">  /// should be the loop's exit condition.</td>
    <td class="lineNumber">1192</td>
    <td class="codeline">  /// should be the loop's exit condition.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeline">  std::optional<LoopInvariantPredicate></td>
    <td class="lineNumber">1193</td>
    <td class="codeline">  std::optional<LoopInvariantPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeline">  getLoopInvariantExitCondDuringFirstIterations(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">1194</td>
    <td class="codeline">  getLoopInvariantExitCondDuringFirstIterations(ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeline">                                                const SCEV *LHS,</td>
    <td class="lineNumber">1195</td>
    <td class="codeline">                                                const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeline">                                                const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">1196</td>
    <td class="codeline">                                                const SCEV *RHS, const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeline">                                                const Instruction *CtxI,</td>
    <td class="lineNumber">1197</td>
    <td class="codeline">                                                const Instruction *CtxI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeline">                                                const SCEV *MaxIter);</td>
    <td class="lineNumber">1198</td>
    <td class="codeline">                                                const SCEV *MaxIter);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeline"></td>
    <td class="lineNumber">1199</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeline">  std::optional<LoopInvariantPredicate></td>
    <td class="lineNumber">1200</td>
    <td class="codeline">  std::optional<LoopInvariantPredicate></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeline">  getLoopInvariantExitCondDuringFirstIterationsImpl(</td>
    <td class="lineNumber">1201</td>
    <td class="codeline">  getLoopInvariantExitCondDuringFirstIterationsImpl(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeline">      ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">1202</td>
    <td class="codeline">      ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeline">      const Instruction *CtxI, const SCEV *MaxIter);</td>
    <td class="lineNumber">1203</td>
    <td class="codeline">      const Instruction *CtxI, const SCEV *MaxIter);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeline"></td>
    <td class="lineNumber">1204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeline">  /// Simplify LHS and RHS in a comparison with predicate Pred. Return true</td>
    <td class="lineNumber">1205</td>
    <td class="codeline">  /// Simplify LHS and RHS in a comparison with predicate Pred. Return true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeline">  /// iff any changes were made. If the operands are provably equal or</td>
    <td class="lineNumber">1206</td>
    <td class="codeline">  /// iff any changes were made. If the operands are provably equal or</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeline">  /// unequal, LHS and RHS are set to the same value and Pred is set to either</td>
    <td class="lineNumber">1207</td>
    <td class="codeline">  /// unequal, LHS and RHS are set to the same value and Pred is set to either</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeline">  /// ICMP_EQ or ICMP_NE.</td>
    <td class="lineNumber">1208</td>
    <td class="codeline">  /// ICMP_EQ or ICMP_NE.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeline">  bool SimplifyICmpOperands(ICmpInst::Predicate &Pred, const SCEV *&LHS,</td>
    <td class="lineNumber">1209</td>
    <td class="codeline">  bool SimplifyICmpOperands(ICmpInst::Predicate &Pred, const SCEV *&LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeline">                            const SCEV *&RHS, unsigned Depth = 0);</td>
    <td class="lineNumber">1210</td>
    <td class="codeline">                            const SCEV *&RHS, unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeline"></td>
    <td class="lineNumber">1211</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeline">  /// Return the "disposition" of the given SCEV with respect to the given</td>
    <td class="lineNumber">1212</td>
    <td class="codeline">  /// Return the "disposition" of the given SCEV with respect to the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeline">  /// loop.</td>
    <td class="lineNumber">1213</td>
    <td class="codeline">  /// loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeline">  LoopDisposition getLoopDisposition(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">1214</td>
    <td class="codeline">  LoopDisposition getLoopDisposition(const SCEV *S, const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeline"></td>
    <td class="lineNumber">1215</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeline">  /// Return true if the value of the given SCEV is unchanging in the</td>
    <td class="lineNumber">1216</td>
    <td class="codeline">  /// Return true if the value of the given SCEV is unchanging in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeline">  /// specified loop.</td>
    <td class="lineNumber">1217</td>
    <td class="codeline">  /// specified loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeline">  bool isLoopInvariant(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">1218</td>
    <td class="codeline">  bool isLoopInvariant(const SCEV *S, const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
    <td class="lineNumber">1219</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeline">  /// Determine if the SCEV can be evaluated at loop's entry. It is true if it</td>
    <td class="lineNumber">1220</td>
    <td class="codeline">  /// Determine if the SCEV can be evaluated at loop's entry. It is true if it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeline">  /// doesn't depend on a SCEVUnknown of an instruction which is dominated by</td>
    <td class="lineNumber">1221</td>
    <td class="codeline">  /// doesn't depend on a SCEVUnknown of an instruction which is dominated by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeline">  /// the header of loop L.</td>
    <td class="lineNumber">1222</td>
    <td class="codeline">  /// the header of loop L.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeline">  bool isAvailableAtLoopEntry(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">1223</td>
    <td class="codeline">  bool isAvailableAtLoopEntry(const SCEV *S, const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeline"></td>
    <td class="lineNumber">1224</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeline">  /// Return true if the given SCEV changes value in a known way in the</td>
    <td class="lineNumber">1225</td>
    <td class="codeline">  /// Return true if the given SCEV changes value in a known way in the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeline">  /// specified loop.  This property being true implies that the value is</td>
    <td class="lineNumber">1226</td>
    <td class="codeline">  /// specified loop.  This property being true implies that the value is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeline">  /// variant in the loop AND that we can emit an expression to compute the</td>
    <td class="lineNumber">1227</td>
    <td class="codeline">  /// variant in the loop AND that we can emit an expression to compute the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeline">  /// value of the expression at any particular loop iteration.</td>
    <td class="lineNumber">1228</td>
    <td class="codeline">  /// value of the expression at any particular loop iteration.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeline">  bool hasComputableLoopEvolution(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">1229</td>
    <td class="codeline">  bool hasComputableLoopEvolution(const SCEV *S, const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeline"></td>
    <td class="lineNumber">1230</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeline">  /// Return the "disposition" of the given SCEV with respect to the given</td>
    <td class="lineNumber">1231</td>
    <td class="codeline">  /// Return the "disposition" of the given SCEV with respect to the given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeline">  /// block.</td>
    <td class="lineNumber">1232</td>
    <td class="codeline">  /// block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeline">  BlockDisposition getBlockDisposition(const SCEV *S, const BasicBlock *BB);</td>
    <td class="lineNumber">1233</td>
    <td class="codeline">  BlockDisposition getBlockDisposition(const SCEV *S, const BasicBlock *BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeline"></td>
    <td class="lineNumber">1234</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeline">  /// Return true if elements that makes up the given SCEV dominate the</td>
    <td class="lineNumber">1235</td>
    <td class="codeline">  /// Return true if elements that makes up the given SCEV dominate the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeline">  /// specified basic block.</td>
    <td class="lineNumber">1236</td>
    <td class="codeline">  /// specified basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeline">  bool dominates(const SCEV *S, const BasicBlock *BB);</td>
    <td class="lineNumber">1237</td>
    <td class="codeline">  bool dominates(const SCEV *S, const BasicBlock *BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeline"></td>
    <td class="lineNumber">1238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeline">  /// Return true if elements that makes up the given SCEV properly dominate</td>
    <td class="lineNumber">1239</td>
    <td class="codeline">  /// Return true if elements that makes up the given SCEV properly dominate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeline">  /// the specified basic block.</td>
    <td class="lineNumber">1240</td>
    <td class="codeline">  /// the specified basic block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeline">  bool properlyDominates(const SCEV *S, const BasicBlock *BB);</td>
    <td class="lineNumber">1241</td>
    <td class="codeline">  bool properlyDominates(const SCEV *S, const BasicBlock *BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeline"></td>
    <td class="lineNumber">1242</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeline">  /// Test whether the given SCEV has Op as a direct or indirect operand.</td>
    <td class="lineNumber">1243</td>
    <td class="codeline">  /// Test whether the given SCEV has Op as a direct or indirect operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeline">  bool hasOperand(const SCEV *S, const SCEV *Op) const;</td>
    <td class="lineNumber">1244</td>
    <td class="codeline">  bool hasOperand(const SCEV *S, const SCEV *Op) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeline"></td>
    <td class="lineNumber">1245</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeline">  /// Return the size of an element read or written by Inst.</td>
    <td class="lineNumber">1246</td>
    <td class="codeline">  /// Return the size of an element read or written by Inst.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeline">  const SCEV *getElementSize(Instruction *Inst);</td>
    <td class="lineNumber">1247</td>
    <td class="codeline">  const SCEV *getElementSize(Instruction *Inst);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeline"></td>
    <td class="lineNumber">1248</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeline">  void print(raw_ostream &OS) const;</td>
    <td class="lineNumber">1249</td>
    <td class="codeline">  void print(raw_ostream &OS) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeline">  void verify() const;</td>
    <td class="lineNumber">1250</td>
    <td class="codeline">  void verify() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeline">  bool invalidate(Function &F, const PreservedAnalyses &PA,</td>
    <td class="lineNumber">1251</td>
    <td class="codeline">  bool invalidate(Function &F, const PreservedAnalyses &PA,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeline">                  FunctionAnalysisManager::Invalidator &Inv);</td>
    <td class="lineNumber">1252</td>
    <td class="codeline">                  FunctionAnalysisManager::Invalidator &Inv);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeline"></td>
    <td class="lineNumber">1253</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeline">  /// Return the DataLayout associated with the module this SCEV instance is</td>
    <td class="lineNumber">1254</td>
    <td class="codeline">  /// Return the DataLayout associated with the module this SCEV instance is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeline">  /// operating on.</td>
    <td class="lineNumber">1255</td>
    <td class="codeline">  /// operating on.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeline">  const DataLayout &getDataLayout() const {</td>
    <td class="lineNumber">1256</td>
    <td class="codeline">  const DataLayout &getDataLayout() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeline">    return F.getParent()->getDataLayout();</td>
    <td class="lineNumber">1257</td>
    <td class="codeline">    return F.getParent()->getDataLayout();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1258</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeline"></td>
    <td class="lineNumber">1259</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeline">  const SCEVPredicate *getEqualPredicate(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">1260</td>
    <td class="codeline">  const SCEVPredicate *getEqualPredicate(const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeline">  const SCEVPredicate *getComparePredicate(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">1261</td>
    <td class="codeline">  const SCEVPredicate *getComparePredicate(ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeline">                                           const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">1262</td>
    <td class="codeline">                                           const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeline"></td>
    <td class="lineNumber">1263</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeline">  const SCEVPredicate *</td>
    <td class="lineNumber">1264</td>
    <td class="codeline">  const SCEVPredicate *</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeline">  getWrapPredicate(const SCEVAddRecExpr *AR,</td>
    <td class="lineNumber">1265</td>
    <td class="codeline">  getWrapPredicate(const SCEVAddRecExpr *AR,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeline">                   SCEVWrapPredicate::IncrementWrapFlags AddedFlags);</td>
    <td class="lineNumber">1266</td>
    <td class="codeline">                   SCEVWrapPredicate::IncrementWrapFlags AddedFlags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeline"></td>
    <td class="lineNumber">1267</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeline">  /// Re-writes the SCEV according to the Predicates in \p A.</td>
    <td class="lineNumber">1268</td>
    <td class="codeline">  /// Re-writes the SCEV according to the Predicates in \p A.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeline">  const SCEV *rewriteUsingPredicate(const SCEV *S, const Loop *L,</td>
    <td class="lineNumber">1269</td>
    <td class="codeline">  const SCEV *rewriteUsingPredicate(const SCEV *S, const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeline">                                    const SCEVPredicate &A);</td>
    <td class="lineNumber">1270</td>
    <td class="codeline">                                    const SCEVPredicate &A);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeline">  /// Tries to convert the \p S expression to an AddRec expression,</td>
    <td class="lineNumber">1271</td>
    <td class="codeline">  /// Tries to convert the \p S expression to an AddRec expression,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeline">  /// adding additional predicates to \p Preds as required.</td>
    <td class="lineNumber">1272</td>
    <td class="codeline">  /// adding additional predicates to \p Preds as required.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeline">  const SCEVAddRecExpr *convertSCEVToAddRecWithPredicates(</td>
    <td class="lineNumber">1273</td>
    <td class="codeline">  const SCEVAddRecExpr *convertSCEVToAddRecWithPredicates(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeline">      const SCEV *S, const Loop *L,</td>
    <td class="lineNumber">1274</td>
    <td class="codeline">      const SCEV *S, const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeline">      SmallPtrSetImpl<const SCEVPredicate *> &Preds);</td>
    <td class="lineNumber">1275</td>
    <td class="codeline">      SmallPtrSetImpl<const SCEVPredicate *> &Preds);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
    <td class="lineNumber">1276</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeline">  /// Compute \p LHS - \p RHS and returns the result as an APInt if it is a</td>
    <td class="lineNumber">1277</td>
    <td class="codeline">  /// Compute \p LHS - \p RHS and returns the result as an APInt if it is a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeline">  /// constant, and std::nullopt if it isn't.</td>
    <td class="lineNumber">1278</td>
    <td class="codeline">  /// constant, and std::nullopt if it isn't.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1279</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeline">  /// This is intended to be a cheaper version of getMinusSCEV.  We can be</td>
    <td class="lineNumber">1280</td>
    <td class="codeline">  /// This is intended to be a cheaper version of getMinusSCEV.  We can be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeline">  /// frugal here since we just bail out of actually constructing and</td>
    <td class="lineNumber">1281</td>
    <td class="codeline">  /// frugal here since we just bail out of actually constructing and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeline">  /// canonicalizing an expression in the cases where the result isn't going</td>
    <td class="lineNumber">1282</td>
    <td class="codeline">  /// canonicalizing an expression in the cases where the result isn't going</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeline">  /// to be a constant.</td>
    <td class="lineNumber">1283</td>
    <td class="codeline">  /// to be a constant.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeline">  std::optional<APInt> computeConstantDifference(const SCEV *LHS,</td>
    <td class="lineNumber">1284</td>
    <td class="codeline">  std::optional<APInt> computeConstantDifference(const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeline">                                                 const SCEV *RHS);</td>
    <td class="lineNumber">1285</td>
    <td class="codeline">                                                 const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeline"></td>
    <td class="lineNumber">1286</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeline">  /// Update no-wrap flags of an AddRec. This may drop the cached info about</td>
    <td class="lineNumber">1287</td>
    <td class="codeline">  /// Update no-wrap flags of an AddRec. This may drop the cached info about</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeline">  /// this AddRec (such as range info) in case if new flags may potentially</td>
    <td class="lineNumber">1288</td>
    <td class="codeline">  /// this AddRec (such as range info) in case if new flags may potentially</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeline">  /// sharpen it.</td>
    <td class="lineNumber">1289</td>
    <td class="codeline">  /// sharpen it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeline">  void setNoWrapFlags(SCEVAddRecExpr *AddRec, SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">1290</td>
    <td class="codeline">  void setNoWrapFlags(SCEVAddRecExpr *AddRec, SCEV::NoWrapFlags Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeline"></td>
    <td class="lineNumber">1291</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeline">  /// Try to apply information from loop guards for \p L to \p Expr.</td>
    <td class="lineNumber">1292</td>
    <td class="codeline">  /// Try to apply information from loop guards for \p L to \p Expr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeline">  const SCEV *applyLoopGuards(const SCEV *Expr, const Loop *L);</td>
    <td class="lineNumber">1293</td>
    <td class="codeline">  const SCEV *applyLoopGuards(const SCEV *Expr, const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeline"></td>
    <td class="lineNumber">1294</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeline">  /// Return true if the loop has no abnormal exits. That is, if the loop</td>
    <td class="lineNumber">1295</td>
    <td class="codeline">  /// Return true if the loop has no abnormal exits. That is, if the loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeline">  /// is not infinite, it must exit through an explicit edge in the CFG.</td>
    <td class="lineNumber">1296</td>
    <td class="codeline">  /// is not infinite, it must exit through an explicit edge in the CFG.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeline">  /// (As opposed to either a) throwing out of the function or b) entering a</td>
    <td class="lineNumber">1297</td>
    <td class="codeline">  /// (As opposed to either a) throwing out of the function or b) entering a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeline">  /// well defined infinite loop in some callee.)</td>
    <td class="lineNumber">1298</td>
    <td class="codeline">  /// well defined infinite loop in some callee.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeline">  bool loopHasNoAbnormalExits(const Loop *L) {</td>
    <td class="lineNumber">1299</td>
    <td class="codeline">  bool loopHasNoAbnormalExits(const Loop *L) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeline">    return getLoopProperties(L).HasNoAbnormalExits;</td>
    <td class="lineNumber">1300</td>
    <td class="codeline">    return getLoopProperties(L).HasNoAbnormalExits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1301</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeline"></td>
    <td class="lineNumber">1302</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeline">  /// Return true if this loop is finite by assumption.  That is,</td>
    <td class="lineNumber">1303</td>
    <td class="codeline">  /// Return true if this loop is finite by assumption.  That is,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeline">  /// to be infinite, it must also be undefined.</td>
    <td class="lineNumber">1304</td>
    <td class="codeline">  /// to be infinite, it must also be undefined.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeline">  bool loopIsFiniteByAssumption(const Loop *L);</td>
    <td class="lineNumber">1305</td>
    <td class="codeline">  bool loopIsFiniteByAssumption(const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeline"></td>
    <td class="lineNumber">1306</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeline">  class FoldID {</td>
    <td class="lineNumber">1307</td>
    <td class="codeline">  class FoldID {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeline">    const SCEV *Op = nullptr;</td>
    <td class="lineNumber">1308</td>
    <td class="codeline">    const SCEV *Op = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeline">    const Type *Ty = nullptr;</td>
    <td class="lineNumber">1309</td>
    <td class="codeline">    const Type *Ty = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeline">    unsigned short C;</td>
    <td class="lineNumber">1310</td>
    <td class="codeline">    unsigned short C;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
    <td class="lineNumber">1311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">1312</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeline">    FoldID(SCEVTypes C, const SCEV *Op, const Type *Ty) : Op(Op), Ty(Ty), C(C) {</td>
    <td class="lineNumber">1313</td>
    <td class="codeline">    FoldID(SCEVTypes C, const SCEV *Op, const Type *Ty) : Op(Op), Ty(Ty), C(C) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeline">      assert(Op);</td>
    <td class="lineNumber">1314</td>
    <td class="codeline">      assert(Op);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeline">      assert(Ty);</td>
    <td class="lineNumber">1315</td>
    <td class="codeline">      assert(Ty);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1316</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
    <td class="lineNumber">1317</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeline">    FoldID(unsigned short C) : C(C) {}</td>
    <td class="lineNumber">1318</td>
    <td class="codeline">    FoldID(unsigned short C) : C(C) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeline"></td>
    <td class="lineNumber">1319</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeline">    unsigned computeHash() const {</td>
    <td class="lineNumber">1320</td>
    <td class="codeline">    unsigned computeHash() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeline">      return detail::combineHashValue(</td>
    <td class="lineNumber">1321</td>
    <td class="codeline">      return detail::combineHashValue(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeline">          C, detail::combineHashValue(reinterpret_cast<uintptr_t>(Op),</td>
    <td class="lineNumber">1322</td>
    <td class="codeline">          C, detail::combineHashValue(reinterpret_cast<uintptr_t>(Op),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeline">                                      reinterpret_cast<uintptr_t>(Ty)));</td>
    <td class="lineNumber">1323</td>
    <td class="codeline">                                      reinterpret_cast<uintptr_t>(Ty)));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1324</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeline"></td>
    <td class="lineNumber">1325</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeline">    bool operator==(const FoldID &RHS) const {</td>
    <td class="lineNumber">1326</td>
    <td class="codeline">    bool operator==(const FoldID &RHS) const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeline">      return std::tie(Op, Ty, C) == std::tie(RHS.Op, RHS.Ty, RHS.C);</td>
    <td class="lineNumber">1327</td>
    <td class="codeline">      return std::tie(Op, Ty, C) == std::tie(RHS.Op, RHS.Ty, RHS.C);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1328</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1329</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeline"></td>
    <td class="lineNumber">1330</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">1331</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeline">  /// A CallbackVH to arrange for ScalarEvolution to be notified whenever a</td>
    <td class="lineNumber">1332</td>
    <td class="codeline">  /// A CallbackVH to arrange for ScalarEvolution to be notified whenever a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeline">  /// Value is deleted.</td>
    <td class="lineNumber">1333</td>
    <td class="codeline">  /// Value is deleted.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeline">  class SCEVCallbackVH final : public CallbackVH {</td>
    <td class="lineNumber">1334</td>
    <td class="codeline">  class SCEVCallbackVH final : public CallbackVH {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeline">    ScalarEvolution *SE;</td>
    <td class="lineNumber">1335</td>
    <td class="codeline">    ScalarEvolution *SE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeline"></td>
    <td class="lineNumber">1336</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeline">    void deleted() override;</td>
    <td class="lineNumber">1337</td>
    <td class="codeline">    void deleted() override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeline">    void allUsesReplacedWith(Value *New) override;</td>
    <td class="lineNumber">1338</td>
    <td class="codeline">    void allUsesReplacedWith(Value *New) override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeline"></td>
    <td class="lineNumber">1339</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">1340</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeline">    SCEVCallbackVH(Value *V, ScalarEvolution *SE = nullptr);</td>
    <td class="lineNumber">1341</td>
    <td class="codeline">    SCEVCallbackVH(Value *V, ScalarEvolution *SE = nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1342</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
    <td class="lineNumber">1343</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeline">  friend class SCEVCallbackVH;</td>
    <td class="lineNumber">1344</td>
    <td class="codeline">  friend class SCEVCallbackVH;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeline">  friend class SCEVExpander;</td>
    <td class="lineNumber">1345</td>
    <td class="codeline">  friend class SCEVExpander;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeline">  friend class SCEVUnknown;</td>
    <td class="lineNumber">1346</td>
    <td class="codeline">  friend class SCEVUnknown;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeline"></td>
    <td class="lineNumber">1347</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeline">  /// The function we are analyzing.</td>
    <td class="lineNumber">1348</td>
    <td class="codeline">  /// The function we are analyzing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeline">  Function &F;</td>
    <td class="lineNumber">1349</td>
    <td class="codeline">  Function &F;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeline"></td>
    <td class="lineNumber">1350</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeline">  /// Does the module have any calls to the llvm.experimental.guard intrinsic</td>
    <td class="lineNumber">1351</td>
    <td class="codeline">  /// Does the module have any calls to the llvm.experimental.guard intrinsic</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeline">  /// at all?  If this is false, we avoid doing work that will only help if</td>
    <td class="lineNumber">1352</td>
    <td class="codeline">  /// at all?  If this is false, we avoid doing work that will only help if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeline">  /// thare are guards present in the IR.</td>
    <td class="lineNumber">1353</td>
    <td class="codeline">  /// thare are guards present in the IR.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeline">  bool HasGuards;</td>
    <td class="lineNumber">1354</td>
    <td class="codeline">  bool HasGuards;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeline"></td>
    <td class="lineNumber">1355</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeline">  /// The target library information for the target we are targeting.</td>
    <td class="lineNumber">1356</td>
    <td class="codeline">  /// The target library information for the target we are targeting.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeline">  TargetLibraryInfo &TLI;</td>
    <td class="lineNumber">1357</td>
    <td class="codeline">  TargetLibraryInfo &TLI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeline"></td>
    <td class="lineNumber">1358</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeline">  /// The tracker for \@llvm.assume intrinsics in this function.</td>
    <td class="lineNumber">1359</td>
    <td class="codeline">  /// The tracker for \@llvm.assume intrinsics in this function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeline">  AssumptionCache &AC;</td>
    <td class="lineNumber">1360</td>
    <td class="codeline">  AssumptionCache &AC;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeline"></td>
    <td class="lineNumber">1361</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeline">  /// The dominator tree.</td>
    <td class="lineNumber">1362</td>
    <td class="codeline">  /// The dominator tree.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeline">  DominatorTree &DT;</td>
    <td class="lineNumber">1363</td>
    <td class="codeline">  DominatorTree &DT;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeline"></td>
    <td class="lineNumber">1364</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeline">  /// The loop information for the function we are currently analyzing.</td>
    <td class="lineNumber">1365</td>
    <td class="codeline">  /// The loop information for the function we are currently analyzing.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeline">  LoopInfo &LI;</td>
    <td class="lineNumber">1366</td>
    <td class="codeline">  LoopInfo &LI;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeline"></td>
    <td class="lineNumber">1367</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeline">  /// This SCEV is used to represent unknown trip counts and things.</td>
    <td class="lineNumber">1368</td>
    <td class="codeline">  /// This SCEV is used to represent unknown trip counts and things.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeline">  std::unique_ptr<SCEVCouldNotCompute> CouldNotCompute;</td>
    <td class="lineNumber">1369</td>
    <td class="codeline">  std::unique_ptr<SCEVCouldNotCompute> CouldNotCompute;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeline"></td>
    <td class="lineNumber">1370</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeline">  /// The type for HasRecMap.</td>
    <td class="lineNumber">1371</td>
    <td class="codeline">  /// The type for HasRecMap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeline">  using HasRecMapType = DenseMap<const SCEV *, bool>;</td>
    <td class="lineNumber">1372</td>
    <td class="codeline">  using HasRecMapType = DenseMap<const SCEV *, bool>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeline"></td>
    <td class="lineNumber">1373</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeline">  /// This is a cache to record whether a SCEV contains any scAddRecExpr.</td>
    <td class="lineNumber">1374</td>
    <td class="codeline">  /// This is a cache to record whether a SCEV contains any scAddRecExpr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeline">  HasRecMapType HasRecMap;</td>
    <td class="lineNumber">1375</td>
    <td class="codeline">  HasRecMapType HasRecMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeline"></td>
    <td class="lineNumber">1376</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeline">  /// The type for ExprValueMap.</td>
    <td class="lineNumber">1377</td>
    <td class="codeline">  /// The type for ExprValueMap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeline">  using ValueSetVector = SmallSetVector<Value *, 4>;</td>
    <td class="lineNumber">1378</td>
    <td class="codeline">  using ValueSetVector = SmallSetVector<Value *, 4>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeline">  using ExprValueMapType = DenseMap<const SCEV *, ValueSetVector>;</td>
    <td class="lineNumber">1379</td>
    <td class="codeline">  using ExprValueMapType = DenseMap<const SCEV *, ValueSetVector>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeline"></td>
    <td class="lineNumber">1380</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeline">  /// ExprValueMap -- This map records the original values from which</td>
    <td class="lineNumber">1381</td>
    <td class="codeline">  /// ExprValueMap -- This map records the original values from which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeline">  /// the SCEV expr is generated from.</td>
    <td class="lineNumber">1382</td>
    <td class="codeline">  /// the SCEV expr is generated from.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeline">  ExprValueMapType ExprValueMap;</td>
    <td class="lineNumber">1383</td>
    <td class="codeline">  ExprValueMapType ExprValueMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeline"></td>
    <td class="lineNumber">1384</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeline">  /// The type for ValueExprMap.</td>
    <td class="lineNumber">1385</td>
    <td class="codeline">  /// The type for ValueExprMap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeline">  using ValueExprMapType =</td>
    <td class="lineNumber">1386</td>
    <td class="codeline">  using ValueExprMapType =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeline">      DenseMap<SCEVCallbackVH, const SCEV *, DenseMapInfo<Value *>>;</td>
    <td class="lineNumber">1387</td>
    <td class="codeline">      DenseMap<SCEVCallbackVH, const SCEV *, DenseMapInfo<Value *>>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeline"></td>
    <td class="lineNumber">1388</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeline">  /// This is a cache of the values we have analyzed so far.</td>
    <td class="lineNumber">1389</td>
    <td class="codeline">  /// This is a cache of the values we have analyzed so far.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeline">  ValueExprMapType ValueExprMap;</td>
    <td class="lineNumber">1390</td>
    <td class="codeline">  ValueExprMapType ValueExprMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeline"></td>
    <td class="lineNumber">1391</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeline">  /// This is a cache for expressions that got folded to a different existing</td>
    <td class="lineNumber">1392</td>
    <td class="codeline">  /// This is a cache for expressions that got folded to a different existing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeline">  /// SCEV.</td>
    <td class="lineNumber">1393</td>
    <td class="codeline">  /// SCEV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeline">  DenseMap<FoldID, const SCEV *> FoldCache;</td>
    <td class="lineNumber">1394</td>
    <td class="codeline">  DenseMap<FoldID, const SCEV *> FoldCache;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeline">  DenseMap<const SCEV *, SmallVector<FoldID, 2>> FoldCacheUser;</td>
    <td class="lineNumber">1395</td>
    <td class="codeline">  DenseMap<const SCEV *, SmallVector<FoldID, 2>> FoldCacheUser;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeline"></td>
    <td class="lineNumber">1396</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeline">  /// Mark predicate values currently being processed by isImpliedCond.</td>
    <td class="lineNumber">1397</td>
    <td class="codeline">  /// Mark predicate values currently being processed by isImpliedCond.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeline">  SmallPtrSet<const Value *, 6> PendingLoopPredicates;</td>
    <td class="lineNumber">1398</td>
    <td class="codeline">  SmallPtrSet<const Value *, 6> PendingLoopPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeline"></td>
    <td class="lineNumber">1399</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeline">  /// Mark SCEVUnknown Phis currently being processed by getRangeRef.</td>
    <td class="lineNumber">1400</td>
    <td class="codeline">  /// Mark SCEVUnknown Phis currently being processed by getRangeRef.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeline">  SmallPtrSet<const PHINode *, 6> PendingPhiRanges;</td>
    <td class="lineNumber">1401</td>
    <td class="codeline">  SmallPtrSet<const PHINode *, 6> PendingPhiRanges;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeline"></td>
    <td class="lineNumber">1402</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeline">  /// Mark SCEVUnknown Phis currently being processed by getRangeRefIter.</td>
    <td class="lineNumber">1403</td>
    <td class="codeline">  /// Mark SCEVUnknown Phis currently being processed by getRangeRefIter.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeline">  SmallPtrSet<const PHINode *, 6> PendingPhiRangesIter;</td>
    <td class="lineNumber">1404</td>
    <td class="codeline">  SmallPtrSet<const PHINode *, 6> PendingPhiRangesIter;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeline"></td>
    <td class="lineNumber">1405</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeline">  // Mark SCEVUnknown Phis currently being processed by isImpliedViaMerge.</td>
    <td class="lineNumber">1406</td>
    <td class="codeline">  // Mark SCEVUnknown Phis currently being processed by isImpliedViaMerge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeline">  SmallPtrSet<const PHINode *, 6> PendingMerges;</td>
    <td class="lineNumber">1407</td>
    <td class="codeline">  SmallPtrSet<const PHINode *, 6> PendingMerges;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeline"></td>
    <td class="lineNumber">1408</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeline">  /// Set to true by isLoopBackedgeGuardedByCond when we're walking the set of</td>
    <td class="lineNumber">1409</td>
    <td class="codeline">  /// Set to true by isLoopBackedgeGuardedByCond when we're walking the set of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeline">  /// conditions dominating the backedge of a loop.</td>
    <td class="lineNumber">1410</td>
    <td class="codeline">  /// conditions dominating the backedge of a loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeline">  bool WalkingBEDominatingConds = false;</td>
    <td class="lineNumber">1411</td>
    <td class="codeline">  bool WalkingBEDominatingConds = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeline"></td>
    <td class="lineNumber">1412</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeline">  /// Set to true by isKnownPredicateViaSplitting when we're trying to prove a</td>
    <td class="lineNumber">1413</td>
    <td class="codeline">  /// Set to true by isKnownPredicateViaSplitting when we're trying to prove a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeline">  /// predicate by splitting it into a set of independent predicates.</td>
    <td class="lineNumber">1414</td>
    <td class="codeline">  /// predicate by splitting it into a set of independent predicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeline">  bool ProvingSplitPredicate = false;</td>
    <td class="lineNumber">1415</td>
    <td class="codeline">  bool ProvingSplitPredicate = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeline"></td>
    <td class="lineNumber">1416</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeline">  /// Memoized values for the getConstantMultiple</td>
    <td class="lineNumber">1417</td>
    <td class="codeline">  /// Memoized values for the getConstantMultiple</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeline">  DenseMap<const SCEV *, APInt> ConstantMultipleCache;</td>
    <td class="lineNumber">1418</td>
    <td class="codeline">  DenseMap<const SCEV *, APInt> ConstantMultipleCache;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeline"></td>
    <td class="lineNumber">1419</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeline">  /// Return the Value set from which the SCEV expr is generated.</td>
    <td class="lineNumber">1420</td>
    <td class="codeline">  /// Return the Value set from which the SCEV expr is generated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeline">  ArrayRef<Value *> getSCEVValues(const SCEV *S);</td>
    <td class="lineNumber">1421</td>
    <td class="codeline">  ArrayRef<Value *> getSCEVValues(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeline"></td>
    <td class="lineNumber">1422</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeline">  /// Private helper method for the getConstantMultiple method.</td>
    <td class="lineNumber">1423</td>
    <td class="codeline">  /// Private helper method for the getConstantMultiple method.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeline">  APInt getConstantMultipleImpl(const SCEV *S);</td>
    <td class="lineNumber">1424</td>
    <td class="codeline">  APInt getConstantMultipleImpl(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeline"></td>
    <td class="lineNumber">1425</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeline">  /// Information about the number of times a particular loop exit may be</td>
    <td class="lineNumber">1426</td>
    <td class="codeline">  /// Information about the number of times a particular loop exit may be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeline">  /// reached before exiting the loop.</td>
    <td class="lineNumber">1427</td>
    <td class="codeline">  /// reached before exiting the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeline">  struct ExitNotTakenInfo {</td>
    <td class="lineNumber">1428</td>
    <td class="codeline">  struct ExitNotTakenInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeline">    PoisoningVH<BasicBlock> ExitingBlock;</td>
    <td class="lineNumber">1429</td>
    <td class="codeline">    PoisoningVH<BasicBlock> ExitingBlock;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeline">    const SCEV *ExactNotTaken;</td>
    <td class="lineNumber">1430</td>
    <td class="codeline">    const SCEV *ExactNotTaken;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeline">    const SCEV *ConstantMaxNotTaken;</td>
    <td class="lineNumber">1431</td>
    <td class="codeline">    const SCEV *ConstantMaxNotTaken;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeline">    const SCEV *SymbolicMaxNotTaken;</td>
    <td class="lineNumber">1432</td>
    <td class="codeline">    const SCEV *SymbolicMaxNotTaken;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeline">    SmallPtrSet<const SCEVPredicate *, 4> Predicates;</td>
    <td class="lineNumber">1433</td>
    <td class="codeline">    SmallPtrSet<const SCEVPredicate *, 4> Predicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeline"></td>
    <td class="lineNumber">1434</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeline">    explicit ExitNotTakenInfo(</td>
    <td class="lineNumber">1435</td>
    <td class="codeline">    explicit ExitNotTakenInfo(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeline">        PoisoningVH<BasicBlock> ExitingBlock, const SCEV *ExactNotTaken,</td>
    <td class="lineNumber">1436</td>
    <td class="codeline">        PoisoningVH<BasicBlock> ExitingBlock, const SCEV *ExactNotTaken,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeline">        const SCEV *ConstantMaxNotTaken, const SCEV *SymbolicMaxNotTaken,</td>
    <td class="lineNumber">1437</td>
    <td class="codeline">        const SCEV *ConstantMaxNotTaken, const SCEV *SymbolicMaxNotTaken,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeline">        const SmallPtrSet<const SCEVPredicate *, 4> &Predicates)</td>
    <td class="lineNumber">1438</td>
    <td class="codeline">        const SmallPtrSet<const SCEVPredicate *, 4> &Predicates)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeline">        : ExitingBlock(ExitingBlock), ExactNotTaken(ExactNotTaken),</td>
    <td class="lineNumber">1439</td>
    <td class="codeline">        : ExitingBlock(ExitingBlock), ExactNotTaken(ExactNotTaken),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeline">          ConstantMaxNotTaken(ConstantMaxNotTaken),</td>
    <td class="lineNumber">1440</td>
    <td class="codeline">          ConstantMaxNotTaken(ConstantMaxNotTaken),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeline">          SymbolicMaxNotTaken(SymbolicMaxNotTaken), Predicates(Predicates) {}</td>
    <td class="lineNumber">1441</td>
    <td class="codeline">          SymbolicMaxNotTaken(SymbolicMaxNotTaken), Predicates(Predicates) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeline"></td>
    <td class="lineNumber">1442</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeline">    bool hasAlwaysTruePredicate() const {</td>
    <td class="lineNumber">1443</td>
    <td class="codeline">    bool hasAlwaysTruePredicate() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeline">      return Predicates.empty();</td>
    <td class="lineNumber">1444</td>
    <td class="codeline">      return Predicates.empty();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1445</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1446</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeline"></td>
    <td class="lineNumber">1447</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeline">  /// Information about the backedge-taken count of a loop. This currently</td>
    <td class="lineNumber">1448</td>
    <td class="codeline">  /// Information about the backedge-taken count of a loop. This currently</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeline">  /// includes an exact count and a maximum count.</td>
    <td class="lineNumber">1449</td>
    <td class="codeline">  /// includes an exact count and a maximum count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1450</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeline">  class BackedgeTakenInfo {</td>
    <td class="lineNumber">1451</td>
    <td class="codeline">  class BackedgeTakenInfo {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeline">    friend class ScalarEvolution;</td>
    <td class="lineNumber">1452</td>
    <td class="codeline">    friend class ScalarEvolution;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeline"></td>
    <td class="lineNumber">1453</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeline">    /// A list of computable exits and their not-taken counts.  Loops almost</td>
    <td class="lineNumber">1454</td>
    <td class="codeline">    /// A list of computable exits and their not-taken counts.  Loops almost</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeline">    /// never have more than one computable exit.</td>
    <td class="lineNumber">1455</td>
    <td class="codeline">    /// never have more than one computable exit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeline">    SmallVector<ExitNotTakenInfo, 1> ExitNotTaken;</td>
    <td class="lineNumber">1456</td>
    <td class="codeline">    SmallVector<ExitNotTakenInfo, 1> ExitNotTaken;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeline"></td>
    <td class="lineNumber">1457</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeline">    /// Expression indicating the least constant maximum backedge-taken count of</td>
    <td class="lineNumber">1458</td>
    <td class="codeline">    /// Expression indicating the least constant maximum backedge-taken count of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeline">    /// the loop that is known, or a SCEVCouldNotCompute. This expression is</td>
    <td class="lineNumber">1459</td>
    <td class="codeline">    /// the loop that is known, or a SCEVCouldNotCompute. This expression is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeline">    /// only valid if the redicates associated with all loop exits are true.</td>
    <td class="lineNumber">1460</td>
    <td class="codeline">    /// only valid if the redicates associated with all loop exits are true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeline">    const SCEV *ConstantMax = nullptr;</td>
    <td class="lineNumber">1461</td>
    <td class="codeline">    const SCEV *ConstantMax = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeline"></td>
    <td class="lineNumber">1462</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeline">    /// Indicating if \c ExitNotTaken has an element for every exiting block in</td>
    <td class="lineNumber">1463</td>
    <td class="codeline">    /// Indicating if \c ExitNotTaken has an element for every exiting block in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeline">    /// the loop.</td>
    <td class="lineNumber">1464</td>
    <td class="codeline">    /// the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeline">    bool IsComplete = false;</td>
    <td class="lineNumber">1465</td>
    <td class="codeline">    bool IsComplete = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeline"></td>
    <td class="lineNumber">1466</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeline">    /// Expression indicating the least maximum backedge-taken count of the loop</td>
    <td class="lineNumber">1467</td>
    <td class="codeline">    /// Expression indicating the least maximum backedge-taken count of the loop</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeline">    /// that is known, or a SCEVCouldNotCompute. Lazily computed on first query.</td>
    <td class="lineNumber">1468</td>
    <td class="codeline">    /// that is known, or a SCEVCouldNotCompute. Lazily computed on first query.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeline">    const SCEV *SymbolicMax = nullptr;</td>
    <td class="lineNumber">1469</td>
    <td class="codeline">    const SCEV *SymbolicMax = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeline"></td>
    <td class="lineNumber">1470</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeline">    /// True iff the backedge is taken either exactly Max or zero times.</td>
    <td class="lineNumber">1471</td>
    <td class="codeline">    /// True iff the backedge is taken either exactly Max or zero times.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeline">    bool MaxOrZero = false;</td>
    <td class="lineNumber">1472</td>
    <td class="codeline">    bool MaxOrZero = false;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeline"></td>
    <td class="lineNumber">1473</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeline">    bool isComplete() const { return IsComplete; }</td>
    <td class="lineNumber">1474</td>
    <td class="codeline">    bool isComplete() const { return IsComplete; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeline">    const SCEV *getConstantMax() const { return ConstantMax; }</td>
    <td class="lineNumber">1475</td>
    <td class="codeline">    const SCEV *getConstantMax() const { return ConstantMax; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeline"></td>
    <td class="lineNumber">1476</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">1477</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeline">    BackedgeTakenInfo() = default;</td>
    <td class="lineNumber">1478</td>
    <td class="codeline">    BackedgeTakenInfo() = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeline">    BackedgeTakenInfo(BackedgeTakenInfo &&) = default;</td>
    <td class="lineNumber">1479</td>
    <td class="codeline">    BackedgeTakenInfo(BackedgeTakenInfo &&) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeline">    BackedgeTakenInfo &operator=(BackedgeTakenInfo &&) = default;</td>
    <td class="lineNumber">1480</td>
    <td class="codeline">    BackedgeTakenInfo &operator=(BackedgeTakenInfo &&) = default;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeline"></td>
    <td class="lineNumber">1481</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeline">    using EdgeExitInfo = std::pair<BasicBlock *, ExitLimit>;</td>
    <td class="lineNumber">1482</td>
    <td class="codeline">    using EdgeExitInfo = std::pair<BasicBlock *, ExitLimit>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeline"></td>
    <td class="lineNumber">1483</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeline">    /// Initialize BackedgeTakenInfo from a list of exact exit counts.</td>
    <td class="lineNumber">1484</td>
    <td class="codeline">    /// Initialize BackedgeTakenInfo from a list of exact exit counts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeline">    BackedgeTakenInfo(ArrayRef<EdgeExitInfo> ExitCounts, bool IsComplete,</td>
    <td class="lineNumber">1485</td>
    <td class="codeline">    BackedgeTakenInfo(ArrayRef<EdgeExitInfo> ExitCounts, bool IsComplete,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeline">                      const SCEV *ConstantMax, bool MaxOrZero);</td>
    <td class="lineNumber">1486</td>
    <td class="codeline">                      const SCEV *ConstantMax, bool MaxOrZero);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeline"></td>
    <td class="lineNumber">1487</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeline">    /// Test whether this BackedgeTakenInfo contains any computed information,</td>
    <td class="lineNumber">1488</td>
    <td class="codeline">    /// Test whether this BackedgeTakenInfo contains any computed information,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeline">    /// or whether it's all SCEVCouldNotCompute values.</td>
    <td class="lineNumber">1489</td>
    <td class="codeline">    /// or whether it's all SCEVCouldNotCompute values.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeline">    bool hasAnyInfo() const {</td>
    <td class="lineNumber">1490</td>
    <td class="codeline">    bool hasAnyInfo() const {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeline">      return !ExitNotTaken.empty() ||</td>
    <td class="lineNumber">1491</td>
    <td class="codeline">      return !ExitNotTaken.empty() ||</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeline">             !isa<SCEVCouldNotCompute>(getConstantMax());</td>
    <td class="lineNumber">1492</td>
    <td class="codeline">             !isa<SCEVCouldNotCompute>(getConstantMax());</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeline">    }</td>
    <td class="lineNumber">1493</td>
    <td class="codeline">    }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeline"></td>
    <td class="lineNumber">1494</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeline">    /// Test whether this BackedgeTakenInfo contains complete information.</td>
    <td class="lineNumber">1495</td>
    <td class="codeline">    /// Test whether this BackedgeTakenInfo contains complete information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeline">    bool hasFullInfo() const { return isComplete(); }</td>
    <td class="lineNumber">1496</td>
    <td class="codeline">    bool hasFullInfo() const { return isComplete(); }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeline"></td>
    <td class="lineNumber">1497</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeline">    /// Return an expression indicating the exact *backedge-taken*</td>
    <td class="lineNumber">1498</td>
    <td class="codeline">    /// Return an expression indicating the exact *backedge-taken*</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeline">    /// count of the loop if it is known or SCEVCouldNotCompute</td>
    <td class="lineNumber">1499</td>
    <td class="codeline">    /// count of the loop if it is known or SCEVCouldNotCompute</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeline">    /// otherwise.  If execution makes it to the backedge on every</td>
    <td class="lineNumber">1500</td>
    <td class="codeline">    /// otherwise.  If execution makes it to the backedge on every</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeline">    /// iteration (i.e. there are no abnormal exists like exception</td>
    <td class="lineNumber">1501</td>
    <td class="codeline">    /// iteration (i.e. there are no abnormal exists like exception</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeline">    /// throws and thread exits) then this is the number of times the</td>
    <td class="lineNumber">1502</td>
    <td class="codeline">    /// throws and thread exits) then this is the number of times the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeline">    /// loop header will execute minus one.</td>
    <td class="lineNumber">1503</td>
    <td class="codeline">    /// loop header will execute minus one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeline">    ///</td>
    <td class="lineNumber">1504</td>
    <td class="codeline">    ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeline">    /// If the SCEV predicate associated with the answer can be different</td>
    <td class="lineNumber">1505</td>
    <td class="codeline">    /// If the SCEV predicate associated with the answer can be different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeline">    /// from AlwaysTrue, we must add a (non null) Predicates argument.</td>
    <td class="lineNumber">1506</td>
    <td class="codeline">    /// from AlwaysTrue, we must add a (non null) Predicates argument.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeline">    /// The SCEV predicate associated with the answer will be added to</td>
    <td class="lineNumber">1507</td>
    <td class="codeline">    /// The SCEV predicate associated with the answer will be added to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeline">    /// Predicates. A run-time check needs to be emitted for the SCEV</td>
    <td class="lineNumber">1508</td>
    <td class="codeline">    /// Predicates. A run-time check needs to be emitted for the SCEV</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeline">    /// predicate in order for the answer to be valid.</td>
    <td class="lineNumber">1509</td>
    <td class="codeline">    /// predicate in order for the answer to be valid.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeline">    ///</td>
    <td class="lineNumber">1510</td>
    <td class="codeline">    ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeline">    /// Note that we should always know if we need to pass a predicate</td>
    <td class="lineNumber">1511</td>
    <td class="codeline">    /// Note that we should always know if we need to pass a predicate</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeline">    /// argument or not from the way the ExitCounts vector was computed.</td>
    <td class="lineNumber">1512</td>
    <td class="codeline">    /// argument or not from the way the ExitCounts vector was computed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeline">    /// If we allowed SCEV predicates to be generated when populating this</td>
    <td class="lineNumber">1513</td>
    <td class="codeline">    /// If we allowed SCEV predicates to be generated when populating this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeline">    /// vector, this information can contain them and therefore a</td>
    <td class="lineNumber">1514</td>
    <td class="codeline">    /// vector, this information can contain them and therefore a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeline">    /// SCEVPredicate argument should be added to getExact.</td>
    <td class="lineNumber">1515</td>
    <td class="codeline">    /// SCEVPredicate argument should be added to getExact.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeline">    const SCEV *getExact(const Loop *L, ScalarEvolution *SE,</td>
    <td class="lineNumber">1516</td>
    <td class="codeline">    const SCEV *getExact(const Loop *L, ScalarEvolution *SE,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeline">                         SmallVector<const SCEVPredicate *, 4> *Predicates = nullptr) const;</td>
    <td class="lineNumber">1517</td>
    <td class="codeline">                         SmallVector<const SCEVPredicate *, 4> *Predicates = nullptr) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeline"></td>
    <td class="lineNumber">1518</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeline">    /// Return the number of times this loop exit may fall through to the back</td>
    <td class="lineNumber">1519</td>
    <td class="codeline">    /// Return the number of times this loop exit may fall through to the back</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeline">    /// edge, or SCEVCouldNotCompute. The loop is guaranteed not to exit via</td>
    <td class="lineNumber">1520</td>
    <td class="codeline">    /// edge, or SCEVCouldNotCompute. The loop is guaranteed not to exit via</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeline">    /// this block before this number of iterations, but may exit via another</td>
    <td class="lineNumber">1521</td>
    <td class="codeline">    /// this block before this number of iterations, but may exit via another</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeline">    /// block.</td>
    <td class="lineNumber">1522</td>
    <td class="codeline">    /// block.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeline">    const SCEV *getExact(const BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">1523</td>
    <td class="codeline">    const SCEV *getExact(const BasicBlock *ExitingBlock,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeline">                         ScalarEvolution *SE) const;</td>
    <td class="lineNumber">1524</td>
    <td class="codeline">                         ScalarEvolution *SE) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeline"></td>
    <td class="lineNumber">1525</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeline">    /// Get the constant max backedge taken count for the loop.</td>
    <td class="lineNumber">1526</td>
    <td class="codeline">    /// Get the constant max backedge taken count for the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeline">    const SCEV *getConstantMax(ScalarEvolution *SE) const;</td>
    <td class="lineNumber">1527</td>
    <td class="codeline">    const SCEV *getConstantMax(ScalarEvolution *SE) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeline"></td>
    <td class="lineNumber">1528</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeline">    /// Get the constant max backedge taken count for the particular loop exit.</td>
    <td class="lineNumber">1529</td>
    <td class="codeline">    /// Get the constant max backedge taken count for the particular loop exit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeline">    const SCEV *getConstantMax(const BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">1530</td>
    <td class="codeline">    const SCEV *getConstantMax(const BasicBlock *ExitingBlock,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeline">                               ScalarEvolution *SE) const;</td>
    <td class="lineNumber">1531</td>
    <td class="codeline">                               ScalarEvolution *SE) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeline"></td>
    <td class="lineNumber">1532</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeline">    /// Get the symbolic max backedge taken count for the loop.</td>
    <td class="lineNumber">1533</td>
    <td class="codeline">    /// Get the symbolic max backedge taken count for the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeline">    const SCEV *getSymbolicMax(const Loop *L, ScalarEvolution *SE);</td>
    <td class="lineNumber">1534</td>
    <td class="codeline">    const SCEV *getSymbolicMax(const Loop *L, ScalarEvolution *SE);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeline"></td>
    <td class="lineNumber">1535</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeline">    /// Get the symbolic max backedge taken count for the particular loop exit.</td>
    <td class="lineNumber">1536</td>
    <td class="codeline">    /// Get the symbolic max backedge taken count for the particular loop exit.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeline">    const SCEV *getSymbolicMax(const BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">1537</td>
    <td class="codeline">    const SCEV *getSymbolicMax(const BasicBlock *ExitingBlock,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeline">                               ScalarEvolution *SE) const;</td>
    <td class="lineNumber">1538</td>
    <td class="codeline">                               ScalarEvolution *SE) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeline"></td>
    <td class="lineNumber">1539</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeline">    /// Return true if the number of times this backedge is taken is either the</td>
    <td class="lineNumber">1540</td>
    <td class="codeline">    /// Return true if the number of times this backedge is taken is either the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeline">    /// value returned by getConstantMax or zero.</td>
    <td class="lineNumber">1541</td>
    <td class="codeline">    /// value returned by getConstantMax or zero.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeline">    bool isConstantMaxOrZero(ScalarEvolution *SE) const;</td>
    <td class="lineNumber">1542</td>
    <td class="codeline">    bool isConstantMaxOrZero(ScalarEvolution *SE) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1543</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeline"></td>
    <td class="lineNumber">1544</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeline">  /// Cache the backedge-taken count of the loops for this function as they</td>
    <td class="lineNumber">1545</td>
    <td class="codeline">  /// Cache the backedge-taken count of the loops for this function as they</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeline">  /// are computed.</td>
    <td class="lineNumber">1546</td>
    <td class="codeline">  /// are computed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeline">  DenseMap<const Loop *, BackedgeTakenInfo> BackedgeTakenCounts;</td>
    <td class="lineNumber">1547</td>
    <td class="codeline">  DenseMap<const Loop *, BackedgeTakenInfo> BackedgeTakenCounts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
    <td class="lineNumber">1548</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeline">  /// Cache the predicated backedge-taken count of the loops for this</td>
    <td class="lineNumber">1549</td>
    <td class="codeline">  /// Cache the predicated backedge-taken count of the loops for this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeline">  /// function as they are computed.</td>
    <td class="lineNumber">1550</td>
    <td class="codeline">  /// function as they are computed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeline">  DenseMap<const Loop *, BackedgeTakenInfo> PredicatedBackedgeTakenCounts;</td>
    <td class="lineNumber">1551</td>
    <td class="codeline">  DenseMap<const Loop *, BackedgeTakenInfo> PredicatedBackedgeTakenCounts;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
    <td class="lineNumber">1552</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeline">  /// Loops whose backedge taken counts directly use this non-constant SCEV.</td>
    <td class="lineNumber">1553</td>
    <td class="codeline">  /// Loops whose backedge taken counts directly use this non-constant SCEV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeline">  DenseMap<const SCEV *, SmallPtrSet<PointerIntPair<const Loop *, 1, bool>, 4>></td>
    <td class="lineNumber">1554</td>
    <td class="codeline">  DenseMap<const SCEV *, SmallPtrSet<PointerIntPair<const Loop *, 1, bool>, 4>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeline">      BECountUsers;</td>
    <td class="lineNumber">1555</td>
    <td class="codeline">      BECountUsers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeline"></td>
    <td class="lineNumber">1556</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeline">  /// This map contains entries for all of the PHI instructions that we</td>
    <td class="lineNumber">1557</td>
    <td class="codeline">  /// This map contains entries for all of the PHI instructions that we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeline">  /// attempt to compute constant evolutions for.  This allows us to avoid</td>
    <td class="lineNumber">1558</td>
    <td class="codeline">  /// attempt to compute constant evolutions for.  This allows us to avoid</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeline">  /// potentially expensive recomputation of these properties.  An instruction</td>
    <td class="lineNumber">1559</td>
    <td class="codeline">  /// potentially expensive recomputation of these properties.  An instruction</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeline">  /// maps to null if we are unable to compute its exit value.</td>
    <td class="lineNumber">1560</td>
    <td class="codeline">  /// maps to null if we are unable to compute its exit value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeline">  DenseMap<PHINode *, Constant *> ConstantEvolutionLoopExitValue;</td>
    <td class="lineNumber">1561</td>
    <td class="codeline">  DenseMap<PHINode *, Constant *> ConstantEvolutionLoopExitValue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeline"></td>
    <td class="lineNumber">1562</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeline">  /// This map contains entries for all the expressions that we attempt to</td>
    <td class="lineNumber">1563</td>
    <td class="codeline">  /// This map contains entries for all the expressions that we attempt to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeline">  /// compute getSCEVAtScope information for, which can be expensive in</td>
    <td class="lineNumber">1564</td>
    <td class="codeline">  /// compute getSCEVAtScope information for, which can be expensive in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeline">  /// extreme cases.</td>
    <td class="lineNumber">1565</td>
    <td class="codeline">  /// extreme cases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeline">  DenseMap<const SCEV *, SmallVector<std::pair<const Loop *, const SCEV *>, 2>></td>
    <td class="lineNumber">1566</td>
    <td class="codeline">  DenseMap<const SCEV *, SmallVector<std::pair<const Loop *, const SCEV *>, 2>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeline">      ValuesAtScopes;</td>
    <td class="lineNumber">1567</td>
    <td class="codeline">      ValuesAtScopes;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeline"></td>
    <td class="lineNumber">1568</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeline">  /// Reverse map for invalidation purposes: Stores of which SCEV and which</td>
    <td class="lineNumber">1569</td>
    <td class="codeline">  /// Reverse map for invalidation purposes: Stores of which SCEV and which</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeline">  /// loop this is the value-at-scope of.</td>
    <td class="lineNumber">1570</td>
    <td class="codeline">  /// loop this is the value-at-scope of.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeline">  DenseMap<const SCEV *, SmallVector<std::pair<const Loop *, const SCEV *>, 2>></td>
    <td class="lineNumber">1571</td>
    <td class="codeline">  DenseMap<const SCEV *, SmallVector<std::pair<const Loop *, const SCEV *>, 2>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeline">      ValuesAtScopesUsers;</td>
    <td class="lineNumber">1572</td>
    <td class="codeline">      ValuesAtScopesUsers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeline"></td>
    <td class="lineNumber">1573</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeline">  /// Memoized computeLoopDisposition results.</td>
    <td class="lineNumber">1574</td>
    <td class="codeline">  /// Memoized computeLoopDisposition results.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeline">  DenseMap<const SCEV *,</td>
    <td class="lineNumber">1575</td>
    <td class="codeline">  DenseMap<const SCEV *,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeline">           SmallVector<PointerIntPair<const Loop *, 2, LoopDisposition>, 2>></td>
    <td class="lineNumber">1576</td>
    <td class="codeline">           SmallVector<PointerIntPair<const Loop *, 2, LoopDisposition>, 2>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeline">      LoopDispositions;</td>
    <td class="lineNumber">1577</td>
    <td class="codeline">      LoopDispositions;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeline"></td>
    <td class="lineNumber">1578</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeline">  struct LoopProperties {</td>
    <td class="lineNumber">1579</td>
    <td class="codeline">  struct LoopProperties {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeline">    /// Set to true if the loop contains no instruction that can abnormally exit</td>
    <td class="lineNumber">1580</td>
    <td class="codeline">    /// Set to true if the loop contains no instruction that can abnormally exit</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeline">    /// the loop (i.e. via throwing an exception, by terminating the thread</td>
    <td class="lineNumber">1581</td>
    <td class="codeline">    /// the loop (i.e. via throwing an exception, by terminating the thread</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeline">    /// cleanly or by infinite looping in a called function).  Strictly</td>
    <td class="lineNumber">1582</td>
    <td class="codeline">    /// cleanly or by infinite looping in a called function).  Strictly</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeline">    /// speaking, the last one is not leaving the loop, but is identical to</td>
    <td class="lineNumber">1583</td>
    <td class="codeline">    /// speaking, the last one is not leaving the loop, but is identical to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeline">    /// leaving the loop for reasoning about undefined behavior.</td>
    <td class="lineNumber">1584</td>
    <td class="codeline">    /// leaving the loop for reasoning about undefined behavior.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeline">    bool HasNoAbnormalExits;</td>
    <td class="lineNumber">1585</td>
    <td class="codeline">    bool HasNoAbnormalExits;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeline"></td>
    <td class="lineNumber">1586</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeline">    /// Set to true if the loop contains no instruction that can have side</td>
    <td class="lineNumber">1587</td>
    <td class="codeline">    /// Set to true if the loop contains no instruction that can have side</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeline">    /// effects (i.e. via throwing an exception, volatile or atomic access).</td>
    <td class="lineNumber">1588</td>
    <td class="codeline">    /// effects (i.e. via throwing an exception, volatile or atomic access).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeline">    bool HasNoSideEffects;</td>
    <td class="lineNumber">1589</td>
    <td class="codeline">    bool HasNoSideEffects;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1590</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeline"></td>
    <td class="lineNumber">1591</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeline">  /// Cache for \c getLoopProperties.</td>
    <td class="lineNumber">1592</td>
    <td class="codeline">  /// Cache for \c getLoopProperties.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeline">  DenseMap<const Loop *, LoopProperties> LoopPropertiesCache;</td>
    <td class="lineNumber">1593</td>
    <td class="codeline">  DenseMap<const Loop *, LoopProperties> LoopPropertiesCache;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeline"></td>
    <td class="lineNumber">1594</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeline">  /// Return a \c LoopProperties instance for \p L, creating one if necessary.</td>
    <td class="lineNumber">1595</td>
    <td class="codeline">  /// Return a \c LoopProperties instance for \p L, creating one if necessary.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeline">  LoopProperties getLoopProperties(const Loop *L);</td>
    <td class="lineNumber">1596</td>
    <td class="codeline">  LoopProperties getLoopProperties(const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeline"></td>
    <td class="lineNumber">1597</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeline">  bool loopHasNoSideEffects(const Loop *L) {</td>
    <td class="lineNumber">1598</td>
    <td class="codeline">  bool loopHasNoSideEffects(const Loop *L) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeline">    return getLoopProperties(L).HasNoSideEffects;</td>
    <td class="lineNumber">1599</td>
    <td class="codeline">    return getLoopProperties(L).HasNoSideEffects;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1600</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeline"></td>
    <td class="lineNumber">1601</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeline">  /// Compute a LoopDisposition value.</td>
    <td class="lineNumber">1602</td>
    <td class="codeline">  /// Compute a LoopDisposition value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeline">  LoopDisposition computeLoopDisposition(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">1603</td>
    <td class="codeline">  LoopDisposition computeLoopDisposition(const SCEV *S, const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeline"></td>
    <td class="lineNumber">1604</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeline">  /// Memoized computeBlockDisposition results.</td>
    <td class="lineNumber">1605</td>
    <td class="codeline">  /// Memoized computeBlockDisposition results.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeline">  DenseMap<</td>
    <td class="lineNumber">1606</td>
    <td class="codeline">  DenseMap<</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeline">      const SCEV *,</td>
    <td class="lineNumber">1607</td>
    <td class="codeline">      const SCEV *,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeline">      SmallVector<PointerIntPair<const BasicBlock *, 2, BlockDisposition>, 2>></td>
    <td class="lineNumber">1608</td>
    <td class="codeline">      SmallVector<PointerIntPair<const BasicBlock *, 2, BlockDisposition>, 2>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeline">      BlockDispositions;</td>
    <td class="lineNumber">1609</td>
    <td class="codeline">      BlockDispositions;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeline"></td>
    <td class="lineNumber">1610</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeline">  /// Compute a BlockDisposition value.</td>
    <td class="lineNumber">1611</td>
    <td class="codeline">  /// Compute a BlockDisposition value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeline">  BlockDisposition computeBlockDisposition(const SCEV *S, const BasicBlock *BB);</td>
    <td class="lineNumber">1612</td>
    <td class="codeline">  BlockDisposition computeBlockDisposition(const SCEV *S, const BasicBlock *BB);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeline"></td>
    <td class="lineNumber">1613</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeline">  /// Stores all SCEV that use a given SCEV as its direct operand.</td>
    <td class="lineNumber">1614</td>
    <td class="codeline">  /// Stores all SCEV that use a given SCEV as its direct operand.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeline">  DenseMap<const SCEV *, SmallPtrSet<const SCEV *, 8> > SCEVUsers;</td>
    <td class="lineNumber">1615</td>
    <td class="codeline">  DenseMap<const SCEV *, SmallPtrSet<const SCEV *, 8> > SCEVUsers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeline"></td>
    <td class="lineNumber">1616</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeline">  /// Memoized results from getRange</td>
    <td class="lineNumber">1617</td>
    <td class="codeline">  /// Memoized results from getRange</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeline">  DenseMap<const SCEV *, ConstantRange> UnsignedRanges;</td>
    <td class="lineNumber">1618</td>
    <td class="codeline">  DenseMap<const SCEV *, ConstantRange> UnsignedRanges;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeline"></td>
    <td class="lineNumber">1619</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeline">  /// Memoized results from getRange</td>
    <td class="lineNumber">1620</td>
    <td class="codeline">  /// Memoized results from getRange</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeline">  DenseMap<const SCEV *, ConstantRange> SignedRanges;</td>
    <td class="lineNumber">1621</td>
    <td class="codeline">  DenseMap<const SCEV *, ConstantRange> SignedRanges;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeline"></td>
    <td class="lineNumber">1622</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeline">  /// Used to parameterize getRange</td>
    <td class="lineNumber">1623</td>
    <td class="codeline">  /// Used to parameterize getRange</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeline">  enum RangeSignHint { HINT_RANGE_UNSIGNED, HINT_RANGE_SIGNED };</td>
    <td class="lineNumber">1624</td>
    <td class="codeline">  enum RangeSignHint { HINT_RANGE_UNSIGNED, HINT_RANGE_SIGNED };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeline"></td>
    <td class="lineNumber">1625</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeline">  /// Set the memoized range for the given SCEV.</td>
    <td class="lineNumber">1626</td>
    <td class="codeline">  /// Set the memoized range for the given SCEV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeline">  const ConstantRange &setRange(const SCEV *S, RangeSignHint Hint,</td>
    <td class="lineNumber">1627</td>
    <td class="codeline">  const ConstantRange &setRange(const SCEV *S, RangeSignHint Hint,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeline">                                ConstantRange CR) {</td>
    <td class="lineNumber">1628</td>
    <td class="codeline">                                ConstantRange CR) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeline">    DenseMap<const SCEV *, ConstantRange> &Cache =</td>
    <td class="lineNumber">1629</td>
    <td class="codeline">    DenseMap<const SCEV *, ConstantRange> &Cache =</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeline">        Hint == HINT_RANGE_UNSIGNED ? UnsignedRanges : SignedRanges;</td>
    <td class="lineNumber">1630</td>
    <td class="codeline">        Hint == HINT_RANGE_UNSIGNED ? UnsignedRanges : SignedRanges;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeline"></td>
    <td class="lineNumber">1631</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeline">    auto Pair = Cache.try_emplace(S, std::move(CR));</td>
    <td class="lineNumber">1632</td>
    <td class="codeline">    auto Pair = Cache.try_emplace(S, std::move(CR));</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeline">    if (!Pair.second)</td>
    <td class="lineNumber">1633</td>
    <td class="codeline">    if (!Pair.second)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeline">      Pair.first->second = std::move(CR);</td>
    <td class="lineNumber">1634</td>
    <td class="codeline">      Pair.first->second = std::move(CR);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeline">    return Pair.first->second;</td>
    <td class="lineNumber">1635</td>
    <td class="codeline">    return Pair.first->second;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">1636</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeline"></td>
    <td class="lineNumber">1637</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeline">  /// Determine the range for a particular SCEV.</td>
    <td class="lineNumber">1638</td>
    <td class="codeline">  /// Determine the range for a particular SCEV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeline">  /// NOTE: This returns a reference to an entry in a cache. It must be</td>
    <td class="lineNumber">1639</td>
    <td class="codeline">  /// NOTE: This returns a reference to an entry in a cache. It must be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeline">  /// copied if its needed for longer.</td>
    <td class="lineNumber">1640</td>
    <td class="codeline">  /// copied if its needed for longer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeline">  const ConstantRange &getRangeRef(const SCEV *S, RangeSignHint Hint,</td>
    <td class="lineNumber">1641</td>
    <td class="codeline">  const ConstantRange &getRangeRef(const SCEV *S, RangeSignHint Hint,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeline">                                   unsigned Depth = 0);</td>
    <td class="lineNumber">1642</td>
    <td class="codeline">                                   unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeline"></td>
    <td class="lineNumber">1643</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeline">  /// Determine the range for a particular SCEV, but evaluates ranges for</td>
    <td class="lineNumber">1644</td>
    <td class="codeline">  /// Determine the range for a particular SCEV, but evaluates ranges for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeline">  /// operands iteratively first.</td>
    <td class="lineNumber">1645</td>
    <td class="codeline">  /// operands iteratively first.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeline">  const ConstantRange &getRangeRefIter(const SCEV *S, RangeSignHint Hint);</td>
    <td class="lineNumber">1646</td>
    <td class="codeline">  const ConstantRange &getRangeRefIter(const SCEV *S, RangeSignHint Hint);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeline"></td>
    <td class="lineNumber">1647</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeline">  /// Determines the range for the affine SCEVAddRecExpr {\p Start,+,\p Step}.</td>
    <td class="lineNumber">1648</td>
    <td class="codeline">  /// Determines the range for the affine SCEVAddRecExpr {\p Start,+,\p Step}.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeline">  /// Helper for \c getRange.</td>
    <td class="lineNumber">1649</td>
    <td class="codeline">  /// Helper for \c getRange.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeline">  ConstantRange getRangeForAffineAR(const SCEV *Start, const SCEV *Step,</td>
    <td class="lineNumber">1650</td>
    <td class="codeline">  ConstantRange getRangeForAffineAR(const SCEV *Start, const SCEV *Step,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeline">                                    const APInt &MaxBECount);</td>
    <td class="lineNumber">1651</td>
    <td class="codeline">                                    const APInt &MaxBECount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeline"></td>
    <td class="lineNumber">1652</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeline">  /// Determines the range for the affine non-self-wrapping SCEVAddRecExpr {\p</td>
    <td class="lineNumber">1653</td>
    <td class="codeline">  /// Determines the range for the affine non-self-wrapping SCEVAddRecExpr {\p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeline">  /// Start,+,\p Step}<nw>.</td>
    <td class="lineNumber">1654</td>
    <td class="codeline">  /// Start,+,\p Step}<nw>.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeline">  ConstantRange getRangeForAffineNoSelfWrappingAR(const SCEVAddRecExpr *AddRec,</td>
    <td class="lineNumber">1655</td>
    <td class="codeline">  ConstantRange getRangeForAffineNoSelfWrappingAR(const SCEVAddRecExpr *AddRec,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeline">                                                  const SCEV *MaxBECount,</td>
    <td class="lineNumber">1656</td>
    <td class="codeline">                                                  const SCEV *MaxBECount,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeline">                                                  unsigned BitWidth,</td>
    <td class="lineNumber">1657</td>
    <td class="codeline">                                                  unsigned BitWidth,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeline">                                                  RangeSignHint SignHint);</td>
    <td class="lineNumber">1658</td>
    <td class="codeline">                                                  RangeSignHint SignHint);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeline"></td>
    <td class="lineNumber">1659</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeline">  /// Try to compute a range for the affine SCEVAddRecExpr {\p Start,+,\p</td>
    <td class="lineNumber">1660</td>
    <td class="codeline">  /// Try to compute a range for the affine SCEVAddRecExpr {\p Start,+,\p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeline">  /// Step} by "factoring out" a ternary expression from the add recurrence.</td>
    <td class="lineNumber">1661</td>
    <td class="codeline">  /// Step} by "factoring out" a ternary expression from the add recurrence.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeline">  /// Helper called by \c getRange.</td>
    <td class="lineNumber">1662</td>
    <td class="codeline">  /// Helper called by \c getRange.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeline">  ConstantRange getRangeViaFactoring(const SCEV *Start, const SCEV *Step,</td>
    <td class="lineNumber">1663</td>
    <td class="codeline">  ConstantRange getRangeViaFactoring(const SCEV *Start, const SCEV *Step,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeline">                                     const APInt &MaxBECount);</td>
    <td class="lineNumber">1664</td>
    <td class="codeline">                                     const APInt &MaxBECount);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeline"></td>
    <td class="lineNumber">1665</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeline">  /// If the unknown expression U corresponds to a simple recurrence, return</td>
    <td class="lineNumber">1666</td>
    <td class="codeline">  /// If the unknown expression U corresponds to a simple recurrence, return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeline">  /// a constant range which represents the entire recurrence.  Note that</td>
    <td class="lineNumber">1667</td>
    <td class="codeline">  /// a constant range which represents the entire recurrence.  Note that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeline">  /// *add* recurrences with loop invariant steps aren't represented by</td>
    <td class="lineNumber">1668</td>
    <td class="codeline">  /// *add* recurrences with loop invariant steps aren't represented by</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeline">  /// SCEVUnknowns and thus don't use this mechanism.</td>
    <td class="lineNumber">1669</td>
    <td class="codeline">  /// SCEVUnknowns and thus don't use this mechanism.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeline">  ConstantRange getRangeForUnknownRecurrence(const SCEVUnknown *U);</td>
    <td class="lineNumber">1670</td>
    <td class="codeline">  ConstantRange getRangeForUnknownRecurrence(const SCEVUnknown *U);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeline"></td>
    <td class="lineNumber">1671</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeline">  /// We know that there is no SCEV for the specified value.  Analyze the</td>
    <td class="lineNumber">1672</td>
    <td class="codeline">  /// We know that there is no SCEV for the specified value.  Analyze the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeline">  /// expression recursively.</td>
    <td class="lineNumber">1673</td>
    <td class="codeline">  /// expression recursively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeline">  const SCEV *createSCEV(Value *V);</td>
    <td class="lineNumber">1674</td>
    <td class="codeline">  const SCEV *createSCEV(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeline"></td>
    <td class="lineNumber">1675</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeline">  /// We know that there is no SCEV for the specified value. Create a new SCEV</td>
    <td class="lineNumber">1676</td>
    <td class="codeline">  /// We know that there is no SCEV for the specified value. Create a new SCEV</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeline">  /// for \p V iteratively.</td>
    <td class="lineNumber">1677</td>
    <td class="codeline">  /// for \p V iteratively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeline">  const SCEV *createSCEVIter(Value *V);</td>
    <td class="lineNumber">1678</td>
    <td class="codeline">  const SCEV *createSCEVIter(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeline">  /// Collect operands of \p V for which SCEV expressions should be constructed</td>
    <td class="lineNumber">1679</td>
    <td class="codeline">  /// Collect operands of \p V for which SCEV expressions should be constructed</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeline">  /// first. Returns a SCEV directly if it can be constructed trivially for \p</td>
    <td class="lineNumber">1680</td>
    <td class="codeline">  /// first. Returns a SCEV directly if it can be constructed trivially for \p</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeline">  /// V.</td>
    <td class="lineNumber">1681</td>
    <td class="codeline">  /// V.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeline">  const SCEV *getOperandsToCreate(Value *V, SmallVectorImpl<Value *> &Ops);</td>
    <td class="lineNumber">1682</td>
    <td class="codeline">  const SCEV *getOperandsToCreate(Value *V, SmallVectorImpl<Value *> &Ops);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeline"></td>
    <td class="lineNumber">1683</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeline">  /// Provide the special handling we need to analyze PHI SCEVs.</td>
    <td class="lineNumber">1684</td>
    <td class="codeline">  /// Provide the special handling we need to analyze PHI SCEVs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeline">  const SCEV *createNodeForPHI(PHINode *PN);</td>
    <td class="lineNumber">1685</td>
    <td class="codeline">  const SCEV *createNodeForPHI(PHINode *PN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeline"></td>
    <td class="lineNumber">1686</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeline">  /// Helper function called from createNodeForPHI.</td>
    <td class="lineNumber">1687</td>
    <td class="codeline">  /// Helper function called from createNodeForPHI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeline">  const SCEV *createAddRecFromPHI(PHINode *PN);</td>
    <td class="lineNumber">1688</td>
    <td class="codeline">  const SCEV *createAddRecFromPHI(PHINode *PN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeline"></td>
    <td class="lineNumber">1689</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeline">  /// A helper function for createAddRecFromPHI to handle simple cases.</td>
    <td class="lineNumber">1690</td>
    <td class="codeline">  /// A helper function for createAddRecFromPHI to handle simple cases.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeline">  const SCEV *createSimpleAffineAddRec(PHINode *PN, Value *BEValueV,</td>
    <td class="lineNumber">1691</td>
    <td class="codeline">  const SCEV *createSimpleAffineAddRec(PHINode *PN, Value *BEValueV,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeline">                                            Value *StartValueV);</td>
    <td class="lineNumber">1692</td>
    <td class="codeline">                                            Value *StartValueV);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeline"></td>
    <td class="lineNumber">1693</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeline">  /// Helper function called from createNodeForPHI.</td>
    <td class="lineNumber">1694</td>
    <td class="codeline">  /// Helper function called from createNodeForPHI.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeline">  const SCEV *createNodeFromSelectLikePHI(PHINode *PN);</td>
    <td class="lineNumber">1695</td>
    <td class="codeline">  const SCEV *createNodeFromSelectLikePHI(PHINode *PN);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
    <td class="lineNumber">1696</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeline">  /// Provide special handling for a select-like instruction (currently this</td>
    <td class="lineNumber">1697</td>
    <td class="codeline">  /// Provide special handling for a select-like instruction (currently this</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeline">  /// is either a select instruction or a phi node).  \p Ty is the type of the</td>
    <td class="lineNumber">1698</td>
    <td class="codeline">  /// is either a select instruction or a phi node).  \p Ty is the type of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeline">  /// instruction being processed, that is assumed equivalent to</td>
    <td class="lineNumber">1699</td>
    <td class="codeline">  /// instruction being processed, that is assumed equivalent to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeline">  /// "Cond ? TrueVal : FalseVal".</td>
    <td class="lineNumber">1700</td>
    <td class="codeline">  /// "Cond ? TrueVal : FalseVal".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeline">  std::optional<const SCEV *></td>
    <td class="lineNumber">1701</td>
    <td class="codeline">  std::optional<const SCEV *></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeline">  createNodeForSelectOrPHIInstWithICmpInstCond(Type *Ty, ICmpInst *Cond,</td>
    <td class="lineNumber">1702</td>
    <td class="codeline">  createNodeForSelectOrPHIInstWithICmpInstCond(Type *Ty, ICmpInst *Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeline">                                               Value *TrueVal, Value *FalseVal);</td>
    <td class="lineNumber">1703</td>
    <td class="codeline">                                               Value *TrueVal, Value *FalseVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeline"></td>
    <td class="lineNumber">1704</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeline">  /// See if we can model this select-like instruction via umin_seq expression.</td>
    <td class="lineNumber">1705</td>
    <td class="codeline">  /// See if we can model this select-like instruction via umin_seq expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeline">  const SCEV *createNodeForSelectOrPHIViaUMinSeq(Value *I, Value *Cond,</td>
    <td class="lineNumber">1706</td>
    <td class="codeline">  const SCEV *createNodeForSelectOrPHIViaUMinSeq(Value *I, Value *Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeline">                                                 Value *TrueVal,</td>
    <td class="lineNumber">1707</td>
    <td class="codeline">                                                 Value *TrueVal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeline">                                                 Value *FalseVal);</td>
    <td class="lineNumber">1708</td>
    <td class="codeline">                                                 Value *FalseVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeline"></td>
    <td class="lineNumber">1709</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeline">  /// Given a value \p V, which is a select-like instruction (currently this is</td>
    <td class="lineNumber">1710</td>
    <td class="codeline">  /// Given a value \p V, which is a select-like instruction (currently this is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeline">  /// either a select instruction or a phi node), which is assumed equivalent to</td>
    <td class="lineNumber">1711</td>
    <td class="codeline">  /// either a select instruction or a phi node), which is assumed equivalent to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeline">  ///   Cond ? TrueVal : FalseVal</td>
    <td class="lineNumber">1712</td>
    <td class="codeline">  ///   Cond ? TrueVal : FalseVal</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeline">  /// see if we can model it as a SCEV expression.</td>
    <td class="lineNumber">1713</td>
    <td class="codeline">  /// see if we can model it as a SCEV expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeline">  const SCEV *createNodeForSelectOrPHI(Value *V, Value *Cond, Value *TrueVal,</td>
    <td class="lineNumber">1714</td>
    <td class="codeline">  const SCEV *createNodeForSelectOrPHI(Value *V, Value *Cond, Value *TrueVal,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeline">                                       Value *FalseVal);</td>
    <td class="lineNumber">1715</td>
    <td class="codeline">                                       Value *FalseVal);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeline"></td>
    <td class="lineNumber">1716</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeline">  /// Provide the special handling we need to analyze GEP SCEVs.</td>
    <td class="lineNumber">1717</td>
    <td class="codeline">  /// Provide the special handling we need to analyze GEP SCEVs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeline">  const SCEV *createNodeForGEP(GEPOperator *GEP);</td>
    <td class="lineNumber">1718</td>
    <td class="codeline">  const SCEV *createNodeForGEP(GEPOperator *GEP);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeline"></td>
    <td class="lineNumber">1719</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeline">  /// Implementation code for getSCEVAtScope; called at most once for each</td>
    <td class="lineNumber">1720</td>
    <td class="codeline">  /// Implementation code for getSCEVAtScope; called at most once for each</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeline">  /// SCEV+Loop pair.</td>
    <td class="lineNumber">1721</td>
    <td class="codeline">  /// SCEV+Loop pair.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeline">  const SCEV *computeSCEVAtScope(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">1722</td>
    <td class="codeline">  const SCEV *computeSCEVAtScope(const SCEV *S, const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeline"></td>
    <td class="lineNumber">1723</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeline">  /// Return the BackedgeTakenInfo for the given loop, lazily computing new</td>
    <td class="lineNumber">1724</td>
    <td class="codeline">  /// Return the BackedgeTakenInfo for the given loop, lazily computing new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeline">  /// values if the loop hasn't been analyzed yet. The returned result is</td>
    <td class="lineNumber">1725</td>
    <td class="codeline">  /// values if the loop hasn't been analyzed yet. The returned result is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeline">  /// guaranteed not to be predicated.</td>
    <td class="lineNumber">1726</td>
    <td class="codeline">  /// guaranteed not to be predicated.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeline">  BackedgeTakenInfo &getBackedgeTakenInfo(const Loop *L);</td>
    <td class="lineNumber">1727</td>
    <td class="codeline">  BackedgeTakenInfo &getBackedgeTakenInfo(const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeline"></td>
    <td class="lineNumber">1728</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeline">  /// Similar to getBackedgeTakenInfo, but will add predicates as required</td>
    <td class="lineNumber">1729</td>
    <td class="codeline">  /// Similar to getBackedgeTakenInfo, but will add predicates as required</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeline">  /// with the purpose of returning complete information.</td>
    <td class="lineNumber">1730</td>
    <td class="codeline">  /// with the purpose of returning complete information.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeline">  const BackedgeTakenInfo &getPredicatedBackedgeTakenInfo(const Loop *L);</td>
    <td class="lineNumber">1731</td>
    <td class="codeline">  const BackedgeTakenInfo &getPredicatedBackedgeTakenInfo(const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeline"></td>
    <td class="lineNumber">1732</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeline">  /// Compute the number of times the specified loop will iterate.</td>
    <td class="lineNumber">1733</td>
    <td class="codeline">  /// Compute the number of times the specified loop will iterate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeline">  /// If AllowPredicates is set, we will create new SCEV predicates as</td>
    <td class="lineNumber">1734</td>
    <td class="codeline">  /// If AllowPredicates is set, we will create new SCEV predicates as</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeline">  /// necessary in order to return an exact answer.</td>
    <td class="lineNumber">1735</td>
    <td class="codeline">  /// necessary in order to return an exact answer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeline">  BackedgeTakenInfo computeBackedgeTakenCount(const Loop *L,</td>
    <td class="lineNumber">1736</td>
    <td class="codeline">  BackedgeTakenInfo computeBackedgeTakenCount(const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeline">                                              bool AllowPredicates = false);</td>
    <td class="lineNumber">1737</td>
    <td class="codeline">                                              bool AllowPredicates = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeline"></td>
    <td class="lineNumber">1738</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeline">  /// Compute the number of times the backedge of the specified loop will</td>
    <td class="lineNumber">1739</td>
    <td class="codeline">  /// Compute the number of times the backedge of the specified loop will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeline">  /// execute if it exits via the specified block. If AllowPredicates is set,</td>
    <td class="lineNumber">1740</td>
    <td class="codeline">  /// execute if it exits via the specified block. If AllowPredicates is set,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeline">  /// this call will try to use a minimal set of SCEV predicates in order to</td>
    <td class="lineNumber">1741</td>
    <td class="codeline">  /// this call will try to use a minimal set of SCEV predicates in order to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeline">  /// return an exact answer.</td>
    <td class="lineNumber">1742</td>
    <td class="codeline">  /// return an exact answer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeline">  ExitLimit computeExitLimit(const Loop *L, BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">1743</td>
    <td class="codeline">  ExitLimit computeExitLimit(const Loop *L, BasicBlock *ExitingBlock,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeline">                             bool AllowPredicates = false);</td>
    <td class="lineNumber">1744</td>
    <td class="codeline">                             bool AllowPredicates = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeline"></td>
    <td class="lineNumber">1745</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeline">  /// Return a symbolic upper bound for the backedge taken count of the loop.</td>
    <td class="lineNumber">1746</td>
    <td class="codeline">  /// Return a symbolic upper bound for the backedge taken count of the loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeline">  /// This is more general than getConstantMaxBackedgeTakenCount as it returns</td>
    <td class="lineNumber">1747</td>
    <td class="codeline">  /// This is more general than getConstantMaxBackedgeTakenCount as it returns</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeline">  /// an arbitrary expression as opposed to only constants.</td>
    <td class="lineNumber">1748</td>
    <td class="codeline">  /// an arbitrary expression as opposed to only constants.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeline">  const SCEV *computeSymbolicMaxBackedgeTakenCount(const Loop *L);</td>
    <td class="lineNumber">1749</td>
    <td class="codeline">  const SCEV *computeSymbolicMaxBackedgeTakenCount(const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeline"></td>
    <td class="lineNumber">1750</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeline">  // Helper functions for computeExitLimitFromCond to avoid exponential time</td>
    <td class="lineNumber">1751</td>
    <td class="codeline">  // Helper functions for computeExitLimitFromCond to avoid exponential time</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeline">  // complexity.</td>
    <td class="lineNumber">1752</td>
    <td class="codeline">  // complexity.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeline"></td>
    <td class="lineNumber">1753</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeline">  class ExitLimitCache {</td>
    <td class="lineNumber">1754</td>
    <td class="codeline">  class ExitLimitCache {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeline">    // It may look like we need key on the whole (L, ExitIfTrue,</td>
    <td class="lineNumber">1755</td>
    <td class="codeline">    // It may look like we need key on the whole (L, ExitIfTrue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeline">    // ControlsOnlyExit, AllowPredicates) tuple, but recursive calls to</td>
    <td class="lineNumber">1756</td>
    <td class="codeline">    // ControlsOnlyExit, AllowPredicates) tuple, but recursive calls to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeline">    // computeExitLimitFromCondCached from computeExitLimitFromCondImpl only</td>
    <td class="lineNumber">1757</td>
    <td class="codeline">    // computeExitLimitFromCondCached from computeExitLimitFromCondImpl only</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeline">    // vary the in \c ExitCond and \c ControlsOnlyExit parameters.  We remember</td>
    <td class="lineNumber">1758</td>
    <td class="codeline">    // vary the in \c ExitCond and \c ControlsOnlyExit parameters.  We remember</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeline">    // the initial values of the other values to assert our assumption.</td>
    <td class="lineNumber">1759</td>
    <td class="codeline">    // the initial values of the other values to assert our assumption.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeline">    SmallDenseMap<PointerIntPair<Value *, 1>, ExitLimit> TripCountMap;</td>
    <td class="lineNumber">1760</td>
    <td class="codeline">    SmallDenseMap<PointerIntPair<Value *, 1>, ExitLimit> TripCountMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeline"></td>
    <td class="lineNumber">1761</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeline">    const Loop *L;</td>
    <td class="lineNumber">1762</td>
    <td class="codeline">    const Loop *L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeline">    bool ExitIfTrue;</td>
    <td class="lineNumber">1763</td>
    <td class="codeline">    bool ExitIfTrue;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeline">    bool AllowPredicates;</td>
    <td class="lineNumber">1764</td>
    <td class="codeline">    bool AllowPredicates;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeline"></td>
    <td class="lineNumber">1765</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeline">  public:</td>
    <td class="lineNumber">1766</td>
    <td class="codeline">  public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeline">    ExitLimitCache(const Loop *L, bool ExitIfTrue, bool AllowPredicates)</td>
    <td class="lineNumber">1767</td>
    <td class="codeline">    ExitLimitCache(const Loop *L, bool ExitIfTrue, bool AllowPredicates)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeline">        : L(L), ExitIfTrue(ExitIfTrue), AllowPredicates(AllowPredicates) {}</td>
    <td class="lineNumber">1768</td>
    <td class="codeline">        : L(L), ExitIfTrue(ExitIfTrue), AllowPredicates(AllowPredicates) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeline"></td>
    <td class="lineNumber">1769</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeline">    std::optional<ExitLimit> find(const Loop *L, Value *ExitCond,</td>
    <td class="lineNumber">1770</td>
    <td class="codeline">    std::optional<ExitLimit> find(const Loop *L, Value *ExitCond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeline">                                  bool ExitIfTrue, bool ControlsOnlyExit,</td>
    <td class="lineNumber">1771</td>
    <td class="codeline">                                  bool ExitIfTrue, bool ControlsOnlyExit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeline">                                  bool AllowPredicates);</td>
    <td class="lineNumber">1772</td>
    <td class="codeline">                                  bool AllowPredicates);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeline"></td>
    <td class="lineNumber">1773</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeline">    void insert(const Loop *L, Value *ExitCond, bool ExitIfTrue,</td>
    <td class="lineNumber">1774</td>
    <td class="codeline">    void insert(const Loop *L, Value *ExitCond, bool ExitIfTrue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeline">                bool ControlsOnlyExit, bool AllowPredicates,</td>
    <td class="lineNumber">1775</td>
    <td class="codeline">                bool ControlsOnlyExit, bool AllowPredicates,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeline">                const ExitLimit &EL);</td>
    <td class="lineNumber">1776</td>
    <td class="codeline">                const ExitLimit &EL);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeline">  };</td>
    <td class="lineNumber">1777</td>
    <td class="codeline">  };</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeline"></td>
    <td class="lineNumber">1778</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeline">  using ExitLimitCacheTy = ExitLimitCache;</td>
    <td class="lineNumber">1779</td>
    <td class="codeline">  using ExitLimitCacheTy = ExitLimitCache;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeline"></td>
    <td class="lineNumber">1780</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeline">  ExitLimit computeExitLimitFromCondCached(ExitLimitCacheTy &Cache,</td>
    <td class="lineNumber">1781</td>
    <td class="codeline">  ExitLimit computeExitLimitFromCondCached(ExitLimitCacheTy &Cache,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeline">                                           const Loop *L, Value *ExitCond,</td>
    <td class="lineNumber">1782</td>
    <td class="codeline">                                           const Loop *L, Value *ExitCond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeline">                                           bool ExitIfTrue,</td>
    <td class="lineNumber">1783</td>
    <td class="codeline">                                           bool ExitIfTrue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeline">                                           bool ControlsOnlyExit,</td>
    <td class="lineNumber">1784</td>
    <td class="codeline">                                           bool ControlsOnlyExit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeline">                                           bool AllowPredicates);</td>
    <td class="lineNumber">1785</td>
    <td class="codeline">                                           bool AllowPredicates);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeline">  ExitLimit computeExitLimitFromCondImpl(ExitLimitCacheTy &Cache, const Loop *L,</td>
    <td class="lineNumber">1786</td>
    <td class="codeline">  ExitLimit computeExitLimitFromCondImpl(ExitLimitCacheTy &Cache, const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeline">                                         Value *ExitCond, bool ExitIfTrue,</td>
    <td class="lineNumber">1787</td>
    <td class="codeline">                                         Value *ExitCond, bool ExitIfTrue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeline">                                         bool ControlsOnlyExit,</td>
    <td class="lineNumber">1788</td>
    <td class="codeline">                                         bool ControlsOnlyExit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeline">                                         bool AllowPredicates);</td>
    <td class="lineNumber">1789</td>
    <td class="codeline">                                         bool AllowPredicates);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeline">  std::optional<ScalarEvolution::ExitLimit> computeExitLimitFromCondFromBinOp(</td>
    <td class="lineNumber">1790</td>
    <td class="codeline">  std::optional<ScalarEvolution::ExitLimit> computeExitLimitFromCondFromBinOp(</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeline">      ExitLimitCacheTy &Cache, const Loop *L, Value *ExitCond, bool ExitIfTrue,</td>
    <td class="lineNumber">1791</td>
    <td class="codeline">      ExitLimitCacheTy &Cache, const Loop *L, Value *ExitCond, bool ExitIfTrue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeline">      bool ControlsOnlyExit, bool AllowPredicates);</td>
    <td class="lineNumber">1792</td>
    <td class="codeline">      bool ControlsOnlyExit, bool AllowPredicates);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeline"></td>
    <td class="lineNumber">1793</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeline">  /// Compute the number of times the backedge of the specified loop will</td>
    <td class="lineNumber">1794</td>
    <td class="codeline">  /// Compute the number of times the backedge of the specified loop will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeline">  /// execute if its exit condition were a conditional branch of the ICmpInst</td>
    <td class="lineNumber">1795</td>
    <td class="codeline">  /// execute if its exit condition were a conditional branch of the ICmpInst</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeline">  /// ExitCond and ExitIfTrue. If AllowPredicates is set, this call will try</td>
    <td class="lineNumber">1796</td>
    <td class="codeline">  /// ExitCond and ExitIfTrue. If AllowPredicates is set, this call will try</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeline">  /// to use a minimal set of SCEV predicates in order to return an exact</td>
    <td class="lineNumber">1797</td>
    <td class="codeline">  /// to use a minimal set of SCEV predicates in order to return an exact</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeline">  /// answer.</td>
    <td class="lineNumber">1798</td>
    <td class="codeline">  /// answer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeline">  ExitLimit computeExitLimitFromICmp(const Loop *L, ICmpInst *ExitCond,</td>
    <td class="lineNumber">1799</td>
    <td class="codeline">  ExitLimit computeExitLimitFromICmp(const Loop *L, ICmpInst *ExitCond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeline">                                     bool ExitIfTrue,</td>
    <td class="lineNumber">1800</td>
    <td class="codeline">                                     bool ExitIfTrue,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeline">                                     bool IsSubExpr,</td>
    <td class="lineNumber">1801</td>
    <td class="codeline">                                     bool IsSubExpr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeline">                                     bool AllowPredicates = false);</td>
    <td class="lineNumber">1802</td>
    <td class="codeline">                                     bool AllowPredicates = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeline"></td>
    <td class="lineNumber">1803</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeline">  /// Variant of previous which takes the components representing an ICmp</td>
    <td class="lineNumber">1804</td>
    <td class="codeline">  /// Variant of previous which takes the components representing an ICmp</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeline">  /// as opposed to the ICmpInst itself.  Note that the prior version can</td>
    <td class="lineNumber">1805</td>
    <td class="codeline">  /// as opposed to the ICmpInst itself.  Note that the prior version can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeline">  /// return more precise results in some cases and is preferred when caller</td>
    <td class="lineNumber">1806</td>
    <td class="codeline">  /// return more precise results in some cases and is preferred when caller</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeline">  /// has a materialized ICmp.</td>
    <td class="lineNumber">1807</td>
    <td class="codeline">  /// has a materialized ICmp.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeline">  ExitLimit computeExitLimitFromICmp(const Loop *L, ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">1808</td>
    <td class="codeline">  ExitLimit computeExitLimitFromICmp(const Loop *L, ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeline">                                     const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">1809</td>
    <td class="codeline">                                     const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeline">                                     bool IsSubExpr,</td>
    <td class="lineNumber">1810</td>
    <td class="codeline">                                     bool IsSubExpr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeline">                                     bool AllowPredicates = false);</td>
    <td class="lineNumber">1811</td>
    <td class="codeline">                                     bool AllowPredicates = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeline"></td>
    <td class="lineNumber">1812</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeline">  /// Compute the number of times the backedge of the specified loop will</td>
    <td class="lineNumber">1813</td>
    <td class="codeline">  /// Compute the number of times the backedge of the specified loop will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeline">  /// execute if its exit condition were a switch with a single exiting case</td>
    <td class="lineNumber">1814</td>
    <td class="codeline">  /// execute if its exit condition were a switch with a single exiting case</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeline">  /// to ExitingBB.</td>
    <td class="lineNumber">1815</td>
    <td class="codeline">  /// to ExitingBB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeline">  ExitLimit computeExitLimitFromSingleExitSwitch(const Loop *L,</td>
    <td class="lineNumber">1816</td>
    <td class="codeline">  ExitLimit computeExitLimitFromSingleExitSwitch(const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeline">                                                 SwitchInst *Switch,</td>
    <td class="lineNumber">1817</td>
    <td class="codeline">                                                 SwitchInst *Switch,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeline">                                                 BasicBlock *ExitingBB,</td>
    <td class="lineNumber">1818</td>
    <td class="codeline">                                                 BasicBlock *ExitingBB,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeline">                                                 bool IsSubExpr);</td>
    <td class="lineNumber">1819</td>
    <td class="codeline">                                                 bool IsSubExpr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeline"></td>
    <td class="lineNumber">1820</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeline">  /// Compute the exit limit of a loop that is controlled by a</td>
    <td class="lineNumber">1821</td>
    <td class="codeline">  /// Compute the exit limit of a loop that is controlled by a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeline">  /// "(IV >> 1) != 0" type comparison.  We cannot compute the exact trip</td>
    <td class="lineNumber">1822</td>
    <td class="codeline">  /// "(IV >> 1) != 0" type comparison.  We cannot compute the exact trip</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeline">  /// count in these cases (since SCEV has no way of expressing them), but we</td>
    <td class="lineNumber">1823</td>
    <td class="codeline">  /// count in these cases (since SCEV has no way of expressing them), but we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeline">  /// can still sometimes compute an upper bound.</td>
    <td class="lineNumber">1824</td>
    <td class="codeline">  /// can still sometimes compute an upper bound.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1825</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeline">  /// Return an ExitLimit for a loop whose backedge is guarded by `LHS Pred</td>
    <td class="lineNumber">1826</td>
    <td class="codeline">  /// Return an ExitLimit for a loop whose backedge is guarded by `LHS Pred</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeline">  /// RHS`.</td>
    <td class="lineNumber">1827</td>
    <td class="codeline">  /// RHS`.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeline">  ExitLimit computeShiftCompareExitLimit(Value *LHS, Value *RHS, const Loop *L,</td>
    <td class="lineNumber">1828</td>
    <td class="codeline">  ExitLimit computeShiftCompareExitLimit(Value *LHS, Value *RHS, const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeline">                                         ICmpInst::Predicate Pred);</td>
    <td class="lineNumber">1829</td>
    <td class="codeline">                                         ICmpInst::Predicate Pred);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeline"></td>
    <td class="lineNumber">1830</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeline">  /// If the loop is known to execute a constant number of times (the</td>
    <td class="lineNumber">1831</td>
    <td class="codeline">  /// If the loop is known to execute a constant number of times (the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeline">  /// condition evolves only from constants), try to evaluate a few iterations</td>
    <td class="lineNumber">1832</td>
    <td class="codeline">  /// condition evolves only from constants), try to evaluate a few iterations</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeline">  /// of the loop until we get the exit condition gets a value of ExitWhen</td>
    <td class="lineNumber">1833</td>
    <td class="codeline">  /// of the loop until we get the exit condition gets a value of ExitWhen</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeline">  /// (true or false).  If we cannot evaluate the exit count of the loop,</td>
    <td class="lineNumber">1834</td>
    <td class="codeline">  /// (true or false).  If we cannot evaluate the exit count of the loop,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeline">  /// return CouldNotCompute.</td>
    <td class="lineNumber">1835</td>
    <td class="codeline">  /// return CouldNotCompute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeline">  const SCEV *computeExitCountExhaustively(const Loop *L, Value *Cond,</td>
    <td class="lineNumber">1836</td>
    <td class="codeline">  const SCEV *computeExitCountExhaustively(const Loop *L, Value *Cond,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeline">                                           bool ExitWhen);</td>
    <td class="lineNumber">1837</td>
    <td class="codeline">                                           bool ExitWhen);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeline"></td>
    <td class="lineNumber">1838</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeline">  /// Return the number of times an exit condition comparing the specified</td>
    <td class="lineNumber">1839</td>
    <td class="codeline">  /// Return the number of times an exit condition comparing the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeline">  /// value to zero will execute.  If not computable, return CouldNotCompute.</td>
    <td class="lineNumber">1840</td>
    <td class="codeline">  /// value to zero will execute.  If not computable, return CouldNotCompute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeline">  /// If AllowPredicates is set, this call will try to use a minimal set of</td>
    <td class="lineNumber">1841</td>
    <td class="codeline">  /// If AllowPredicates is set, this call will try to use a minimal set of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeline">  /// SCEV predicates in order to return an exact answer.</td>
    <td class="lineNumber">1842</td>
    <td class="codeline">  /// SCEV predicates in order to return an exact answer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeline">  ExitLimit howFarToZero(const SCEV *V, const Loop *L, bool IsSubExpr,</td>
    <td class="lineNumber">1843</td>
    <td class="codeline">  ExitLimit howFarToZero(const SCEV *V, const Loop *L, bool IsSubExpr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeline">                         bool AllowPredicates = false);</td>
    <td class="lineNumber">1844</td>
    <td class="codeline">                         bool AllowPredicates = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeline"></td>
    <td class="lineNumber">1845</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeline">  /// Return the number of times an exit condition checking the specified</td>
    <td class="lineNumber">1846</td>
    <td class="codeline">  /// Return the number of times an exit condition checking the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeline">  /// value for nonzero will execute.  If not computable, return</td>
    <td class="lineNumber">1847</td>
    <td class="codeline">  /// value for nonzero will execute.  If not computable, return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeline">  /// CouldNotCompute.</td>
    <td class="lineNumber">1848</td>
    <td class="codeline">  /// CouldNotCompute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeline">  ExitLimit howFarToNonZero(const SCEV *V, const Loop *L);</td>
    <td class="lineNumber">1849</td>
    <td class="codeline">  ExitLimit howFarToNonZero(const SCEV *V, const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeline"></td>
    <td class="lineNumber">1850</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeline">  /// Return the number of times an exit condition containing the specified</td>
    <td class="lineNumber">1851</td>
    <td class="codeline">  /// Return the number of times an exit condition containing the specified</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeline">  /// less-than comparison will execute.  If not computable, return</td>
    <td class="lineNumber">1852</td>
    <td class="codeline">  /// less-than comparison will execute.  If not computable, return</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeline">  /// CouldNotCompute.</td>
    <td class="lineNumber">1853</td>
    <td class="codeline">  /// CouldNotCompute.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1854</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeline">  /// \p isSigned specifies whether the less-than is signed.</td>
    <td class="lineNumber">1855</td>
    <td class="codeline">  /// \p isSigned specifies whether the less-than is signed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1856</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeline">  /// \p ControlsOnlyExit is true when the LHS < RHS condition directly controls</td>
    <td class="lineNumber">1857</td>
    <td class="codeline">  /// \p ControlsOnlyExit is true when the LHS < RHS condition directly controls</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeline">  /// the branch (loops exits only if condition is true). In this case, we can</td>
    <td class="lineNumber">1858</td>
    <td class="codeline">  /// the branch (loops exits only if condition is true). In this case, we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeline">  /// use NoWrapFlags to skip overflow checks.</td>
    <td class="lineNumber">1859</td>
    <td class="codeline">  /// use NoWrapFlags to skip overflow checks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1860</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeline">  /// If \p AllowPredicates is set, this call will try to use a minimal set of</td>
    <td class="lineNumber">1861</td>
    <td class="codeline">  /// If \p AllowPredicates is set, this call will try to use a minimal set of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeline">  /// SCEV predicates in order to return an exact answer.</td>
    <td class="lineNumber">1862</td>
    <td class="codeline">  /// SCEV predicates in order to return an exact answer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeline">  ExitLimit howManyLessThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">1863</td>
    <td class="codeline">  ExitLimit howManyLessThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeline">                             bool isSigned, bool ControlsOnlyExit,</td>
    <td class="lineNumber">1864</td>
    <td class="codeline">                             bool isSigned, bool ControlsOnlyExit,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeline">                             bool AllowPredicates = false);</td>
    <td class="lineNumber">1865</td>
    <td class="codeline">                             bool AllowPredicates = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeline"></td>
    <td class="lineNumber">1866</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeline">  ExitLimit howManyGreaterThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">1867</td>
    <td class="codeline">  ExitLimit howManyGreaterThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeline">                                bool isSigned, bool IsSubExpr,</td>
    <td class="lineNumber">1868</td>
    <td class="codeline">                                bool isSigned, bool IsSubExpr,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeline">                                bool AllowPredicates = false);</td>
    <td class="lineNumber">1869</td>
    <td class="codeline">                                bool AllowPredicates = false);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeline"></td>
    <td class="lineNumber">1870</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeline">  /// Return a predecessor of BB (which may not be an immediate predecessor)</td>
    <td class="lineNumber">1871</td>
    <td class="codeline">  /// Return a predecessor of BB (which may not be an immediate predecessor)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeline">  /// which has exactly one successor from which BB is reachable, or null if</td>
    <td class="lineNumber">1872</td>
    <td class="codeline">  /// which has exactly one successor from which BB is reachable, or null if</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeline">  /// no such block is found.</td>
    <td class="lineNumber">1873</td>
    <td class="codeline">  /// no such block is found.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeline">  std::pair<const BasicBlock *, const BasicBlock *></td>
    <td class="lineNumber">1874</td>
    <td class="codeline">  std::pair<const BasicBlock *, const BasicBlock *></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeline">  getPredecessorWithUniqueSuccessorForBB(const BasicBlock *BB) const;</td>
    <td class="lineNumber">1875</td>
    <td class="codeline">  getPredecessorWithUniqueSuccessorForBB(const BasicBlock *BB) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeline"></td>
    <td class="lineNumber">1876</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">1877</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeline">  /// whenever the given FoundCondValue value evaluates to true in given</td>
    <td class="lineNumber">1878</td>
    <td class="codeline">  /// whenever the given FoundCondValue value evaluates to true in given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeline">  /// Context. If Context is nullptr, then the found predicate is true</td>
    <td class="lineNumber">1879</td>
    <td class="codeline">  /// Context. If Context is nullptr, then the found predicate is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeline">  /// everywhere. LHS and FoundLHS may have different type width.</td>
    <td class="lineNumber">1880</td>
    <td class="codeline">  /// everywhere. LHS and FoundLHS may have different type width.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeline">  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">1881</td>
    <td class="codeline">  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeline">                     const Value *FoundCondValue, bool Inverse,</td>
    <td class="lineNumber">1882</td>
    <td class="codeline">                     const Value *FoundCondValue, bool Inverse,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeline">                     const Instruction *Context = nullptr);</td>
    <td class="lineNumber">1883</td>
    <td class="codeline">                     const Instruction *Context = nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeline"></td>
    <td class="lineNumber">1884</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">1885</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeline">  /// whenever the given FoundCondValue value evaluates to true in given</td>
    <td class="lineNumber">1886</td>
    <td class="codeline">  /// whenever the given FoundCondValue value evaluates to true in given</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeline">  /// Context. If Context is nullptr, then the found predicate is true</td>
    <td class="lineNumber">1887</td>
    <td class="codeline">  /// Context. If Context is nullptr, then the found predicate is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeline">  /// everywhere. LHS and FoundLHS must have same type width.</td>
    <td class="lineNumber">1888</td>
    <td class="codeline">  /// everywhere. LHS and FoundLHS must have same type width.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeline">  bool isImpliedCondBalancedTypes(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">1889</td>
    <td class="codeline">  bool isImpliedCondBalancedTypes(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeline">                                  const SCEV *RHS,</td>
    <td class="lineNumber">1890</td>
    <td class="codeline">                                  const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeline">                                  ICmpInst::Predicate FoundPred,</td>
    <td class="lineNumber">1891</td>
    <td class="codeline">                                  ICmpInst::Predicate FoundPred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeline">                                  const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
    <td class="lineNumber">1892</td>
    <td class="codeline">                                  const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeline">                                  const Instruction *CtxI);</td>
    <td class="lineNumber">1893</td>
    <td class="codeline">                                  const Instruction *CtxI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeline"></td>
    <td class="lineNumber">1894</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">1895</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeline">  /// whenever the condition described by FoundPred, FoundLHS, FoundRHS is</td>
    <td class="lineNumber">1896</td>
    <td class="codeline">  /// whenever the condition described by FoundPred, FoundLHS, FoundRHS is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeline">  /// true in given Context. If Context is nullptr, then the found predicate is</td>
    <td class="lineNumber">1897</td>
    <td class="codeline">  /// true in given Context. If Context is nullptr, then the found predicate is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeline">  /// true everywhere.</td>
    <td class="lineNumber">1898</td>
    <td class="codeline">  /// true everywhere.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeline">  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">1899</td>
    <td class="codeline">  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeline">                     ICmpInst::Predicate FoundPred, const SCEV *FoundLHS,</td>
    <td class="lineNumber">1900</td>
    <td class="codeline">                     ICmpInst::Predicate FoundPred, const SCEV *FoundLHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeline">                     const SCEV *FoundRHS,</td>
    <td class="lineNumber">1901</td>
    <td class="codeline">                     const SCEV *FoundRHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeline">                     const Instruction *Context = nullptr);</td>
    <td class="lineNumber">1902</td>
    <td class="codeline">                     const Instruction *Context = nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeline"></td>
    <td class="lineNumber">1903</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">1904</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">1905</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeline">  /// true in given Context. If Context is nullptr, then the found predicate is</td>
    <td class="lineNumber">1906</td>
    <td class="codeline">  /// true in given Context. If Context is nullptr, then the found predicate is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeline">  /// true everywhere.</td>
    <td class="lineNumber">1907</td>
    <td class="codeline">  /// true everywhere.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeline">  bool isImpliedCondOperands(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">1908</td>
    <td class="codeline">  bool isImpliedCondOperands(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeline">                             const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td class="lineNumber">1909</td>
    <td class="codeline">                             const SCEV *RHS, const SCEV *FoundLHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeline">                             const SCEV *FoundRHS,</td>
    <td class="lineNumber">1910</td>
    <td class="codeline">                             const SCEV *FoundRHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeline">                             const Instruction *Context = nullptr);</td>
    <td class="lineNumber">1911</td>
    <td class="codeline">                             const Instruction *Context = nullptr);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeline"></td>
    <td class="lineNumber">1912</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">1913</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">1914</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeline">  /// true. Here LHS is an operation that includes FoundLHS as one of its</td>
    <td class="lineNumber">1915</td>
    <td class="codeline">  /// true. Here LHS is an operation that includes FoundLHS as one of its</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeline">  /// arguments.</td>
    <td class="lineNumber">1916</td>
    <td class="codeline">  /// arguments.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeline">  bool isImpliedViaOperations(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">1917</td>
    <td class="codeline">  bool isImpliedViaOperations(ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeline">                              const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">1918</td>
    <td class="codeline">                              const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeline">                              const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
    <td class="lineNumber">1919</td>
    <td class="codeline">                              const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeline">                              unsigned Depth = 0);</td>
    <td class="lineNumber">1920</td>
    <td class="codeline">                              unsigned Depth = 0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeline"></td>
    <td class="lineNumber">1921</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true.</td>
    <td class="lineNumber">1922</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeline">  /// Use only simple non-recursive types of checks, such as range analysis etc.</td>
    <td class="lineNumber">1923</td>
    <td class="codeline">  /// Use only simple non-recursive types of checks, such as range analysis etc.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeline">  bool isKnownViaNonRecursiveReasoning(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">1924</td>
    <td class="codeline">  bool isKnownViaNonRecursiveReasoning(ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeline">                                       const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">1925</td>
    <td class="codeline">                                       const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeline"></td>
    <td class="lineNumber">1926</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">1927</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">1928</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeline">  /// true.</td>
    <td class="lineNumber">1929</td>
    <td class="codeline">  /// true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeline">  bool isImpliedCondOperandsHelper(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">1930</td>
    <td class="codeline">  bool isImpliedCondOperandsHelper(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeline">                                   const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td class="lineNumber">1931</td>
    <td class="codeline">                                   const SCEV *RHS, const SCEV *FoundLHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeline">                                   const SCEV *FoundRHS);</td>
    <td class="lineNumber">1932</td>
    <td class="codeline">                                   const SCEV *FoundRHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeline"></td>
    <td class="lineNumber">1933</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">1934</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">1935</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeline">  /// true.  Utility function used by isImpliedCondOperands.  Tries to get</td>
    <td class="lineNumber">1936</td>
    <td class="codeline">  /// true.  Utility function used by isImpliedCondOperands.  Tries to get</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeline">  /// cases like "X `sgt` 0 => X - 1 `sgt` -1".</td>
    <td class="lineNumber">1937</td>
    <td class="codeline">  /// cases like "X `sgt` 0 => X - 1 `sgt` -1".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeline">  bool isImpliedCondOperandsViaRanges(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">1938</td>
    <td class="codeline">  bool isImpliedCondOperandsViaRanges(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeline">                                      const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td class="lineNumber">1939</td>
    <td class="codeline">                                      const SCEV *RHS, const SCEV *FoundLHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeline">                                      const SCEV *FoundRHS);</td>
    <td class="lineNumber">1940</td>
    <td class="codeline">                                      const SCEV *FoundRHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeline"></td>
    <td class="lineNumber">1941</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeline">  /// Return true if the condition denoted by \p LHS \p Pred \p RHS is implied</td>
    <td class="lineNumber">1942</td>
    <td class="codeline">  /// Return true if the condition denoted by \p LHS \p Pred \p RHS is implied</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeline">  /// by a call to @llvm.experimental.guard in \p BB.</td>
    <td class="lineNumber">1943</td>
    <td class="codeline">  /// by a call to @llvm.experimental.guard in \p BB.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeline">  bool isImpliedViaGuard(const BasicBlock *BB, ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">1944</td>
    <td class="codeline">  bool isImpliedViaGuard(const BasicBlock *BB, ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeline">                         const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">1945</td>
    <td class="codeline">                         const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeline"></td>
    <td class="lineNumber">1946</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">1947</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">1948</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeline">  /// true.</td>
    <td class="lineNumber">1949</td>
    <td class="codeline">  /// true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1950</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeline">  /// This routine tries to rule out certain kinds of integer overflow, and</td>
    <td class="lineNumber">1951</td>
    <td class="codeline">  /// This routine tries to rule out certain kinds of integer overflow, and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeline">  /// then tries to reason about arithmetic properties of the predicates.</td>
    <td class="lineNumber">1952</td>
    <td class="codeline">  /// then tries to reason about arithmetic properties of the predicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeline">  bool isImpliedCondOperandsViaNoOverflow(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">1953</td>
    <td class="codeline">  bool isImpliedCondOperandsViaNoOverflow(ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeline">                                          const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">1954</td>
    <td class="codeline">                                          const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeline">                                          const SCEV *FoundLHS,</td>
    <td class="lineNumber">1955</td>
    <td class="codeline">                                          const SCEV *FoundLHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeline">                                          const SCEV *FoundRHS);</td>
    <td class="lineNumber">1956</td>
    <td class="codeline">                                          const SCEV *FoundRHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeline"></td>
    <td class="lineNumber">1957</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">1958</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">1959</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeline">  /// true.</td>
    <td class="lineNumber">1960</td>
    <td class="codeline">  /// true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1961</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeline">  /// This routine tries to weaken the known condition basing on fact that</td>
    <td class="lineNumber">1962</td>
    <td class="codeline">  /// This routine tries to weaken the known condition basing on fact that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeline">  /// FoundLHS is an AddRec.</td>
    <td class="lineNumber">1963</td>
    <td class="codeline">  /// FoundLHS is an AddRec.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeline">  bool isImpliedCondOperandsViaAddRecStart(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">1964</td>
    <td class="codeline">  bool isImpliedCondOperandsViaAddRecStart(ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeline">                                           const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">1965</td>
    <td class="codeline">                                           const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeline">                                           const SCEV *FoundLHS,</td>
    <td class="lineNumber">1966</td>
    <td class="codeline">                                           const SCEV *FoundLHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeline">                                           const SCEV *FoundRHS,</td>
    <td class="lineNumber">1967</td>
    <td class="codeline">                                           const SCEV *FoundRHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeline">                                           const Instruction *CtxI);</td>
    <td class="lineNumber">1968</td>
    <td class="codeline">                                           const Instruction *CtxI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeline"></td>
    <td class="lineNumber">1969</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">1970</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">1971</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeline">  /// true.</td>
    <td class="lineNumber">1972</td>
    <td class="codeline">  /// true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1973</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeline">  /// This routine tries to figure out predicate for Phis which are SCEVUnknown</td>
    <td class="lineNumber">1974</td>
    <td class="codeline">  /// This routine tries to figure out predicate for Phis which are SCEVUnknown</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeline">  /// if it is true for every possible incoming value from their respective</td>
    <td class="lineNumber">1975</td>
    <td class="codeline">  /// if it is true for every possible incoming value from their respective</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeline">  /// basic blocks.</td>
    <td class="lineNumber">1976</td>
    <td class="codeline">  /// basic blocks.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeline">  bool isImpliedViaMerge(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">1977</td>
    <td class="codeline">  bool isImpliedViaMerge(ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeline">                         const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">1978</td>
    <td class="codeline">                         const SCEV *LHS, const SCEV *RHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeline">                         const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
    <td class="lineNumber">1979</td>
    <td class="codeline">                         const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeline">                         unsigned Depth);</td>
    <td class="lineNumber">1980</td>
    <td class="codeline">                         unsigned Depth);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeline"></td>
    <td class="lineNumber">1981</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">1982</td>
    <td class="codeline">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">1983</td>
    <td class="codeline">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeline">  /// true.</td>
    <td class="lineNumber">1984</td>
    <td class="codeline">  /// true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">1985</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeline">  /// This routine tries to reason about shifts.</td>
    <td class="lineNumber">1986</td>
    <td class="codeline">  /// This routine tries to reason about shifts.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeline">  bool isImpliedCondOperandsViaShift(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">1987</td>
    <td class="codeline">  bool isImpliedCondOperandsViaShift(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeline">                                     const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td class="lineNumber">1988</td>
    <td class="codeline">                                     const SCEV *RHS, const SCEV *FoundLHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeline">                                     const SCEV *FoundRHS);</td>
    <td class="lineNumber">1989</td>
    <td class="codeline">                                     const SCEV *FoundRHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeline"></td>
    <td class="lineNumber">1990</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeline">  /// If we know that the specified Phi is in the header of its containing</td>
    <td class="lineNumber">1991</td>
    <td class="codeline">  /// If we know that the specified Phi is in the header of its containing</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeline">  /// loop, we know the loop executes a constant number of times, and the PHI</td>
    <td class="lineNumber">1992</td>
    <td class="codeline">  /// loop, we know the loop executes a constant number of times, and the PHI</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeline">  /// node is just a recurrence involving constants, fold it.</td>
    <td class="lineNumber">1993</td>
    <td class="codeline">  /// node is just a recurrence involving constants, fold it.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeline">  Constant *getConstantEvolutionLoopExitValue(PHINode *PN, const APInt &BEs,</td>
    <td class="lineNumber">1994</td>
    <td class="codeline">  Constant *getConstantEvolutionLoopExitValue(PHINode *PN, const APInt &BEs,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeline">                                              const Loop *L);</td>
    <td class="lineNumber">1995</td>
    <td class="codeline">                                              const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeline"></td>
    <td class="lineNumber">1996</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeline">  /// Test if the given expression is known to satisfy the condition described</td>
    <td class="lineNumber">1997</td>
    <td class="codeline">  /// Test if the given expression is known to satisfy the condition described</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeline">  /// by Pred and the known constant ranges of LHS and RHS.</td>
    <td class="lineNumber">1998</td>
    <td class="codeline">  /// by Pred and the known constant ranges of LHS and RHS.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeline">  bool isKnownPredicateViaConstantRanges(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">1999</td>
    <td class="codeline">  bool isKnownPredicateViaConstantRanges(ICmpInst::Predicate Pred,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeline">                                         const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">2000</td>
    <td class="codeline">                                         const SCEV *LHS, const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeline"></td>
    <td class="lineNumber">2001</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeline">  /// Try to prove the condition described by "LHS Pred RHS" by ruling out</td>
    <td class="lineNumber">2002</td>
    <td class="codeline">  /// Try to prove the condition described by "LHS Pred RHS" by ruling out</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeline">  /// integer overflow.</td>
    <td class="lineNumber">2003</td>
    <td class="codeline">  /// integer overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2004</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeline">  /// For instance, this will return true for "A s< (A + C)<nsw>" if C is</td>
    <td class="lineNumber">2005</td>
    <td class="codeline">  /// For instance, this will return true for "A s< (A + C)<nsw>" if C is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeline">  /// positive.</td>
    <td class="lineNumber">2006</td>
    <td class="codeline">  /// positive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeline">  bool isKnownPredicateViaNoOverflow(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">2007</td>
    <td class="codeline">  bool isKnownPredicateViaNoOverflow(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeline">                                     const SCEV *RHS);</td>
    <td class="lineNumber">2008</td>
    <td class="codeline">                                     const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeline"></td>
    <td class="lineNumber">2009</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeline">  /// Try to split Pred LHS RHS into logical conjunctions (and's) and try to</td>
    <td class="lineNumber">2010</td>
    <td class="codeline">  /// Try to split Pred LHS RHS into logical conjunctions (and's) and try to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeline">  /// prove them individually.</td>
    <td class="lineNumber">2011</td>
    <td class="codeline">  /// prove them individually.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeline">  bool isKnownPredicateViaSplitting(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">2012</td>
    <td class="codeline">  bool isKnownPredicateViaSplitting(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeline">                                    const SCEV *RHS);</td>
    <td class="lineNumber">2013</td>
    <td class="codeline">                                    const SCEV *RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeline"></td>
    <td class="lineNumber">2014</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeline">  /// Try to match the Expr as "(L + R)<Flags>".</td>
    <td class="lineNumber">2015</td>
    <td class="codeline">  /// Try to match the Expr as "(L + R)<Flags>".</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeline">  bool splitBinaryAdd(const SCEV *Expr, const SCEV *&L, const SCEV *&R,</td>
    <td class="lineNumber">2016</td>
    <td class="codeline">  bool splitBinaryAdd(const SCEV *Expr, const SCEV *&L, const SCEV *&R,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeline">                      SCEV::NoWrapFlags &Flags);</td>
    <td class="lineNumber">2017</td>
    <td class="codeline">                      SCEV::NoWrapFlags &Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeline"></td>
    <td class="lineNumber">2018</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeline">  /// Forget predicated/non-predicated backedge taken counts for the given loop.</td>
    <td class="lineNumber">2019</td>
    <td class="codeline">  /// Forget predicated/non-predicated backedge taken counts for the given loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeline">  void forgetBackedgeTakenCounts(const Loop *L, bool Predicated);</td>
    <td class="lineNumber">2020</td>
    <td class="codeline">  void forgetBackedgeTakenCounts(const Loop *L, bool Predicated);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeline"></td>
    <td class="lineNumber">2021</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeline">  /// Drop memoized information for all \p SCEVs.</td>
    <td class="lineNumber">2022</td>
    <td class="codeline">  /// Drop memoized information for all \p SCEVs.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeline">  void forgetMemoizedResults(ArrayRef<const SCEV *> SCEVs);</td>
    <td class="lineNumber">2023</td>
    <td class="codeline">  void forgetMemoizedResults(ArrayRef<const SCEV *> SCEVs);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeline"></td>
    <td class="lineNumber">2024</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeline">  /// Helper for forgetMemoizedResults.</td>
    <td class="lineNumber">2025</td>
    <td class="codeline">  /// Helper for forgetMemoizedResults.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeline">  void forgetMemoizedResultsImpl(const SCEV *S);</td>
    <td class="lineNumber">2026</td>
    <td class="codeline">  void forgetMemoizedResultsImpl(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeline"></td>
    <td class="lineNumber">2027</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeline">  /// Iterate over instructions in \p Worklist and their users. Erase entries</td>
    <td class="lineNumber">2028</td>
    <td class="codeline">  /// Iterate over instructions in \p Worklist and their users. Erase entries</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeline">  /// from ValueExprMap and collect SCEV expressions in \p ToForget</td>
    <td class="lineNumber">2029</td>
    <td class="codeline">  /// from ValueExprMap and collect SCEV expressions in \p ToForget</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeline">  void visitAndClearUsers(SmallVectorImpl<Instruction *> &Worklist,</td>
    <td class="lineNumber">2030</td>
    <td class="codeline">  void visitAndClearUsers(SmallVectorImpl<Instruction *> &Worklist,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeline">                          SmallPtrSetImpl<Instruction *> &Visited,</td>
    <td class="lineNumber">2031</td>
    <td class="codeline">                          SmallPtrSetImpl<Instruction *> &Visited,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeline">                          SmallVectorImpl<const SCEV *> &ToForget);</td>
    <td class="lineNumber">2032</td>
    <td class="codeline">                          SmallVectorImpl<const SCEV *> &ToForget);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeline"></td>
    <td class="lineNumber">2033</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeline">  /// Erase Value from ValueExprMap and ExprValueMap.</td>
    <td class="lineNumber">2034</td>
    <td class="codeline">  /// Erase Value from ValueExprMap and ExprValueMap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeline">  void eraseValueFromMap(Value *V);</td>
    <td class="lineNumber">2035</td>
    <td class="codeline">  void eraseValueFromMap(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeline"></td>
    <td class="lineNumber">2036</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeline">  /// Insert V to S mapping into ValueExprMap and ExprValueMap.</td>
    <td class="lineNumber">2037</td>
    <td class="codeline">  /// Insert V to S mapping into ValueExprMap and ExprValueMap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeline">  void insertValueToMap(Value *V, const SCEV *S);</td>
    <td class="lineNumber">2038</td>
    <td class="codeline">  void insertValueToMap(Value *V, const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeline"></td>
    <td class="lineNumber">2039</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeline">  /// Return false iff given SCEV contains a SCEVUnknown with NULL value-</td>
    <td class="lineNumber">2040</td>
    <td class="codeline">  /// Return false iff given SCEV contains a SCEVUnknown with NULL value-</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeline">  /// pointer.</td>
    <td class="lineNumber">2041</td>
    <td class="codeline">  /// pointer.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeline">  bool checkValidity(const SCEV *S) const;</td>
    <td class="lineNumber">2042</td>
    <td class="codeline">  bool checkValidity(const SCEV *S) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeline"></td>
    <td class="lineNumber">2043</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeline">  /// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be</td>
    <td class="lineNumber">2044</td>
    <td class="codeline">  /// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeline">  /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}.  This is</td>
    <td class="lineNumber">2045</td>
    <td class="codeline">  /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}.  This is</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeline">  /// equivalent to proving no signed (resp. unsigned) wrap in</td>
    <td class="lineNumber">2046</td>
    <td class="codeline">  /// equivalent to proving no signed (resp. unsigned) wrap in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeline">  /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`</td>
    <td class="lineNumber">2047</td>
    <td class="codeline">  /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeline">  /// (resp. `SCEVZeroExtendExpr`).</td>
    <td class="lineNumber">2048</td>
    <td class="codeline">  /// (resp. `SCEVZeroExtendExpr`).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeline">  template <typename ExtendOpTy></td>
    <td class="lineNumber">2049</td>
    <td class="codeline">  template <typename ExtendOpTy></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeline">  bool proveNoWrapByVaryingStart(const SCEV *Start, const SCEV *Step,</td>
    <td class="lineNumber">2050</td>
    <td class="codeline">  bool proveNoWrapByVaryingStart(const SCEV *Start, const SCEV *Step,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeline">                                 const Loop *L);</td>
    <td class="lineNumber">2051</td>
    <td class="codeline">                                 const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeline"></td>
    <td class="lineNumber">2052</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeline">  /// Try to prove NSW or NUW on \p AR relying on ConstantRange manipulation.</td>
    <td class="lineNumber">2053</td>
    <td class="codeline">  /// Try to prove NSW or NUW on \p AR relying on ConstantRange manipulation.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeline">  SCEV::NoWrapFlags proveNoWrapViaConstantRanges(const SCEVAddRecExpr *AR);</td>
    <td class="lineNumber">2054</td>
    <td class="codeline">  SCEV::NoWrapFlags proveNoWrapViaConstantRanges(const SCEVAddRecExpr *AR);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeline"></td>
    <td class="lineNumber">2055</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeline">  /// Try to prove NSW on \p AR by proving facts about conditions known  on</td>
    <td class="lineNumber">2056</td>
    <td class="codeline">  /// Try to prove NSW on \p AR by proving facts about conditions known  on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeline">  /// entry and backedge.</td>
    <td class="lineNumber">2057</td>
    <td class="codeline">  /// entry and backedge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeline">  SCEV::NoWrapFlags proveNoSignedWrapViaInduction(const SCEVAddRecExpr *AR);</td>
    <td class="lineNumber">2058</td>
    <td class="codeline">  SCEV::NoWrapFlags proveNoSignedWrapViaInduction(const SCEVAddRecExpr *AR);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
    <td class="lineNumber">2059</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeline">  /// Try to prove NUW on \p AR by proving facts about conditions known on</td>
    <td class="lineNumber">2060</td>
    <td class="codeline">  /// Try to prove NUW on \p AR by proving facts about conditions known on</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeline">  /// entry and backedge.</td>
    <td class="lineNumber">2061</td>
    <td class="codeline">  /// entry and backedge.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeline">  SCEV::NoWrapFlags proveNoUnsignedWrapViaInduction(const SCEVAddRecExpr *AR);</td>
    <td class="lineNumber">2062</td>
    <td class="codeline">  SCEV::NoWrapFlags proveNoUnsignedWrapViaInduction(const SCEVAddRecExpr *AR);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeline"></td>
    <td class="lineNumber">2063</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeline">  std::optional<MonotonicPredicateType></td>
    <td class="lineNumber">2064</td>
    <td class="codeline">  std::optional<MonotonicPredicateType></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeline">  getMonotonicPredicateTypeImpl(const SCEVAddRecExpr *LHS,</td>
    <td class="lineNumber">2065</td>
    <td class="codeline">  getMonotonicPredicateTypeImpl(const SCEVAddRecExpr *LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeline">                                ICmpInst::Predicate Pred);</td>
    <td class="lineNumber">2066</td>
    <td class="codeline">                                ICmpInst::Predicate Pred);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeline"></td>
    <td class="lineNumber">2067</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeline">  /// Return SCEV no-wrap flags that can be proven based on reasoning about</td>
    <td class="lineNumber">2068</td>
    <td class="codeline">  /// Return SCEV no-wrap flags that can be proven based on reasoning about</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeline">  /// how poison produced from no-wrap flags on this value (e.g. a nuw add)</td>
    <td class="lineNumber">2069</td>
    <td class="codeline">  /// how poison produced from no-wrap flags on this value (e.g. a nuw add)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeline">  /// would trigger undefined behavior on overflow.</td>
    <td class="lineNumber">2070</td>
    <td class="codeline">  /// would trigger undefined behavior on overflow.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeline">  SCEV::NoWrapFlags getNoWrapFlagsFromUB(const Value *V);</td>
    <td class="lineNumber">2071</td>
    <td class="codeline">  SCEV::NoWrapFlags getNoWrapFlagsFromUB(const Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeline"></td>
    <td class="lineNumber">2072</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeline">  /// Return a scope which provides an upper bound on the defining scope of</td>
    <td class="lineNumber">2073</td>
    <td class="codeline">  /// Return a scope which provides an upper bound on the defining scope of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeline">  /// 'S'. Specifically, return the first instruction in said bounding scope.</td>
    <td class="lineNumber">2074</td>
    <td class="codeline">  /// 'S'. Specifically, return the first instruction in said bounding scope.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeline">  /// Return nullptr if the scope is trivial (function entry).</td>
    <td class="lineNumber">2075</td>
    <td class="codeline">  /// Return nullptr if the scope is trivial (function entry).</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeline">  /// (See scope definition rules associated with flag discussion above)</td>
    <td class="lineNumber">2076</td>
    <td class="codeline">  /// (See scope definition rules associated with flag discussion above)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeline">  const Instruction *getNonTrivialDefiningScopeBound(const SCEV *S);</td>
    <td class="lineNumber">2077</td>
    <td class="codeline">  const Instruction *getNonTrivialDefiningScopeBound(const SCEV *S);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeline"></td>
    <td class="lineNumber">2078</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeline">  /// Return a scope which provides an upper bound on the defining scope for</td>
    <td class="lineNumber">2079</td>
    <td class="codeline">  /// Return a scope which provides an upper bound on the defining scope for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeline">  /// a SCEV with the operands in Ops.  The outparam Precise is set if the</td>
    <td class="lineNumber">2080</td>
    <td class="codeline">  /// a SCEV with the operands in Ops.  The outparam Precise is set if the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeline">  /// bound found is a precise bound (i.e. must be the defining scope.)</td>
    <td class="lineNumber">2081</td>
    <td class="codeline">  /// bound found is a precise bound (i.e. must be the defining scope.)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeline">  const Instruction *getDefiningScopeBound(ArrayRef<const SCEV *> Ops,</td>
    <td class="lineNumber">2082</td>
    <td class="codeline">  const Instruction *getDefiningScopeBound(ArrayRef<const SCEV *> Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeline">                                           bool &Precise);</td>
    <td class="lineNumber">2083</td>
    <td class="codeline">                                           bool &Precise);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeline"></td>
    <td class="lineNumber">2084</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeline">  /// Wrapper around the above for cases which don't care if the bound</td>
    <td class="lineNumber">2085</td>
    <td class="codeline">  /// Wrapper around the above for cases which don't care if the bound</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeline">  /// is precise.</td>
    <td class="lineNumber">2086</td>
    <td class="codeline">  /// is precise.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeline">  const Instruction *getDefiningScopeBound(ArrayRef<const SCEV *> Ops);</td>
    <td class="lineNumber">2087</td>
    <td class="codeline">  const Instruction *getDefiningScopeBound(ArrayRef<const SCEV *> Ops);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeline"></td>
    <td class="lineNumber">2088</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeline">  /// Given two instructions in the same function, return true if we can</td>
    <td class="lineNumber">2089</td>
    <td class="codeline">  /// Given two instructions in the same function, return true if we can</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeline">  /// prove B must execute given A executes.</td>
    <td class="lineNumber">2090</td>
    <td class="codeline">  /// prove B must execute given A executes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeline">  bool isGuaranteedToTransferExecutionTo(const Instruction *A,</td>
    <td class="lineNumber">2091</td>
    <td class="codeline">  bool isGuaranteedToTransferExecutionTo(const Instruction *A,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeline">                                         const Instruction *B);</td>
    <td class="lineNumber">2092</td>
    <td class="codeline">                                         const Instruction *B);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeline"></td>
    <td class="lineNumber">2093</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeline">  /// Return true if the SCEV corresponding to \p I is never poison.  Proving</td>
    <td class="lineNumber">2094</td>
    <td class="codeline">  /// Return true if the SCEV corresponding to \p I is never poison.  Proving</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeline">  /// this is more complex than proving that just \p I is never poison, since</td>
    <td class="lineNumber">2095</td>
    <td class="codeline">  /// this is more complex than proving that just \p I is never poison, since</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeline">  /// SCEV commons expressions across control flow, and you can have cases</td>
    <td class="lineNumber">2096</td>
    <td class="codeline">  /// SCEV commons expressions across control flow, and you can have cases</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeline">  /// like:</td>
    <td class="lineNumber">2097</td>
    <td class="codeline">  /// like:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2098</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeline">  ///   idx0 = a + b;</td>
    <td class="lineNumber">2099</td>
    <td class="codeline">  ///   idx0 = a + b;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeline">  ///   ptr[idx0] = 100;</td>
    <td class="lineNumber">2100</td>
    <td class="codeline">  ///   ptr[idx0] = 100;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeline">  ///   if (<condition>) {</td>
    <td class="lineNumber">2101</td>
    <td class="codeline">  ///   if (<condition>) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeline">  ///     idx1 = a +nsw b;</td>
    <td class="lineNumber">2102</td>
    <td class="codeline">  ///     idx1 = a +nsw b;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeline">  ///     ptr[idx1] = 200;</td>
    <td class="lineNumber">2103</td>
    <td class="codeline">  ///     ptr[idx1] = 200;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeline">  ///   }</td>
    <td class="lineNumber">2104</td>
    <td class="codeline">  ///   }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2105</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeline">  /// where the SCEV expression (+ a b) is guaranteed to not be poison (and</td>
    <td class="lineNumber">2106</td>
    <td class="codeline">  /// where the SCEV expression (+ a b) is guaranteed to not be poison (and</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeline">  /// hence not sign-overflow) only if "<condition>" is true.  Since both</td>
    <td class="lineNumber">2107</td>
    <td class="codeline">  /// hence not sign-overflow) only if "<condition>" is true.  Since both</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeline">  /// `idx0` and `idx1` will be mapped to the same SCEV expression, (+ a b),</td>
    <td class="lineNumber">2108</td>
    <td class="codeline">  /// `idx0` and `idx1` will be mapped to the same SCEV expression, (+ a b),</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeline">  /// it is not okay to annotate (+ a b) with <nsw> in the above example.</td>
    <td class="lineNumber">2109</td>
    <td class="codeline">  /// it is not okay to annotate (+ a b) with <nsw> in the above example.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeline">  bool isSCEVExprNeverPoison(const Instruction *I);</td>
    <td class="lineNumber">2110</td>
    <td class="codeline">  bool isSCEVExprNeverPoison(const Instruction *I);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeline"></td>
    <td class="lineNumber">2111</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeline">  /// This is like \c isSCEVExprNeverPoison but it specifically works for</td>
    <td class="lineNumber">2112</td>
    <td class="codeline">  /// This is like \c isSCEVExprNeverPoison but it specifically works for</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeline">  /// instructions that will get mapped to SCEV add recurrences.  Return true</td>
    <td class="lineNumber">2113</td>
    <td class="codeline">  /// instructions that will get mapped to SCEV add recurrences.  Return true</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeline">  /// if \p I will never generate poison under the assumption that \p I is an</td>
    <td class="lineNumber">2114</td>
    <td class="codeline">  /// if \p I will never generate poison under the assumption that \p I is an</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeline">  /// add recurrence on the loop \p L.</td>
    <td class="lineNumber">2115</td>
    <td class="codeline">  /// add recurrence on the loop \p L.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeline">  bool isAddRecNeverPoison(const Instruction *I, const Loop *L);</td>
    <td class="lineNumber">2116</td>
    <td class="codeline">  bool isAddRecNeverPoison(const Instruction *I, const Loop *L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeline"></td>
    <td class="lineNumber">2117</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeline">  /// Similar to createAddRecFromPHI, but with the additional flexibility of</td>
    <td class="lineNumber">2118</td>
    <td class="codeline">  /// Similar to createAddRecFromPHI, but with the additional flexibility of</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeline">  /// suggesting runtime overflow checks in case casts are encountered.</td>
    <td class="lineNumber">2119</td>
    <td class="codeline">  /// suggesting runtime overflow checks in case casts are encountered.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeline">  /// If successful, the analysis records that for this loop, \p SymbolicPHI,</td>
    <td class="lineNumber">2120</td>
    <td class="codeline">  /// If successful, the analysis records that for this loop, \p SymbolicPHI,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeline">  /// which is the UnknownSCEV currently representing the PHI, can be rewritten</td>
    <td class="lineNumber">2121</td>
    <td class="codeline">  /// which is the UnknownSCEV currently representing the PHI, can be rewritten</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeline">  /// into an AddRec, assuming some predicates; The function then returns the</td>
    <td class="lineNumber">2122</td>
    <td class="codeline">  /// into an AddRec, assuming some predicates; The function then returns the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeline">  /// AddRec and the predicates as a pair, and caches this pair in</td>
    <td class="lineNumber">2123</td>
    <td class="codeline">  /// AddRec and the predicates as a pair, and caches this pair in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeline">  /// PredicatedSCEVRewrites.</td>
    <td class="lineNumber">2124</td>
    <td class="codeline">  /// PredicatedSCEVRewrites.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeline">  /// If the analysis is not successful, a mapping from the \p SymbolicPHI to</td>
    <td class="lineNumber">2125</td>
    <td class="codeline">  /// If the analysis is not successful, a mapping from the \p SymbolicPHI to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeline">  /// itself (with no predicates) is recorded, and a nullptr with an empty</td>
    <td class="lineNumber">2126</td>
    <td class="codeline">  /// itself (with no predicates) is recorded, and a nullptr with an empty</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeline">  /// predicates vector is returned as a pair.</td>
    <td class="lineNumber">2127</td>
    <td class="codeline">  /// predicates vector is returned as a pair.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeline">  std::optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
    <td class="lineNumber">2128</td>
    <td class="codeline">  std::optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeline">  createAddRecFromPHIWithCastsImpl(const SCEVUnknown *SymbolicPHI);</td>
    <td class="lineNumber">2129</td>
    <td class="codeline">  createAddRecFromPHIWithCastsImpl(const SCEVUnknown *SymbolicPHI);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeline"></td>
    <td class="lineNumber">2130</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeline">  /// Compute the maximum backedge count based on the range of values</td>
    <td class="lineNumber">2131</td>
    <td class="codeline">  /// Compute the maximum backedge count based on the range of values</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeline">  /// permitted by Start, End, and Stride. This is for loops of the form</td>
    <td class="lineNumber">2132</td>
    <td class="codeline">  /// permitted by Start, End, and Stride. This is for loops of the form</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeline">  /// {Start, +, Stride} LT End.</td>
    <td class="lineNumber">2133</td>
    <td class="codeline">  /// {Start, +, Stride} LT End.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeline">  ///</td>
    <td class="lineNumber">2134</td>
    <td class="codeline">  ///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeline">  /// Preconditions:</td>
    <td class="lineNumber">2135</td>
    <td class="codeline">  /// Preconditions:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeline">  /// * the induction variable is known to be positive.</td>
    <td class="lineNumber">2136</td>
    <td class="codeline">  /// * the induction variable is known to be positive.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeline">  /// * the induction variable is assumed not to overflow (i.e. either it</td>
    <td class="lineNumber">2137</td>
    <td class="codeline">  /// * the induction variable is assumed not to overflow (i.e. either it</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeline">  ///   actually doesn't, or we'd have to immediately execute UB)</td>
    <td class="lineNumber">2138</td>
    <td class="codeline">  ///   actually doesn't, or we'd have to immediately execute UB)</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeline">  /// We *don't* assert these preconditions so please be careful.</td>
    <td class="lineNumber">2139</td>
    <td class="codeline">  /// We *don't* assert these preconditions so please be careful.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeline">  const SCEV *computeMaxBECountForLT(const SCEV *Start, const SCEV *Stride,</td>
    <td class="lineNumber">2140</td>
    <td class="codeline">  const SCEV *computeMaxBECountForLT(const SCEV *Start, const SCEV *Stride,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeline">                                     const SCEV *End, unsigned BitWidth,</td>
    <td class="lineNumber">2141</td>
    <td class="codeline">                                     const SCEV *End, unsigned BitWidth,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeline">                                     bool IsSigned);</td>
    <td class="lineNumber">2142</td>
    <td class="codeline">                                     bool IsSigned);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeline"></td>
    <td class="lineNumber">2143</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeline">  /// Verify if an linear IV with positive stride can overflow when in a</td>
    <td class="lineNumber">2144</td>
    <td class="codeline">  /// Verify if an linear IV with positive stride can overflow when in a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeline">  /// less-than comparison, knowing the invariant term of the comparison,</td>
    <td class="lineNumber">2145</td>
    <td class="codeline">  /// less-than comparison, knowing the invariant term of the comparison,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeline">  /// the stride.</td>
    <td class="lineNumber">2146</td>
    <td class="codeline">  /// the stride.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeline">  bool canIVOverflowOnLT(const SCEV *RHS, const SCEV *Stride, bool IsSigned);</td>
    <td class="lineNumber">2147</td>
    <td class="codeline">  bool canIVOverflowOnLT(const SCEV *RHS, const SCEV *Stride, bool IsSigned);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeline"></td>
    <td class="lineNumber">2148</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeline">  /// Verify if an linear IV with negative stride can overflow when in a</td>
    <td class="lineNumber">2149</td>
    <td class="codeline">  /// Verify if an linear IV with negative stride can overflow when in a</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeline">  /// greater-than comparison, knowing the invariant term of the comparison,</td>
    <td class="lineNumber">2150</td>
    <td class="codeline">  /// greater-than comparison, knowing the invariant term of the comparison,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeline">  /// the stride.</td>
    <td class="lineNumber">2151</td>
    <td class="codeline">  /// the stride.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeline">  bool canIVOverflowOnGT(const SCEV *RHS, const SCEV *Stride, bool IsSigned);</td>
    <td class="lineNumber">2152</td>
    <td class="codeline">  bool canIVOverflowOnGT(const SCEV *RHS, const SCEV *Stride, bool IsSigned);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeline"></td>
    <td class="lineNumber">2153</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeline">  /// Get add expr already created or create a new one.</td>
    <td class="lineNumber">2154</td>
    <td class="codeline">  /// Get add expr already created or create a new one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeline">  const SCEV *getOrCreateAddExpr(ArrayRef<const SCEV *> Ops,</td>
    <td class="lineNumber">2155</td>
    <td class="codeline">  const SCEV *getOrCreateAddExpr(ArrayRef<const SCEV *> Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeline">                                 SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">2156</td>
    <td class="codeline">                                 SCEV::NoWrapFlags Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeline"></td>
    <td class="lineNumber">2157</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeline">  /// Get mul expr already created or create a new one.</td>
    <td class="lineNumber">2158</td>
    <td class="codeline">  /// Get mul expr already created or create a new one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeline">  const SCEV *getOrCreateMulExpr(ArrayRef<const SCEV *> Ops,</td>
    <td class="lineNumber">2159</td>
    <td class="codeline">  const SCEV *getOrCreateMulExpr(ArrayRef<const SCEV *> Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeline">                                 SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">2160</td>
    <td class="codeline">                                 SCEV::NoWrapFlags Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeline"></td>
    <td class="lineNumber">2161</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeline">  // Get addrec expr already created or create a new one.</td>
    <td class="lineNumber">2162</td>
    <td class="codeline">  // Get addrec expr already created or create a new one.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeline">  const SCEV *getOrCreateAddRecExpr(ArrayRef<const SCEV *> Ops,</td>
    <td class="lineNumber">2163</td>
    <td class="codeline">  const SCEV *getOrCreateAddRecExpr(ArrayRef<const SCEV *> Ops,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeline">                                    const Loop *L, SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">2164</td>
    <td class="codeline">                                    const Loop *L, SCEV::NoWrapFlags Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeline"></td>
    <td class="lineNumber">2165</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeline">  /// Return x if \p Val is f(x) where f is a 1-1 function.</td>
    <td class="lineNumber">2166</td>
    <td class="codeline">  /// Return x if \p Val is f(x) where f is a 1-1 function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeline">  const SCEV *stripInjectiveFunctions(const SCEV *Val) const;</td>
    <td class="lineNumber">2167</td>
    <td class="codeline">  const SCEV *stripInjectiveFunctions(const SCEV *Val) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeline"></td>
    <td class="lineNumber">2168</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeline">  /// Find all of the loops transitively used in \p S, and fill \p LoopsUsed.</td>
    <td class="lineNumber">2169</td>
    <td class="codeline">  /// Find all of the loops transitively used in \p S, and fill \p LoopsUsed.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeline">  /// A loop is considered "used" by an expression if it contains</td>
    <td class="lineNumber">2170</td>
    <td class="codeline">  /// A loop is considered "used" by an expression if it contains</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeline">  /// an add rec on said loop.</td>
    <td class="lineNumber">2171</td>
    <td class="codeline">  /// an add rec on said loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeline">  void getUsedLoops(const SCEV *S, SmallPtrSetImpl<const Loop *> &LoopsUsed);</td>
    <td class="lineNumber">2172</td>
    <td class="codeline">  void getUsedLoops(const SCEV *S, SmallPtrSetImpl<const Loop *> &LoopsUsed);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeline"></td>
    <td class="lineNumber">2173</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeline">  /// Try to match the pattern generated by getURemExpr(A, B). If successful,</td>
    <td class="lineNumber">2174</td>
    <td class="codeline">  /// Try to match the pattern generated by getURemExpr(A, B). If successful,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeline">  /// Assign A and B to LHS and RHS, respectively.</td>
    <td class="lineNumber">2175</td>
    <td class="codeline">  /// Assign A and B to LHS and RHS, respectively.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeline">  bool matchURem(const SCEV *Expr, const SCEV *&LHS, const SCEV *&RHS);</td>
    <td class="lineNumber">2176</td>
    <td class="codeline">  bool matchURem(const SCEV *Expr, const SCEV *&LHS, const SCEV *&RHS);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeline"></td>
    <td class="lineNumber">2177</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeline">  /// Look for a SCEV expression with type `SCEVType` and operands `Ops` in</td>
    <td class="lineNumber">2178</td>
    <td class="codeline">  /// Look for a SCEV expression with type `SCEVType` and operands `Ops` in</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeline">  /// `UniqueSCEVs`.  Return if found, else nullptr.</td>
    <td class="lineNumber">2179</td>
    <td class="codeline">  /// `UniqueSCEVs`.  Return if found, else nullptr.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeline">  SCEV *findExistingSCEVInCache(SCEVTypes SCEVType, ArrayRef<const SCEV *> Ops);</td>
    <td class="lineNumber">2180</td>
    <td class="codeline">  SCEV *findExistingSCEVInCache(SCEVTypes SCEVType, ArrayRef<const SCEV *> Ops);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeline"></td>
    <td class="lineNumber">2181</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeline">  /// Get reachable blocks in this function, making limited use of SCEV</td>
    <td class="lineNumber">2182</td>
    <td class="codeline">  /// Get reachable blocks in this function, making limited use of SCEV</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeline">  /// reasoning about conditions.</td>
    <td class="lineNumber">2183</td>
    <td class="codeline">  /// reasoning about conditions.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeline">  void getReachableBlocks(SmallPtrSetImpl<BasicBlock *> &Reachable,</td>
    <td class="lineNumber">2184</td>
    <td class="codeline">  void getReachableBlocks(SmallPtrSetImpl<BasicBlock *> &Reachable,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeline">                          Function &F);</td>
    <td class="lineNumber">2185</td>
    <td class="codeline">                          Function &F);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeline"></td>
    <td class="lineNumber">2186</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeline">  /// Return the given SCEV expression with a new set of operands.</td>
    <td class="lineNumber">2187</td>
    <td class="codeline">  /// Return the given SCEV expression with a new set of operands.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeline">  /// This preserves the origial nowrap flags.</td>
    <td class="lineNumber">2188</td>
    <td class="codeline">  /// This preserves the origial nowrap flags.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeline">  const SCEV *getWithOperands(const SCEV *S,</td>
    <td class="lineNumber">2189</td>
    <td class="codeline">  const SCEV *getWithOperands(const SCEV *S,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeline">                              SmallVectorImpl<const SCEV *> &NewOps);</td>
    <td class="lineNumber">2190</td>
    <td class="codeline">                              SmallVectorImpl<const SCEV *> &NewOps);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeline"></td>
    <td class="lineNumber">2191</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeline">  FoldingSet<SCEV> UniqueSCEVs;</td>
    <td class="lineNumber">2192</td>
    <td class="codeline">  FoldingSet<SCEV> UniqueSCEVs;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeline">  FoldingSet<SCEVPredicate> UniquePreds;</td>
    <td class="lineNumber">2193</td>
    <td class="codeline">  FoldingSet<SCEVPredicate> UniquePreds;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeline">  BumpPtrAllocator SCEVAllocator;</td>
    <td class="lineNumber">2194</td>
    <td class="codeline">  BumpPtrAllocator SCEVAllocator;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeline"></td>
    <td class="lineNumber">2195</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeline">  /// This maps loops to a list of addrecs that directly use said loop.</td>
    <td class="lineNumber">2196</td>
    <td class="codeline">  /// This maps loops to a list of addrecs that directly use said loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeline">  DenseMap<const Loop *, SmallVector<const SCEVAddRecExpr *, 4>> LoopUsers;</td>
    <td class="lineNumber">2197</td>
    <td class="codeline">  DenseMap<const Loop *, SmallVector<const SCEVAddRecExpr *, 4>> LoopUsers;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeline"></td>
    <td class="lineNumber">2198</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeline">  /// Cache tentative mappings from UnknownSCEVs in a Loop, to a SCEV expression</td>
    <td class="lineNumber">2199</td>
    <td class="codeline">  /// Cache tentative mappings from UnknownSCEVs in a Loop, to a SCEV expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeline">  /// they can be rewritten into under certain predicates.</td>
    <td class="lineNumber">2200</td>
    <td class="codeline">  /// they can be rewritten into under certain predicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeline">  DenseMap<std::pair<const SCEVUnknown *, const Loop *>,</td>
    <td class="lineNumber">2201</td>
    <td class="codeline">  DenseMap<std::pair<const SCEVUnknown *, const Loop *>,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeline">           std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
    <td class="lineNumber">2202</td>
    <td class="codeline">           std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeline">      PredicatedSCEVRewrites;</td>
    <td class="lineNumber">2203</td>
    <td class="codeline">      PredicatedSCEVRewrites;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeline"></td>
    <td class="lineNumber">2204</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeline">  /// Set of AddRecs for which proving NUW via an induction has already been</td>
    <td class="lineNumber">2205</td>
    <td class="codeline">  /// Set of AddRecs for which proving NUW via an induction has already been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeline">  /// tried.</td>
    <td class="lineNumber">2206</td>
    <td class="codeline">  /// tried.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeline">  SmallPtrSet<const SCEVAddRecExpr *, 16> UnsignedWrapViaInductionTried;</td>
    <td class="lineNumber">2207</td>
    <td class="codeline">  SmallPtrSet<const SCEVAddRecExpr *, 16> UnsignedWrapViaInductionTried;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeline"></td>
    <td class="lineNumber">2208</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeline">  /// Set of AddRecs for which proving NSW via an induction has already been</td>
    <td class="lineNumber">2209</td>
    <td class="codeline">  /// Set of AddRecs for which proving NSW via an induction has already been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeline">  /// tried.</td>
    <td class="lineNumber">2210</td>
    <td class="codeline">  /// tried.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeline">  SmallPtrSet<const SCEVAddRecExpr *, 16> SignedWrapViaInductionTried;</td>
    <td class="lineNumber">2211</td>
    <td class="codeline">  SmallPtrSet<const SCEVAddRecExpr *, 16> SignedWrapViaInductionTried;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeline"></td>
    <td class="lineNumber">2212</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeline">  /// The head of a linked list of all SCEVUnknown values that have been</td>
    <td class="lineNumber">2213</td>
    <td class="codeline">  /// The head of a linked list of all SCEVUnknown values that have been</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeline">  /// allocated. This is used by releaseMemory to locate them all and call</td>
    <td class="lineNumber">2214</td>
    <td class="codeline">  /// allocated. This is used by releaseMemory to locate them all and call</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeline">  /// their destructors.</td>
    <td class="lineNumber">2215</td>
    <td class="codeline">  /// their destructors.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeline">  SCEVUnknown *FirstUnknown = nullptr;</td>
    <td class="lineNumber">2216</td>
    <td class="codeline">  SCEVUnknown *FirstUnknown = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2217</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeline"></td>
    <td class="lineNumber">2218</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeline">/// Analysis pass that exposes the \c ScalarEvolution for a function.</td>
    <td class="lineNumber">2219</td>
    <td class="codeline">/// Analysis pass that exposes the \c ScalarEvolution for a function.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeline">class ScalarEvolutionAnalysis</td>
    <td class="lineNumber">2220</td>
    <td class="codeline">class ScalarEvolutionAnalysis</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeline">    : public AnalysisInfoMixin<ScalarEvolutionAnalysis> {</td>
    <td class="lineNumber">2221</td>
    <td class="codeline">    : public AnalysisInfoMixin<ScalarEvolutionAnalysis> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeline">  friend AnalysisInfoMixin<ScalarEvolutionAnalysis>;</td>
    <td class="lineNumber">2222</td>
    <td class="codeline">  friend AnalysisInfoMixin<ScalarEvolutionAnalysis>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeline"></td>
    <td class="lineNumber">2223</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeline">  static AnalysisKey Key;</td>
    <td class="lineNumber">2224</td>
    <td class="codeline">  static AnalysisKey Key;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeline"></td>
    <td class="lineNumber">2225</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2226</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeline">  using Result = ScalarEvolution;</td>
    <td class="lineNumber">2227</td>
    <td class="codeline">  using Result = ScalarEvolution;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeline"></td>
    <td class="lineNumber">2228</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeline">  ScalarEvolution run(Function &F, FunctionAnalysisManager &AM);</td>
    <td class="lineNumber">2229</td>
    <td class="codeline">  ScalarEvolution run(Function &F, FunctionAnalysisManager &AM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2230</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeline"></td>
    <td class="lineNumber">2231</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeline">/// Verifier pass for the \c ScalarEvolutionAnalysis results.</td>
    <td class="lineNumber">2232</td>
    <td class="codeline">/// Verifier pass for the \c ScalarEvolutionAnalysis results.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeline">class ScalarEvolutionVerifierPass</td>
    <td class="lineNumber">2233</td>
    <td class="codeline">class ScalarEvolutionVerifierPass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeline">    : public PassInfoMixin<ScalarEvolutionVerifierPass> {</td>
    <td class="lineNumber">2234</td>
    <td class="codeline">    : public PassInfoMixin<ScalarEvolutionVerifierPass> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2235</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeline">  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);</td>
    <td class="lineNumber">2236</td>
    <td class="codeline">  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2237</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeline"></td>
    <td class="lineNumber">2238</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeline">/// Printer pass for the \c ScalarEvolutionAnalysis results.</td>
    <td class="lineNumber">2239</td>
    <td class="codeline">/// Printer pass for the \c ScalarEvolutionAnalysis results.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeline">class ScalarEvolutionPrinterPass</td>
    <td class="lineNumber">2240</td>
    <td class="codeline">class ScalarEvolutionPrinterPass</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeline">    : public PassInfoMixin<ScalarEvolutionPrinterPass> {</td>
    <td class="lineNumber">2241</td>
    <td class="codeline">    : public PassInfoMixin<ScalarEvolutionPrinterPass> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeline">  raw_ostream &OS;</td>
    <td class="lineNumber">2242</td>
    <td class="codeline">  raw_ostream &OS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeline"></td>
    <td class="lineNumber">2243</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2244</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeline">  explicit ScalarEvolutionPrinterPass(raw_ostream &OS) : OS(OS) {}</td>
    <td class="lineNumber">2245</td>
    <td class="codeline">  explicit ScalarEvolutionPrinterPass(raw_ostream &OS) : OS(OS) {}</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeline"></td>
    <td class="lineNumber">2246</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeline">  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);</td>
    <td class="lineNumber">2247</td>
    <td class="codeline">  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2248</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeline"></td>
    <td class="lineNumber">2249</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeline">class ScalarEvolutionWrapperPass : public FunctionPass {</td>
    <td class="lineNumber">2250</td>
    <td class="codeline">class ScalarEvolutionWrapperPass : public FunctionPass {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeline">  std::unique_ptr<ScalarEvolution> SE;</td>
    <td class="lineNumber">2251</td>
    <td class="codeline">  std::unique_ptr<ScalarEvolution> SE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeline"></td>
    <td class="lineNumber">2252</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2253</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeline">  static char ID;</td>
    <td class="lineNumber">2254</td>
    <td class="codeline">  static char ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeline"></td>
    <td class="lineNumber">2255</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeline">  ScalarEvolutionWrapperPass();</td>
    <td class="lineNumber">2256</td>
    <td class="codeline">  ScalarEvolutionWrapperPass();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeline"></td>
    <td class="lineNumber">2257</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeline">  ScalarEvolution &getSE() { return *SE; }</td>
    <td class="lineNumber">2258</td>
    <td class="codeline">  ScalarEvolution &getSE() { return *SE; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeline">  const ScalarEvolution &getSE() const { return *SE; }</td>
    <td class="lineNumber">2259</td>
    <td class="codeline">  const ScalarEvolution &getSE() const { return *SE; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeline"></td>
    <td class="lineNumber">2260</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">2261</td>
    <td class="codeline">  bool runOnFunction(Function &F) override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeline">  void releaseMemory() override;</td>
    <td class="lineNumber">2262</td>
    <td class="codeline">  void releaseMemory() override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
    <td class="lineNumber">2263</td>
    <td class="codeline">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeline">  void print(raw_ostream &OS, const Module * = nullptr) const override;</td>
    <td class="lineNumber">2264</td>
    <td class="codeline">  void print(raw_ostream &OS, const Module * = nullptr) const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeline">  void verifyAnalysis() const override;</td>
    <td class="lineNumber">2265</td>
    <td class="codeline">  void verifyAnalysis() const override;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2266</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeline"></td>
    <td class="lineNumber">2267</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeline">/// An interface layer with SCEV used to manage how we see SCEV expressions</td>
    <td class="lineNumber">2268</td>
    <td class="codeline">/// An interface layer with SCEV used to manage how we see SCEV expressions</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeline">/// for values in the context of existing predicates. We can add new</td>
    <td class="lineNumber">2269</td>
    <td class="codeline">/// for values in the context of existing predicates. We can add new</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeline">/// predicates, but we cannot remove them.</td>
    <td class="lineNumber">2270</td>
    <td class="codeline">/// predicates, but we cannot remove them.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeline">///</td>
    <td class="lineNumber">2271</td>
    <td class="codeline">///</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeline">/// This layer has multiple purposes:</td>
    <td class="lineNumber">2272</td>
    <td class="codeline">/// This layer has multiple purposes:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeline">///   - provides a simple interface for SCEV versioning.</td>
    <td class="lineNumber">2273</td>
    <td class="codeline">///   - provides a simple interface for SCEV versioning.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeline">///   - guarantees that the order of transformations applied on a SCEV</td>
    <td class="lineNumber">2274</td>
    <td class="codeline">///   - guarantees that the order of transformations applied on a SCEV</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeline">///     expression for a single Value is consistent across two different</td>
    <td class="lineNumber">2275</td>
    <td class="codeline">///     expression for a single Value is consistent across two different</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeline">///     getSCEV calls. This means that, for example, once we've obtained</td>
    <td class="lineNumber">2276</td>
    <td class="codeline">///     getSCEV calls. This means that, for example, once we've obtained</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeline">///     an AddRec expression for a certain value through expression</td>
    <td class="lineNumber">2277</td>
    <td class="codeline">///     an AddRec expression for a certain value through expression</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeline">///     rewriting, we will continue to get an AddRec expression for that</td>
    <td class="lineNumber">2278</td>
    <td class="codeline">///     rewriting, we will continue to get an AddRec expression for that</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeline">///     Value.</td>
    <td class="lineNumber">2279</td>
    <td class="codeline">///     Value.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeline">///   - lowers the number of expression rewrites.</td>
    <td class="lineNumber">2280</td>
    <td class="codeline">///   - lowers the number of expression rewrites.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeline">class PredicatedScalarEvolution {</td>
    <td class="lineNumber">2281</td>
    <td class="codeline">class PredicatedScalarEvolution {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeline">public:</td>
    <td class="lineNumber">2282</td>
    <td class="codeline">public:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeline">  PredicatedScalarEvolution(ScalarEvolution &SE, Loop &L);</td>
    <td class="lineNumber">2283</td>
    <td class="codeline">  PredicatedScalarEvolution(ScalarEvolution &SE, Loop &L);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeline"></td>
    <td class="lineNumber">2284</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeline">  const SCEVPredicate &getPredicate() const;</td>
    <td class="lineNumber">2285</td>
    <td class="codeline">  const SCEVPredicate &getPredicate() const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeline"></td>
    <td class="lineNumber">2286</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeline">  /// Returns the SCEV expression of V, in the context of the current SCEV</td>
    <td class="lineNumber">2287</td>
    <td class="codeline">  /// Returns the SCEV expression of V, in the context of the current SCEV</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeline">  /// predicate.  The order of transformations applied on the expression of V</td>
    <td class="lineNumber">2288</td>
    <td class="codeline">  /// predicate.  The order of transformations applied on the expression of V</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeline">  /// returned by ScalarEvolution is guaranteed to be preserved, even when</td>
    <td class="lineNumber">2289</td>
    <td class="codeline">  /// returned by ScalarEvolution is guaranteed to be preserved, even when</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeline">  /// adding new predicates.</td>
    <td class="lineNumber">2290</td>
    <td class="codeline">  /// adding new predicates.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeline">  const SCEV *getSCEV(Value *V);</td>
    <td class="lineNumber">2291</td>
    <td class="codeline">  const SCEV *getSCEV(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeline"></td>
    <td class="lineNumber">2292</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeline">  /// Get the (predicated) backedge count for the analyzed loop.</td>
    <td class="lineNumber">2293</td>
    <td class="codeline">  /// Get the (predicated) backedge count for the analyzed loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeline">  const SCEV *getBackedgeTakenCount();</td>
    <td class="lineNumber">2294</td>
    <td class="codeline">  const SCEV *getBackedgeTakenCount();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeline"></td>
    <td class="lineNumber">2295</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeline">  /// Adds a new predicate.</td>
    <td class="lineNumber">2296</td>
    <td class="codeline">  /// Adds a new predicate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeline">  void addPredicate(const SCEVPredicate &Pred);</td>
    <td class="lineNumber">2297</td>
    <td class="codeline">  void addPredicate(const SCEVPredicate &Pred);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeline"></td>
    <td class="lineNumber">2298</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeline">  /// Attempts to produce an AddRecExpr for V by adding additional SCEV</td>
    <td class="lineNumber">2299</td>
    <td class="codeline">  /// Attempts to produce an AddRecExpr for V by adding additional SCEV</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeline">  /// predicates. If we can't transform the expression into an AddRecExpr we</td>
    <td class="lineNumber">2300</td>
    <td class="codeline">  /// predicates. If we can't transform the expression into an AddRecExpr we</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeline">  /// return nullptr and not add additional SCEV predicates to the current</td>
    <td class="lineNumber">2301</td>
    <td class="codeline">  /// return nullptr and not add additional SCEV predicates to the current</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeline">  /// context.</td>
    <td class="lineNumber">2302</td>
    <td class="codeline">  /// context.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeline">  const SCEVAddRecExpr *getAsAddRec(Value *V);</td>
    <td class="lineNumber">2303</td>
    <td class="codeline">  const SCEVAddRecExpr *getAsAddRec(Value *V);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeline"></td>
    <td class="lineNumber">2304</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeline">  /// Proves that V doesn't overflow by adding SCEV predicate.</td>
    <td class="lineNumber">2305</td>
    <td class="codeline">  /// Proves that V doesn't overflow by adding SCEV predicate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeline">  void setNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);</td>
    <td class="lineNumber">2306</td>
    <td class="codeline">  void setNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeline"></td>
    <td class="lineNumber">2307</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeline">  /// Returns true if we've proved that V doesn't wrap by means of a SCEV</td>
    <td class="lineNumber">2308</td>
    <td class="codeline">  /// Returns true if we've proved that V doesn't wrap by means of a SCEV</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeline">  /// predicate.</td>
    <td class="lineNumber">2309</td>
    <td class="codeline">  /// predicate.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeline">  bool hasNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);</td>
    <td class="lineNumber">2310</td>
    <td class="codeline">  bool hasNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeline"></td>
    <td class="lineNumber">2311</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeline">  /// Returns the ScalarEvolution analysis used.</td>
    <td class="lineNumber">2312</td>
    <td class="codeline">  /// Returns the ScalarEvolution analysis used.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeline">  ScalarEvolution *getSE() const { return &SE; }</td>
    <td class="lineNumber">2313</td>
    <td class="codeline">  ScalarEvolution *getSE() const { return &SE; }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeline"></td>
    <td class="lineNumber">2314</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeline">  /// We need to explicitly define the copy constructor because of FlagsMap.</td>
    <td class="lineNumber">2315</td>
    <td class="codeline">  /// We need to explicitly define the copy constructor because of FlagsMap.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeline">  PredicatedScalarEvolution(const PredicatedScalarEvolution &);</td>
    <td class="lineNumber">2316</td>
    <td class="codeline">  PredicatedScalarEvolution(const PredicatedScalarEvolution &);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeline"></td>
    <td class="lineNumber">2317</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeline">  /// Print the SCEV mappings done by the Predicated Scalar Evolution.</td>
    <td class="lineNumber">2318</td>
    <td class="codeline">  /// Print the SCEV mappings done by the Predicated Scalar Evolution.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeline">  /// The printed text is indented by \p Depth.</td>
    <td class="lineNumber">2319</td>
    <td class="codeline">  /// The printed text is indented by \p Depth.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeline">  void print(raw_ostream &OS, unsigned Depth) const;</td>
    <td class="lineNumber">2320</td>
    <td class="codeline">  void print(raw_ostream &OS, unsigned Depth) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeline"></td>
    <td class="lineNumber">2321</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeline">  /// Check if \p AR1 and \p AR2 are equal, while taking into account</td>
    <td class="lineNumber">2322</td>
    <td class="codeline">  /// Check if \p AR1 and \p AR2 are equal, while taking into account</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeline">  /// Equal predicates in Preds.</td>
    <td class="lineNumber">2323</td>
    <td class="codeline">  /// Equal predicates in Preds.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeline">  bool areAddRecsEqualWithPreds(const SCEVAddRecExpr *AR1,</td>
    <td class="lineNumber">2324</td>
    <td class="codeline">  bool areAddRecsEqualWithPreds(const SCEVAddRecExpr *AR1,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeline">                                const SCEVAddRecExpr *AR2) const;</td>
    <td class="lineNumber">2325</td>
    <td class="codeline">                                const SCEVAddRecExpr *AR2) const;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeline"></td>
    <td class="lineNumber">2326</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeline">private:</td>
    <td class="lineNumber">2327</td>
    <td class="codeline">private:</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeline">  /// Increments the version number of the predicate.  This needs to be called</td>
    <td class="lineNumber">2328</td>
    <td class="codeline">  /// Increments the version number of the predicate.  This needs to be called</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeline">  /// every time the SCEV predicate changes.</td>
    <td class="lineNumber">2329</td>
    <td class="codeline">  /// every time the SCEV predicate changes.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeline">  void updateGeneration();</td>
    <td class="lineNumber">2330</td>
    <td class="codeline">  void updateGeneration();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeline"></td>
    <td class="lineNumber">2331</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeline">  /// Holds a SCEV and the version number of the SCEV predicate used to</td>
    <td class="lineNumber">2332</td>
    <td class="codeline">  /// Holds a SCEV and the version number of the SCEV predicate used to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeline">  /// perform the rewrite of the expression.</td>
    <td class="lineNumber">2333</td>
    <td class="codeline">  /// perform the rewrite of the expression.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeline">  using RewriteEntry = std::pair<unsigned, const SCEV *>;</td>
    <td class="lineNumber">2334</td>
    <td class="codeline">  using RewriteEntry = std::pair<unsigned, const SCEV *>;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeline"></td>
    <td class="lineNumber">2335</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeline">  /// Maps a SCEV to the rewrite result of that SCEV at a certain version</td>
    <td class="lineNumber">2336</td>
    <td class="codeline">  /// Maps a SCEV to the rewrite result of that SCEV at a certain version</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeline">  /// number. If this number doesn't match the current Generation, we will</td>
    <td class="lineNumber">2337</td>
    <td class="codeline">  /// number. If this number doesn't match the current Generation, we will</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeline">  /// need to do a rewrite. To preserve the transformation order of previous</td>
    <td class="lineNumber">2338</td>
    <td class="codeline">  /// need to do a rewrite. To preserve the transformation order of previous</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeline">  /// rewrites, we will rewrite the previous result instead of the original</td>
    <td class="lineNumber">2339</td>
    <td class="codeline">  /// rewrites, we will rewrite the previous result instead of the original</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeline">  /// SCEV.</td>
    <td class="lineNumber">2340</td>
    <td class="codeline">  /// SCEV.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeline">  DenseMap<const SCEV *, RewriteEntry> RewriteMap;</td>
    <td class="lineNumber">2341</td>
    <td class="codeline">  DenseMap<const SCEV *, RewriteEntry> RewriteMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeline"></td>
    <td class="lineNumber">2342</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeline">  /// Records what NoWrap flags we've added to a Value *.</td>
    <td class="lineNumber">2343</td>
    <td class="codeline">  /// Records what NoWrap flags we've added to a Value *.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeline">  ValueMap<Value *, SCEVWrapPredicate::IncrementWrapFlags> FlagsMap;</td>
    <td class="lineNumber">2344</td>
    <td class="codeline">  ValueMap<Value *, SCEVWrapPredicate::IncrementWrapFlags> FlagsMap;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeline"></td>
    <td class="lineNumber">2345</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeline">  /// The ScalarEvolution analysis.</td>
    <td class="lineNumber">2346</td>
    <td class="codeline">  /// The ScalarEvolution analysis.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeline">  ScalarEvolution &SE;</td>
    <td class="lineNumber">2347</td>
    <td class="codeline">  ScalarEvolution &SE;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeline"></td>
    <td class="lineNumber">2348</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeline">  /// The analyzed Loop.</td>
    <td class="lineNumber">2349</td>
    <td class="codeline">  /// The analyzed Loop.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeline">  const Loop &L;</td>
    <td class="lineNumber">2350</td>
    <td class="codeline">  const Loop &L;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeline"></td>
    <td class="lineNumber">2351</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeline">  /// The SCEVPredicate that forms our context. We will rewrite all</td>
    <td class="lineNumber">2352</td>
    <td class="codeline">  /// The SCEVPredicate that forms our context. We will rewrite all</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeline">  /// expressions assuming that this predicate true.</td>
    <td class="lineNumber">2353</td>
    <td class="codeline">  /// expressions assuming that this predicate true.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeline">  std::unique_ptr<SCEVUnionPredicate> Preds;</td>
    <td class="lineNumber">2354</td>
    <td class="codeline">  std::unique_ptr<SCEVUnionPredicate> Preds;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeline"></td>
    <td class="lineNumber">2355</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeline">  /// Marks the version of the SCEV predicate used. When rewriting a SCEV</td>
    <td class="lineNumber">2356</td>
    <td class="codeline">  /// Marks the version of the SCEV predicate used. When rewriting a SCEV</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeline">  /// expression we mark it with the version of the predicate. We use this to</td>
    <td class="lineNumber">2357</td>
    <td class="codeline">  /// expression we mark it with the version of the predicate. We use this to</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeline">  /// figure out if the predicate has changed from the last rewrite of the</td>
    <td class="lineNumber">2358</td>
    <td class="codeline">  /// figure out if the predicate has changed from the last rewrite of the</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeline">  /// SCEV. If so, we need to perform a new rewrite.</td>
    <td class="lineNumber">2359</td>
    <td class="codeline">  /// SCEV. If so, we need to perform a new rewrite.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeline">  unsigned Generation = 0;</td>
    <td class="lineNumber">2360</td>
    <td class="codeline">  unsigned Generation = 0;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeline"></td>
    <td class="lineNumber">2361</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeline">  /// The backedge taken count.</td>
    <td class="lineNumber">2362</td>
    <td class="codeline">  /// The backedge taken count.</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeline">  const SCEV *BackedgeCount = nullptr;</td>
    <td class="lineNumber">2363</td>
    <td class="codeline">  const SCEV *BackedgeCount = nullptr;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2364</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeline"></td>
    <td class="lineNumber">2365</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeline">template <> struct DenseMapInfo<ScalarEvolution::FoldID> {</td>
    <td class="lineNumber">2366</td>
    <td class="codeline">template <> struct DenseMapInfo<ScalarEvolution::FoldID> {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeline">  static inline ScalarEvolution::FoldID getEmptyKey() {</td>
    <td class="lineNumber">2367</td>
    <td class="codeline">  static inline ScalarEvolution::FoldID getEmptyKey() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeline">    ScalarEvolution::FoldID ID(0);</td>
    <td class="lineNumber">2368</td>
    <td class="codeline">    ScalarEvolution::FoldID ID(0);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeline">    return ID;</td>
    <td class="lineNumber">2369</td>
    <td class="codeline">    return ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2370</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeline">  static inline ScalarEvolution::FoldID getTombstoneKey() {</td>
    <td class="lineNumber">2371</td>
    <td class="codeline">  static inline ScalarEvolution::FoldID getTombstoneKey() {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeline">    ScalarEvolution::FoldID ID(1);</td>
    <td class="lineNumber">2372</td>
    <td class="codeline">    ScalarEvolution::FoldID ID(1);</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeline">    return ID;</td>
    <td class="lineNumber">2373</td>
    <td class="codeline">    return ID;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2374</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeline"></td>
    <td class="lineNumber">2375</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeline">  static unsigned getHashValue(const ScalarEvolution::FoldID &Val) {</td>
    <td class="lineNumber">2376</td>
    <td class="codeline">  static unsigned getHashValue(const ScalarEvolution::FoldID &Val) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeline">    return Val.computeHash();</td>
    <td class="lineNumber">2377</td>
    <td class="codeline">    return Val.computeHash();</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2378</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeline"></td>
    <td class="lineNumber">2379</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeline">  static bool isEqual(const ScalarEvolution::FoldID &LHS,</td>
    <td class="lineNumber">2380</td>
    <td class="codeline">  static bool isEqual(const ScalarEvolution::FoldID &LHS,</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeline">                      const ScalarEvolution::FoldID &RHS) {</td>
    <td class="lineNumber">2381</td>
    <td class="codeline">                      const ScalarEvolution::FoldID &RHS) {</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeline">    return LHS == RHS;</td>
    <td class="lineNumber">2382</td>
    <td class="codeline">    return LHS == RHS;</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeline">  }</td>
    <td class="lineNumber">2383</td>
    <td class="codeline">  }</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeline">};</td>
    <td class="lineNumber">2384</td>
    <td class="codeline">};</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeline"></td>
    <td class="lineNumber">2385</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeline">} // end namespace llvm</td>
    <td class="lineNumber">2386</td>
    <td class="codeline">} // end namespace llvm</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeline"></td>
    <td class="lineNumber">2387</td>
    <td class="codeline"></td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeline">#endif // LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
    <td class="lineNumber">2388</td>
    <td class="codeline">#endif // LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeline"></td>
    <td class="lineNumber">2389</td>
    <td class="codeline"></td>
  </tr>
</table>
    </div>
    <button class="collapsible" type="button">Open Side By Side Comparison</button>
    <div class="content" style="display: none;">
      <hr />
      <h3 class="subheader">Side By Side Comparison</h3>
      <table class="mainTable">
  <tr class="mainTr">
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips_dbg.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
    <th class="mainTh">Line Number</th>
    <th class="mainTh">
      <span class="badge">../DebugInfoTest/example_mips.ll</span>
    </th>
    <th class="mainTh">Hit count</th>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- llvm/Analysis/ScalarEvolution.h - Scalar Evolution -------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1</td>
    <td class="codeLine">//===- llvm/Analysis/ScalarEvolution.h - Scalar Evolution -------*- C++ -*-===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">3</td>
    <td class="codeLine">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">4</td>
    <td class="codeLine">// See https://llvm.org/LICENSE.txt for license information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">5</td>
    <td class="codeLine">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">6</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">7</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">8</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">9</td>
    <td class="codeLine">// The ScalarEvolution class is an LLVM pass which can be used to analyze and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">9</td>
    <td class="codeLine">// The ScalarEvolution class is an LLVM pass which can be used to analyze and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">10</td>
    <td class="codeLine">// categorize scalar expressions in loops.  It specializes in recognizing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">10</td>
    <td class="codeLine">// categorize scalar expressions in loops.  It specializes in recognizing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">11</td>
    <td class="codeLine">// general induction variables, representing them with the abstract and opaque</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">11</td>
    <td class="codeLine">// general induction variables, representing them with the abstract and opaque</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">12</td>
    <td class="codeLine">// SCEV class.  Given this analysis, trip counts of loops and other important</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">12</td>
    <td class="codeLine">// SCEV class.  Given this analysis, trip counts of loops and other important</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">13</td>
    <td class="codeLine">// properties can be obtained.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">13</td>
    <td class="codeLine">// properties can be obtained.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">14</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">14</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">15</td>
    <td class="codeLine">// This analysis is primarily useful for induction variable substitution and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">15</td>
    <td class="codeLine">// This analysis is primarily useful for induction variable substitution and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">16</td>
    <td class="codeLine">// strength reduction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">16</td>
    <td class="codeLine">// strength reduction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">17</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">17</td>
    <td class="codeLine">//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">18</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">18</td>
    <td class="codeLine">//===----------------------------------------------------------------------===//</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">19</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">19</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">20</td>
    <td class="codeLine">#ifndef LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">20</td>
    <td class="codeLine">#ifndef LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">21</td>
    <td class="codeLine">#define LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">21</td>
    <td class="codeLine">#define LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">22</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">22</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">23</td>
    <td class="codeLine">#include "llvm/ADT/APInt.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">24</td>
    <td class="codeLine">#include "llvm/ADT/ArrayRef.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">25</td>
    <td class="codeLine">#include "llvm/ADT/DenseMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">26</td>
    <td class="codeLine">#include "llvm/ADT/DenseMapInfo.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/ADT/FoldingSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">27</td>
    <td class="codeLine">#include "llvm/ADT/FoldingSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/ADT/PointerIntPair.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">28</td>
    <td class="codeLine">#include "llvm/ADT/PointerIntPair.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">29</td>
    <td class="codeLine">#include "llvm/ADT/SetVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">30</td>
    <td class="codeLine">#include "llvm/ADT/SmallPtrSet.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">31</td>
    <td class="codeLine">#include "llvm/ADT/SmallVector.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/IR/ConstantRange.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">32</td>
    <td class="codeLine">#include "llvm/IR/ConstantRange.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">33</td>
    <td class="codeLine">#include "llvm/IR/InstrTypes.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">34</td>
    <td class="codeLine">#include "llvm/IR/Instructions.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">35</td>
    <td class="codeLine">#include "llvm/IR/PassManager.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/ValueHandle.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">36</td>
    <td class="codeLine">#include "llvm/IR/ValueHandle.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/ValueMap.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">37</td>
    <td class="codeLine">#include "llvm/IR/ValueMap.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">38</td>
    <td class="codeLine">#include "llvm/Pass.h"</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">39</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">39</td>
    <td class="codeLine">#include <cassert></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">40</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">40</td>
    <td class="codeLine">#include <cstdint></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">41</td>
    <td class="codeLine">#include <memory></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">41</td>
    <td class="codeLine">#include <memory></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">42</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">42</td>
    <td class="codeLine">#include <optional></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">43</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">43</td>
    <td class="codeLine">#include <utility></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">44</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">44</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">45</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">45</td>
    <td class="codeLine">namespace llvm {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">46</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">46</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">47</td>
    <td class="codeLine">class OverflowingBinaryOperator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">47</td>
    <td class="codeLine">class OverflowingBinaryOperator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">48</td>
    <td class="codeLine">class AssumptionCache;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">48</td>
    <td class="codeLine">class AssumptionCache;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">49</td>
    <td class="codeLine">class BasicBlock;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">49</td>
    <td class="codeLine">class BasicBlock;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">50</td>
    <td class="codeLine">class Constant;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">50</td>
    <td class="codeLine">class Constant;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">51</td>
    <td class="codeLine">class ConstantInt;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">51</td>
    <td class="codeLine">class ConstantInt;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">52</td>
    <td class="codeLine">class DataLayout;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">52</td>
    <td class="codeLine">class DataLayout;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">53</td>
    <td class="codeLine">class DominatorTree;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">53</td>
    <td class="codeLine">class DominatorTree;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">54</td>
    <td class="codeLine">class Function;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">54</td>
    <td class="codeLine">class Function;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">55</td>
    <td class="codeLine">class GEPOperator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">55</td>
    <td class="codeLine">class GEPOperator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">56</td>
    <td class="codeLine">class Instruction;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">56</td>
    <td class="codeLine">class Instruction;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">57</td>
    <td class="codeLine">class LLVMContext;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">57</td>
    <td class="codeLine">class LLVMContext;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">58</td>
    <td class="codeLine">class Loop;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">58</td>
    <td class="codeLine">class Loop;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">59</td>
    <td class="codeLine">class LoopInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">59</td>
    <td class="codeLine">class LoopInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">60</td>
    <td class="codeLine">class raw_ostream;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">60</td>
    <td class="codeLine">class raw_ostream;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">61</td>
    <td class="codeLine">class ScalarEvolution;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">61</td>
    <td class="codeLine">class ScalarEvolution;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">62</td>
    <td class="codeLine">class SCEVAddRecExpr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">62</td>
    <td class="codeLine">class SCEVAddRecExpr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">63</td>
    <td class="codeLine">class SCEVUnknown;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">63</td>
    <td class="codeLine">class SCEVUnknown;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">64</td>
    <td class="codeLine">class StructType;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">64</td>
    <td class="codeLine">class StructType;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">65</td>
    <td class="codeLine">class TargetLibraryInfo;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">65</td>
    <td class="codeLine">class TargetLibraryInfo;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">66</td>
    <td class="codeLine">class Type;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">66</td>
    <td class="codeLine">class Type;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">67</td>
    <td class="codeLine">class Value;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">67</td>
    <td class="codeLine">class Value;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">68</td>
    <td class="codeLine">enum SCEVTypes : unsigned short;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">68</td>
    <td class="codeLine">enum SCEVTypes : unsigned short;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">69</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">69</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">70</td>
    <td class="codeLine">extern bool VerifySCEV;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">70</td>
    <td class="codeLine">extern bool VerifySCEV;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">71</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">72</td>
    <td class="codeLine">/// This class represents an analyzed expression in the program.  These are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">72</td>
    <td class="codeLine">/// This class represents an analyzed expression in the program.  These are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">73</td>
    <td class="codeLine">/// opaque objects that the client is not allowed to do much with directly.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">73</td>
    <td class="codeLine">/// opaque objects that the client is not allowed to do much with directly.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">74</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">74</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">75</td>
    <td class="codeLine">class SCEV : public FoldingSetNode {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">75</td>
    <td class="codeLine">class SCEV : public FoldingSetNode {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">76</td>
    <td class="codeLine">  friend struct FoldingSetTrait<SCEV>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">76</td>
    <td class="codeLine">  friend struct FoldingSetTrait<SCEV>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">77</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">78</td>
    <td class="codeLine">  /// A reference to an Interned FoldingSetNodeID for this node.  The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">78</td>
    <td class="codeLine">  /// A reference to an Interned FoldingSetNodeID for this node.  The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">79</td>
    <td class="codeLine">  /// ScalarEvolution's BumpPtrAllocator holds the data.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">79</td>
    <td class="codeLine">  /// ScalarEvolution's BumpPtrAllocator holds the data.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">80</td>
    <td class="codeLine">  FoldingSetNodeIDRef FastID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">80</td>
    <td class="codeLine">  FoldingSetNodeIDRef FastID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">81</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">82</td>
    <td class="codeLine">  // The SCEV baseclass this node corresponds to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">82</td>
    <td class="codeLine">  // The SCEV baseclass this node corresponds to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">83</td>
    <td class="codeLine">  const SCEVTypes SCEVType;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">83</td>
    <td class="codeLine">  const SCEVTypes SCEVType;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">84</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">84</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">85</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">85</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">86</td>
    <td class="codeLine">  // Estimated complexity of this node's expression tree size.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">86</td>
    <td class="codeLine">  // Estimated complexity of this node's expression tree size.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">87</td>
    <td class="codeLine">  const unsigned short ExpressionSize;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">87</td>
    <td class="codeLine">  const unsigned short ExpressionSize;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">88</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">89</td>
    <td class="codeLine">  /// This field is initialized to zero and may be used in subclasses to store</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">89</td>
    <td class="codeLine">  /// This field is initialized to zero and may be used in subclasses to store</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">90</td>
    <td class="codeLine">  /// miscellaneous information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">90</td>
    <td class="codeLine">  /// miscellaneous information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">91</td>
    <td class="codeLine">  unsigned short SubclassData = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">91</td>
    <td class="codeLine">  unsigned short SubclassData = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">92</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">92</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">93</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">93</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">94</td>
    <td class="codeLine">  /// NoWrapFlags are bitfield indices into SubclassData.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">94</td>
    <td class="codeLine">  /// NoWrapFlags are bitfield indices into SubclassData.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">95</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">95</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">96</td>
    <td class="codeLine">  /// Add and Mul expressions may have no-unsigned-wrap <NUW> or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">96</td>
    <td class="codeLine">  /// Add and Mul expressions may have no-unsigned-wrap <NUW> or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">97</td>
    <td class="codeLine">  /// no-signed-wrap <NSW> properties, which are derived from the IR</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">97</td>
    <td class="codeLine">  /// no-signed-wrap <NSW> properties, which are derived from the IR</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">98</td>
    <td class="codeLine">  /// operator. NSW is a misnomer that we use to mean no signed overflow or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">98</td>
    <td class="codeLine">  /// operator. NSW is a misnomer that we use to mean no signed overflow or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">99</td>
    <td class="codeLine">  /// underflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">99</td>
    <td class="codeLine">  /// underflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">100</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">100</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">101</td>
    <td class="codeLine">  /// AddRec expressions may have a no-self-wraparound <NW> property if, in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">101</td>
    <td class="codeLine">  /// AddRec expressions may have a no-self-wraparound <NW> property if, in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">102</td>
    <td class="codeLine">  /// the integer domain, abs(step) * max-iteration(loop) <=</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">102</td>
    <td class="codeLine">  /// the integer domain, abs(step) * max-iteration(loop) <=</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">103</td>
    <td class="codeLine">  /// unsigned-max(bitwidth).  This means that the recurrence will never reach</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">103</td>
    <td class="codeLine">  /// unsigned-max(bitwidth).  This means that the recurrence will never reach</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">104</td>
    <td class="codeLine">  /// its start value if the step is non-zero.  Computing the same value on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">104</td>
    <td class="codeLine">  /// its start value if the step is non-zero.  Computing the same value on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">105</td>
    <td class="codeLine">  /// each iteration is not considered wrapping, and recurrences with step = 0</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">105</td>
    <td class="codeLine">  /// each iteration is not considered wrapping, and recurrences with step = 0</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">106</td>
    <td class="codeLine">  /// are trivially <NW>.  <NW> is independent of the sign of step and the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">106</td>
    <td class="codeLine">  /// are trivially <NW>.  <NW> is independent of the sign of step and the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">107</td>
    <td class="codeLine">  /// value the add recurrence starts with.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">107</td>
    <td class="codeLine">  /// value the add recurrence starts with.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">108</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">108</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">109</td>
    <td class="codeLine">  /// Note that NUW and NSW are also valid properties of a recurrence, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">109</td>
    <td class="codeLine">  /// Note that NUW and NSW are also valid properties of a recurrence, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">110</td>
    <td class="codeLine">  /// either implies NW. For convenience, NW will be set for a recurrence</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">110</td>
    <td class="codeLine">  /// either implies NW. For convenience, NW will be set for a recurrence</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">111</td>
    <td class="codeLine">  /// whenever either NUW or NSW are set.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">111</td>
    <td class="codeLine">  /// whenever either NUW or NSW are set.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">112</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">112</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">113</td>
    <td class="codeLine">  /// We require that the flag on a SCEV apply to the entire scope in which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">113</td>
    <td class="codeLine">  /// We require that the flag on a SCEV apply to the entire scope in which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">114</td>
    <td class="codeLine">  /// that SCEV is defined.  A SCEV's scope is set of locations dominated by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">114</td>
    <td class="codeLine">  /// that SCEV is defined.  A SCEV's scope is set of locations dominated by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">115</td>
    <td class="codeLine">  /// a defining location, which is in turn described by the following rules:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">115</td>
    <td class="codeLine">  /// a defining location, which is in turn described by the following rules:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">116</td>
    <td class="codeLine">  /// * A SCEVUnknown is at the point of definition of the Value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">116</td>
    <td class="codeLine">  /// * A SCEVUnknown is at the point of definition of the Value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">117</td>
    <td class="codeLine">  /// * A SCEVConstant is defined at all points.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">117</td>
    <td class="codeLine">  /// * A SCEVConstant is defined at all points.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">118</td>
    <td class="codeLine">  /// * A SCEVAddRec is defined starting with the header of the associated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">118</td>
    <td class="codeLine">  /// * A SCEVAddRec is defined starting with the header of the associated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">119</td>
    <td class="codeLine">  ///   loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">119</td>
    <td class="codeLine">  ///   loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">120</td>
    <td class="codeLine">  /// * All other SCEVs are defined at the earlest point all operands are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">120</td>
    <td class="codeLine">  /// * All other SCEVs are defined at the earlest point all operands are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">121</td>
    <td class="codeLine">  ///   defined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">121</td>
    <td class="codeLine">  ///   defined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">122</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">122</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">123</td>
    <td class="codeLine">  /// The above rules describe a maximally hoisted form (without regards to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">123</td>
    <td class="codeLine">  /// The above rules describe a maximally hoisted form (without regards to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">124</td>
    <td class="codeLine">  /// potential control dependence).  A SCEV is defined anywhere a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">124</td>
    <td class="codeLine">  /// potential control dependence).  A SCEV is defined anywhere a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">125</td>
    <td class="codeLine">  /// corresponding instruction could be defined in said maximally hoisted</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">125</td>
    <td class="codeLine">  /// corresponding instruction could be defined in said maximally hoisted</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">126</td>
    <td class="codeLine">  /// form.  Note that SCEVUDivExpr (currently the only expression type which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">126</td>
    <td class="codeLine">  /// form.  Note that SCEVUDivExpr (currently the only expression type which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">127</td>
    <td class="codeLine">  /// can trap) can be defined per these rules in regions where it would trap</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">127</td>
    <td class="codeLine">  /// can trap) can be defined per these rules in regions where it would trap</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">128</td>
    <td class="codeLine">  /// at runtime.  A SCEV being defined does not require the existence of any</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">128</td>
    <td class="codeLine">  /// at runtime.  A SCEV being defined does not require the existence of any</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">129</td>
    <td class="codeLine">  /// instruction within the defined scope.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">129</td>
    <td class="codeLine">  /// instruction within the defined scope.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">130</td>
    <td class="codeLine">  enum NoWrapFlags {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">130</td>
    <td class="codeLine">  enum NoWrapFlags {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">131</td>
    <td class="codeLine">    FlagAnyWrap = 0,    // No guarantee.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">131</td>
    <td class="codeLine">    FlagAnyWrap = 0,    // No guarantee.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">132</td>
    <td class="codeLine">    FlagNW = (1 << 0),  // No self-wrap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">132</td>
    <td class="codeLine">    FlagNW = (1 << 0),  // No self-wrap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">133</td>
    <td class="codeLine">    FlagNUW = (1 << 1), // No unsigned wrap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">133</td>
    <td class="codeLine">    FlagNUW = (1 << 1), // No unsigned wrap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">134</td>
    <td class="codeLine">    FlagNSW = (1 << 2), // No signed wrap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">134</td>
    <td class="codeLine">    FlagNSW = (1 << 2), // No signed wrap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">135</td>
    <td class="codeLine">    NoWrapMask = (1 << 3) - 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">135</td>
    <td class="codeLine">    NoWrapMask = (1 << 3) - 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">136</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">136</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">138</td>
    <td class="codeLine coveredLine">  explicit SCEV(const FoldingSetNodeIDRef ID, SCEVTypes SCEVTy,</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">138</td>
    <td class="codeLine coveredLine">  explicit SCEV(const FoldingSetNodeIDRef ID, SCEVTypes SCEVTy,</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">139</td>
    <td class="codeLine">                unsigned short ExpressionSize)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">139</td>
    <td class="codeLine">                unsigned short ExpressionSize)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">140</td>
    <td class="codeLine coveredLine">      : FastID(ID), SCEVType(SCEVTy), ExpressionSize(ExpressionSize) {}</td>
    <td class="lineNumber">1</td>
    <td class="lineNumber">140</td>
    <td class="codeLine coveredLine">      : FastID(ID), SCEVType(SCEVTy), ExpressionSize(ExpressionSize) {}</td>
    <td class="lineNumber">1</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">141</td>
    <td class="codeLine">  SCEV(const SCEV &) = delete;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">141</td>
    <td class="codeLine">  SCEV(const SCEV &) = delete;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">142</td>
    <td class="codeLine">  SCEV &operator=(const SCEV &) = delete;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">142</td>
    <td class="codeLine">  SCEV &operator=(const SCEV &) = delete;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">144</td>
    <td class="codeLine">  SCEVTypes getSCEVType() const { return SCEVType; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">144</td>
    <td class="codeLine">  SCEVTypes getSCEVType() const { return SCEVType; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">145</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">146</td>
    <td class="codeLine">  /// Return the LLVM type of this SCEV expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">146</td>
    <td class="codeLine">  /// Return the LLVM type of this SCEV expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">147</td>
    <td class="codeLine">  Type *getType() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">147</td>
    <td class="codeLine">  Type *getType() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">149</td>
    <td class="codeLine">  /// Return operands of this SCEV expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">149</td>
    <td class="codeLine">  /// Return operands of this SCEV expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">150</td>
    <td class="codeLine">  ArrayRef<const SCEV *> operands() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">150</td>
    <td class="codeLine">  ArrayRef<const SCEV *> operands() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">152</td>
    <td class="codeLine">  /// Return true if the expression is a constant zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">152</td>
    <td class="codeLine">  /// Return true if the expression is a constant zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">153</td>
    <td class="codeLine">  bool isZero() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">153</td>
    <td class="codeLine">  bool isZero() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">154</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">155</td>
    <td class="codeLine">  /// Return true if the expression is a constant one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">155</td>
    <td class="codeLine">  /// Return true if the expression is a constant one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">156</td>
    <td class="codeLine">  bool isOne() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">156</td>
    <td class="codeLine">  bool isOne() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">158</td>
    <td class="codeLine">  /// Return true if the expression is a constant all-ones value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">158</td>
    <td class="codeLine">  /// Return true if the expression is a constant all-ones value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">159</td>
    <td class="codeLine">  bool isAllOnesValue() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">159</td>
    <td class="codeLine">  bool isAllOnesValue() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">160</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">161</td>
    <td class="codeLine">  /// Return true if the specified scev is negated, but not a constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">161</td>
    <td class="codeLine">  /// Return true if the specified scev is negated, but not a constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">162</td>
    <td class="codeLine">  bool isNonConstantNegative() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">162</td>
    <td class="codeLine">  bool isNonConstantNegative() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">163</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">163</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">164</td>
    <td class="codeLine">  // Returns estimated size of the mathematical expression represented by this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">164</td>
    <td class="codeLine">  // Returns estimated size of the mathematical expression represented by this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">165</td>
    <td class="codeLine">  // SCEV. The rules of its calculation are following:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">165</td>
    <td class="codeLine">  // SCEV. The rules of its calculation are following:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">166</td>
    <td class="codeLine">  // 1) Size of a SCEV without operands (like constants and SCEVUnknown) is 1;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">166</td>
    <td class="codeLine">  // 1) Size of a SCEV without operands (like constants and SCEVUnknown) is 1;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">167</td>
    <td class="codeLine">  // 2) Size SCEV with operands Op1, Op2, ..., OpN is calculated by formula:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">167</td>
    <td class="codeLine">  // 2) Size SCEV with operands Op1, Op2, ..., OpN is calculated by formula:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">168</td>
    <td class="codeLine">  //    (1 + Size(Op1) + ... + Size(OpN)).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">168</td>
    <td class="codeLine">  //    (1 + Size(Op1) + ... + Size(OpN)).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">169</td>
    <td class="codeLine">  // This value gives us an estimation of time we need to traverse through this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">169</td>
    <td class="codeLine">  // This value gives us an estimation of time we need to traverse through this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">170</td>
    <td class="codeLine">  // SCEV and all its operands recursively. We may use it to avoid performing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">170</td>
    <td class="codeLine">  // SCEV and all its operands recursively. We may use it to avoid performing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">171</td>
    <td class="codeLine">  // heavy transformations on SCEVs of excessive size for sake of saving the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">171</td>
    <td class="codeLine">  // heavy transformations on SCEVs of excessive size for sake of saving the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">172</td>
    <td class="codeLine">  // compilation time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">172</td>
    <td class="codeLine">  // compilation time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">173</td>
    <td class="codeLine">  unsigned short getExpressionSize() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">173</td>
    <td class="codeLine">  unsigned short getExpressionSize() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">174</td>
    <td class="codeLine">    return ExpressionSize;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">174</td>
    <td class="codeLine">    return ExpressionSize;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">175</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">175</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">176</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">177</td>
    <td class="codeLine">  /// Print out the internal representation of this scalar to the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">177</td>
    <td class="codeLine">  /// Print out the internal representation of this scalar to the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">178</td>
    <td class="codeLine">  /// stream.  This should really only be used for debugging purposes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">178</td>
    <td class="codeLine">  /// stream.  This should really only be used for debugging purposes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">179</td>
    <td class="codeLine">  void print(raw_ostream &OS) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">179</td>
    <td class="codeLine">  void print(raw_ostream &OS) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">180</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">181</td>
    <td class="codeLine">  /// This method is used for debugging.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">181</td>
    <td class="codeLine">  /// This method is used for debugging.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">182</td>
    <td class="codeLine">  void dump() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">182</td>
    <td class="codeLine">  void dump() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">183</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">183</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">184</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">185</td>
    <td class="codeLine">// Specialize FoldingSetTrait for SCEV to avoid needing to compute</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">185</td>
    <td class="codeLine">// Specialize FoldingSetTrait for SCEV to avoid needing to compute</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">186</td>
    <td class="codeLine">// temporary FoldingSetNodeID values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">186</td>
    <td class="codeLine">// temporary FoldingSetNodeID values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">187</td>
    <td class="codeLine">template <> struct FoldingSetTrait<SCEV> : DefaultFoldingSetTrait<SCEV> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">187</td>
    <td class="codeLine">template <> struct FoldingSetTrait<SCEV> : DefaultFoldingSetTrait<SCEV> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">188</td>
    <td class="codeLine">  static void Profile(const SCEV &X, FoldingSetNodeID &ID) { ID = X.FastID; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">188</td>
    <td class="codeLine">  static void Profile(const SCEV &X, FoldingSetNodeID &ID) { ID = X.FastID; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">189</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">190</td>
    <td class="codeLine">  static bool Equals(const SCEV &X, const FoldingSetNodeID &ID, unsigned IDHash,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">190</td>
    <td class="codeLine">  static bool Equals(const SCEV &X, const FoldingSetNodeID &ID, unsigned IDHash,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">191</td>
    <td class="codeLine">                     FoldingSetNodeID &TempID) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">191</td>
    <td class="codeLine">                     FoldingSetNodeID &TempID) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">192</td>
    <td class="codeLine">    return ID == X.FastID;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">192</td>
    <td class="codeLine">    return ID == X.FastID;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">193</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">193</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">194</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">195</td>
    <td class="codeLine">  static unsigned ComputeHash(const SCEV &X, FoldingSetNodeID &TempID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">195</td>
    <td class="codeLine">  static unsigned ComputeHash(const SCEV &X, FoldingSetNodeID &TempID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">196</td>
    <td class="codeLine">    return X.FastID.ComputeHash();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">196</td>
    <td class="codeLine">    return X.FastID.ComputeHash();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">197</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">197</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">198</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">198</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">200</td>
    <td class="codeLine">inline raw_ostream &operator<<(raw_ostream &OS, const SCEV &S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">200</td>
    <td class="codeLine">inline raw_ostream &operator<<(raw_ostream &OS, const SCEV &S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">201</td>
    <td class="codeLine">  S.print(OS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">201</td>
    <td class="codeLine">  S.print(OS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">202</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">202</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">203</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">203</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">205</td>
    <td class="codeLine">/// An object of this class is returned by queries that could not be answered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">205</td>
    <td class="codeLine">/// An object of this class is returned by queries that could not be answered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">206</td>
    <td class="codeLine">/// For example, if you ask for the number of iterations of a linked-list</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">206</td>
    <td class="codeLine">/// For example, if you ask for the number of iterations of a linked-list</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">207</td>
    <td class="codeLine">/// traversal loop, you will get one of these.  None of the standard SCEV</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">207</td>
    <td class="codeLine">/// traversal loop, you will get one of these.  None of the standard SCEV</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">208</td>
    <td class="codeLine">/// operations are valid on this class, it is just a marker.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">208</td>
    <td class="codeLine">/// operations are valid on this class, it is just a marker.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">209</td>
    <td class="codeLine">struct SCEVCouldNotCompute : public SCEV {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">209</td>
    <td class="codeLine">struct SCEVCouldNotCompute : public SCEV {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">210</td>
    <td class="codeLine">  SCEVCouldNotCompute();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">210</td>
    <td class="codeLine">  SCEVCouldNotCompute();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">212</td>
    <td class="codeLine">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">212</td>
    <td class="codeLine">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">213</td>
    <td class="codeLine">  static bool classof(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">213</td>
    <td class="codeLine">  static bool classof(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">214</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">214</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">216</td>
    <td class="codeLine">/// This class represents an assumption made using SCEV expressions which can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">216</td>
    <td class="codeLine">/// This class represents an assumption made using SCEV expressions which can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">217</td>
    <td class="codeLine">/// be checked at run-time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">217</td>
    <td class="codeLine">/// be checked at run-time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">218</td>
    <td class="codeLine">class SCEVPredicate : public FoldingSetNode {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">218</td>
    <td class="codeLine">class SCEVPredicate : public FoldingSetNode {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">219</td>
    <td class="codeLine">  friend struct FoldingSetTrait<SCEVPredicate>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">219</td>
    <td class="codeLine">  friend struct FoldingSetTrait<SCEVPredicate>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">220</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">221</td>
    <td class="codeLine">  /// A reference to an Interned FoldingSetNodeID for this node.  The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">221</td>
    <td class="codeLine">  /// A reference to an Interned FoldingSetNodeID for this node.  The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">222</td>
    <td class="codeLine">  /// ScalarEvolution's BumpPtrAllocator holds the data.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">222</td>
    <td class="codeLine">  /// ScalarEvolution's BumpPtrAllocator holds the data.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">223</td>
    <td class="codeLine">  FoldingSetNodeIDRef FastID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">223</td>
    <td class="codeLine">  FoldingSetNodeIDRef FastID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">225</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">225</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">226</td>
    <td class="codeLine">  enum SCEVPredicateKind { P_Union, P_Compare, P_Wrap };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">226</td>
    <td class="codeLine">  enum SCEVPredicateKind { P_Union, P_Compare, P_Wrap };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">227</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">228</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">228</td>
    <td class="codeLine">protected:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">229</td>
    <td class="codeLine">  SCEVPredicateKind Kind;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">229</td>
    <td class="codeLine">  SCEVPredicateKind Kind;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">230</td>
    <td class="codeLine">  ~SCEVPredicate() = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">230</td>
    <td class="codeLine">  ~SCEVPredicate() = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">231</td>
    <td class="codeLine">  SCEVPredicate(const SCEVPredicate &) = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">231</td>
    <td class="codeLine">  SCEVPredicate(const SCEVPredicate &) = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">232</td>
    <td class="codeLine">  SCEVPredicate &operator=(const SCEVPredicate &) = default;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">232</td>
    <td class="codeLine">  SCEVPredicate &operator=(const SCEVPredicate &) = default;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">233</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">234</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">234</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">235</td>
    <td class="codeLine">  SCEVPredicate(const FoldingSetNodeIDRef ID, SCEVPredicateKind Kind);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">235</td>
    <td class="codeLine">  SCEVPredicate(const FoldingSetNodeIDRef ID, SCEVPredicateKind Kind);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">236</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">237</td>
    <td class="codeLine">  SCEVPredicateKind getKind() const { return Kind; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">237</td>
    <td class="codeLine">  SCEVPredicateKind getKind() const { return Kind; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">239</td>
    <td class="codeLine">  /// Returns the estimated complexity of this predicate.  This is roughly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">239</td>
    <td class="codeLine">  /// Returns the estimated complexity of this predicate.  This is roughly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">240</td>
    <td class="codeLine">  /// measured in the number of run-time checks required.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">240</td>
    <td class="codeLine">  /// measured in the number of run-time checks required.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">241</td>
    <td class="codeLine">  virtual unsigned getComplexity() const { return 1; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">241</td>
    <td class="codeLine">  virtual unsigned getComplexity() const { return 1; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">243</td>
    <td class="codeLine">  /// Returns true if the predicate is always true. This means that no</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">243</td>
    <td class="codeLine">  /// Returns true if the predicate is always true. This means that no</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">244</td>
    <td class="codeLine">  /// assumptions were made and nothing needs to be checked at run-time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">244</td>
    <td class="codeLine">  /// assumptions were made and nothing needs to be checked at run-time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">245</td>
    <td class="codeLine">  virtual bool isAlwaysTrue() const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">245</td>
    <td class="codeLine">  virtual bool isAlwaysTrue() const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">247</td>
    <td class="codeLine">  /// Returns true if this predicate implies \p N.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">247</td>
    <td class="codeLine">  /// Returns true if this predicate implies \p N.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">248</td>
    <td class="codeLine">  virtual bool implies(const SCEVPredicate *N) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">248</td>
    <td class="codeLine">  virtual bool implies(const SCEVPredicate *N) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">250</td>
    <td class="codeLine">  /// Prints a textual representation of this predicate with an indentation of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">250</td>
    <td class="codeLine">  /// Prints a textual representation of this predicate with an indentation of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">251</td>
    <td class="codeLine">  /// \p Depth.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">251</td>
    <td class="codeLine">  /// \p Depth.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">252</td>
    <td class="codeLine">  virtual void print(raw_ostream &OS, unsigned Depth = 0) const = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">252</td>
    <td class="codeLine">  virtual void print(raw_ostream &OS, unsigned Depth = 0) const = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">253</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">253</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">254</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">255</td>
    <td class="codeLine">inline raw_ostream &operator<<(raw_ostream &OS, const SCEVPredicate &P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">255</td>
    <td class="codeLine">inline raw_ostream &operator<<(raw_ostream &OS, const SCEVPredicate &P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">256</td>
    <td class="codeLine">  P.print(OS);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">256</td>
    <td class="codeLine">  P.print(OS);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">257</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">257</td>
    <td class="codeLine">  return OS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">258</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">258</td>
    <td class="codeLine">}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">260</td>
    <td class="codeLine">// Specialize FoldingSetTrait for SCEVPredicate to avoid needing to compute</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">260</td>
    <td class="codeLine">// Specialize FoldingSetTrait for SCEVPredicate to avoid needing to compute</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">261</td>
    <td class="codeLine">// temporary FoldingSetNodeID values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">261</td>
    <td class="codeLine">// temporary FoldingSetNodeID values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">262</td>
    <td class="codeLine">template <></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">262</td>
    <td class="codeLine">template <></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">263</td>
    <td class="codeLine">struct FoldingSetTrait<SCEVPredicate> : DefaultFoldingSetTrait<SCEVPredicate> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">263</td>
    <td class="codeLine">struct FoldingSetTrait<SCEVPredicate> : DefaultFoldingSetTrait<SCEVPredicate> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">264</td>
    <td class="codeLine">  static void Profile(const SCEVPredicate &X, FoldingSetNodeID &ID) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">264</td>
    <td class="codeLine">  static void Profile(const SCEVPredicate &X, FoldingSetNodeID &ID) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">265</td>
    <td class="codeLine">    ID = X.FastID;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">265</td>
    <td class="codeLine">    ID = X.FastID;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">266</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">266</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">268</td>
    <td class="codeLine">  static bool Equals(const SCEVPredicate &X, const FoldingSetNodeID &ID,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">268</td>
    <td class="codeLine">  static bool Equals(const SCEVPredicate &X, const FoldingSetNodeID &ID,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">269</td>
    <td class="codeLine">                     unsigned IDHash, FoldingSetNodeID &TempID) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">269</td>
    <td class="codeLine">                     unsigned IDHash, FoldingSetNodeID &TempID) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">270</td>
    <td class="codeLine">    return ID == X.FastID;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">270</td>
    <td class="codeLine">    return ID == X.FastID;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">271</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">271</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">272</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">273</td>
    <td class="codeLine">  static unsigned ComputeHash(const SCEVPredicate &X,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">273</td>
    <td class="codeLine">  static unsigned ComputeHash(const SCEVPredicate &X,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">274</td>
    <td class="codeLine">                              FoldingSetNodeID &TempID) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">274</td>
    <td class="codeLine">                              FoldingSetNodeID &TempID) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">275</td>
    <td class="codeLine">    return X.FastID.ComputeHash();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">275</td>
    <td class="codeLine">    return X.FastID.ComputeHash();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">276</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">276</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">277</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">277</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">278</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">279</td>
    <td class="codeLine">/// This class represents an assumption that the expression LHS Pred RHS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">279</td>
    <td class="codeLine">/// This class represents an assumption that the expression LHS Pred RHS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">280</td>
    <td class="codeLine">/// evaluates to true, and this can be checked at run-time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">280</td>
    <td class="codeLine">/// evaluates to true, and this can be checked at run-time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">281</td>
    <td class="codeLine">class SCEVComparePredicate final : public SCEVPredicate {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">281</td>
    <td class="codeLine">class SCEVComparePredicate final : public SCEVPredicate {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">282</td>
    <td class="codeLine">  /// We assume that LHS Pred RHS is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">282</td>
    <td class="codeLine">  /// We assume that LHS Pred RHS is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">283</td>
    <td class="codeLine">  const ICmpInst::Predicate Pred;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">283</td>
    <td class="codeLine">  const ICmpInst::Predicate Pred;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">284</td>
    <td class="codeLine">  const SCEV *LHS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">284</td>
    <td class="codeLine">  const SCEV *LHS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">285</td>
    <td class="codeLine">  const SCEV *RHS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">285</td>
    <td class="codeLine">  const SCEV *RHS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">287</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">287</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">288</td>
    <td class="codeLine">  SCEVComparePredicate(const FoldingSetNodeIDRef ID,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">288</td>
    <td class="codeLine">  SCEVComparePredicate(const FoldingSetNodeIDRef ID,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">289</td>
    <td class="codeLine">                       const ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">289</td>
    <td class="codeLine">                       const ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">290</td>
    <td class="codeLine">                       const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">290</td>
    <td class="codeLine">                       const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">292</td>
    <td class="codeLine">  /// Implementation of the SCEVPredicate interface</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">292</td>
    <td class="codeLine">  /// Implementation of the SCEVPredicate interface</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">293</td>
    <td class="codeLine">  bool implies(const SCEVPredicate *N) const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">293</td>
    <td class="codeLine">  bool implies(const SCEVPredicate *N) const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">294</td>
    <td class="codeLine">  void print(raw_ostream &OS, unsigned Depth = 0) const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">294</td>
    <td class="codeLine">  void print(raw_ostream &OS, unsigned Depth = 0) const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">295</td>
    <td class="codeLine">  bool isAlwaysTrue() const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">295</td>
    <td class="codeLine">  bool isAlwaysTrue() const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">296</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">297</td>
    <td class="codeLine">  ICmpInst::Predicate getPredicate() const { return Pred; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">297</td>
    <td class="codeLine">  ICmpInst::Predicate getPredicate() const { return Pred; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">299</td>
    <td class="codeLine">  /// Returns the left hand side of the predicate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">299</td>
    <td class="codeLine">  /// Returns the left hand side of the predicate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">300</td>
    <td class="codeLine">  const SCEV *getLHS() const { return LHS; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">300</td>
    <td class="codeLine">  const SCEV *getLHS() const { return LHS; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">301</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">302</td>
    <td class="codeLine">  /// Returns the right hand side of the predicate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">302</td>
    <td class="codeLine">  /// Returns the right hand side of the predicate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">303</td>
    <td class="codeLine">  const SCEV *getRHS() const { return RHS; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">303</td>
    <td class="codeLine">  const SCEV *getRHS() const { return RHS; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">305</td>
    <td class="codeLine">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">305</td>
    <td class="codeLine">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">306</td>
    <td class="codeLine">  static bool classof(const SCEVPredicate *P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">306</td>
    <td class="codeLine">  static bool classof(const SCEVPredicate *P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">307</td>
    <td class="codeLine">    return P->getKind() == P_Compare;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">307</td>
    <td class="codeLine">    return P->getKind() == P_Compare;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">308</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">308</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">309</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">309</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">310</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">311</td>
    <td class="codeLine">/// This class represents an assumption made on an AddRec expression. Given an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">311</td>
    <td class="codeLine">/// This class represents an assumption made on an AddRec expression. Given an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">312</td>
    <td class="codeLine">/// affine AddRec expression {a,+,b}, we assume that it has the nssw or nusw</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">312</td>
    <td class="codeLine">/// affine AddRec expression {a,+,b}, we assume that it has the nssw or nusw</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">313</td>
    <td class="codeLine">/// flags (defined below) in the first X iterations of the loop, where X is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">313</td>
    <td class="codeLine">/// flags (defined below) in the first X iterations of the loop, where X is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">314</td>
    <td class="codeLine">/// SCEV expression returned by getPredicatedBackedgeTakenCount).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">314</td>
    <td class="codeLine">/// SCEV expression returned by getPredicatedBackedgeTakenCount).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">315</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">315</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">316</td>
    <td class="codeLine">/// Note that this does not imply that X is equal to the backedge taken</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">316</td>
    <td class="codeLine">/// Note that this does not imply that X is equal to the backedge taken</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">317</td>
    <td class="codeLine">/// count. This means that if we have a nusw predicate for i32 {0,+,1} with a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">317</td>
    <td class="codeLine">/// count. This means that if we have a nusw predicate for i32 {0,+,1} with a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">318</td>
    <td class="codeLine">/// predicated backedge taken count of X, we only guarantee that {0,+,1} has</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">318</td>
    <td class="codeLine">/// predicated backedge taken count of X, we only guarantee that {0,+,1} has</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">319</td>
    <td class="codeLine">/// nusw in the first X iterations. {0,+,1} may still wrap in the loop if we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">319</td>
    <td class="codeLine">/// nusw in the first X iterations. {0,+,1} may still wrap in the loop if we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">320</td>
    <td class="codeLine">/// have more than X iterations.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">320</td>
    <td class="codeLine">/// have more than X iterations.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">321</td>
    <td class="codeLine">class SCEVWrapPredicate final : public SCEVPredicate {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">321</td>
    <td class="codeLine">class SCEVWrapPredicate final : public SCEVPredicate {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">322</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">322</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">323</td>
    <td class="codeLine">  /// Similar to SCEV::NoWrapFlags, but with slightly different semantics</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">323</td>
    <td class="codeLine">  /// Similar to SCEV::NoWrapFlags, but with slightly different semantics</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">324</td>
    <td class="codeLine">  /// for FlagNUSW. The increment is considered to be signed, and a + b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">324</td>
    <td class="codeLine">  /// for FlagNUSW. The increment is considered to be signed, and a + b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">325</td>
    <td class="codeLine">  /// (where b is the increment) is considered to wrap if:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">325</td>
    <td class="codeLine">  /// (where b is the increment) is considered to wrap if:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">326</td>
    <td class="codeLine">  ///    zext(a + b) != zext(a) + sext(b)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">326</td>
    <td class="codeLine">  ///    zext(a + b) != zext(a) + sext(b)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">327</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">327</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">328</td>
    <td class="codeLine">  /// If Signed is a function that takes an n-bit tuple and maps to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">328</td>
    <td class="codeLine">  /// If Signed is a function that takes an n-bit tuple and maps to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">329</td>
    <td class="codeLine">  /// integer domain as the tuples value interpreted as twos complement,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">329</td>
    <td class="codeLine">  /// integer domain as the tuples value interpreted as twos complement,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">330</td>
    <td class="codeLine">  /// and Unsigned a function that takes an n-bit tuple and maps to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">330</td>
    <td class="codeLine">  /// and Unsigned a function that takes an n-bit tuple and maps to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">331</td>
    <td class="codeLine">  /// integer domain as as the base two value of input tuple, then a + b</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">331</td>
    <td class="codeLine">  /// integer domain as as the base two value of input tuple, then a + b</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">332</td>
    <td class="codeLine">  /// has IncrementNUSW iff:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">332</td>
    <td class="codeLine">  /// has IncrementNUSW iff:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">333</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">333</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">334</td>
    <td class="codeLine">  /// 0 <= Unsigned(a) + Signed(b) < 2^n</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">334</td>
    <td class="codeLine">  /// 0 <= Unsigned(a) + Signed(b) < 2^n</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">335</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">335</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">336</td>
    <td class="codeLine">  /// The IncrementNSSW flag has identical semantics with SCEV::FlagNSW.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">336</td>
    <td class="codeLine">  /// The IncrementNSSW flag has identical semantics with SCEV::FlagNSW.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">337</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">337</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">338</td>
    <td class="codeLine">  /// Note that the IncrementNUSW flag is not commutative: if base + inc</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">338</td>
    <td class="codeLine">  /// Note that the IncrementNUSW flag is not commutative: if base + inc</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">339</td>
    <td class="codeLine">  /// has IncrementNUSW, then inc + base doesn't neccessarily have this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">339</td>
    <td class="codeLine">  /// has IncrementNUSW, then inc + base doesn't neccessarily have this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">340</td>
    <td class="codeLine">  /// property. The reason for this is that this is used for sign/zero</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">340</td>
    <td class="codeLine">  /// property. The reason for this is that this is used for sign/zero</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">341</td>
    <td class="codeLine">  /// extending affine AddRec SCEV expressions when a SCEVWrapPredicate is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">341</td>
    <td class="codeLine">  /// extending affine AddRec SCEV expressions when a SCEVWrapPredicate is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">342</td>
    <td class="codeLine">  /// assumed. A {base,+,inc} expression is already non-commutative with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">342</td>
    <td class="codeLine">  /// assumed. A {base,+,inc} expression is already non-commutative with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">343</td>
    <td class="codeLine">  /// regards to base and inc, since it is interpreted as:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">343</td>
    <td class="codeLine">  /// regards to base and inc, since it is interpreted as:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">344</td>
    <td class="codeLine">  ///     (((base + inc) + inc) + inc) ...</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">344</td>
    <td class="codeLine">  ///     (((base + inc) + inc) + inc) ...</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">345</td>
    <td class="codeLine">  enum IncrementWrapFlags {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">345</td>
    <td class="codeLine">  enum IncrementWrapFlags {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">346</td>
    <td class="codeLine">    IncrementAnyWrap = 0,     // No guarantee.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">346</td>
    <td class="codeLine">    IncrementAnyWrap = 0,     // No guarantee.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">347</td>
    <td class="codeLine">    IncrementNUSW = (1 << 0), // No unsigned with signed increment wrap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">347</td>
    <td class="codeLine">    IncrementNUSW = (1 << 0), // No unsigned with signed increment wrap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">348</td>
    <td class="codeLine">    IncrementNSSW = (1 << 1), // No signed with signed increment wrap</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">348</td>
    <td class="codeLine">    IncrementNSSW = (1 << 1), // No signed with signed increment wrap</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">349</td>
    <td class="codeLine">                              // (equivalent with SCEV::NSW)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">349</td>
    <td class="codeLine">                              // (equivalent with SCEV::NSW)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">350</td>
    <td class="codeLine">    IncrementNoWrapMask = (1 << 2) - 1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">350</td>
    <td class="codeLine">    IncrementNoWrapMask = (1 << 2) - 1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">351</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">351</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">352</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">353</td>
    <td class="codeLine">  /// Convenient IncrementWrapFlags manipulation methods.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">353</td>
    <td class="codeLine">  /// Convenient IncrementWrapFlags manipulation methods.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">354</td>
    <td class="codeLine">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">354</td>
    <td class="codeLine">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">355</td>
    <td class="codeLine">  clearFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">355</td>
    <td class="codeLine">  clearFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">356</td>
    <td class="codeLine">             SCEVWrapPredicate::IncrementWrapFlags OffFlags) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">356</td>
    <td class="codeLine">             SCEVWrapPredicate::IncrementWrapFlags OffFlags) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">357</td>
    <td class="codeLine">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">357</td>
    <td class="codeLine">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">358</td>
    <td class="codeLine">    assert((OffFlags & IncrementNoWrapMask) == OffFlags &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">358</td>
    <td class="codeLine">    assert((OffFlags & IncrementNoWrapMask) == OffFlags &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">359</td>
    <td class="codeLine">           "Invalid flags value!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">359</td>
    <td class="codeLine">           "Invalid flags value!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">360</td>
    <td class="codeLine">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & ~OffFlags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">360</td>
    <td class="codeLine">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & ~OffFlags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">361</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">361</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">362</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">363</td>
    <td class="codeLine">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">363</td>
    <td class="codeLine">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">364</td>
    <td class="codeLine">  maskFlags(SCEVWrapPredicate::IncrementWrapFlags Flags, int Mask) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">364</td>
    <td class="codeLine">  maskFlags(SCEVWrapPredicate::IncrementWrapFlags Flags, int Mask) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">365</td>
    <td class="codeLine">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">365</td>
    <td class="codeLine">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">366</td>
    <td class="codeLine">    assert((Mask & IncrementNoWrapMask) == Mask && "Invalid mask value!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">366</td>
    <td class="codeLine">    assert((Mask & IncrementNoWrapMask) == Mask && "Invalid mask value!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">368</td>
    <td class="codeLine">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & Mask);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">368</td>
    <td class="codeLine">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags & Mask);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">369</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">369</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">371</td>
    <td class="codeLine">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">371</td>
    <td class="codeLine">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">372</td>
    <td class="codeLine">  setFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">372</td>
    <td class="codeLine">  setFlags(SCEVWrapPredicate::IncrementWrapFlags Flags,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">373</td>
    <td class="codeLine">           SCEVWrapPredicate::IncrementWrapFlags OnFlags) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">373</td>
    <td class="codeLine">           SCEVWrapPredicate::IncrementWrapFlags OnFlags) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">374</td>
    <td class="codeLine">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">374</td>
    <td class="codeLine">    assert((Flags & IncrementNoWrapMask) == Flags && "Invalid flags value!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">375</td>
    <td class="codeLine">    assert((OnFlags & IncrementNoWrapMask) == OnFlags &&</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">375</td>
    <td class="codeLine">    assert((OnFlags & IncrementNoWrapMask) == OnFlags &&</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">376</td>
    <td class="codeLine">           "Invalid flags value!");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">376</td>
    <td class="codeLine">           "Invalid flags value!");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">377</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">378</td>
    <td class="codeLine">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags | OnFlags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">378</td>
    <td class="codeLine">    return (SCEVWrapPredicate::IncrementWrapFlags)(Flags | OnFlags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">379</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">379</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">381</td>
    <td class="codeLine">  /// Returns the set of SCEVWrapPredicate no wrap flags implied by a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">381</td>
    <td class="codeLine">  /// Returns the set of SCEVWrapPredicate no wrap flags implied by a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">382</td>
    <td class="codeLine">  /// SCEVAddRecExpr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">382</td>
    <td class="codeLine">  /// SCEVAddRecExpr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">383</td>
    <td class="codeLine">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">383</td>
    <td class="codeLine">  [[nodiscard]] static SCEVWrapPredicate::IncrementWrapFlags</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">384</td>
    <td class="codeLine">  getImpliedFlags(const SCEVAddRecExpr *AR, ScalarEvolution &SE);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">384</td>
    <td class="codeLine">  getImpliedFlags(const SCEVAddRecExpr *AR, ScalarEvolution &SE);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">386</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">386</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">387</td>
    <td class="codeLine">  const SCEVAddRecExpr *AR;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">387</td>
    <td class="codeLine">  const SCEVAddRecExpr *AR;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">388</td>
    <td class="codeLine">  IncrementWrapFlags Flags;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">388</td>
    <td class="codeLine">  IncrementWrapFlags Flags;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">390</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">390</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">391</td>
    <td class="codeLine">  explicit SCEVWrapPredicate(const FoldingSetNodeIDRef ID,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">391</td>
    <td class="codeLine">  explicit SCEVWrapPredicate(const FoldingSetNodeIDRef ID,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">392</td>
    <td class="codeLine">                             const SCEVAddRecExpr *AR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">392</td>
    <td class="codeLine">                             const SCEVAddRecExpr *AR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">393</td>
    <td class="codeLine">                             IncrementWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">393</td>
    <td class="codeLine">                             IncrementWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">394</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">394</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">395</td>
    <td class="codeLine">  /// Returns the set assumed no overflow flags.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">395</td>
    <td class="codeLine">  /// Returns the set assumed no overflow flags.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">396</td>
    <td class="codeLine">  IncrementWrapFlags getFlags() const { return Flags; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">396</td>
    <td class="codeLine">  IncrementWrapFlags getFlags() const { return Flags; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">397</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">398</td>
    <td class="codeLine">  /// Implementation of the SCEVPredicate interface</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">398</td>
    <td class="codeLine">  /// Implementation of the SCEVPredicate interface</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">399</td>
    <td class="codeLine">  const SCEVAddRecExpr *getExpr() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">399</td>
    <td class="codeLine">  const SCEVAddRecExpr *getExpr() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">400</td>
    <td class="codeLine">  bool implies(const SCEVPredicate *N) const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">400</td>
    <td class="codeLine">  bool implies(const SCEVPredicate *N) const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">401</td>
    <td class="codeLine">  void print(raw_ostream &OS, unsigned Depth = 0) const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">401</td>
    <td class="codeLine">  void print(raw_ostream &OS, unsigned Depth = 0) const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">402</td>
    <td class="codeLine">  bool isAlwaysTrue() const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">402</td>
    <td class="codeLine">  bool isAlwaysTrue() const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">403</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">404</td>
    <td class="codeLine">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">404</td>
    <td class="codeLine">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">405</td>
    <td class="codeLine">  static bool classof(const SCEVPredicate *P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">405</td>
    <td class="codeLine">  static bool classof(const SCEVPredicate *P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">406</td>
    <td class="codeLine">    return P->getKind() == P_Wrap;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">406</td>
    <td class="codeLine">    return P->getKind() == P_Wrap;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">407</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">407</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">408</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">408</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">409</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">410</td>
    <td class="codeLine">/// This class represents a composition of other SCEV predicates, and is the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">410</td>
    <td class="codeLine">/// This class represents a composition of other SCEV predicates, and is the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">411</td>
    <td class="codeLine">/// class that most clients will interact with.  This is equivalent to a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">411</td>
    <td class="codeLine">/// class that most clients will interact with.  This is equivalent to a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">412</td>
    <td class="codeLine">/// logical "AND" of all the predicates in the union.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">412</td>
    <td class="codeLine">/// logical "AND" of all the predicates in the union.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">413</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">413</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">414</td>
    <td class="codeLine">/// NB! Unlike other SCEVPredicate sub-classes this class does not live in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">414</td>
    <td class="codeLine">/// NB! Unlike other SCEVPredicate sub-classes this class does not live in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">415</td>
    <td class="codeLine">/// ScalarEvolution::Preds folding set.  This is why the \c add function is sound.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">415</td>
    <td class="codeLine">/// ScalarEvolution::Preds folding set.  This is why the \c add function is sound.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">416</td>
    <td class="codeLine">class SCEVUnionPredicate final : public SCEVPredicate {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">416</td>
    <td class="codeLine">class SCEVUnionPredicate final : public SCEVPredicate {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">417</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">417</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">418</td>
    <td class="codeLine">  using PredicateMap =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">418</td>
    <td class="codeLine">  using PredicateMap =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">419</td>
    <td class="codeLine">      DenseMap<const SCEV *, SmallVector<const SCEVPredicate *, 4>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">419</td>
    <td class="codeLine">      DenseMap<const SCEV *, SmallVector<const SCEVPredicate *, 4>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">420</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">421</td>
    <td class="codeLine">  /// Vector with references to all predicates in this union.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">421</td>
    <td class="codeLine">  /// Vector with references to all predicates in this union.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">422</td>
    <td class="codeLine">  SmallVector<const SCEVPredicate *, 16> Preds;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">422</td>
    <td class="codeLine">  SmallVector<const SCEVPredicate *, 16> Preds;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">423</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">424</td>
    <td class="codeLine">  /// Adds a predicate to this union.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">424</td>
    <td class="codeLine">  /// Adds a predicate to this union.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">425</td>
    <td class="codeLine">  void add(const SCEVPredicate *N);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">425</td>
    <td class="codeLine">  void add(const SCEVPredicate *N);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">426</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">427</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">427</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">428</td>
    <td class="codeLine">  SCEVUnionPredicate(ArrayRef<const SCEVPredicate *> Preds);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">428</td>
    <td class="codeLine">  SCEVUnionPredicate(ArrayRef<const SCEVPredicate *> Preds);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">429</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">430</td>
    <td class="codeLine">  const SmallVectorImpl<const SCEVPredicate *> &getPredicates() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">430</td>
    <td class="codeLine">  const SmallVectorImpl<const SCEVPredicate *> &getPredicates() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">431</td>
    <td class="codeLine">    return Preds;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">431</td>
    <td class="codeLine">    return Preds;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">432</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">432</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">433</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">434</td>
    <td class="codeLine">  /// Implementation of the SCEVPredicate interface</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">434</td>
    <td class="codeLine">  /// Implementation of the SCEVPredicate interface</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">435</td>
    <td class="codeLine">  bool isAlwaysTrue() const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">435</td>
    <td class="codeLine">  bool isAlwaysTrue() const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">436</td>
    <td class="codeLine">  bool implies(const SCEVPredicate *N) const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">436</td>
    <td class="codeLine">  bool implies(const SCEVPredicate *N) const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">437</td>
    <td class="codeLine">  void print(raw_ostream &OS, unsigned Depth) const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">437</td>
    <td class="codeLine">  void print(raw_ostream &OS, unsigned Depth) const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">438</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">439</td>
    <td class="codeLine">  /// We estimate the complexity of a union predicate as the size number of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">439</td>
    <td class="codeLine">  /// We estimate the complexity of a union predicate as the size number of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">440</td>
    <td class="codeLine">  /// predicates in the union.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">440</td>
    <td class="codeLine">  /// predicates in the union.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">441</td>
    <td class="codeLine">  unsigned getComplexity() const override { return Preds.size(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">441</td>
    <td class="codeLine">  unsigned getComplexity() const override { return Preds.size(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">443</td>
    <td class="codeLine">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">443</td>
    <td class="codeLine">  /// Methods for support type inquiry through isa, cast, and dyn_cast:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">444</td>
    <td class="codeLine">  static bool classof(const SCEVPredicate *P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">444</td>
    <td class="codeLine">  static bool classof(const SCEVPredicate *P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">445</td>
    <td class="codeLine">    return P->getKind() == P_Union;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">445</td>
    <td class="codeLine">    return P->getKind() == P_Union;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">446</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">446</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">447</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">447</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">448</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">449</td>
    <td class="codeLine">/// The main scalar evolution driver. Because client code (intentionally)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">449</td>
    <td class="codeLine">/// The main scalar evolution driver. Because client code (intentionally)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">450</td>
    <td class="codeLine">/// can't do much with the SCEV objects directly, they must ask this class</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">450</td>
    <td class="codeLine">/// can't do much with the SCEV objects directly, they must ask this class</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">451</td>
    <td class="codeLine">/// for services.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">451</td>
    <td class="codeLine">/// for services.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">452</td>
    <td class="codeLine">class ScalarEvolution {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">452</td>
    <td class="codeLine">class ScalarEvolution {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">453</td>
    <td class="codeLine">  friend class ScalarEvolutionsTest;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">453</td>
    <td class="codeLine">  friend class ScalarEvolutionsTest;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">454</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">454</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">455</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">455</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">456</td>
    <td class="codeLine">  /// An enum describing the relationship between a SCEV and a loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">456</td>
    <td class="codeLine">  /// An enum describing the relationship between a SCEV and a loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">457</td>
    <td class="codeLine">  enum LoopDisposition {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">457</td>
    <td class="codeLine">  enum LoopDisposition {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">458</td>
    <td class="codeLine">    LoopVariant,   ///< The SCEV is loop-variant (unknown).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">458</td>
    <td class="codeLine">    LoopVariant,   ///< The SCEV is loop-variant (unknown).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">459</td>
    <td class="codeLine">    LoopInvariant, ///< The SCEV is loop-invariant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">459</td>
    <td class="codeLine">    LoopInvariant, ///< The SCEV is loop-invariant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">460</td>
    <td class="codeLine">    LoopComputable ///< The SCEV varies predictably with the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">460</td>
    <td class="codeLine">    LoopComputable ///< The SCEV varies predictably with the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">461</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">461</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">463</td>
    <td class="codeLine">  /// An enum describing the relationship between a SCEV and a basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">463</td>
    <td class="codeLine">  /// An enum describing the relationship between a SCEV and a basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">464</td>
    <td class="codeLine">  enum BlockDisposition {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">464</td>
    <td class="codeLine">  enum BlockDisposition {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">465</td>
    <td class="codeLine">    DoesNotDominateBlock,  ///< The SCEV does not dominate the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">465</td>
    <td class="codeLine">    DoesNotDominateBlock,  ///< The SCEV does not dominate the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">466</td>
    <td class="codeLine">    DominatesBlock,        ///< The SCEV dominates the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">466</td>
    <td class="codeLine">    DominatesBlock,        ///< The SCEV dominates the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">467</td>
    <td class="codeLine">    ProperlyDominatesBlock ///< The SCEV properly dominates the block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">467</td>
    <td class="codeLine">    ProperlyDominatesBlock ///< The SCEV properly dominates the block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">468</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">468</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">469</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">470</td>
    <td class="codeLine">  /// Convenient NoWrapFlags manipulation that hides enum casts and is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">470</td>
    <td class="codeLine">  /// Convenient NoWrapFlags manipulation that hides enum casts and is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">471</td>
    <td class="codeLine">  /// visible in the ScalarEvolution name space.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">471</td>
    <td class="codeLine">  /// visible in the ScalarEvolution name space.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">472</td>
    <td class="codeLine">  [[nodiscard]] static SCEV::NoWrapFlags maskFlags(SCEV::NoWrapFlags Flags,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">472</td>
    <td class="codeLine">  [[nodiscard]] static SCEV::NoWrapFlags maskFlags(SCEV::NoWrapFlags Flags,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">473</td>
    <td class="codeLine">                                                   int Mask) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">473</td>
    <td class="codeLine">                                                   int Mask) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">474</td>
    <td class="codeLine">    return (SCEV::NoWrapFlags)(Flags & Mask);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">474</td>
    <td class="codeLine">    return (SCEV::NoWrapFlags)(Flags & Mask);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">475</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">475</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">476</td>
    <td class="codeLine">  [[nodiscard]] static SCEV::NoWrapFlags setFlags(SCEV::NoWrapFlags Flags,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">476</td>
    <td class="codeLine">  [[nodiscard]] static SCEV::NoWrapFlags setFlags(SCEV::NoWrapFlags Flags,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">477</td>
    <td class="codeLine">                                                  SCEV::NoWrapFlags OnFlags) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">477</td>
    <td class="codeLine">                                                  SCEV::NoWrapFlags OnFlags) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">478</td>
    <td class="codeLine">    return (SCEV::NoWrapFlags)(Flags | OnFlags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">478</td>
    <td class="codeLine">    return (SCEV::NoWrapFlags)(Flags | OnFlags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">479</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">479</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">480</td>
    <td class="codeLine">  [[nodiscard]] static SCEV::NoWrapFlags</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">480</td>
    <td class="codeLine">  [[nodiscard]] static SCEV::NoWrapFlags</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">481</td>
    <td class="codeLine">  clearFlags(SCEV::NoWrapFlags Flags, SCEV::NoWrapFlags OffFlags) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">481</td>
    <td class="codeLine">  clearFlags(SCEV::NoWrapFlags Flags, SCEV::NoWrapFlags OffFlags) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">482</td>
    <td class="codeLine">    return (SCEV::NoWrapFlags)(Flags & ~OffFlags);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">482</td>
    <td class="codeLine">    return (SCEV::NoWrapFlags)(Flags & ~OffFlags);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">483</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">483</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">484</td>
    <td class="codeLine">  [[nodiscard]] static bool hasFlags(SCEV::NoWrapFlags Flags,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">484</td>
    <td class="codeLine">  [[nodiscard]] static bool hasFlags(SCEV::NoWrapFlags Flags,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">485</td>
    <td class="codeLine">                                     SCEV::NoWrapFlags TestFlags) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">485</td>
    <td class="codeLine">                                     SCEV::NoWrapFlags TestFlags) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">486</td>
    <td class="codeLine">    return TestFlags == maskFlags(Flags, TestFlags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">486</td>
    <td class="codeLine">    return TestFlags == maskFlags(Flags, TestFlags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">487</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">487</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">488</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">489</td>
    <td class="codeLine">  ScalarEvolution(Function &F, TargetLibraryInfo &TLI, AssumptionCache &AC,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">489</td>
    <td class="codeLine">  ScalarEvolution(Function &F, TargetLibraryInfo &TLI, AssumptionCache &AC,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">490</td>
    <td class="codeLine">                  DominatorTree &DT, LoopInfo &LI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">490</td>
    <td class="codeLine">                  DominatorTree &DT, LoopInfo &LI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">491</td>
    <td class="codeLine">  ScalarEvolution(ScalarEvolution &&Arg);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">491</td>
    <td class="codeLine">  ScalarEvolution(ScalarEvolution &&Arg);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">492</td>
    <td class="codeLine">  ~ScalarEvolution();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">492</td>
    <td class="codeLine">  ~ScalarEvolution();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">493</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">494</td>
    <td class="codeLine">  LLVMContext &getContext() const { return F.getContext(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">494</td>
    <td class="codeLine">  LLVMContext &getContext() const { return F.getContext(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">495</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">496</td>
    <td class="codeLine">  /// Test if values of the given type are analyzable within the SCEV</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">496</td>
    <td class="codeLine">  /// Test if values of the given type are analyzable within the SCEV</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">497</td>
    <td class="codeLine">  /// framework. This primarily includes integer types, and it can optionally</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">497</td>
    <td class="codeLine">  /// framework. This primarily includes integer types, and it can optionally</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">498</td>
    <td class="codeLine">  /// include pointer types if the ScalarEvolution class has access to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">498</td>
    <td class="codeLine">  /// include pointer types if the ScalarEvolution class has access to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">499</td>
    <td class="codeLine">  /// target-specific information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">499</td>
    <td class="codeLine">  /// target-specific information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">500</td>
    <td class="codeLine">  bool isSCEVable(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">500</td>
    <td class="codeLine">  bool isSCEVable(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">501</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">502</td>
    <td class="codeLine">  /// Return the size in bits of the specified type, for which isSCEVable must</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">502</td>
    <td class="codeLine">  /// Return the size in bits of the specified type, for which isSCEVable must</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">503</td>
    <td class="codeLine">  /// return true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">503</td>
    <td class="codeLine">  /// return true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">504</td>
    <td class="codeLine">  uint64_t getTypeSizeInBits(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">504</td>
    <td class="codeLine">  uint64_t getTypeSizeInBits(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">505</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">506</td>
    <td class="codeLine">  /// Return a type with the same bitwidth as the given type and which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">506</td>
    <td class="codeLine">  /// Return a type with the same bitwidth as the given type and which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">507</td>
    <td class="codeLine">  /// represents how SCEV will treat the given type, for which isSCEVable must</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">507</td>
    <td class="codeLine">  /// represents how SCEV will treat the given type, for which isSCEVable must</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">508</td>
    <td class="codeLine">  /// return true. For pointer types, this is the pointer-sized integer type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">508</td>
    <td class="codeLine">  /// return true. For pointer types, this is the pointer-sized integer type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">509</td>
    <td class="codeLine">  Type *getEffectiveSCEVType(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">509</td>
    <td class="codeLine">  Type *getEffectiveSCEVType(Type *Ty) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">510</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">511</td>
    <td class="codeLine">  // Returns a wider type among {Ty1, Ty2}.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">511</td>
    <td class="codeLine">  // Returns a wider type among {Ty1, Ty2}.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">512</td>
    <td class="codeLine">  Type *getWiderType(Type *Ty1, Type *Ty2) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">512</td>
    <td class="codeLine">  Type *getWiderType(Type *Ty1, Type *Ty2) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">513</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">514</td>
    <td class="codeLine">  /// Return true if there exists a point in the program at which both</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">514</td>
    <td class="codeLine">  /// Return true if there exists a point in the program at which both</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">515</td>
    <td class="codeLine">  /// A and B could be operands to the same instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">515</td>
    <td class="codeLine">  /// A and B could be operands to the same instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">516</td>
    <td class="codeLine">  /// SCEV expressions are generally assumed to correspond to instructions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">516</td>
    <td class="codeLine">  /// SCEV expressions are generally assumed to correspond to instructions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">517</td>
    <td class="codeLine">  /// which could exists in IR.  In general, this requires that there exists</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">517</td>
    <td class="codeLine">  /// which could exists in IR.  In general, this requires that there exists</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">518</td>
    <td class="codeLine">  /// a use point in the program where all operands dominate the use.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">518</td>
    <td class="codeLine">  /// a use point in the program where all operands dominate the use.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">519</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">519</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">520</td>
    <td class="codeLine">  /// Example:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">520</td>
    <td class="codeLine">  /// Example:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">521</td>
    <td class="codeLine">  /// loop {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">521</td>
    <td class="codeLine">  /// loop {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">522</td>
    <td class="codeLine">  ///   if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">522</td>
    <td class="codeLine">  ///   if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">523</td>
    <td class="codeLine">  ///     loop { v1 = load @global1; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">523</td>
    <td class="codeLine">  ///     loop { v1 = load @global1; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">524</td>
    <td class="codeLine">  ///   else</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">524</td>
    <td class="codeLine">  ///   else</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">525</td>
    <td class="codeLine">  ///     loop { v2 = load @global2; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">525</td>
    <td class="codeLine">  ///     loop { v2 = load @global2; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">526</td>
    <td class="codeLine">  /// }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">526</td>
    <td class="codeLine">  /// }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">527</td>
    <td class="codeLine">  /// No SCEV with operand V1, and v2 can exist in this program.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">527</td>
    <td class="codeLine">  /// No SCEV with operand V1, and v2 can exist in this program.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">528</td>
    <td class="codeLine">  bool instructionCouldExistWitthOperands(const SCEV *A, const SCEV *B);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">528</td>
    <td class="codeLine">  bool instructionCouldExistWitthOperands(const SCEV *A, const SCEV *B);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">529</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">529</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">530</td>
    <td class="codeLine">  /// Return true if the SCEV is a scAddRecExpr or it contains</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">530</td>
    <td class="codeLine">  /// Return true if the SCEV is a scAddRecExpr or it contains</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">531</td>
    <td class="codeLine">  /// scAddRecExpr. The result will be cached in HasRecMap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">531</td>
    <td class="codeLine">  /// scAddRecExpr. The result will be cached in HasRecMap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">532</td>
    <td class="codeLine">  bool containsAddRecurrence(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">532</td>
    <td class="codeLine">  bool containsAddRecurrence(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">533</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">534</td>
    <td class="codeLine">  /// Is operation \p BinOp between \p LHS and \p RHS provably does not have</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">534</td>
    <td class="codeLine">  /// Is operation \p BinOp between \p LHS and \p RHS provably does not have</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">535</td>
    <td class="codeLine">  /// a signed/unsigned overflow (\p Signed)? If \p CtxI is specified, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">535</td>
    <td class="codeLine">  /// a signed/unsigned overflow (\p Signed)? If \p CtxI is specified, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">536</td>
    <td class="codeLine">  /// no-overflow fact should be true in the context of this instruction.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">536</td>
    <td class="codeLine">  /// no-overflow fact should be true in the context of this instruction.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">537</td>
    <td class="codeLine">  bool willNotOverflow(Instruction::BinaryOps BinOp, bool Signed,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">537</td>
    <td class="codeLine">  bool willNotOverflow(Instruction::BinaryOps BinOp, bool Signed,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">538</td>
    <td class="codeLine">                       const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">538</td>
    <td class="codeLine">                       const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">539</td>
    <td class="codeLine">                       const Instruction *CtxI = nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">539</td>
    <td class="codeLine">                       const Instruction *CtxI = nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">540</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">541</td>
    <td class="codeLine">  /// Parse NSW/NUW flags from add/sub/mul IR binary operation \p Op into</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">541</td>
    <td class="codeLine">  /// Parse NSW/NUW flags from add/sub/mul IR binary operation \p Op into</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">542</td>
    <td class="codeLine">  /// SCEV no-wrap flags, and deduce flag[s] that aren't known yet.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">542</td>
    <td class="codeLine">  /// SCEV no-wrap flags, and deduce flag[s] that aren't known yet.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">543</td>
    <td class="codeLine">  /// Does not mutate the original instruction. Returns std::nullopt if it could</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">543</td>
    <td class="codeLine">  /// Does not mutate the original instruction. Returns std::nullopt if it could</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">544</td>
    <td class="codeLine">  /// not deduce more precise flags than the instruction already has, otherwise</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">544</td>
    <td class="codeLine">  /// not deduce more precise flags than the instruction already has, otherwise</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">545</td>
    <td class="codeLine">  /// returns proven flags.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">545</td>
    <td class="codeLine">  /// returns proven flags.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">546</td>
    <td class="codeLine">  std::optional<SCEV::NoWrapFlags></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">546</td>
    <td class="codeLine">  std::optional<SCEV::NoWrapFlags></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">547</td>
    <td class="codeLine">  getStrengthenedNoWrapFlagsFromBinOp(const OverflowingBinaryOperator *OBO);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">547</td>
    <td class="codeLine">  getStrengthenedNoWrapFlagsFromBinOp(const OverflowingBinaryOperator *OBO);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">549</td>
    <td class="codeLine">  /// Notify this ScalarEvolution that \p User directly uses SCEVs in \p Ops.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">549</td>
    <td class="codeLine">  /// Notify this ScalarEvolution that \p User directly uses SCEVs in \p Ops.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">550</td>
    <td class="codeLine">  void registerUser(const SCEV *User, ArrayRef<const SCEV *> Ops);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">550</td>
    <td class="codeLine">  void registerUser(const SCEV *User, ArrayRef<const SCEV *> Ops);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">551</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">552</td>
    <td class="codeLine">  /// Return true if the SCEV expression contains an undef value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">552</td>
    <td class="codeLine">  /// Return true if the SCEV expression contains an undef value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">553</td>
    <td class="codeLine">  bool containsUndefs(const SCEV *S) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">553</td>
    <td class="codeLine">  bool containsUndefs(const SCEV *S) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">554</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">555</td>
    <td class="codeLine">  /// Return true if the SCEV expression contains a Value that has been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">555</td>
    <td class="codeLine">  /// Return true if the SCEV expression contains a Value that has been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">556</td>
    <td class="codeLine">  /// optimised out and is now a nullptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">556</td>
    <td class="codeLine">  /// optimised out and is now a nullptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">557</td>
    <td class="codeLine">  bool containsErasedValue(const SCEV *S) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">557</td>
    <td class="codeLine">  bool containsErasedValue(const SCEV *S) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">558</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">559</td>
    <td class="codeLine">  /// Return a SCEV expression for the full generality of the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">559</td>
    <td class="codeLine">  /// Return a SCEV expression for the full generality of the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">560</td>
    <td class="codeLine">  /// expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">560</td>
    <td class="codeLine">  /// expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">561</td>
    <td class="codeLine">  const SCEV *getSCEV(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">561</td>
    <td class="codeLine">  const SCEV *getSCEV(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">563</td>
    <td class="codeLine">  /// Return an existing SCEV for V if there is one, otherwise return nullptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">563</td>
    <td class="codeLine">  /// Return an existing SCEV for V if there is one, otherwise return nullptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">564</td>
    <td class="codeLine">  const SCEV *getExistingSCEV(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">564</td>
    <td class="codeLine">  const SCEV *getExistingSCEV(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">565</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">566</td>
    <td class="codeLine">  const SCEV *getConstant(ConstantInt *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">566</td>
    <td class="codeLine">  const SCEV *getConstant(ConstantInt *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">567</td>
    <td class="codeLine">  const SCEV *getConstant(const APInt &Val);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">567</td>
    <td class="codeLine">  const SCEV *getConstant(const APInt &Val);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">568</td>
    <td class="codeLine">  const SCEV *getConstant(Type *Ty, uint64_t V, bool isSigned = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">568</td>
    <td class="codeLine">  const SCEV *getConstant(Type *Ty, uint64_t V, bool isSigned = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">569</td>
    <td class="codeLine">  const SCEV *getLosslessPtrToIntExpr(const SCEV *Op, unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">569</td>
    <td class="codeLine">  const SCEV *getLosslessPtrToIntExpr(const SCEV *Op, unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">570</td>
    <td class="codeLine">  const SCEV *getPtrToIntExpr(const SCEV *Op, Type *Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">570</td>
    <td class="codeLine">  const SCEV *getPtrToIntExpr(const SCEV *Op, Type *Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">571</td>
    <td class="codeLine">  const SCEV *getTruncateExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">571</td>
    <td class="codeLine">  const SCEV *getTruncateExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">572</td>
    <td class="codeLine">  const SCEV *getVScale(Type *Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">572</td>
    <td class="codeLine">  const SCEV *getVScale(Type *Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">573</td>
    <td class="codeLine">  const SCEV *getZeroExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">573</td>
    <td class="codeLine">  const SCEV *getZeroExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">574</td>
    <td class="codeLine">  const SCEV *getZeroExtendExprImpl(const SCEV *Op, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">574</td>
    <td class="codeLine">  const SCEV *getZeroExtendExprImpl(const SCEV *Op, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">575</td>
    <td class="codeLine">                                    unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">575</td>
    <td class="codeLine">                                    unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">576</td>
    <td class="codeLine">  const SCEV *getSignExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">576</td>
    <td class="codeLine">  const SCEV *getSignExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">577</td>
    <td class="codeLine">  const SCEV *getSignExtendExprImpl(const SCEV *Op, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">577</td>
    <td class="codeLine">  const SCEV *getSignExtendExprImpl(const SCEV *Op, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">578</td>
    <td class="codeLine">                                    unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">578</td>
    <td class="codeLine">                                    unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">579</td>
    <td class="codeLine">  const SCEV *getCastExpr(SCEVTypes Kind, const SCEV *Op, Type *Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">579</td>
    <td class="codeLine">  const SCEV *getCastExpr(SCEVTypes Kind, const SCEV *Op, Type *Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">580</td>
    <td class="codeLine">  const SCEV *getAnyExtendExpr(const SCEV *Op, Type *Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">580</td>
    <td class="codeLine">  const SCEV *getAnyExtendExpr(const SCEV *Op, Type *Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">581</td>
    <td class="codeLine">  const SCEV *getAddExpr(SmallVectorImpl<const SCEV *> &Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">581</td>
    <td class="codeLine">  const SCEV *getAddExpr(SmallVectorImpl<const SCEV *> &Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">582</td>
    <td class="codeLine">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">582</td>
    <td class="codeLine">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">583</td>
    <td class="codeLine">                         unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">583</td>
    <td class="codeLine">                         unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">584</td>
    <td class="codeLine">  const SCEV *getAddExpr(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">584</td>
    <td class="codeLine">  const SCEV *getAddExpr(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">585</td>
    <td class="codeLine">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">585</td>
    <td class="codeLine">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">586</td>
    <td class="codeLine">                         unsigned Depth = 0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">586</td>
    <td class="codeLine">                         unsigned Depth = 0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">587</td>
    <td class="codeLine">    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">587</td>
    <td class="codeLine">    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">588</td>
    <td class="codeLine">    return getAddExpr(Ops, Flags, Depth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">588</td>
    <td class="codeLine">    return getAddExpr(Ops, Flags, Depth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">589</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">589</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">590</td>
    <td class="codeLine">  const SCEV *getAddExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">590</td>
    <td class="codeLine">  const SCEV *getAddExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">591</td>
    <td class="codeLine">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">591</td>
    <td class="codeLine">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">592</td>
    <td class="codeLine">                         unsigned Depth = 0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">592</td>
    <td class="codeLine">                         unsigned Depth = 0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">593</td>
    <td class="codeLine">    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">593</td>
    <td class="codeLine">    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">594</td>
    <td class="codeLine">    return getAddExpr(Ops, Flags, Depth);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">594</td>
    <td class="codeLine">    return getAddExpr(Ops, Flags, Depth);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">595</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">595</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">596</td>
    <td class="codeLine">  const SCEV *getMulExpr(SmallVectorImpl<const SCEV *> &Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">596</td>
    <td class="codeLine">  const SCEV *getMulExpr(SmallVectorImpl<const SCEV *> &Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">597</td>
    <td class="codeLine">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">597</td>
    <td class="codeLine">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">598</td>
    <td class="codeLine">                         unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">598</td>
    <td class="codeLine">                         unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">599</td>
    <td class="codeLine">  const SCEV *getMulExpr(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">599</td>
    <td class="codeLine">  const SCEV *getMulExpr(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">600</td>
    <td class="codeLine">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">600</td>
    <td class="codeLine">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">601</td>
    <td class="codeLine">                         unsigned Depth = 0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">601</td>
    <td class="codeLine">                         unsigned Depth = 0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">602</td>
    <td class="codeLine">    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">602</td>
    <td class="codeLine">    SmallVector<const SCEV *, 2> Ops = {LHS, RHS};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">603</td>
    <td class="codeLine">    return getMulExpr(Ops, Flags, Depth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">603</td>
    <td class="codeLine">    return getMulExpr(Ops, Flags, Depth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">604</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">604</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">605</td>
    <td class="codeLine">  const SCEV *getMulExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">605</td>
    <td class="codeLine">  const SCEV *getMulExpr(const SCEV *Op0, const SCEV *Op1, const SCEV *Op2,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">606</td>
    <td class="codeLine">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">606</td>
    <td class="codeLine">                         SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">607</td>
    <td class="codeLine">                         unsigned Depth = 0) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">607</td>
    <td class="codeLine">                         unsigned Depth = 0) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">608</td>
    <td class="codeLine">    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">608</td>
    <td class="codeLine">    SmallVector<const SCEV *, 3> Ops = {Op0, Op1, Op2};</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">609</td>
    <td class="codeLine">    return getMulExpr(Ops, Flags, Depth);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">609</td>
    <td class="codeLine">    return getMulExpr(Ops, Flags, Depth);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">610</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">610</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">611</td>
    <td class="codeLine">  const SCEV *getUDivExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">611</td>
    <td class="codeLine">  const SCEV *getUDivExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">612</td>
    <td class="codeLine">  const SCEV *getUDivExactExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">612</td>
    <td class="codeLine">  const SCEV *getUDivExactExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">613</td>
    <td class="codeLine">  const SCEV *getURemExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">613</td>
    <td class="codeLine">  const SCEV *getURemExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">614</td>
    <td class="codeLine">  const SCEV *getAddRecExpr(const SCEV *Start, const SCEV *Step, const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">614</td>
    <td class="codeLine">  const SCEV *getAddRecExpr(const SCEV *Start, const SCEV *Step, const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">615</td>
    <td class="codeLine">                            SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">615</td>
    <td class="codeLine">                            SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">616</td>
    <td class="codeLine">  const SCEV *getAddRecExpr(SmallVectorImpl<const SCEV *> &Operands,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">616</td>
    <td class="codeLine">  const SCEV *getAddRecExpr(SmallVectorImpl<const SCEV *> &Operands,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">617</td>
    <td class="codeLine">                            const Loop *L, SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">617</td>
    <td class="codeLine">                            const Loop *L, SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">618</td>
    <td class="codeLine">  const SCEV *getAddRecExpr(const SmallVectorImpl<const SCEV *> &Operands,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">618</td>
    <td class="codeLine">  const SCEV *getAddRecExpr(const SmallVectorImpl<const SCEV *> &Operands,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">619</td>
    <td class="codeLine">                            const Loop *L, SCEV::NoWrapFlags Flags) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">619</td>
    <td class="codeLine">                            const Loop *L, SCEV::NoWrapFlags Flags) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">620</td>
    <td class="codeLine">    SmallVector<const SCEV *, 4> NewOp(Operands.begin(), Operands.end());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">620</td>
    <td class="codeLine">    SmallVector<const SCEV *, 4> NewOp(Operands.begin(), Operands.end());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">621</td>
    <td class="codeLine">    return getAddRecExpr(NewOp, L, Flags);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">621</td>
    <td class="codeLine">    return getAddRecExpr(NewOp, L, Flags);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">622</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">622</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">623</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">624</td>
    <td class="codeLine">  /// Checks if \p SymbolicPHI can be rewritten as an AddRecExpr under some</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">624</td>
    <td class="codeLine">  /// Checks if \p SymbolicPHI can be rewritten as an AddRecExpr under some</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">625</td>
    <td class="codeLine">  /// Predicates. If successful return these <AddRecExpr, Predicates>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">625</td>
    <td class="codeLine">  /// Predicates. If successful return these <AddRecExpr, Predicates>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">626</td>
    <td class="codeLine">  /// The function is intended to be called from PSCEV (the caller will decide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">626</td>
    <td class="codeLine">  /// The function is intended to be called from PSCEV (the caller will decide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">627</td>
    <td class="codeLine">  /// whether to actually add the predicates and carry out the rewrites).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">627</td>
    <td class="codeLine">  /// whether to actually add the predicates and carry out the rewrites).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">628</td>
    <td class="codeLine">  std::optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">628</td>
    <td class="codeLine">  std::optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">629</td>
    <td class="codeLine">  createAddRecFromPHIWithCasts(const SCEVUnknown *SymbolicPHI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">629</td>
    <td class="codeLine">  createAddRecFromPHIWithCasts(const SCEVUnknown *SymbolicPHI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">630</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">631</td>
    <td class="codeLine">  /// Returns an expression for a GEP</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">631</td>
    <td class="codeLine">  /// Returns an expression for a GEP</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">632</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">632</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">633</td>
    <td class="codeLine">  /// \p GEP The GEP. The indices contained in the GEP itself are ignored,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">633</td>
    <td class="codeLine">  /// \p GEP The GEP. The indices contained in the GEP itself are ignored,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">634</td>
    <td class="codeLine">  /// instead we use IndexExprs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">634</td>
    <td class="codeLine">  /// instead we use IndexExprs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">635</td>
    <td class="codeLine">  /// \p IndexExprs The expressions for the indices.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">635</td>
    <td class="codeLine">  /// \p IndexExprs The expressions for the indices.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">636</td>
    <td class="codeLine">  const SCEV *getGEPExpr(GEPOperator *GEP,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">636</td>
    <td class="codeLine">  const SCEV *getGEPExpr(GEPOperator *GEP,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">637</td>
    <td class="codeLine">                         const SmallVectorImpl<const SCEV *> &IndexExprs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">637</td>
    <td class="codeLine">                         const SmallVectorImpl<const SCEV *> &IndexExprs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">638</td>
    <td class="codeLine">  const SCEV *getAbsExpr(const SCEV *Op, bool IsNSW);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">638</td>
    <td class="codeLine">  const SCEV *getAbsExpr(const SCEV *Op, bool IsNSW);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">639</td>
    <td class="codeLine">  const SCEV *getMinMaxExpr(SCEVTypes Kind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">639</td>
    <td class="codeLine">  const SCEV *getMinMaxExpr(SCEVTypes Kind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">640</td>
    <td class="codeLine">                            SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">640</td>
    <td class="codeLine">                            SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">641</td>
    <td class="codeLine">  const SCEV *getSequentialMinMaxExpr(SCEVTypes Kind,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">641</td>
    <td class="codeLine">  const SCEV *getSequentialMinMaxExpr(SCEVTypes Kind,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">642</td>
    <td class="codeLine">                                      SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">642</td>
    <td class="codeLine">                                      SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">643</td>
    <td class="codeLine">  const SCEV *getSMaxExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">643</td>
    <td class="codeLine">  const SCEV *getSMaxExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">644</td>
    <td class="codeLine">  const SCEV *getSMaxExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">644</td>
    <td class="codeLine">  const SCEV *getSMaxExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">645</td>
    <td class="codeLine">  const SCEV *getUMaxExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">645</td>
    <td class="codeLine">  const SCEV *getUMaxExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">646</td>
    <td class="codeLine">  const SCEV *getUMaxExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">646</td>
    <td class="codeLine">  const SCEV *getUMaxExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">647</td>
    <td class="codeLine">  const SCEV *getSMinExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">647</td>
    <td class="codeLine">  const SCEV *getSMinExpr(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">648</td>
    <td class="codeLine">  const SCEV *getSMinExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">648</td>
    <td class="codeLine">  const SCEV *getSMinExpr(SmallVectorImpl<const SCEV *> &Operands);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">649</td>
    <td class="codeLine">  const SCEV *getUMinExpr(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">649</td>
    <td class="codeLine">  const SCEV *getUMinExpr(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">650</td>
    <td class="codeLine">                          bool Sequential = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">650</td>
    <td class="codeLine">                          bool Sequential = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">651</td>
    <td class="codeLine">  const SCEV *getUMinExpr(SmallVectorImpl<const SCEV *> &Operands,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">651</td>
    <td class="codeLine">  const SCEV *getUMinExpr(SmallVectorImpl<const SCEV *> &Operands,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">652</td>
    <td class="codeLine">                          bool Sequential = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">652</td>
    <td class="codeLine">                          bool Sequential = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">653</td>
    <td class="codeLine">  const SCEV *getUnknown(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">653</td>
    <td class="codeLine">  const SCEV *getUnknown(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">654</td>
    <td class="codeLine">  const SCEV *getCouldNotCompute();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">654</td>
    <td class="codeLine">  const SCEV *getCouldNotCompute();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">655</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">655</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">656</td>
    <td class="codeLine">  /// Return a SCEV for the constant 0 of a specific type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">656</td>
    <td class="codeLine">  /// Return a SCEV for the constant 0 of a specific type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">657</td>
    <td class="codeLine">  const SCEV *getZero(Type *Ty) { return getConstant(Ty, 0); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">657</td>
    <td class="codeLine">  const SCEV *getZero(Type *Ty) { return getConstant(Ty, 0); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">658</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">659</td>
    <td class="codeLine">  /// Return a SCEV for the constant 1 of a specific type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">659</td>
    <td class="codeLine">  /// Return a SCEV for the constant 1 of a specific type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">660</td>
    <td class="codeLine">  const SCEV *getOne(Type *Ty) { return getConstant(Ty, 1); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">660</td>
    <td class="codeLine">  const SCEV *getOne(Type *Ty) { return getConstant(Ty, 1); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">661</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">662</td>
    <td class="codeLine">  /// Return a SCEV for the constant \p Power of two.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">662</td>
    <td class="codeLine">  /// Return a SCEV for the constant \p Power of two.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">663</td>
    <td class="codeLine">  const SCEV *getPowerOfTwo(Type *Ty, unsigned Power) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">663</td>
    <td class="codeLine">  const SCEV *getPowerOfTwo(Type *Ty, unsigned Power) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">664</td>
    <td class="codeLine">    assert(Power < getTypeSizeInBits(Ty) && "Power out of range");</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">664</td>
    <td class="codeLine">    assert(Power < getTypeSizeInBits(Ty) && "Power out of range");</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">665</td>
    <td class="codeLine">    return getConstant(APInt::getOneBitSet(getTypeSizeInBits(Ty), Power));</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">665</td>
    <td class="codeLine">    return getConstant(APInt::getOneBitSet(getTypeSizeInBits(Ty), Power));</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">666</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">666</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">667</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">667</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">668</td>
    <td class="codeLine">  /// Return a SCEV for the constant -1 of a specific type.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">668</td>
    <td class="codeLine">  /// Return a SCEV for the constant -1 of a specific type.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">669</td>
    <td class="codeLine">  const SCEV *getMinusOne(Type *Ty) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">669</td>
    <td class="codeLine">  const SCEV *getMinusOne(Type *Ty) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">670</td>
    <td class="codeLine">    return getConstant(Ty, -1, /*isSigned=*/true);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">670</td>
    <td class="codeLine">    return getConstant(Ty, -1, /*isSigned=*/true);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">671</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">671</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">672</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">673</td>
    <td class="codeLine">  /// Return an expression for a TypeSize.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">673</td>
    <td class="codeLine">  /// Return an expression for a TypeSize.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">674</td>
    <td class="codeLine">  const SCEV *getSizeOfExpr(Type *IntTy, TypeSize Size);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">674</td>
    <td class="codeLine">  const SCEV *getSizeOfExpr(Type *IntTy, TypeSize Size);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">676</td>
    <td class="codeLine">  /// Return an expression for the alloc size of AllocTy that is type IntTy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">676</td>
    <td class="codeLine">  /// Return an expression for the alloc size of AllocTy that is type IntTy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">677</td>
    <td class="codeLine">  const SCEV *getSizeOfExpr(Type *IntTy, Type *AllocTy);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">677</td>
    <td class="codeLine">  const SCEV *getSizeOfExpr(Type *IntTy, Type *AllocTy);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">678</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">679</td>
    <td class="codeLine">  /// Return an expression for the store size of StoreTy that is type IntTy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">679</td>
    <td class="codeLine">  /// Return an expression for the store size of StoreTy that is type IntTy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">680</td>
    <td class="codeLine">  const SCEV *getStoreSizeOfExpr(Type *IntTy, Type *StoreTy);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">680</td>
    <td class="codeLine">  const SCEV *getStoreSizeOfExpr(Type *IntTy, Type *StoreTy);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">681</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">682</td>
    <td class="codeLine">  /// Return an expression for offsetof on the given field with type IntTy</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">682</td>
    <td class="codeLine">  /// Return an expression for offsetof on the given field with type IntTy</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">683</td>
    <td class="codeLine">  const SCEV *getOffsetOfExpr(Type *IntTy, StructType *STy, unsigned FieldNo);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">683</td>
    <td class="codeLine">  const SCEV *getOffsetOfExpr(Type *IntTy, StructType *STy, unsigned FieldNo);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">684</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">684</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">685</td>
    <td class="codeLine">  /// Return the SCEV object corresponding to -V.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">685</td>
    <td class="codeLine">  /// Return the SCEV object corresponding to -V.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">686</td>
    <td class="codeLine">  const SCEV *getNegativeSCEV(const SCEV *V,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">686</td>
    <td class="codeLine">  const SCEV *getNegativeSCEV(const SCEV *V,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">687</td>
    <td class="codeLine">                              SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">687</td>
    <td class="codeLine">                              SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">688</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">689</td>
    <td class="codeLine">  /// Return the SCEV object corresponding to ~V.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">689</td>
    <td class="codeLine">  /// Return the SCEV object corresponding to ~V.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">690</td>
    <td class="codeLine">  const SCEV *getNotSCEV(const SCEV *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">690</td>
    <td class="codeLine">  const SCEV *getNotSCEV(const SCEV *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">691</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">692</td>
    <td class="codeLine">  /// Return LHS-RHS.  Minus is represented in SCEV as A+B*-1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">692</td>
    <td class="codeLine">  /// Return LHS-RHS.  Minus is represented in SCEV as A+B*-1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">693</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">693</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">694</td>
    <td class="codeLine">  /// If the LHS and RHS are pointers which don't share a common base</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">694</td>
    <td class="codeLine">  /// If the LHS and RHS are pointers which don't share a common base</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">695</td>
    <td class="codeLine">  /// (according to getPointerBase()), this returns a SCEVCouldNotCompute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">695</td>
    <td class="codeLine">  /// (according to getPointerBase()), this returns a SCEVCouldNotCompute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">696</td>
    <td class="codeLine">  /// To compute the difference between two unrelated pointers, you can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">696</td>
    <td class="codeLine">  /// To compute the difference between two unrelated pointers, you can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">697</td>
    <td class="codeLine">  /// explicitly convert the arguments using getPtrToIntExpr(), for pointer</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">697</td>
    <td class="codeLine">  /// explicitly convert the arguments using getPtrToIntExpr(), for pointer</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">698</td>
    <td class="codeLine">  /// types that support it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">698</td>
    <td class="codeLine">  /// types that support it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">699</td>
    <td class="codeLine">  const SCEV *getMinusSCEV(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">699</td>
    <td class="codeLine">  const SCEV *getMinusSCEV(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">700</td>
    <td class="codeLine">                           SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">700</td>
    <td class="codeLine">                           SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">701</td>
    <td class="codeLine">                           unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">701</td>
    <td class="codeLine">                           unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">702</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">703</td>
    <td class="codeLine">  /// Compute ceil(N / D). N and D are treated as unsigned values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">703</td>
    <td class="codeLine">  /// Compute ceil(N / D). N and D are treated as unsigned values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">704</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">704</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">705</td>
    <td class="codeLine">  /// Since SCEV doesn't have native ceiling division, this generates a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">705</td>
    <td class="codeLine">  /// Since SCEV doesn't have native ceiling division, this generates a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">706</td>
    <td class="codeLine">  /// SCEV expression of the following form:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">706</td>
    <td class="codeLine">  /// SCEV expression of the following form:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">707</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">707</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">708</td>
    <td class="codeLine">  /// umin(N, 1) + floor((N - umin(N, 1)) / D)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">708</td>
    <td class="codeLine">  /// umin(N, 1) + floor((N - umin(N, 1)) / D)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">709</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">709</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">710</td>
    <td class="codeLine">  /// A denominator of zero or poison is handled the same way as getUDivExpr().</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">710</td>
    <td class="codeLine">  /// A denominator of zero or poison is handled the same way as getUDivExpr().</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">711</td>
    <td class="codeLine">  const SCEV *getUDivCeilSCEV(const SCEV *N, const SCEV *D);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">711</td>
    <td class="codeLine">  const SCEV *getUDivCeilSCEV(const SCEV *N, const SCEV *D);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">712</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">713</td>
    <td class="codeLine">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">713</td>
    <td class="codeLine">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">714</td>
    <td class="codeLine">  /// specified type.  If the type must be extended, it is zero extended.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">714</td>
    <td class="codeLine">  /// specified type.  If the type must be extended, it is zero extended.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">715</td>
    <td class="codeLine">  const SCEV *getTruncateOrZeroExtend(const SCEV *V, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">715</td>
    <td class="codeLine">  const SCEV *getTruncateOrZeroExtend(const SCEV *V, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">716</td>
    <td class="codeLine">                                      unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">716</td>
    <td class="codeLine">                                      unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">717</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">717</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">718</td>
    <td class="codeLine">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">718</td>
    <td class="codeLine">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">719</td>
    <td class="codeLine">  /// specified type.  If the type must be extended, it is sign extended.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">719</td>
    <td class="codeLine">  /// specified type.  If the type must be extended, it is sign extended.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">720</td>
    <td class="codeLine">  const SCEV *getTruncateOrSignExtend(const SCEV *V, Type *Ty,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">720</td>
    <td class="codeLine">  const SCEV *getTruncateOrSignExtend(const SCEV *V, Type *Ty,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">721</td>
    <td class="codeLine">                                      unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">721</td>
    <td class="codeLine">                                      unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">722</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">723</td>
    <td class="codeLine">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">723</td>
    <td class="codeLine">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">724</td>
    <td class="codeLine">  /// specified type.  If the type must be extended, it is zero extended.  The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">724</td>
    <td class="codeLine">  /// specified type.  If the type must be extended, it is zero extended.  The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">725</td>
    <td class="codeLine">  /// conversion must not be narrowing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">725</td>
    <td class="codeLine">  /// conversion must not be narrowing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">726</td>
    <td class="codeLine">  const SCEV *getNoopOrZeroExtend(const SCEV *V, Type *Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">726</td>
    <td class="codeLine">  const SCEV *getNoopOrZeroExtend(const SCEV *V, Type *Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">727</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">728</td>
    <td class="codeLine">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">728</td>
    <td class="codeLine">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">729</td>
    <td class="codeLine">  /// specified type.  If the type must be extended, it is sign extended.  The</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">729</td>
    <td class="codeLine">  /// specified type.  If the type must be extended, it is sign extended.  The</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">730</td>
    <td class="codeLine">  /// conversion must not be narrowing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">730</td>
    <td class="codeLine">  /// conversion must not be narrowing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">731</td>
    <td class="codeLine">  const SCEV *getNoopOrSignExtend(const SCEV *V, Type *Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">731</td>
    <td class="codeLine">  const SCEV *getNoopOrSignExtend(const SCEV *V, Type *Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">733</td>
    <td class="codeLine">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">733</td>
    <td class="codeLine">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">734</td>
    <td class="codeLine">  /// specified type. If the type must be extended, it is extended with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">734</td>
    <td class="codeLine">  /// specified type. If the type must be extended, it is extended with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">735</td>
    <td class="codeLine">  /// unspecified bits. The conversion must not be narrowing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">735</td>
    <td class="codeLine">  /// unspecified bits. The conversion must not be narrowing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">736</td>
    <td class="codeLine">  const SCEV *getNoopOrAnyExtend(const SCEV *V, Type *Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">736</td>
    <td class="codeLine">  const SCEV *getNoopOrAnyExtend(const SCEV *V, Type *Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">737</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">738</td>
    <td class="codeLine">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">738</td>
    <td class="codeLine">  /// Return a SCEV corresponding to a conversion of the input value to the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">739</td>
    <td class="codeLine">  /// specified type.  The conversion must not be widening.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">739</td>
    <td class="codeLine">  /// specified type.  The conversion must not be widening.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">740</td>
    <td class="codeLine">  const SCEV *getTruncateOrNoop(const SCEV *V, Type *Ty);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">740</td>
    <td class="codeLine">  const SCEV *getTruncateOrNoop(const SCEV *V, Type *Ty);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">741</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">742</td>
    <td class="codeLine">  /// Promote the operands to the wider of the types using zero-extension, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">742</td>
    <td class="codeLine">  /// Promote the operands to the wider of the types using zero-extension, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">743</td>
    <td class="codeLine">  /// then perform a umax operation with them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">743</td>
    <td class="codeLine">  /// then perform a umax operation with them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">744</td>
    <td class="codeLine">  const SCEV *getUMaxFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">744</td>
    <td class="codeLine">  const SCEV *getUMaxFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">746</td>
    <td class="codeLine">  /// Promote the operands to the wider of the types using zero-extension, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">746</td>
    <td class="codeLine">  /// Promote the operands to the wider of the types using zero-extension, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">747</td>
    <td class="codeLine">  /// then perform a umin operation with them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">747</td>
    <td class="codeLine">  /// then perform a umin operation with them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">748</td>
    <td class="codeLine">  const SCEV *getUMinFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">748</td>
    <td class="codeLine">  const SCEV *getUMinFromMismatchedTypes(const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">749</td>
    <td class="codeLine">                                         bool Sequential = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">749</td>
    <td class="codeLine">                                         bool Sequential = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">751</td>
    <td class="codeLine">  /// Promote the operands to the wider of the types using zero-extension, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">751</td>
    <td class="codeLine">  /// Promote the operands to the wider of the types using zero-extension, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">752</td>
    <td class="codeLine">  /// then perform a umin operation with them. N-ary function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">752</td>
    <td class="codeLine">  /// then perform a umin operation with them. N-ary function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">753</td>
    <td class="codeLine">  const SCEV *getUMinFromMismatchedTypes(SmallVectorImpl<const SCEV *> &Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">753</td>
    <td class="codeLine">  const SCEV *getUMinFromMismatchedTypes(SmallVectorImpl<const SCEV *> &Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">754</td>
    <td class="codeLine">                                         bool Sequential = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">754</td>
    <td class="codeLine">                                         bool Sequential = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">755</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">756</td>
    <td class="codeLine">  /// Transitively follow the chain of pointer-type operands until reaching a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">756</td>
    <td class="codeLine">  /// Transitively follow the chain of pointer-type operands until reaching a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">757</td>
    <td class="codeLine">  /// SCEV that does not have a single pointer operand. This returns a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">757</td>
    <td class="codeLine">  /// SCEV that does not have a single pointer operand. This returns a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">758</td>
    <td class="codeLine">  /// SCEVUnknown pointer for well-formed pointer-type expressions, but corner</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">758</td>
    <td class="codeLine">  /// SCEVUnknown pointer for well-formed pointer-type expressions, but corner</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">759</td>
    <td class="codeLine">  /// cases do exist.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">759</td>
    <td class="codeLine">  /// cases do exist.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">760</td>
    <td class="codeLine">  const SCEV *getPointerBase(const SCEV *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">760</td>
    <td class="codeLine">  const SCEV *getPointerBase(const SCEV *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">762</td>
    <td class="codeLine">  /// Compute an expression equivalent to S - getPointerBase(S).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">762</td>
    <td class="codeLine">  /// Compute an expression equivalent to S - getPointerBase(S).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">763</td>
    <td class="codeLine">  const SCEV *removePointerBase(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">763</td>
    <td class="codeLine">  const SCEV *removePointerBase(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">764</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">764</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">765</td>
    <td class="codeLine">  /// Return a SCEV expression for the specified value at the specified scope</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">765</td>
    <td class="codeLine">  /// Return a SCEV expression for the specified value at the specified scope</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">766</td>
    <td class="codeLine">  /// in the program.  The L value specifies a loop nest to evaluate the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">766</td>
    <td class="codeLine">  /// in the program.  The L value specifies a loop nest to evaluate the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">767</td>
    <td class="codeLine">  /// expression at, where null is the top-level or a specified loop is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">767</td>
    <td class="codeLine">  /// expression at, where null is the top-level or a specified loop is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">768</td>
    <td class="codeLine">  /// immediately inside of the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">768</td>
    <td class="codeLine">  /// immediately inside of the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">769</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">769</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">770</td>
    <td class="codeLine">  /// This method can be used to compute the exit value for a variable defined</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">770</td>
    <td class="codeLine">  /// This method can be used to compute the exit value for a variable defined</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">771</td>
    <td class="codeLine">  /// in a loop by querying what the value will hold in the parent loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">771</td>
    <td class="codeLine">  /// in a loop by querying what the value will hold in the parent loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">772</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">772</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">773</td>
    <td class="codeLine">  /// In the case that a relevant loop exit value cannot be computed, the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">773</td>
    <td class="codeLine">  /// In the case that a relevant loop exit value cannot be computed, the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">774</td>
    <td class="codeLine">  /// original value V is returned.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">774</td>
    <td class="codeLine">  /// original value V is returned.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">775</td>
    <td class="codeLine">  const SCEV *getSCEVAtScope(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">775</td>
    <td class="codeLine">  const SCEV *getSCEVAtScope(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">776</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">777</td>
    <td class="codeLine">  /// This is a convenience function which does getSCEVAtScope(getSCEV(V), L).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">777</td>
    <td class="codeLine">  /// This is a convenience function which does getSCEVAtScope(getSCEV(V), L).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">778</td>
    <td class="codeLine">  const SCEV *getSCEVAtScope(Value *V, const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">778</td>
    <td class="codeLine">  const SCEV *getSCEVAtScope(Value *V, const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">779</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">780</td>
    <td class="codeLine">  /// Test whether entry to the loop is protected by a conditional between LHS</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">780</td>
    <td class="codeLine">  /// Test whether entry to the loop is protected by a conditional between LHS</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">781</td>
    <td class="codeLine">  /// and RHS.  This is used to help avoid max expressions in loop trip</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">781</td>
    <td class="codeLine">  /// and RHS.  This is used to help avoid max expressions in loop trip</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">782</td>
    <td class="codeLine">  /// counts, and to eliminate casts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">782</td>
    <td class="codeLine">  /// counts, and to eliminate casts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">783</td>
    <td class="codeLine">  bool isLoopEntryGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">783</td>
    <td class="codeLine">  bool isLoopEntryGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">784</td>
    <td class="codeLine">                                const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">784</td>
    <td class="codeLine">                                const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">785</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">786</td>
    <td class="codeLine">  /// Test whether entry to the basic block is protected by a conditional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">786</td>
    <td class="codeLine">  /// Test whether entry to the basic block is protected by a conditional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">787</td>
    <td class="codeLine">  /// between LHS and RHS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">787</td>
    <td class="codeLine">  /// between LHS and RHS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">788</td>
    <td class="codeLine">  bool isBasicBlockEntryGuardedByCond(const BasicBlock *BB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">788</td>
    <td class="codeLine">  bool isBasicBlockEntryGuardedByCond(const BasicBlock *BB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">789</td>
    <td class="codeLine">                                      ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">789</td>
    <td class="codeLine">                                      ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">790</td>
    <td class="codeLine">                                      const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">790</td>
    <td class="codeLine">                                      const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">791</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">792</td>
    <td class="codeLine">  /// Test whether the backedge of the loop is protected by a conditional</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">792</td>
    <td class="codeLine">  /// Test whether the backedge of the loop is protected by a conditional</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">793</td>
    <td class="codeLine">  /// between LHS and RHS.  This is used to eliminate casts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">793</td>
    <td class="codeLine">  /// between LHS and RHS.  This is used to eliminate casts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">794</td>
    <td class="codeLine">  bool isLoopBackedgeGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">794</td>
    <td class="codeLine">  bool isLoopBackedgeGuardedByCond(const Loop *L, ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">795</td>
    <td class="codeLine">                                   const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">795</td>
    <td class="codeLine">                                   const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">796</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">797</td>
    <td class="codeLine">  /// A version of getTripCountFromExitCount below which always picks an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">797</td>
    <td class="codeLine">  /// A version of getTripCountFromExitCount below which always picks an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">798</td>
    <td class="codeLine">  /// evaluation type which can not result in overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">798</td>
    <td class="codeLine">  /// evaluation type which can not result in overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">799</td>
    <td class="codeLine">  const SCEV *getTripCountFromExitCount(const SCEV *ExitCount);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">799</td>
    <td class="codeLine">  const SCEV *getTripCountFromExitCount(const SCEV *ExitCount);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">800</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">801</td>
    <td class="codeLine">  /// Convert from an "exit count" (i.e. "backedge taken count") to a "trip</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">801</td>
    <td class="codeLine">  /// Convert from an "exit count" (i.e. "backedge taken count") to a "trip</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">802</td>
    <td class="codeLine">  /// count".  A "trip count" is the number of times the header of the loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">802</td>
    <td class="codeLine">  /// count".  A "trip count" is the number of times the header of the loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">803</td>
    <td class="codeLine">  /// will execute if an exit is taken after the specified number of backedges</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">803</td>
    <td class="codeLine">  /// will execute if an exit is taken after the specified number of backedges</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">804</td>
    <td class="codeLine">  /// have been taken.  (e.g. TripCount = ExitCount + 1).  Note that the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">804</td>
    <td class="codeLine">  /// have been taken.  (e.g. TripCount = ExitCount + 1).  Note that the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">805</td>
    <td class="codeLine">  /// expression can overflow if ExitCount = UINT_MAX.  If EvalTy is not wide</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">805</td>
    <td class="codeLine">  /// expression can overflow if ExitCount = UINT_MAX.  If EvalTy is not wide</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">806</td>
    <td class="codeLine">  /// enough to hold the result without overflow, result unsigned wraps with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">806</td>
    <td class="codeLine">  /// enough to hold the result without overflow, result unsigned wraps with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">807</td>
    <td class="codeLine">  /// 2s-complement semantics.  ex: EC = 255 (i8), TC = 0 (i8)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">807</td>
    <td class="codeLine">  /// 2s-complement semantics.  ex: EC = 255 (i8), TC = 0 (i8)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">808</td>
    <td class="codeLine">  const SCEV *getTripCountFromExitCount(const SCEV *ExitCount, Type *EvalTy,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">808</td>
    <td class="codeLine">  const SCEV *getTripCountFromExitCount(const SCEV *ExitCount, Type *EvalTy,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">809</td>
    <td class="codeLine">                                        const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">809</td>
    <td class="codeLine">                                        const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">810</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">811</td>
    <td class="codeLine">  /// Returns the exact trip count of the loop if we can compute it, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">811</td>
    <td class="codeLine">  /// Returns the exact trip count of the loop if we can compute it, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">812</td>
    <td class="codeLine">  /// the result is a small constant.  '0' is used to represent an unknown</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">812</td>
    <td class="codeLine">  /// the result is a small constant.  '0' is used to represent an unknown</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">813</td>
    <td class="codeLine">  /// or non-constant trip count.  Note that a trip count is simply one more</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">813</td>
    <td class="codeLine">  /// or non-constant trip count.  Note that a trip count is simply one more</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">814</td>
    <td class="codeLine">  /// than the backedge taken count for the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">814</td>
    <td class="codeLine">  /// than the backedge taken count for the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">815</td>
    <td class="codeLine">  unsigned getSmallConstantTripCount(const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">815</td>
    <td class="codeLine">  unsigned getSmallConstantTripCount(const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">816</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">817</td>
    <td class="codeLine">  /// Return the exact trip count for this loop if we exit through ExitingBlock.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">817</td>
    <td class="codeLine">  /// Return the exact trip count for this loop if we exit through ExitingBlock.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">818</td>
    <td class="codeLine">  /// '0' is used to represent an unknown or non-constant trip count.  Note</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">818</td>
    <td class="codeLine">  /// '0' is used to represent an unknown or non-constant trip count.  Note</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">819</td>
    <td class="codeLine">  /// that a trip count is simply one more than the backedge taken count for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">819</td>
    <td class="codeLine">  /// that a trip count is simply one more than the backedge taken count for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">820</td>
    <td class="codeLine">  /// the same exit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">820</td>
    <td class="codeLine">  /// the same exit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">821</td>
    <td class="codeLine">  /// This "trip count" assumes that control exits via ExitingBlock. More</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">821</td>
    <td class="codeLine">  /// This "trip count" assumes that control exits via ExitingBlock. More</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">822</td>
    <td class="codeLine">  /// precisely, it is the number of times that control will reach ExitingBlock</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">822</td>
    <td class="codeLine">  /// precisely, it is the number of times that control will reach ExitingBlock</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">823</td>
    <td class="codeLine">  /// before taking the branch. For loops with multiple exits, it may not be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">823</td>
    <td class="codeLine">  /// before taking the branch. For loops with multiple exits, it may not be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">824</td>
    <td class="codeLine">  /// the number times that the loop header executes if the loop exits</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">824</td>
    <td class="codeLine">  /// the number times that the loop header executes if the loop exits</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">825</td>
    <td class="codeLine">  /// prematurely via another branch.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">825</td>
    <td class="codeLine">  /// prematurely via another branch.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">826</td>
    <td class="codeLine">  unsigned getSmallConstantTripCount(const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">826</td>
    <td class="codeLine">  unsigned getSmallConstantTripCount(const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">827</td>
    <td class="codeLine">                                     const BasicBlock *ExitingBlock);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">827</td>
    <td class="codeLine">                                     const BasicBlock *ExitingBlock);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">828</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">829</td>
    <td class="codeLine">  /// Returns the upper bound of the loop trip count as a normal unsigned</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">829</td>
    <td class="codeLine">  /// Returns the upper bound of the loop trip count as a normal unsigned</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">830</td>
    <td class="codeLine">  /// value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">830</td>
    <td class="codeLine">  /// value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">831</td>
    <td class="codeLine">  /// Returns 0 if the trip count is unknown or not constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">831</td>
    <td class="codeLine">  /// Returns 0 if the trip count is unknown or not constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">832</td>
    <td class="codeLine">  unsigned getSmallConstantMaxTripCount(const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">832</td>
    <td class="codeLine">  unsigned getSmallConstantMaxTripCount(const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">833</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">834</td>
    <td class="codeLine">  /// Returns the largest constant divisor of the trip count as a normal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">834</td>
    <td class="codeLine">  /// Returns the largest constant divisor of the trip count as a normal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">835</td>
    <td class="codeLine">  /// unsigned value, if possible. This means that the actual trip count is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">835</td>
    <td class="codeLine">  /// unsigned value, if possible. This means that the actual trip count is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">836</td>
    <td class="codeLine">  /// always a multiple of the returned value. Returns 1 if the trip count is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">836</td>
    <td class="codeLine">  /// always a multiple of the returned value. Returns 1 if the trip count is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">837</td>
    <td class="codeLine">  /// unknown or not guaranteed to be the multiple of a constant., Will also</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">837</td>
    <td class="codeLine">  /// unknown or not guaranteed to be the multiple of a constant., Will also</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">838</td>
    <td class="codeLine">  /// return 1 if the trip count is very large (>= 2^32).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">838</td>
    <td class="codeLine">  /// return 1 if the trip count is very large (>= 2^32).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">839</td>
    <td class="codeLine">  /// Note that the argument is an exit count for loop L, NOT a trip count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">839</td>
    <td class="codeLine">  /// Note that the argument is an exit count for loop L, NOT a trip count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">840</td>
    <td class="codeLine">  unsigned getSmallConstantTripMultiple(const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">840</td>
    <td class="codeLine">  unsigned getSmallConstantTripMultiple(const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">841</td>
    <td class="codeLine">                                        const SCEV *ExitCount);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">841</td>
    <td class="codeLine">                                        const SCEV *ExitCount);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">842</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">842</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">843</td>
    <td class="codeLine">  /// Returns the largest constant divisor of the trip count of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">843</td>
    <td class="codeLine">  /// Returns the largest constant divisor of the trip count of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">844</td>
    <td class="codeLine">  /// loop.  Will return 1 if no trip count could be computed, or if a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">844</td>
    <td class="codeLine">  /// loop.  Will return 1 if no trip count could be computed, or if a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">845</td>
    <td class="codeLine">  /// divisor could not be found.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">845</td>
    <td class="codeLine">  /// divisor could not be found.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">846</td>
    <td class="codeLine">  unsigned getSmallConstantTripMultiple(const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">846</td>
    <td class="codeLine">  unsigned getSmallConstantTripMultiple(const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">847</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">848</td>
    <td class="codeLine">  /// Returns the largest constant divisor of the trip count of this loop as a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">848</td>
    <td class="codeLine">  /// Returns the largest constant divisor of the trip count of this loop as a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">849</td>
    <td class="codeLine">  /// normal unsigned value, if possible. This means that the actual trip</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">849</td>
    <td class="codeLine">  /// normal unsigned value, if possible. This means that the actual trip</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">850</td>
    <td class="codeLine">  /// count is always a multiple of the returned value (don't forget the trip</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">850</td>
    <td class="codeLine">  /// count is always a multiple of the returned value (don't forget the trip</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">851</td>
    <td class="codeLine">  /// count could very well be zero as well!). As explained in the comments</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">851</td>
    <td class="codeLine">  /// count could very well be zero as well!). As explained in the comments</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">852</td>
    <td class="codeLine">  /// for getSmallConstantTripCount, this assumes that control exits the loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">852</td>
    <td class="codeLine">  /// for getSmallConstantTripCount, this assumes that control exits the loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">853</td>
    <td class="codeLine">  /// via ExitingBlock.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">853</td>
    <td class="codeLine">  /// via ExitingBlock.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">854</td>
    <td class="codeLine">  unsigned getSmallConstantTripMultiple(const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">854</td>
    <td class="codeLine">  unsigned getSmallConstantTripMultiple(const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">855</td>
    <td class="codeLine">                                        const BasicBlock *ExitingBlock);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">855</td>
    <td class="codeLine">                                        const BasicBlock *ExitingBlock);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">856</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">856</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">857</td>
    <td class="codeLine">  /// The terms "backedge taken count" and "exit count" are used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">857</td>
    <td class="codeLine">  /// The terms "backedge taken count" and "exit count" are used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">858</td>
    <td class="codeLine">  /// interchangeably to refer to the number of times the backedge of a loop </td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">858</td>
    <td class="codeLine">  /// interchangeably to refer to the number of times the backedge of a loop </td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">859</td>
    <td class="codeLine">  /// has executed before the loop is exited.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">859</td>
    <td class="codeLine">  /// has executed before the loop is exited.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">860</td>
    <td class="codeLine">  enum ExitCountKind {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">860</td>
    <td class="codeLine">  enum ExitCountKind {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">861</td>
    <td class="codeLine">    /// An expression exactly describing the number of times the backedge has</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">861</td>
    <td class="codeLine">    /// An expression exactly describing the number of times the backedge has</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">862</td>
    <td class="codeLine">    /// executed when a loop is exited.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">862</td>
    <td class="codeLine">    /// executed when a loop is exited.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">863</td>
    <td class="codeLine">    Exact,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">863</td>
    <td class="codeLine">    Exact,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">864</td>
    <td class="codeLine">    /// A constant which provides an upper bound on the exact trip count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">864</td>
    <td class="codeLine">    /// A constant which provides an upper bound on the exact trip count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">865</td>
    <td class="codeLine">    ConstantMaximum,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">865</td>
    <td class="codeLine">    ConstantMaximum,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">866</td>
    <td class="codeLine">    /// An expression which provides an upper bound on the exact trip count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">866</td>
    <td class="codeLine">    /// An expression which provides an upper bound on the exact trip count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">867</td>
    <td class="codeLine">    SymbolicMaximum,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">867</td>
    <td class="codeLine">    SymbolicMaximum,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">868</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">868</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">869</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">870</td>
    <td class="codeLine">  /// Return the number of times the backedge executes before the given exit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">870</td>
    <td class="codeLine">  /// Return the number of times the backedge executes before the given exit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">871</td>
    <td class="codeLine">  /// would be taken; if not exactly computable, return SCEVCouldNotCompute. </td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">871</td>
    <td class="codeLine">  /// would be taken; if not exactly computable, return SCEVCouldNotCompute. </td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">872</td>
    <td class="codeLine">  /// For a single exit loop, this value is equivelent to the result of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">872</td>
    <td class="codeLine">  /// For a single exit loop, this value is equivelent to the result of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">873</td>
    <td class="codeLine">  /// getBackedgeTakenCount.  The loop is guaranteed to exit (via *some* exit)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">873</td>
    <td class="codeLine">  /// getBackedgeTakenCount.  The loop is guaranteed to exit (via *some* exit)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">874</td>
    <td class="codeLine">  /// before the backedge is executed (ExitCount + 1) times.  Note that there</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">874</td>
    <td class="codeLine">  /// before the backedge is executed (ExitCount + 1) times.  Note that there</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">875</td>
    <td class="codeLine">  /// is no guarantee about *which* exit is taken on the exiting iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">875</td>
    <td class="codeLine">  /// is no guarantee about *which* exit is taken on the exiting iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">876</td>
    <td class="codeLine">  const SCEV *getExitCount(const Loop *L, const BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">876</td>
    <td class="codeLine">  const SCEV *getExitCount(const Loop *L, const BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">877</td>
    <td class="codeLine">                           ExitCountKind Kind = Exact);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">877</td>
    <td class="codeLine">                           ExitCountKind Kind = Exact);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">878</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">878</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">879</td>
    <td class="codeLine">  /// If the specified loop has a predictable backedge-taken count, return it,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">879</td>
    <td class="codeLine">  /// If the specified loop has a predictable backedge-taken count, return it,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">880</td>
    <td class="codeLine">  /// otherwise return a SCEVCouldNotCompute object. The backedge-taken count is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">880</td>
    <td class="codeLine">  /// otherwise return a SCEVCouldNotCompute object. The backedge-taken count is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">881</td>
    <td class="codeLine">  /// the number of times the loop header will be branched to from within the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">881</td>
    <td class="codeLine">  /// the number of times the loop header will be branched to from within the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">882</td>
    <td class="codeLine">  /// loop, assuming there are no abnormal exists like exception throws. This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">882</td>
    <td class="codeLine">  /// loop, assuming there are no abnormal exists like exception throws. This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">883</td>
    <td class="codeLine">  /// one less than the trip count of the loop, since it doesn't count the first</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">883</td>
    <td class="codeLine">  /// one less than the trip count of the loop, since it doesn't count the first</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">884</td>
    <td class="codeLine">  /// iteration, when the header is branched to from outside the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">884</td>
    <td class="codeLine">  /// iteration, when the header is branched to from outside the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">885</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">885</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">886</td>
    <td class="codeLine">  /// Note that it is not valid to call this method on a loop without a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">886</td>
    <td class="codeLine">  /// Note that it is not valid to call this method on a loop without a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">887</td>
    <td class="codeLine">  /// loop-invariant backedge-taken count (see</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">887</td>
    <td class="codeLine">  /// loop-invariant backedge-taken count (see</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">888</td>
    <td class="codeLine">  /// hasLoopInvariantBackedgeTakenCount).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">888</td>
    <td class="codeLine">  /// hasLoopInvariantBackedgeTakenCount).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">889</td>
    <td class="codeLine">  const SCEV *getBackedgeTakenCount(const Loop *L, ExitCountKind Kind = Exact);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">889</td>
    <td class="codeLine">  const SCEV *getBackedgeTakenCount(const Loop *L, ExitCountKind Kind = Exact);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">890</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">891</td>
    <td class="codeLine">  /// Similar to getBackedgeTakenCount, except it will add a set of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">891</td>
    <td class="codeLine">  /// Similar to getBackedgeTakenCount, except it will add a set of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">892</td>
    <td class="codeLine">  /// SCEV predicates to Predicates that are required to be true in order for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">892</td>
    <td class="codeLine">  /// SCEV predicates to Predicates that are required to be true in order for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">893</td>
    <td class="codeLine">  /// the answer to be correct. Predicates can be checked with run-time</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">893</td>
    <td class="codeLine">  /// the answer to be correct. Predicates can be checked with run-time</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">894</td>
    <td class="codeLine">  /// checks and can be used to perform loop versioning.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">894</td>
    <td class="codeLine">  /// checks and can be used to perform loop versioning.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">895</td>
    <td class="codeLine">  const SCEV *getPredicatedBackedgeTakenCount(const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">895</td>
    <td class="codeLine">  const SCEV *getPredicatedBackedgeTakenCount(const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">896</td>
    <td class="codeLine">                                              SmallVector<const SCEVPredicate *, 4> &Predicates);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">896</td>
    <td class="codeLine">                                              SmallVector<const SCEVPredicate *, 4> &Predicates);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">897</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">898</td>
    <td class="codeLine">  /// When successful, this returns a SCEVConstant that is greater than or equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">898</td>
    <td class="codeLine">  /// When successful, this returns a SCEVConstant that is greater than or equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">899</td>
    <td class="codeLine">  /// to (i.e. a "conservative over-approximation") of the value returend by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">899</td>
    <td class="codeLine">  /// to (i.e. a "conservative over-approximation") of the value returend by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">900</td>
    <td class="codeLine">  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">900</td>
    <td class="codeLine">  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">901</td>
    <td class="codeLine">  /// SCEVCouldNotCompute object.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">901</td>
    <td class="codeLine">  /// SCEVCouldNotCompute object.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">902</td>
    <td class="codeLine">  const SCEV *getConstantMaxBackedgeTakenCount(const Loop *L) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">902</td>
    <td class="codeLine">  const SCEV *getConstantMaxBackedgeTakenCount(const Loop *L) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">903</td>
    <td class="codeLine">    return getBackedgeTakenCount(L, ConstantMaximum);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">903</td>
    <td class="codeLine">    return getBackedgeTakenCount(L, ConstantMaximum);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">904</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">904</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">905</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">905</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">906</td>
    <td class="codeLine">  /// When successful, this returns a SCEV that is greater than or equal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">906</td>
    <td class="codeLine">  /// When successful, this returns a SCEV that is greater than or equal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">907</td>
    <td class="codeLine">  /// to (i.e. a "conservative over-approximation") of the value returend by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">907</td>
    <td class="codeLine">  /// to (i.e. a "conservative over-approximation") of the value returend by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">908</td>
    <td class="codeLine">  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">908</td>
    <td class="codeLine">  /// getBackedgeTakenCount.  If such a value cannot be computed, it returns the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">909</td>
    <td class="codeLine">  /// SCEVCouldNotCompute object.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">909</td>
    <td class="codeLine">  /// SCEVCouldNotCompute object.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">910</td>
    <td class="codeLine">  const SCEV *getSymbolicMaxBackedgeTakenCount(const Loop *L) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">910</td>
    <td class="codeLine">  const SCEV *getSymbolicMaxBackedgeTakenCount(const Loop *L) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">911</td>
    <td class="codeLine">    return getBackedgeTakenCount(L, SymbolicMaximum);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">911</td>
    <td class="codeLine">    return getBackedgeTakenCount(L, SymbolicMaximum);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">912</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">912</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">913</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">914</td>
    <td class="codeLine">  /// Return true if the backedge taken count is either the value returned by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">914</td>
    <td class="codeLine">  /// Return true if the backedge taken count is either the value returned by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">915</td>
    <td class="codeLine">  /// getConstantMaxBackedgeTakenCount or zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">915</td>
    <td class="codeLine">  /// getConstantMaxBackedgeTakenCount or zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">916</td>
    <td class="codeLine">  bool isBackedgeTakenCountMaxOrZero(const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">916</td>
    <td class="codeLine">  bool isBackedgeTakenCountMaxOrZero(const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">917</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">917</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">918</td>
    <td class="codeLine">  /// Return true if the specified loop has an analyzable loop-invariant</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">918</td>
    <td class="codeLine">  /// Return true if the specified loop has an analyzable loop-invariant</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">919</td>
    <td class="codeLine">  /// backedge-taken count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">919</td>
    <td class="codeLine">  /// backedge-taken count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">920</td>
    <td class="codeLine">  bool hasLoopInvariantBackedgeTakenCount(const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">920</td>
    <td class="codeLine">  bool hasLoopInvariantBackedgeTakenCount(const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">921</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">921</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">922</td>
    <td class="codeLine">  // This method should be called by the client when it made any change that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">922</td>
    <td class="codeLine">  // This method should be called by the client when it made any change that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">923</td>
    <td class="codeLine">  // would invalidate SCEV's answers, and the client wants to remove all loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">923</td>
    <td class="codeLine">  // would invalidate SCEV's answers, and the client wants to remove all loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">924</td>
    <td class="codeLine">  // information held internally by ScalarEvolution. This is intended to be used</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">924</td>
    <td class="codeLine">  // information held internally by ScalarEvolution. This is intended to be used</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">925</td>
    <td class="codeLine">  // when the alternative to forget a loop is too expensive (i.e. large loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">925</td>
    <td class="codeLine">  // when the alternative to forget a loop is too expensive (i.e. large loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">926</td>
    <td class="codeLine">  // bodies).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">926</td>
    <td class="codeLine">  // bodies).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">927</td>
    <td class="codeLine">  void forgetAllLoops();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">927</td>
    <td class="codeLine">  void forgetAllLoops();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">928</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">928</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">929</td>
    <td class="codeLine">  /// This method should be called by the client when it has changed a loop in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">929</td>
    <td class="codeLine">  /// This method should be called by the client when it has changed a loop in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">930</td>
    <td class="codeLine">  /// a way that may effect ScalarEvolution's ability to compute a trip count,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">930</td>
    <td class="codeLine">  /// a way that may effect ScalarEvolution's ability to compute a trip count,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">931</td>
    <td class="codeLine">  /// or if the loop is deleted.  This call is potentially expensive for large</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">931</td>
    <td class="codeLine">  /// or if the loop is deleted.  This call is potentially expensive for large</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">932</td>
    <td class="codeLine">  /// loop bodies.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">932</td>
    <td class="codeLine">  /// loop bodies.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">933</td>
    <td class="codeLine">  void forgetLoop(const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">933</td>
    <td class="codeLine">  void forgetLoop(const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">934</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">934</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">935</td>
    <td class="codeLine">  // This method invokes forgetLoop for the outermost loop of the given loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">935</td>
    <td class="codeLine">  // This method invokes forgetLoop for the outermost loop of the given loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">936</td>
    <td class="codeLine">  // \p L, making ScalarEvolution forget about all this subtree. This needs to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">936</td>
    <td class="codeLine">  // \p L, making ScalarEvolution forget about all this subtree. This needs to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">937</td>
    <td class="codeLine">  // be done whenever we make a transform that may affect the parameters of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">937</td>
    <td class="codeLine">  // be done whenever we make a transform that may affect the parameters of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">938</td>
    <td class="codeLine">  // outer loop, such as exit counts for branches.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">938</td>
    <td class="codeLine">  // outer loop, such as exit counts for branches.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">939</td>
    <td class="codeLine">  void forgetTopmostLoop(const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">939</td>
    <td class="codeLine">  void forgetTopmostLoop(const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">940</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">941</td>
    <td class="codeLine">  /// This method should be called by the client when it has changed a value</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">941</td>
    <td class="codeLine">  /// This method should be called by the client when it has changed a value</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">942</td>
    <td class="codeLine">  /// in a way that may effect its value, or which may disconnect it from a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">942</td>
    <td class="codeLine">  /// in a way that may effect its value, or which may disconnect it from a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">943</td>
    <td class="codeLine">  /// def-use chain linking it to a loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">943</td>
    <td class="codeLine">  /// def-use chain linking it to a loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">944</td>
    <td class="codeLine">  void forgetValue(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">944</td>
    <td class="codeLine">  void forgetValue(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">945</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">945</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">946</td>
    <td class="codeLine">  /// Called when the client has changed the disposition of values in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">946</td>
    <td class="codeLine">  /// Called when the client has changed the disposition of values in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">947</td>
    <td class="codeLine">  /// this loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">947</td>
    <td class="codeLine">  /// this loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">948</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">948</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">949</td>
    <td class="codeLine">  /// We don't have a way to invalidate per-loop dispositions. Clear and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">949</td>
    <td class="codeLine">  /// We don't have a way to invalidate per-loop dispositions. Clear and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">950</td>
    <td class="codeLine">  /// recompute is simpler.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">950</td>
    <td class="codeLine">  /// recompute is simpler.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">951</td>
    <td class="codeLine">  void forgetLoopDispositions();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">951</td>
    <td class="codeLine">  void forgetLoopDispositions();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">952</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">952</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">953</td>
    <td class="codeLine">  /// Called when the client has changed the disposition of values in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">953</td>
    <td class="codeLine">  /// Called when the client has changed the disposition of values in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">954</td>
    <td class="codeLine">  /// a loop or block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">954</td>
    <td class="codeLine">  /// a loop or block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">955</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">955</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">956</td>
    <td class="codeLine">  /// We don't have a way to invalidate per-loop/per-block dispositions. Clear</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">956</td>
    <td class="codeLine">  /// We don't have a way to invalidate per-loop/per-block dispositions. Clear</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">957</td>
    <td class="codeLine">  /// and recompute is simpler.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">957</td>
    <td class="codeLine">  /// and recompute is simpler.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">958</td>
    <td class="codeLine">  void forgetBlockAndLoopDispositions(Value *V = nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">958</td>
    <td class="codeLine">  void forgetBlockAndLoopDispositions(Value *V = nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">959</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">960</td>
    <td class="codeLine">  /// Determine the minimum number of zero bits that S is guaranteed to end in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">960</td>
    <td class="codeLine">  /// Determine the minimum number of zero bits that S is guaranteed to end in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">961</td>
    <td class="codeLine">  /// (at every loop iteration).  It is, at the same time, the minimum number</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">961</td>
    <td class="codeLine">  /// (at every loop iteration).  It is, at the same time, the minimum number</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">962</td>
    <td class="codeLine">  /// of times S is divisible by 2.  For example, given {4,+,8} it returns 2.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">962</td>
    <td class="codeLine">  /// of times S is divisible by 2.  For example, given {4,+,8} it returns 2.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">963</td>
    <td class="codeLine">  /// If S is guaranteed to be 0, it returns the bitwidth of S.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">963</td>
    <td class="codeLine">  /// If S is guaranteed to be 0, it returns the bitwidth of S.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">964</td>
    <td class="codeLine">  uint32_t getMinTrailingZeros(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">964</td>
    <td class="codeLine">  uint32_t getMinTrailingZeros(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">965</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">966</td>
    <td class="codeLine">  /// Returns the max constant multiple of S.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">966</td>
    <td class="codeLine">  /// Returns the max constant multiple of S.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">967</td>
    <td class="codeLine">  APInt getConstantMultiple(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">967</td>
    <td class="codeLine">  APInt getConstantMultiple(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">968</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">969</td>
    <td class="codeLine">  // Returns the max constant multiple of S. If S is exactly 0, return 1.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">969</td>
    <td class="codeLine">  // Returns the max constant multiple of S. If S is exactly 0, return 1.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">970</td>
    <td class="codeLine">  APInt getNonZeroConstantMultiple(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">970</td>
    <td class="codeLine">  APInt getNonZeroConstantMultiple(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">971</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">971</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">972</td>
    <td class="codeLine">  /// Determine the unsigned range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">972</td>
    <td class="codeLine">  /// Determine the unsigned range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">973</td>
    <td class="codeLine">  /// NOTE: This returns a copy of the reference returned by getRangeRef.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">973</td>
    <td class="codeLine">  /// NOTE: This returns a copy of the reference returned by getRangeRef.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">974</td>
    <td class="codeLine">  ConstantRange getUnsignedRange(const SCEV *S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">974</td>
    <td class="codeLine">  ConstantRange getUnsignedRange(const SCEV *S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">975</td>
    <td class="codeLine">    return getRangeRef(S, HINT_RANGE_UNSIGNED);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">975</td>
    <td class="codeLine">    return getRangeRef(S, HINT_RANGE_UNSIGNED);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">976</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">976</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">977</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">978</td>
    <td class="codeLine">  /// Determine the min of the unsigned range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">978</td>
    <td class="codeLine">  /// Determine the min of the unsigned range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">979</td>
    <td class="codeLine">  APInt getUnsignedRangeMin(const SCEV *S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">979</td>
    <td class="codeLine">  APInt getUnsignedRangeMin(const SCEV *S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">980</td>
    <td class="codeLine">    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">980</td>
    <td class="codeLine">    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">981</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">981</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">982</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">983</td>
    <td class="codeLine">  /// Determine the max of the unsigned range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">983</td>
    <td class="codeLine">  /// Determine the max of the unsigned range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">984</td>
    <td class="codeLine">  APInt getUnsignedRangeMax(const SCEV *S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">984</td>
    <td class="codeLine">  APInt getUnsignedRangeMax(const SCEV *S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">985</td>
    <td class="codeLine">    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMax();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">985</td>
    <td class="codeLine">    return getRangeRef(S, HINT_RANGE_UNSIGNED).getUnsignedMax();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">986</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">986</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">987</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">988</td>
    <td class="codeLine">  /// Determine the signed range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">988</td>
    <td class="codeLine">  /// Determine the signed range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">989</td>
    <td class="codeLine">  /// NOTE: This returns a copy of the reference returned by getRangeRef.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">989</td>
    <td class="codeLine">  /// NOTE: This returns a copy of the reference returned by getRangeRef.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">990</td>
    <td class="codeLine">  ConstantRange getSignedRange(const SCEV *S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">990</td>
    <td class="codeLine">  ConstantRange getSignedRange(const SCEV *S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">991</td>
    <td class="codeLine">    return getRangeRef(S, HINT_RANGE_SIGNED);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">991</td>
    <td class="codeLine">    return getRangeRef(S, HINT_RANGE_SIGNED);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">992</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">992</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">993</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">994</td>
    <td class="codeLine">  /// Determine the min of the signed range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">994</td>
    <td class="codeLine">  /// Determine the min of the signed range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">995</td>
    <td class="codeLine">  APInt getSignedRangeMin(const SCEV *S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">995</td>
    <td class="codeLine">  APInt getSignedRangeMin(const SCEV *S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">996</td>
    <td class="codeLine">    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMin();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">996</td>
    <td class="codeLine">    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMin();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">997</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">997</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">998</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">998</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">999</td>
    <td class="codeLine">  /// Determine the max of the signed range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">999</td>
    <td class="codeLine">  /// Determine the max of the signed range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1000</td>
    <td class="codeLine">  APInt getSignedRangeMax(const SCEV *S) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1000</td>
    <td class="codeLine">  APInt getSignedRangeMax(const SCEV *S) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1001</td>
    <td class="codeLine">    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMax();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1001</td>
    <td class="codeLine">    return getRangeRef(S, HINT_RANGE_SIGNED).getSignedMax();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1002</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1002</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1003</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1003</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1004</td>
    <td class="codeLine">  /// Test if the given expression is known to be negative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1004</td>
    <td class="codeLine">  /// Test if the given expression is known to be negative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1005</td>
    <td class="codeLine">  bool isKnownNegative(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1005</td>
    <td class="codeLine">  bool isKnownNegative(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1006</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1007</td>
    <td class="codeLine">  /// Test if the given expression is known to be positive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1007</td>
    <td class="codeLine">  /// Test if the given expression is known to be positive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1008</td>
    <td class="codeLine">  bool isKnownPositive(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1008</td>
    <td class="codeLine">  bool isKnownPositive(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1010</td>
    <td class="codeLine">  /// Test if the given expression is known to be non-negative.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1010</td>
    <td class="codeLine">  /// Test if the given expression is known to be non-negative.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1011</td>
    <td class="codeLine">  bool isKnownNonNegative(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1011</td>
    <td class="codeLine">  bool isKnownNonNegative(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1012</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1012</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1013</td>
    <td class="codeLine">  /// Test if the given expression is known to be non-positive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1013</td>
    <td class="codeLine">  /// Test if the given expression is known to be non-positive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1014</td>
    <td class="codeLine">  bool isKnownNonPositive(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1014</td>
    <td class="codeLine">  bool isKnownNonPositive(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1015</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1015</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1016</td>
    <td class="codeLine">  /// Test if the given expression is known to be non-zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1016</td>
    <td class="codeLine">  /// Test if the given expression is known to be non-zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1017</td>
    <td class="codeLine">  bool isKnownNonZero(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1017</td>
    <td class="codeLine">  bool isKnownNonZero(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1019</td>
    <td class="codeLine">  /// Splits SCEV expression \p S into two SCEVs. One of them is obtained from</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1019</td>
    <td class="codeLine">  /// Splits SCEV expression \p S into two SCEVs. One of them is obtained from</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1020</td>
    <td class="codeLine">  /// \p S by substitution of all AddRec sub-expression related to loop \p L</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1020</td>
    <td class="codeLine">  /// \p S by substitution of all AddRec sub-expression related to loop \p L</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1021</td>
    <td class="codeLine">  /// with initial value of that SCEV. The second is obtained from \p S by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1021</td>
    <td class="codeLine">  /// with initial value of that SCEV. The second is obtained from \p S by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1022</td>
    <td class="codeLine">  /// substitution of all AddRec sub-expressions related to loop \p L with post</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1022</td>
    <td class="codeLine">  /// substitution of all AddRec sub-expressions related to loop \p L with post</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1023</td>
    <td class="codeLine">  /// increment of this AddRec in the loop \p L. In both cases all other AddRec</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1023</td>
    <td class="codeLine">  /// increment of this AddRec in the loop \p L. In both cases all other AddRec</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1024</td>
    <td class="codeLine">  /// sub-expressions (not related to \p L) remain the same.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1024</td>
    <td class="codeLine">  /// sub-expressions (not related to \p L) remain the same.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1025</td>
    <td class="codeLine">  /// If the \p S contains non-invariant unknown SCEV the function returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1025</td>
    <td class="codeLine">  /// If the \p S contains non-invariant unknown SCEV the function returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1026</td>
    <td class="codeLine">  /// CouldNotCompute SCEV in both values of std::pair.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1026</td>
    <td class="codeLine">  /// CouldNotCompute SCEV in both values of std::pair.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1027</td>
    <td class="codeLine">  /// For example, for SCEV S={0, +, 1}<L1> + {0, +, 1}<L2> and loop L=L1</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1027</td>
    <td class="codeLine">  /// For example, for SCEV S={0, +, 1}<L1> + {0, +, 1}<L2> and loop L=L1</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1028</td>
    <td class="codeLine">  /// the function returns pair:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1028</td>
    <td class="codeLine">  /// the function returns pair:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1029</td>
    <td class="codeLine">  /// first = {0, +, 1}<L2></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1029</td>
    <td class="codeLine">  /// first = {0, +, 1}<L2></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1030</td>
    <td class="codeLine">  /// second = {1, +, 1}<L1> + {0, +, 1}<L2></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1030</td>
    <td class="codeLine">  /// second = {1, +, 1}<L1> + {0, +, 1}<L2></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1031</td>
    <td class="codeLine">  /// We can see that for the first AddRec sub-expression it was replaced with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1031</td>
    <td class="codeLine">  /// We can see that for the first AddRec sub-expression it was replaced with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1032</td>
    <td class="codeLine">  /// 0 (initial value) for the first element and to {1, +, 1}<L1> (post</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1032</td>
    <td class="codeLine">  /// 0 (initial value) for the first element and to {1, +, 1}<L1> (post</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1033</td>
    <td class="codeLine">  /// increment value) for the second one. In both cases AddRec expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1033</td>
    <td class="codeLine">  /// increment value) for the second one. In both cases AddRec expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1034</td>
    <td class="codeLine">  /// related to L2 remains the same.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1034</td>
    <td class="codeLine">  /// related to L2 remains the same.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1035</td>
    <td class="codeLine">  std::pair<const SCEV *, const SCEV *> SplitIntoInitAndPostInc(const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1035</td>
    <td class="codeLine">  std::pair<const SCEV *, const SCEV *> SplitIntoInitAndPostInc(const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1036</td>
    <td class="codeLine">                                                                const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1036</td>
    <td class="codeLine">                                                                const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1037</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1037</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1038</td>
    <td class="codeLine">  /// We'd like to check the predicate on every iteration of the most dominated</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1038</td>
    <td class="codeLine">  /// We'd like to check the predicate on every iteration of the most dominated</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1039</td>
    <td class="codeLine">  /// loop between loops used in LHS and RHS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1039</td>
    <td class="codeLine">  /// loop between loops used in LHS and RHS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1040</td>
    <td class="codeLine">  /// To do this we use the following list of steps:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1040</td>
    <td class="codeLine">  /// To do this we use the following list of steps:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1041</td>
    <td class="codeLine">  /// 1. Collect set S all loops on which either LHS or RHS depend.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1041</td>
    <td class="codeLine">  /// 1. Collect set S all loops on which either LHS or RHS depend.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1042</td>
    <td class="codeLine">  /// 2. If S is non-empty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1042</td>
    <td class="codeLine">  /// 2. If S is non-empty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1043</td>
    <td class="codeLine">  /// a. Let PD be the element of S which is dominated by all other elements.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1043</td>
    <td class="codeLine">  /// a. Let PD be the element of S which is dominated by all other elements.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1044</td>
    <td class="codeLine">  /// b. Let E(LHS) be value of LHS on entry of PD.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1044</td>
    <td class="codeLine">  /// b. Let E(LHS) be value of LHS on entry of PD.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1045</td>
    <td class="codeLine">  ///    To get E(LHS), we should just take LHS and replace all AddRecs that are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1045</td>
    <td class="codeLine">  ///    To get E(LHS), we should just take LHS and replace all AddRecs that are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1046</td>
    <td class="codeLine">  ///    attached to PD on with their entry values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1046</td>
    <td class="codeLine">  ///    attached to PD on with their entry values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1047</td>
    <td class="codeLine">  ///    Define E(RHS) in the same way.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1047</td>
    <td class="codeLine">  ///    Define E(RHS) in the same way.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1048</td>
    <td class="codeLine">  /// c. Let B(LHS) be value of L on backedge of PD.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1048</td>
    <td class="codeLine">  /// c. Let B(LHS) be value of L on backedge of PD.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1049</td>
    <td class="codeLine">  ///    To get B(LHS), we should just take LHS and replace all AddRecs that are</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1049</td>
    <td class="codeLine">  ///    To get B(LHS), we should just take LHS and replace all AddRecs that are</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1050</td>
    <td class="codeLine">  ///    attached to PD on with their backedge values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1050</td>
    <td class="codeLine">  ///    attached to PD on with their backedge values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1051</td>
    <td class="codeLine">  ///    Define B(RHS) in the same way.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1051</td>
    <td class="codeLine">  ///    Define B(RHS) in the same way.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1052</td>
    <td class="codeLine">  /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1052</td>
    <td class="codeLine">  /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1053</td>
    <td class="codeLine">  ///    so we can assert on that.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1053</td>
    <td class="codeLine">  ///    so we can assert on that.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1054</td>
    <td class="codeLine">  /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1054</td>
    <td class="codeLine">  /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1055</td>
    <td class="codeLine">  ///                   isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1055</td>
    <td class="codeLine">  ///                   isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1056</td>
    <td class="codeLine">  bool isKnownViaInduction(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1056</td>
    <td class="codeLine">  bool isKnownViaInduction(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1057</td>
    <td class="codeLine">                           const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1057</td>
    <td class="codeLine">                           const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1058</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1059</td>
    <td class="codeLine">  /// Test if the given expression is known to satisfy the condition described</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1059</td>
    <td class="codeLine">  /// Test if the given expression is known to satisfy the condition described</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1060</td>
    <td class="codeLine">  /// by Pred, LHS, and RHS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1060</td>
    <td class="codeLine">  /// by Pred, LHS, and RHS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1061</td>
    <td class="codeLine">  bool isKnownPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1061</td>
    <td class="codeLine">  bool isKnownPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1062</td>
    <td class="codeLine">                        const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1062</td>
    <td class="codeLine">                        const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1064</td>
    <td class="codeLine">  /// Check whether the condition described by Pred, LHS, and RHS is true or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1064</td>
    <td class="codeLine">  /// Check whether the condition described by Pred, LHS, and RHS is true or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1065</td>
    <td class="codeLine">  /// false. If we know it, return the evaluation of this condition. If neither</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1065</td>
    <td class="codeLine">  /// false. If we know it, return the evaluation of this condition. If neither</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1066</td>
    <td class="codeLine">  /// is proved, return std::nullopt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1066</td>
    <td class="codeLine">  /// is proved, return std::nullopt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1067</td>
    <td class="codeLine">  std::optional<bool> evaluatePredicate(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1067</td>
    <td class="codeLine">  std::optional<bool> evaluatePredicate(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1068</td>
    <td class="codeLine">                                        const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1068</td>
    <td class="codeLine">                                        const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1069</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1070</td>
    <td class="codeLine">  /// Test if the given expression is known to satisfy the condition described</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1070</td>
    <td class="codeLine">  /// Test if the given expression is known to satisfy the condition described</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1071</td>
    <td class="codeLine">  /// by Pred, LHS, and RHS in the given Context.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1071</td>
    <td class="codeLine">  /// by Pred, LHS, and RHS in the given Context.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1072</td>
    <td class="codeLine">  bool isKnownPredicateAt(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1072</td>
    <td class="codeLine">  bool isKnownPredicateAt(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1073</td>
    <td class="codeLine">                          const SCEV *RHS, const Instruction *CtxI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1073</td>
    <td class="codeLine">                          const SCEV *RHS, const Instruction *CtxI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1074</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1075</td>
    <td class="codeLine">  /// Check whether the condition described by Pred, LHS, and RHS is true or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1075</td>
    <td class="codeLine">  /// Check whether the condition described by Pred, LHS, and RHS is true or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1076</td>
    <td class="codeLine">  /// false in the given \p Context. If we know it, return the evaluation of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1076</td>
    <td class="codeLine">  /// false in the given \p Context. If we know it, return the evaluation of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1077</td>
    <td class="codeLine">  /// this condition. If neither is proved, return std::nullopt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1077</td>
    <td class="codeLine">  /// this condition. If neither is proved, return std::nullopt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1078</td>
    <td class="codeLine">  std::optional<bool> evaluatePredicateAt(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1078</td>
    <td class="codeLine">  std::optional<bool> evaluatePredicateAt(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1079</td>
    <td class="codeLine">                                          const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1079</td>
    <td class="codeLine">                                          const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1080</td>
    <td class="codeLine">                                          const Instruction *CtxI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1080</td>
    <td class="codeLine">                                          const Instruction *CtxI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1081</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1082</td>
    <td class="codeLine">  /// Test if the condition described by Pred, LHS, RHS is known to be true on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1082</td>
    <td class="codeLine">  /// Test if the condition described by Pred, LHS, RHS is known to be true on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1083</td>
    <td class="codeLine">  /// every iteration of the loop of the recurrency LHS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1083</td>
    <td class="codeLine">  /// every iteration of the loop of the recurrency LHS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1084</td>
    <td class="codeLine">  bool isKnownOnEveryIteration(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1084</td>
    <td class="codeLine">  bool isKnownOnEveryIteration(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1085</td>
    <td class="codeLine">                               const SCEVAddRecExpr *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1085</td>
    <td class="codeLine">                               const SCEVAddRecExpr *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1086</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1086</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1087</td>
    <td class="codeLine">  /// Information about the number of loop iterations for which a loop exit's</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1087</td>
    <td class="codeLine">  /// Information about the number of loop iterations for which a loop exit's</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1088</td>
    <td class="codeLine">  /// branch condition evaluates to the not-taken path.  This is a temporary</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1088</td>
    <td class="codeLine">  /// branch condition evaluates to the not-taken path.  This is a temporary</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1089</td>
    <td class="codeLine">  /// pair of exact and max expressions that are eventually summarized in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1089</td>
    <td class="codeLine">  /// pair of exact and max expressions that are eventually summarized in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1090</td>
    <td class="codeLine">  /// ExitNotTakenInfo and BackedgeTakenInfo.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1090</td>
    <td class="codeLine">  /// ExitNotTakenInfo and BackedgeTakenInfo.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1091</td>
    <td class="codeLine">  struct ExitLimit {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1091</td>
    <td class="codeLine">  struct ExitLimit {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1092</td>
    <td class="codeLine">    const SCEV *ExactNotTaken; // The exit is not taken exactly this many times</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1092</td>
    <td class="codeLine">    const SCEV *ExactNotTaken; // The exit is not taken exactly this many times</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1093</td>
    <td class="codeLine">    const SCEV *ConstantMaxNotTaken; // The exit is not taken at most this many</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1093</td>
    <td class="codeLine">    const SCEV *ConstantMaxNotTaken; // The exit is not taken at most this many</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1094</td>
    <td class="codeLine">                                     // times</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1094</td>
    <td class="codeLine">                                     // times</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1095</td>
    <td class="codeLine">    const SCEV *SymbolicMaxNotTaken;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1095</td>
    <td class="codeLine">    const SCEV *SymbolicMaxNotTaken;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1096</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1097</td>
    <td class="codeLine">    // Not taken either exactly ConstantMaxNotTaken or zero times</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1097</td>
    <td class="codeLine">    // Not taken either exactly ConstantMaxNotTaken or zero times</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1098</td>
    <td class="codeLine">    bool MaxOrZero = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1098</td>
    <td class="codeLine">    bool MaxOrZero = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1099</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1100</td>
    <td class="codeLine">    /// A set of predicate guards for this ExitLimit. The result is only valid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1100</td>
    <td class="codeLine">    /// A set of predicate guards for this ExitLimit. The result is only valid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1101</td>
    <td class="codeLine">    /// if all of the predicates in \c Predicates evaluate to 'true' at</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1101</td>
    <td class="codeLine">    /// if all of the predicates in \c Predicates evaluate to 'true' at</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1102</td>
    <td class="codeLine">    /// run-time.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1102</td>
    <td class="codeLine">    /// run-time.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1103</td>
    <td class="codeLine">    SmallPtrSet<const SCEVPredicate *, 4> Predicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1103</td>
    <td class="codeLine">    SmallPtrSet<const SCEVPredicate *, 4> Predicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1104</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1105</td>
    <td class="codeLine">    void addPredicate(const SCEVPredicate *P) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1105</td>
    <td class="codeLine">    void addPredicate(const SCEVPredicate *P) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1106</td>
    <td class="codeLine">      assert(!isa<SCEVUnionPredicate>(P) && "Only add leaf predicates here!");</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1106</td>
    <td class="codeLine">      assert(!isa<SCEVUnionPredicate>(P) && "Only add leaf predicates here!");</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1107</td>
    <td class="codeLine">      Predicates.insert(P);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1107</td>
    <td class="codeLine">      Predicates.insert(P);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1108</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1108</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1109</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1110</td>
    <td class="codeLine">    /// Construct either an exact exit limit from a constant, or an unknown</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1110</td>
    <td class="codeLine">    /// Construct either an exact exit limit from a constant, or an unknown</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1111</td>
    <td class="codeLine">    /// one from a SCEVCouldNotCompute.  No other types of SCEVs are allowed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1111</td>
    <td class="codeLine">    /// one from a SCEVCouldNotCompute.  No other types of SCEVs are allowed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1112</td>
    <td class="codeLine">    /// as arguments and asserts enforce that internally.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1112</td>
    <td class="codeLine">    /// as arguments and asserts enforce that internally.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1113</td>
    <td class="codeLine">    /*implicit*/ ExitLimit(const SCEV *E);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1113</td>
    <td class="codeLine">    /*implicit*/ ExitLimit(const SCEV *E);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1114</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1115</td>
    <td class="codeLine">    ExitLimit(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1115</td>
    <td class="codeLine">    ExitLimit(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1116</td>
    <td class="codeLine">        const SCEV *E, const SCEV *ConstantMaxNotTaken,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1116</td>
    <td class="codeLine">        const SCEV *E, const SCEV *ConstantMaxNotTaken,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1117</td>
    <td class="codeLine">        const SCEV *SymbolicMaxNotTaken, bool MaxOrZero,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1117</td>
    <td class="codeLine">        const SCEV *SymbolicMaxNotTaken, bool MaxOrZero,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1118</td>
    <td class="codeLine">        ArrayRef<const SmallPtrSetImpl<const SCEVPredicate *> *> PredSetList =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1118</td>
    <td class="codeLine">        ArrayRef<const SmallPtrSetImpl<const SCEVPredicate *> *> PredSetList =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1119</td>
    <td class="codeLine">            std::nullopt);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1119</td>
    <td class="codeLine">            std::nullopt);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1120</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1121</td>
    <td class="codeLine">    ExitLimit(const SCEV *E, const SCEV *ConstantMaxNotTaken,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1121</td>
    <td class="codeLine">    ExitLimit(const SCEV *E, const SCEV *ConstantMaxNotTaken,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1122</td>
    <td class="codeLine">              const SCEV *SymbolicMaxNotTaken, bool MaxOrZero,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1122</td>
    <td class="codeLine">              const SCEV *SymbolicMaxNotTaken, bool MaxOrZero,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1123</td>
    <td class="codeLine">              const SmallPtrSetImpl<const SCEVPredicate *> &PredSet);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1123</td>
    <td class="codeLine">              const SmallPtrSetImpl<const SCEVPredicate *> &PredSet);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1124</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1125</td>
    <td class="codeLine">    /// Test whether this ExitLimit contains any computed information, or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1125</td>
    <td class="codeLine">    /// Test whether this ExitLimit contains any computed information, or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1126</td>
    <td class="codeLine">    /// whether it's all SCEVCouldNotCompute values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1126</td>
    <td class="codeLine">    /// whether it's all SCEVCouldNotCompute values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1127</td>
    <td class="codeLine">    bool hasAnyInfo() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1127</td>
    <td class="codeLine">    bool hasAnyInfo() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1128</td>
    <td class="codeLine">      return !isa<SCEVCouldNotCompute>(ExactNotTaken) ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1128</td>
    <td class="codeLine">      return !isa<SCEVCouldNotCompute>(ExactNotTaken) ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1129</td>
    <td class="codeLine">             !isa<SCEVCouldNotCompute>(ConstantMaxNotTaken);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1129</td>
    <td class="codeLine">             !isa<SCEVCouldNotCompute>(ConstantMaxNotTaken);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1130</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1130</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1131</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1132</td>
    <td class="codeLine">    /// Test whether this ExitLimit contains all information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1132</td>
    <td class="codeLine">    /// Test whether this ExitLimit contains all information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1133</td>
    <td class="codeLine">    bool hasFullInfo() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1133</td>
    <td class="codeLine">    bool hasFullInfo() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1134</td>
    <td class="codeLine">      return !isa<SCEVCouldNotCompute>(ExactNotTaken);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1134</td>
    <td class="codeLine">      return !isa<SCEVCouldNotCompute>(ExactNotTaken);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1135</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1135</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1136</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1136</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1137</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1138</td>
    <td class="codeLine">  /// Compute the number of times the backedge of the specified loop will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1138</td>
    <td class="codeLine">  /// Compute the number of times the backedge of the specified loop will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1139</td>
    <td class="codeLine">  /// execute if its exit condition were a conditional branch of ExitCond.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1139</td>
    <td class="codeLine">  /// execute if its exit condition were a conditional branch of ExitCond.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1140</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1140</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1141</td>
    <td class="codeLine">  /// \p ControlsOnlyExit is true if ExitCond directly controls the only exit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1141</td>
    <td class="codeLine">  /// \p ControlsOnlyExit is true if ExitCond directly controls the only exit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1142</td>
    <td class="codeLine">  /// branch. In this case, we can assume that the loop exits only if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1142</td>
    <td class="codeLine">  /// branch. In this case, we can assume that the loop exits only if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1143</td>
    <td class="codeLine">  /// condition is true and can infer that failing to meet the condition prior</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1143</td>
    <td class="codeLine">  /// condition is true and can infer that failing to meet the condition prior</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1144</td>
    <td class="codeLine">  /// to integer wraparound results in undefined behavior.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1144</td>
    <td class="codeLine">  /// to integer wraparound results in undefined behavior.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1145</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1145</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1146</td>
    <td class="codeLine">  /// If \p AllowPredicates is set, this call will try to use a minimal set of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1146</td>
    <td class="codeLine">  /// If \p AllowPredicates is set, this call will try to use a minimal set of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1147</td>
    <td class="codeLine">  /// SCEV predicates in order to return an exact answer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1147</td>
    <td class="codeLine">  /// SCEV predicates in order to return an exact answer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1148</td>
    <td class="codeLine">  ExitLimit computeExitLimitFromCond(const Loop *L, Value *ExitCond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1148</td>
    <td class="codeLine">  ExitLimit computeExitLimitFromCond(const Loop *L, Value *ExitCond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1149</td>
    <td class="codeLine">                                     bool ExitIfTrue, bool ControlsOnlyExit,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1149</td>
    <td class="codeLine">                                     bool ExitIfTrue, bool ControlsOnlyExit,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1150</td>
    <td class="codeLine">                                     bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1150</td>
    <td class="codeLine">                                     bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1151</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1152</td>
    <td class="codeLine">  /// A predicate is said to be monotonically increasing if may go from being</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1152</td>
    <td class="codeLine">  /// A predicate is said to be monotonically increasing if may go from being</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1153</td>
    <td class="codeLine">  /// false to being true as the loop iterates, but never the other way</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1153</td>
    <td class="codeLine">  /// false to being true as the loop iterates, but never the other way</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1154</td>
    <td class="codeLine">  /// around.  A predicate is said to be monotonically decreasing if may go</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1154</td>
    <td class="codeLine">  /// around.  A predicate is said to be monotonically decreasing if may go</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1155</td>
    <td class="codeLine">  /// from being true to being false as the loop iterates, but never the other</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1155</td>
    <td class="codeLine">  /// from being true to being false as the loop iterates, but never the other</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1156</td>
    <td class="codeLine">  /// way around.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1156</td>
    <td class="codeLine">  /// way around.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1157</td>
    <td class="codeLine">  enum MonotonicPredicateType {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1157</td>
    <td class="codeLine">  enum MonotonicPredicateType {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1158</td>
    <td class="codeLine">    MonotonicallyIncreasing,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1158</td>
    <td class="codeLine">    MonotonicallyIncreasing,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1159</td>
    <td class="codeLine">    MonotonicallyDecreasing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1159</td>
    <td class="codeLine">    MonotonicallyDecreasing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1160</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1160</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1162</td>
    <td class="codeLine">  /// If, for all loop invariant X, the predicate "LHS `Pred` X" is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1162</td>
    <td class="codeLine">  /// If, for all loop invariant X, the predicate "LHS `Pred` X" is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1163</td>
    <td class="codeLine">  /// monotonically increasing or decreasing, returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1163</td>
    <td class="codeLine">  /// monotonically increasing or decreasing, returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1164</td>
    <td class="codeLine">  /// Some(MonotonicallyIncreasing) and Some(MonotonicallyDecreasing)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1164</td>
    <td class="codeLine">  /// Some(MonotonicallyIncreasing) and Some(MonotonicallyDecreasing)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1165</td>
    <td class="codeLine">  /// respectively. If we could not prove either of these facts, returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1165</td>
    <td class="codeLine">  /// respectively. If we could not prove either of these facts, returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1166</td>
    <td class="codeLine">  /// std::nullopt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1166</td>
    <td class="codeLine">  /// std::nullopt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1167</td>
    <td class="codeLine">  std::optional<MonotonicPredicateType></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1167</td>
    <td class="codeLine">  std::optional<MonotonicPredicateType></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1168</td>
    <td class="codeLine">  getMonotonicPredicateType(const SCEVAddRecExpr *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1168</td>
    <td class="codeLine">  getMonotonicPredicateType(const SCEVAddRecExpr *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1169</td>
    <td class="codeLine">                            ICmpInst::Predicate Pred);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1169</td>
    <td class="codeLine">                            ICmpInst::Predicate Pred);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1170</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1171</td>
    <td class="codeLine">  struct LoopInvariantPredicate {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1171</td>
    <td class="codeLine">  struct LoopInvariantPredicate {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1172</td>
    <td class="codeLine">    ICmpInst::Predicate Pred;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1172</td>
    <td class="codeLine">    ICmpInst::Predicate Pred;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1173</td>
    <td class="codeLine">    const SCEV *LHS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1173</td>
    <td class="codeLine">    const SCEV *LHS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1174</td>
    <td class="codeLine">    const SCEV *RHS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1174</td>
    <td class="codeLine">    const SCEV *RHS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1175</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1176</td>
    <td class="codeLine">    LoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1176</td>
    <td class="codeLine">    LoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1177</td>
    <td class="codeLine">                           const SCEV *RHS)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1177</td>
    <td class="codeLine">                           const SCEV *RHS)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1178</td>
    <td class="codeLine">        : Pred(Pred), LHS(LHS), RHS(RHS) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1178</td>
    <td class="codeLine">        : Pred(Pred), LHS(LHS), RHS(RHS) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1179</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1179</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1180</td>
    <td class="codeLine">  /// If the result of the predicate LHS `Pred` RHS is loop invariant with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1180</td>
    <td class="codeLine">  /// If the result of the predicate LHS `Pred` RHS is loop invariant with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1181</td>
    <td class="codeLine">  /// respect to L, return a LoopInvariantPredicate with LHS and RHS being</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1181</td>
    <td class="codeLine">  /// respect to L, return a LoopInvariantPredicate with LHS and RHS being</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1182</td>
    <td class="codeLine">  /// invariants, available at L's entry. Otherwise, return std::nullopt.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1182</td>
    <td class="codeLine">  /// invariants, available at L's entry. Otherwise, return std::nullopt.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1183</td>
    <td class="codeLine">  std::optional<LoopInvariantPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1183</td>
    <td class="codeLine">  std::optional<LoopInvariantPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1184</td>
    <td class="codeLine">  getLoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1184</td>
    <td class="codeLine">  getLoopInvariantPredicate(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1185</td>
    <td class="codeLine">                            const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1185</td>
    <td class="codeLine">                            const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1186</td>
    <td class="codeLine">                            const Instruction *CtxI = nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1186</td>
    <td class="codeLine">                            const Instruction *CtxI = nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1187</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1188</td>
    <td class="codeLine">  /// If the result of the predicate LHS `Pred` RHS is loop invariant with</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1188</td>
    <td class="codeLine">  /// If the result of the predicate LHS `Pred` RHS is loop invariant with</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1189</td>
    <td class="codeLine">  /// respect to L at given Context during at least first MaxIter iterations,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1189</td>
    <td class="codeLine">  /// respect to L at given Context during at least first MaxIter iterations,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1190</td>
    <td class="codeLine">  /// return a LoopInvariantPredicate with LHS and RHS being invariants,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1190</td>
    <td class="codeLine">  /// return a LoopInvariantPredicate with LHS and RHS being invariants,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1191</td>
    <td class="codeLine">  /// available at L's entry. Otherwise, return std::nullopt. The predicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1191</td>
    <td class="codeLine">  /// available at L's entry. Otherwise, return std::nullopt. The predicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1192</td>
    <td class="codeLine">  /// should be the loop's exit condition.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1192</td>
    <td class="codeLine">  /// should be the loop's exit condition.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1193</td>
    <td class="codeLine">  std::optional<LoopInvariantPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1193</td>
    <td class="codeLine">  std::optional<LoopInvariantPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1194</td>
    <td class="codeLine">  getLoopInvariantExitCondDuringFirstIterations(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1194</td>
    <td class="codeLine">  getLoopInvariantExitCondDuringFirstIterations(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1195</td>
    <td class="codeLine">                                                const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1195</td>
    <td class="codeLine">                                                const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1196</td>
    <td class="codeLine">                                                const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1196</td>
    <td class="codeLine">                                                const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1197</td>
    <td class="codeLine">                                                const Instruction *CtxI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1197</td>
    <td class="codeLine">                                                const Instruction *CtxI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1198</td>
    <td class="codeLine">                                                const SCEV *MaxIter);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1198</td>
    <td class="codeLine">                                                const SCEV *MaxIter);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1199</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1200</td>
    <td class="codeLine">  std::optional<LoopInvariantPredicate></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1200</td>
    <td class="codeLine">  std::optional<LoopInvariantPredicate></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1201</td>
    <td class="codeLine">  getLoopInvariantExitCondDuringFirstIterationsImpl(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1201</td>
    <td class="codeLine">  getLoopInvariantExitCondDuringFirstIterationsImpl(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1202</td>
    <td class="codeLine">      ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1202</td>
    <td class="codeLine">      ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1203</td>
    <td class="codeLine">      const Instruction *CtxI, const SCEV *MaxIter);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1203</td>
    <td class="codeLine">      const Instruction *CtxI, const SCEV *MaxIter);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1205</td>
    <td class="codeLine">  /// Simplify LHS and RHS in a comparison with predicate Pred. Return true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1205</td>
    <td class="codeLine">  /// Simplify LHS and RHS in a comparison with predicate Pred. Return true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1206</td>
    <td class="codeLine">  /// iff any changes were made. If the operands are provably equal or</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1206</td>
    <td class="codeLine">  /// iff any changes were made. If the operands are provably equal or</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1207</td>
    <td class="codeLine">  /// unequal, LHS and RHS are set to the same value and Pred is set to either</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1207</td>
    <td class="codeLine">  /// unequal, LHS and RHS are set to the same value and Pred is set to either</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1208</td>
    <td class="codeLine">  /// ICMP_EQ or ICMP_NE.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1208</td>
    <td class="codeLine">  /// ICMP_EQ or ICMP_NE.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1209</td>
    <td class="codeLine">  bool SimplifyICmpOperands(ICmpInst::Predicate &Pred, const SCEV *&LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1209</td>
    <td class="codeLine">  bool SimplifyICmpOperands(ICmpInst::Predicate &Pred, const SCEV *&LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1210</td>
    <td class="codeLine">                            const SCEV *&RHS, unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1210</td>
    <td class="codeLine">                            const SCEV *&RHS, unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1211</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1212</td>
    <td class="codeLine">  /// Return the "disposition" of the given SCEV with respect to the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1212</td>
    <td class="codeLine">  /// Return the "disposition" of the given SCEV with respect to the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1213</td>
    <td class="codeLine">  /// loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1213</td>
    <td class="codeLine">  /// loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1214</td>
    <td class="codeLine">  LoopDisposition getLoopDisposition(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1214</td>
    <td class="codeLine">  LoopDisposition getLoopDisposition(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1215</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1216</td>
    <td class="codeLine">  /// Return true if the value of the given SCEV is unchanging in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1216</td>
    <td class="codeLine">  /// Return true if the value of the given SCEV is unchanging in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1217</td>
    <td class="codeLine">  /// specified loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1217</td>
    <td class="codeLine">  /// specified loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1218</td>
    <td class="codeLine">  bool isLoopInvariant(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1218</td>
    <td class="codeLine">  bool isLoopInvariant(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1219</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1220</td>
    <td class="codeLine">  /// Determine if the SCEV can be evaluated at loop's entry. It is true if it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1220</td>
    <td class="codeLine">  /// Determine if the SCEV can be evaluated at loop's entry. It is true if it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1221</td>
    <td class="codeLine">  /// doesn't depend on a SCEVUnknown of an instruction which is dominated by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1221</td>
    <td class="codeLine">  /// doesn't depend on a SCEVUnknown of an instruction which is dominated by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1222</td>
    <td class="codeLine">  /// the header of loop L.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1222</td>
    <td class="codeLine">  /// the header of loop L.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1223</td>
    <td class="codeLine">  bool isAvailableAtLoopEntry(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1223</td>
    <td class="codeLine">  bool isAvailableAtLoopEntry(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1224</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1225</td>
    <td class="codeLine">  /// Return true if the given SCEV changes value in a known way in the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1225</td>
    <td class="codeLine">  /// Return true if the given SCEV changes value in a known way in the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1226</td>
    <td class="codeLine">  /// specified loop.  This property being true implies that the value is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1226</td>
    <td class="codeLine">  /// specified loop.  This property being true implies that the value is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1227</td>
    <td class="codeLine">  /// variant in the loop AND that we can emit an expression to compute the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1227</td>
    <td class="codeLine">  /// variant in the loop AND that we can emit an expression to compute the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1228</td>
    <td class="codeLine">  /// value of the expression at any particular loop iteration.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1228</td>
    <td class="codeLine">  /// value of the expression at any particular loop iteration.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1229</td>
    <td class="codeLine">  bool hasComputableLoopEvolution(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1229</td>
    <td class="codeLine">  bool hasComputableLoopEvolution(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1230</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1231</td>
    <td class="codeLine">  /// Return the "disposition" of the given SCEV with respect to the given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1231</td>
    <td class="codeLine">  /// Return the "disposition" of the given SCEV with respect to the given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1232</td>
    <td class="codeLine">  /// block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1232</td>
    <td class="codeLine">  /// block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1233</td>
    <td class="codeLine">  BlockDisposition getBlockDisposition(const SCEV *S, const BasicBlock *BB);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1233</td>
    <td class="codeLine">  BlockDisposition getBlockDisposition(const SCEV *S, const BasicBlock *BB);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1234</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1235</td>
    <td class="codeLine">  /// Return true if elements that makes up the given SCEV dominate the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1235</td>
    <td class="codeLine">  /// Return true if elements that makes up the given SCEV dominate the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1236</td>
    <td class="codeLine">  /// specified basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1236</td>
    <td class="codeLine">  /// specified basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1237</td>
    <td class="codeLine">  bool dominates(const SCEV *S, const BasicBlock *BB);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1237</td>
    <td class="codeLine">  bool dominates(const SCEV *S, const BasicBlock *BB);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1239</td>
    <td class="codeLine">  /// Return true if elements that makes up the given SCEV properly dominate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1239</td>
    <td class="codeLine">  /// Return true if elements that makes up the given SCEV properly dominate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1240</td>
    <td class="codeLine">  /// the specified basic block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1240</td>
    <td class="codeLine">  /// the specified basic block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1241</td>
    <td class="codeLine">  bool properlyDominates(const SCEV *S, const BasicBlock *BB);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1241</td>
    <td class="codeLine">  bool properlyDominates(const SCEV *S, const BasicBlock *BB);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1242</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1243</td>
    <td class="codeLine">  /// Test whether the given SCEV has Op as a direct or indirect operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1243</td>
    <td class="codeLine">  /// Test whether the given SCEV has Op as a direct or indirect operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1244</td>
    <td class="codeLine">  bool hasOperand(const SCEV *S, const SCEV *Op) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1244</td>
    <td class="codeLine">  bool hasOperand(const SCEV *S, const SCEV *Op) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1245</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1246</td>
    <td class="codeLine">  /// Return the size of an element read or written by Inst.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1246</td>
    <td class="codeLine">  /// Return the size of an element read or written by Inst.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1247</td>
    <td class="codeLine">  const SCEV *getElementSize(Instruction *Inst);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1247</td>
    <td class="codeLine">  const SCEV *getElementSize(Instruction *Inst);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1248</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1249</td>
    <td class="codeLine">  void print(raw_ostream &OS) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1249</td>
    <td class="codeLine">  void print(raw_ostream &OS) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1250</td>
    <td class="codeLine">  void verify() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1250</td>
    <td class="codeLine">  void verify() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1251</td>
    <td class="codeLine">  bool invalidate(Function &F, const PreservedAnalyses &PA,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1251</td>
    <td class="codeLine">  bool invalidate(Function &F, const PreservedAnalyses &PA,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1252</td>
    <td class="codeLine">                  FunctionAnalysisManager::Invalidator &Inv);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1252</td>
    <td class="codeLine">                  FunctionAnalysisManager::Invalidator &Inv);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1253</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1254</td>
    <td class="codeLine">  /// Return the DataLayout associated with the module this SCEV instance is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1254</td>
    <td class="codeLine">  /// Return the DataLayout associated with the module this SCEV instance is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1255</td>
    <td class="codeLine">  /// operating on.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1255</td>
    <td class="codeLine">  /// operating on.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1256</td>
    <td class="codeLine">  const DataLayout &getDataLayout() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1256</td>
    <td class="codeLine">  const DataLayout &getDataLayout() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1257</td>
    <td class="codeLine">    return F.getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1257</td>
    <td class="codeLine">    return F.getParent()->getDataLayout();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1258</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1258</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1259</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1260</td>
    <td class="codeLine">  const SCEVPredicate *getEqualPredicate(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1260</td>
    <td class="codeLine">  const SCEVPredicate *getEqualPredicate(const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1261</td>
    <td class="codeLine">  const SCEVPredicate *getComparePredicate(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1261</td>
    <td class="codeLine">  const SCEVPredicate *getComparePredicate(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1262</td>
    <td class="codeLine">                                           const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1262</td>
    <td class="codeLine">                                           const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1263</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1264</td>
    <td class="codeLine">  const SCEVPredicate *</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1264</td>
    <td class="codeLine">  const SCEVPredicate *</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1265</td>
    <td class="codeLine">  getWrapPredicate(const SCEVAddRecExpr *AR,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1265</td>
    <td class="codeLine">  getWrapPredicate(const SCEVAddRecExpr *AR,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1266</td>
    <td class="codeLine">                   SCEVWrapPredicate::IncrementWrapFlags AddedFlags);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1266</td>
    <td class="codeLine">                   SCEVWrapPredicate::IncrementWrapFlags AddedFlags);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1268</td>
    <td class="codeLine">  /// Re-writes the SCEV according to the Predicates in \p A.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1268</td>
    <td class="codeLine">  /// Re-writes the SCEV according to the Predicates in \p A.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1269</td>
    <td class="codeLine">  const SCEV *rewriteUsingPredicate(const SCEV *S, const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1269</td>
    <td class="codeLine">  const SCEV *rewriteUsingPredicate(const SCEV *S, const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1270</td>
    <td class="codeLine">                                    const SCEVPredicate &A);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1270</td>
    <td class="codeLine">                                    const SCEVPredicate &A);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1271</td>
    <td class="codeLine">  /// Tries to convert the \p S expression to an AddRec expression,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1271</td>
    <td class="codeLine">  /// Tries to convert the \p S expression to an AddRec expression,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1272</td>
    <td class="codeLine">  /// adding additional predicates to \p Preds as required.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1272</td>
    <td class="codeLine">  /// adding additional predicates to \p Preds as required.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1273</td>
    <td class="codeLine">  const SCEVAddRecExpr *convertSCEVToAddRecWithPredicates(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1273</td>
    <td class="codeLine">  const SCEVAddRecExpr *convertSCEVToAddRecWithPredicates(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1274</td>
    <td class="codeLine">      const SCEV *S, const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1274</td>
    <td class="codeLine">      const SCEV *S, const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1275</td>
    <td class="codeLine">      SmallPtrSetImpl<const SCEVPredicate *> &Preds);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1275</td>
    <td class="codeLine">      SmallPtrSetImpl<const SCEVPredicate *> &Preds);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1276</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1277</td>
    <td class="codeLine">  /// Compute \p LHS - \p RHS and returns the result as an APInt if it is a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1277</td>
    <td class="codeLine">  /// Compute \p LHS - \p RHS and returns the result as an APInt if it is a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1278</td>
    <td class="codeLine">  /// constant, and std::nullopt if it isn't.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1278</td>
    <td class="codeLine">  /// constant, and std::nullopt if it isn't.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1279</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1279</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1280</td>
    <td class="codeLine">  /// This is intended to be a cheaper version of getMinusSCEV.  We can be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1280</td>
    <td class="codeLine">  /// This is intended to be a cheaper version of getMinusSCEV.  We can be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1281</td>
    <td class="codeLine">  /// frugal here since we just bail out of actually constructing and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1281</td>
    <td class="codeLine">  /// frugal here since we just bail out of actually constructing and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1282</td>
    <td class="codeLine">  /// canonicalizing an expression in the cases where the result isn't going</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1282</td>
    <td class="codeLine">  /// canonicalizing an expression in the cases where the result isn't going</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1283</td>
    <td class="codeLine">  /// to be a constant.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1283</td>
    <td class="codeLine">  /// to be a constant.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1284</td>
    <td class="codeLine">  std::optional<APInt> computeConstantDifference(const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1284</td>
    <td class="codeLine">  std::optional<APInt> computeConstantDifference(const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1285</td>
    <td class="codeLine">                                                 const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1285</td>
    <td class="codeLine">                                                 const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1287</td>
    <td class="codeLine">  /// Update no-wrap flags of an AddRec. This may drop the cached info about</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1287</td>
    <td class="codeLine">  /// Update no-wrap flags of an AddRec. This may drop the cached info about</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1288</td>
    <td class="codeLine">  /// this AddRec (such as range info) in case if new flags may potentially</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1288</td>
    <td class="codeLine">  /// this AddRec (such as range info) in case if new flags may potentially</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1289</td>
    <td class="codeLine">  /// sharpen it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1289</td>
    <td class="codeLine">  /// sharpen it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1290</td>
    <td class="codeLine">  void setNoWrapFlags(SCEVAddRecExpr *AddRec, SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1290</td>
    <td class="codeLine">  void setNoWrapFlags(SCEVAddRecExpr *AddRec, SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1291</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1292</td>
    <td class="codeLine">  /// Try to apply information from loop guards for \p L to \p Expr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1292</td>
    <td class="codeLine">  /// Try to apply information from loop guards for \p L to \p Expr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1293</td>
    <td class="codeLine">  const SCEV *applyLoopGuards(const SCEV *Expr, const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1293</td>
    <td class="codeLine">  const SCEV *applyLoopGuards(const SCEV *Expr, const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1294</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1295</td>
    <td class="codeLine">  /// Return true if the loop has no abnormal exits. That is, if the loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1295</td>
    <td class="codeLine">  /// Return true if the loop has no abnormal exits. That is, if the loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1296</td>
    <td class="codeLine">  /// is not infinite, it must exit through an explicit edge in the CFG.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1296</td>
    <td class="codeLine">  /// is not infinite, it must exit through an explicit edge in the CFG.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1297</td>
    <td class="codeLine">  /// (As opposed to either a) throwing out of the function or b) entering a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1297</td>
    <td class="codeLine">  /// (As opposed to either a) throwing out of the function or b) entering a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1298</td>
    <td class="codeLine">  /// well defined infinite loop in some callee.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1298</td>
    <td class="codeLine">  /// well defined infinite loop in some callee.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1299</td>
    <td class="codeLine">  bool loopHasNoAbnormalExits(const Loop *L) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1299</td>
    <td class="codeLine">  bool loopHasNoAbnormalExits(const Loop *L) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1300</td>
    <td class="codeLine">    return getLoopProperties(L).HasNoAbnormalExits;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1300</td>
    <td class="codeLine">    return getLoopProperties(L).HasNoAbnormalExits;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1301</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1301</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1302</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1303</td>
    <td class="codeLine">  /// Return true if this loop is finite by assumption.  That is,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1303</td>
    <td class="codeLine">  /// Return true if this loop is finite by assumption.  That is,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1304</td>
    <td class="codeLine">  /// to be infinite, it must also be undefined.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1304</td>
    <td class="codeLine">  /// to be infinite, it must also be undefined.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1305</td>
    <td class="codeLine">  bool loopIsFiniteByAssumption(const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1305</td>
    <td class="codeLine">  bool loopIsFiniteByAssumption(const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1306</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1307</td>
    <td class="codeLine">  class FoldID {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1307</td>
    <td class="codeLine">  class FoldID {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1308</td>
    <td class="codeLine">    const SCEV *Op = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1308</td>
    <td class="codeLine">    const SCEV *Op = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1309</td>
    <td class="codeLine">    const Type *Ty = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1309</td>
    <td class="codeLine">    const Type *Ty = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1310</td>
    <td class="codeLine">    unsigned short C;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1310</td>
    <td class="codeLine">    unsigned short C;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1312</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1312</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1313</td>
    <td class="codeLine">    FoldID(SCEVTypes C, const SCEV *Op, const Type *Ty) : Op(Op), Ty(Ty), C(C) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1313</td>
    <td class="codeLine">    FoldID(SCEVTypes C, const SCEV *Op, const Type *Ty) : Op(Op), Ty(Ty), C(C) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1314</td>
    <td class="codeLine">      assert(Op);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1314</td>
    <td class="codeLine">      assert(Op);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1315</td>
    <td class="codeLine">      assert(Ty);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1315</td>
    <td class="codeLine">      assert(Ty);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1316</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1316</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1318</td>
    <td class="codeLine">    FoldID(unsigned short C) : C(C) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1318</td>
    <td class="codeLine">    FoldID(unsigned short C) : C(C) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1319</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1320</td>
    <td class="codeLine">    unsigned computeHash() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1320</td>
    <td class="codeLine">    unsigned computeHash() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1321</td>
    <td class="codeLine">      return detail::combineHashValue(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1321</td>
    <td class="codeLine">      return detail::combineHashValue(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1322</td>
    <td class="codeLine">          C, detail::combineHashValue(reinterpret_cast<uintptr_t>(Op),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1322</td>
    <td class="codeLine">          C, detail::combineHashValue(reinterpret_cast<uintptr_t>(Op),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1323</td>
    <td class="codeLine">                                      reinterpret_cast<uintptr_t>(Ty)));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1323</td>
    <td class="codeLine">                                      reinterpret_cast<uintptr_t>(Ty)));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1324</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1324</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1325</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1326</td>
    <td class="codeLine">    bool operator==(const FoldID &RHS) const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1326</td>
    <td class="codeLine">    bool operator==(const FoldID &RHS) const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1327</td>
    <td class="codeLine">      return std::tie(Op, Ty, C) == std::tie(RHS.Op, RHS.Ty, RHS.C);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1327</td>
    <td class="codeLine">      return std::tie(Op, Ty, C) == std::tie(RHS.Op, RHS.Ty, RHS.C);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1328</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1328</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1329</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1329</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1330</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1331</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1331</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1332</td>
    <td class="codeLine">  /// A CallbackVH to arrange for ScalarEvolution to be notified whenever a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1332</td>
    <td class="codeLine">  /// A CallbackVH to arrange for ScalarEvolution to be notified whenever a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1333</td>
    <td class="codeLine">  /// Value is deleted.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1333</td>
    <td class="codeLine">  /// Value is deleted.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1334</td>
    <td class="codeLine">  class SCEVCallbackVH final : public CallbackVH {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1334</td>
    <td class="codeLine">  class SCEVCallbackVH final : public CallbackVH {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1335</td>
    <td class="codeLine">    ScalarEvolution *SE;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1335</td>
    <td class="codeLine">    ScalarEvolution *SE;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1336</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1337</td>
    <td class="codeLine">    void deleted() override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1337</td>
    <td class="codeLine">    void deleted() override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1338</td>
    <td class="codeLine">    void allUsesReplacedWith(Value *New) override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1338</td>
    <td class="codeLine">    void allUsesReplacedWith(Value *New) override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1339</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1340</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1340</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1341</td>
    <td class="codeLine">    SCEVCallbackVH(Value *V, ScalarEvolution *SE = nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1341</td>
    <td class="codeLine">    SCEVCallbackVH(Value *V, ScalarEvolution *SE = nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1342</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1342</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1343</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1344</td>
    <td class="codeLine">  friend class SCEVCallbackVH;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1344</td>
    <td class="codeLine">  friend class SCEVCallbackVH;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1345</td>
    <td class="codeLine">  friend class SCEVExpander;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1345</td>
    <td class="codeLine">  friend class SCEVExpander;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1346</td>
    <td class="codeLine">  friend class SCEVUnknown;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1346</td>
    <td class="codeLine">  friend class SCEVUnknown;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1347</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1348</td>
    <td class="codeLine">  /// The function we are analyzing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1348</td>
    <td class="codeLine">  /// The function we are analyzing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1349</td>
    <td class="codeLine">  Function &F;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1349</td>
    <td class="codeLine">  Function &F;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1350</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1351</td>
    <td class="codeLine">  /// Does the module have any calls to the llvm.experimental.guard intrinsic</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1351</td>
    <td class="codeLine">  /// Does the module have any calls to the llvm.experimental.guard intrinsic</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1352</td>
    <td class="codeLine">  /// at all?  If this is false, we avoid doing work that will only help if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1352</td>
    <td class="codeLine">  /// at all?  If this is false, we avoid doing work that will only help if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1353</td>
    <td class="codeLine">  /// thare are guards present in the IR.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1353</td>
    <td class="codeLine">  /// thare are guards present in the IR.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1354</td>
    <td class="codeLine">  bool HasGuards;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1354</td>
    <td class="codeLine">  bool HasGuards;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1356</td>
    <td class="codeLine">  /// The target library information for the target we are targeting.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1356</td>
    <td class="codeLine">  /// The target library information for the target we are targeting.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1357</td>
    <td class="codeLine">  TargetLibraryInfo &TLI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1357</td>
    <td class="codeLine">  TargetLibraryInfo &TLI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1358</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1359</td>
    <td class="codeLine">  /// The tracker for \@llvm.assume intrinsics in this function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1359</td>
    <td class="codeLine">  /// The tracker for \@llvm.assume intrinsics in this function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1360</td>
    <td class="codeLine">  AssumptionCache &AC;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1360</td>
    <td class="codeLine">  AssumptionCache &AC;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1362</td>
    <td class="codeLine">  /// The dominator tree.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1362</td>
    <td class="codeLine">  /// The dominator tree.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1363</td>
    <td class="codeLine">  DominatorTree &DT;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1363</td>
    <td class="codeLine">  DominatorTree &DT;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1364</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1365</td>
    <td class="codeLine">  /// The loop information for the function we are currently analyzing.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1365</td>
    <td class="codeLine">  /// The loop information for the function we are currently analyzing.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1366</td>
    <td class="codeLine">  LoopInfo &LI;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1366</td>
    <td class="codeLine">  LoopInfo &LI;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1367</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1368</td>
    <td class="codeLine">  /// This SCEV is used to represent unknown trip counts and things.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1368</td>
    <td class="codeLine">  /// This SCEV is used to represent unknown trip counts and things.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1369</td>
    <td class="codeLine">  std::unique_ptr<SCEVCouldNotCompute> CouldNotCompute;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1369</td>
    <td class="codeLine">  std::unique_ptr<SCEVCouldNotCompute> CouldNotCompute;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1370</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1371</td>
    <td class="codeLine">  /// The type for HasRecMap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1371</td>
    <td class="codeLine">  /// The type for HasRecMap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1372</td>
    <td class="codeLine">  using HasRecMapType = DenseMap<const SCEV *, bool>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1372</td>
    <td class="codeLine">  using HasRecMapType = DenseMap<const SCEV *, bool>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1373</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1374</td>
    <td class="codeLine">  /// This is a cache to record whether a SCEV contains any scAddRecExpr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1374</td>
    <td class="codeLine">  /// This is a cache to record whether a SCEV contains any scAddRecExpr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1375</td>
    <td class="codeLine">  HasRecMapType HasRecMap;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1375</td>
    <td class="codeLine">  HasRecMapType HasRecMap;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1376</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1377</td>
    <td class="codeLine">  /// The type for ExprValueMap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1377</td>
    <td class="codeLine">  /// The type for ExprValueMap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1378</td>
    <td class="codeLine">  using ValueSetVector = SmallSetVector<Value *, 4>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1378</td>
    <td class="codeLine">  using ValueSetVector = SmallSetVector<Value *, 4>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1379</td>
    <td class="codeLine">  using ExprValueMapType = DenseMap<const SCEV *, ValueSetVector>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1379</td>
    <td class="codeLine">  using ExprValueMapType = DenseMap<const SCEV *, ValueSetVector>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1380</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1381</td>
    <td class="codeLine">  /// ExprValueMap -- This map records the original values from which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1381</td>
    <td class="codeLine">  /// ExprValueMap -- This map records the original values from which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1382</td>
    <td class="codeLine">  /// the SCEV expr is generated from.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1382</td>
    <td class="codeLine">  /// the SCEV expr is generated from.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1383</td>
    <td class="codeLine">  ExprValueMapType ExprValueMap;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1383</td>
    <td class="codeLine">  ExprValueMapType ExprValueMap;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1384</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1385</td>
    <td class="codeLine">  /// The type for ValueExprMap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1385</td>
    <td class="codeLine">  /// The type for ValueExprMap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1386</td>
    <td class="codeLine">  using ValueExprMapType =</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1386</td>
    <td class="codeLine">  using ValueExprMapType =</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1387</td>
    <td class="codeLine">      DenseMap<SCEVCallbackVH, const SCEV *, DenseMapInfo<Value *>>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1387</td>
    <td class="codeLine">      DenseMap<SCEVCallbackVH, const SCEV *, DenseMapInfo<Value *>>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1388</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1389</td>
    <td class="codeLine">  /// This is a cache of the values we have analyzed so far.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1389</td>
    <td class="codeLine">  /// This is a cache of the values we have analyzed so far.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1390</td>
    <td class="codeLine">  ValueExprMapType ValueExprMap;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1390</td>
    <td class="codeLine">  ValueExprMapType ValueExprMap;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1391</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1392</td>
    <td class="codeLine">  /// This is a cache for expressions that got folded to a different existing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1392</td>
    <td class="codeLine">  /// This is a cache for expressions that got folded to a different existing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1393</td>
    <td class="codeLine">  /// SCEV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1393</td>
    <td class="codeLine">  /// SCEV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1394</td>
    <td class="codeLine">  DenseMap<FoldID, const SCEV *> FoldCache;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1394</td>
    <td class="codeLine">  DenseMap<FoldID, const SCEV *> FoldCache;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1395</td>
    <td class="codeLine">  DenseMap<const SCEV *, SmallVector<FoldID, 2>> FoldCacheUser;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1395</td>
    <td class="codeLine">  DenseMap<const SCEV *, SmallVector<FoldID, 2>> FoldCacheUser;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1396</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1397</td>
    <td class="codeLine">  /// Mark predicate values currently being processed by isImpliedCond.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1397</td>
    <td class="codeLine">  /// Mark predicate values currently being processed by isImpliedCond.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1398</td>
    <td class="codeLine">  SmallPtrSet<const Value *, 6> PendingLoopPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1398</td>
    <td class="codeLine">  SmallPtrSet<const Value *, 6> PendingLoopPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1399</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1400</td>
    <td class="codeLine">  /// Mark SCEVUnknown Phis currently being processed by getRangeRef.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1400</td>
    <td class="codeLine">  /// Mark SCEVUnknown Phis currently being processed by getRangeRef.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1401</td>
    <td class="codeLine">  SmallPtrSet<const PHINode *, 6> PendingPhiRanges;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1401</td>
    <td class="codeLine">  SmallPtrSet<const PHINode *, 6> PendingPhiRanges;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1402</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1403</td>
    <td class="codeLine">  /// Mark SCEVUnknown Phis currently being processed by getRangeRefIter.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1403</td>
    <td class="codeLine">  /// Mark SCEVUnknown Phis currently being processed by getRangeRefIter.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1404</td>
    <td class="codeLine">  SmallPtrSet<const PHINode *, 6> PendingPhiRangesIter;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1404</td>
    <td class="codeLine">  SmallPtrSet<const PHINode *, 6> PendingPhiRangesIter;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1405</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1406</td>
    <td class="codeLine">  // Mark SCEVUnknown Phis currently being processed by isImpliedViaMerge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1406</td>
    <td class="codeLine">  // Mark SCEVUnknown Phis currently being processed by isImpliedViaMerge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1407</td>
    <td class="codeLine">  SmallPtrSet<const PHINode *, 6> PendingMerges;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1407</td>
    <td class="codeLine">  SmallPtrSet<const PHINode *, 6> PendingMerges;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1408</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1409</td>
    <td class="codeLine">  /// Set to true by isLoopBackedgeGuardedByCond when we're walking the set of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1409</td>
    <td class="codeLine">  /// Set to true by isLoopBackedgeGuardedByCond when we're walking the set of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1410</td>
    <td class="codeLine">  /// conditions dominating the backedge of a loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1410</td>
    <td class="codeLine">  /// conditions dominating the backedge of a loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1411</td>
    <td class="codeLine">  bool WalkingBEDominatingConds = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1411</td>
    <td class="codeLine">  bool WalkingBEDominatingConds = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1412</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1413</td>
    <td class="codeLine">  /// Set to true by isKnownPredicateViaSplitting when we're trying to prove a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1413</td>
    <td class="codeLine">  /// Set to true by isKnownPredicateViaSplitting when we're trying to prove a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1414</td>
    <td class="codeLine">  /// predicate by splitting it into a set of independent predicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1414</td>
    <td class="codeLine">  /// predicate by splitting it into a set of independent predicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1415</td>
    <td class="codeLine">  bool ProvingSplitPredicate = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1415</td>
    <td class="codeLine">  bool ProvingSplitPredicate = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1416</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1417</td>
    <td class="codeLine">  /// Memoized values for the getConstantMultiple</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1417</td>
    <td class="codeLine">  /// Memoized values for the getConstantMultiple</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1418</td>
    <td class="codeLine">  DenseMap<const SCEV *, APInt> ConstantMultipleCache;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1418</td>
    <td class="codeLine">  DenseMap<const SCEV *, APInt> ConstantMultipleCache;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1419</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1420</td>
    <td class="codeLine">  /// Return the Value set from which the SCEV expr is generated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1420</td>
    <td class="codeLine">  /// Return the Value set from which the SCEV expr is generated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1421</td>
    <td class="codeLine">  ArrayRef<Value *> getSCEVValues(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1421</td>
    <td class="codeLine">  ArrayRef<Value *> getSCEVValues(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1422</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1423</td>
    <td class="codeLine">  /// Private helper method for the getConstantMultiple method.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1423</td>
    <td class="codeLine">  /// Private helper method for the getConstantMultiple method.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1424</td>
    <td class="codeLine">  APInt getConstantMultipleImpl(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1424</td>
    <td class="codeLine">  APInt getConstantMultipleImpl(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1425</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1426</td>
    <td class="codeLine">  /// Information about the number of times a particular loop exit may be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1426</td>
    <td class="codeLine">  /// Information about the number of times a particular loop exit may be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1427</td>
    <td class="codeLine">  /// reached before exiting the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1427</td>
    <td class="codeLine">  /// reached before exiting the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1428</td>
    <td class="codeLine">  struct ExitNotTakenInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1428</td>
    <td class="codeLine">  struct ExitNotTakenInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1429</td>
    <td class="codeLine">    PoisoningVH<BasicBlock> ExitingBlock;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1429</td>
    <td class="codeLine">    PoisoningVH<BasicBlock> ExitingBlock;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1430</td>
    <td class="codeLine">    const SCEV *ExactNotTaken;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1430</td>
    <td class="codeLine">    const SCEV *ExactNotTaken;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1431</td>
    <td class="codeLine">    const SCEV *ConstantMaxNotTaken;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1431</td>
    <td class="codeLine">    const SCEV *ConstantMaxNotTaken;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1432</td>
    <td class="codeLine">    const SCEV *SymbolicMaxNotTaken;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1432</td>
    <td class="codeLine">    const SCEV *SymbolicMaxNotTaken;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1433</td>
    <td class="codeLine">    SmallPtrSet<const SCEVPredicate *, 4> Predicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1433</td>
    <td class="codeLine">    SmallPtrSet<const SCEVPredicate *, 4> Predicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1434</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1435</td>
    <td class="codeLine">    explicit ExitNotTakenInfo(</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1435</td>
    <td class="codeLine">    explicit ExitNotTakenInfo(</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1436</td>
    <td class="codeLine">        PoisoningVH<BasicBlock> ExitingBlock, const SCEV *ExactNotTaken,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1436</td>
    <td class="codeLine">        PoisoningVH<BasicBlock> ExitingBlock, const SCEV *ExactNotTaken,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1437</td>
    <td class="codeLine">        const SCEV *ConstantMaxNotTaken, const SCEV *SymbolicMaxNotTaken,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1437</td>
    <td class="codeLine">        const SCEV *ConstantMaxNotTaken, const SCEV *SymbolicMaxNotTaken,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1438</td>
    <td class="codeLine">        const SmallPtrSet<const SCEVPredicate *, 4> &Predicates)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1438</td>
    <td class="codeLine">        const SmallPtrSet<const SCEVPredicate *, 4> &Predicates)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1439</td>
    <td class="codeLine">        : ExitingBlock(ExitingBlock), ExactNotTaken(ExactNotTaken),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1439</td>
    <td class="codeLine">        : ExitingBlock(ExitingBlock), ExactNotTaken(ExactNotTaken),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1440</td>
    <td class="codeLine">          ConstantMaxNotTaken(ConstantMaxNotTaken),</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1440</td>
    <td class="codeLine">          ConstantMaxNotTaken(ConstantMaxNotTaken),</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1441</td>
    <td class="codeLine">          SymbolicMaxNotTaken(SymbolicMaxNotTaken), Predicates(Predicates) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1441</td>
    <td class="codeLine">          SymbolicMaxNotTaken(SymbolicMaxNotTaken), Predicates(Predicates) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1442</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1443</td>
    <td class="codeLine">    bool hasAlwaysTruePredicate() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1443</td>
    <td class="codeLine">    bool hasAlwaysTruePredicate() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1444</td>
    <td class="codeLine">      return Predicates.empty();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1444</td>
    <td class="codeLine">      return Predicates.empty();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1445</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1445</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1446</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1446</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1447</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1448</td>
    <td class="codeLine">  /// Information about the backedge-taken count of a loop. This currently</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1448</td>
    <td class="codeLine">  /// Information about the backedge-taken count of a loop. This currently</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1449</td>
    <td class="codeLine">  /// includes an exact count and a maximum count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1449</td>
    <td class="codeLine">  /// includes an exact count and a maximum count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1450</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1450</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1451</td>
    <td class="codeLine">  class BackedgeTakenInfo {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1451</td>
    <td class="codeLine">  class BackedgeTakenInfo {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1452</td>
    <td class="codeLine">    friend class ScalarEvolution;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1452</td>
    <td class="codeLine">    friend class ScalarEvolution;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1453</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1454</td>
    <td class="codeLine">    /// A list of computable exits and their not-taken counts.  Loops almost</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1454</td>
    <td class="codeLine">    /// A list of computable exits and their not-taken counts.  Loops almost</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1455</td>
    <td class="codeLine">    /// never have more than one computable exit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1455</td>
    <td class="codeLine">    /// never have more than one computable exit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1456</td>
    <td class="codeLine">    SmallVector<ExitNotTakenInfo, 1> ExitNotTaken;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1456</td>
    <td class="codeLine">    SmallVector<ExitNotTakenInfo, 1> ExitNotTaken;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1457</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1458</td>
    <td class="codeLine">    /// Expression indicating the least constant maximum backedge-taken count of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1458</td>
    <td class="codeLine">    /// Expression indicating the least constant maximum backedge-taken count of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1459</td>
    <td class="codeLine">    /// the loop that is known, or a SCEVCouldNotCompute. This expression is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1459</td>
    <td class="codeLine">    /// the loop that is known, or a SCEVCouldNotCompute. This expression is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1460</td>
    <td class="codeLine">    /// only valid if the redicates associated with all loop exits are true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1460</td>
    <td class="codeLine">    /// only valid if the redicates associated with all loop exits are true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1461</td>
    <td class="codeLine">    const SCEV *ConstantMax = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1461</td>
    <td class="codeLine">    const SCEV *ConstantMax = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1462</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1463</td>
    <td class="codeLine">    /// Indicating if \c ExitNotTaken has an element for every exiting block in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1463</td>
    <td class="codeLine">    /// Indicating if \c ExitNotTaken has an element for every exiting block in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1464</td>
    <td class="codeLine">    /// the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1464</td>
    <td class="codeLine">    /// the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1465</td>
    <td class="codeLine">    bool IsComplete = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1465</td>
    <td class="codeLine">    bool IsComplete = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1466</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1467</td>
    <td class="codeLine">    /// Expression indicating the least maximum backedge-taken count of the loop</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1467</td>
    <td class="codeLine">    /// Expression indicating the least maximum backedge-taken count of the loop</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1468</td>
    <td class="codeLine">    /// that is known, or a SCEVCouldNotCompute. Lazily computed on first query.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1468</td>
    <td class="codeLine">    /// that is known, or a SCEVCouldNotCompute. Lazily computed on first query.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1469</td>
    <td class="codeLine">    const SCEV *SymbolicMax = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1469</td>
    <td class="codeLine">    const SCEV *SymbolicMax = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1470</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1471</td>
    <td class="codeLine">    /// True iff the backedge is taken either exactly Max or zero times.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1471</td>
    <td class="codeLine">    /// True iff the backedge is taken either exactly Max or zero times.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1472</td>
    <td class="codeLine">    bool MaxOrZero = false;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1472</td>
    <td class="codeLine">    bool MaxOrZero = false;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1473</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1474</td>
    <td class="codeLine">    bool isComplete() const { return IsComplete; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1474</td>
    <td class="codeLine">    bool isComplete() const { return IsComplete; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1475</td>
    <td class="codeLine">    const SCEV *getConstantMax() const { return ConstantMax; }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1475</td>
    <td class="codeLine">    const SCEV *getConstantMax() const { return ConstantMax; }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1476</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1477</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1477</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1478</td>
    <td class="codeLine">    BackedgeTakenInfo() = default;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1478</td>
    <td class="codeLine">    BackedgeTakenInfo() = default;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1479</td>
    <td class="codeLine">    BackedgeTakenInfo(BackedgeTakenInfo &&) = default;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1479</td>
    <td class="codeLine">    BackedgeTakenInfo(BackedgeTakenInfo &&) = default;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1480</td>
    <td class="codeLine">    BackedgeTakenInfo &operator=(BackedgeTakenInfo &&) = default;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1480</td>
    <td class="codeLine">    BackedgeTakenInfo &operator=(BackedgeTakenInfo &&) = default;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1481</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1482</td>
    <td class="codeLine">    using EdgeExitInfo = std::pair<BasicBlock *, ExitLimit>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1482</td>
    <td class="codeLine">    using EdgeExitInfo = std::pair<BasicBlock *, ExitLimit>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1483</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1484</td>
    <td class="codeLine">    /// Initialize BackedgeTakenInfo from a list of exact exit counts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1484</td>
    <td class="codeLine">    /// Initialize BackedgeTakenInfo from a list of exact exit counts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1485</td>
    <td class="codeLine">    BackedgeTakenInfo(ArrayRef<EdgeExitInfo> ExitCounts, bool IsComplete,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1485</td>
    <td class="codeLine">    BackedgeTakenInfo(ArrayRef<EdgeExitInfo> ExitCounts, bool IsComplete,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1486</td>
    <td class="codeLine">                      const SCEV *ConstantMax, bool MaxOrZero);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1486</td>
    <td class="codeLine">                      const SCEV *ConstantMax, bool MaxOrZero);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1487</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1488</td>
    <td class="codeLine">    /// Test whether this BackedgeTakenInfo contains any computed information,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1488</td>
    <td class="codeLine">    /// Test whether this BackedgeTakenInfo contains any computed information,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1489</td>
    <td class="codeLine">    /// or whether it's all SCEVCouldNotCompute values.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1489</td>
    <td class="codeLine">    /// or whether it's all SCEVCouldNotCompute values.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1490</td>
    <td class="codeLine">    bool hasAnyInfo() const {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1490</td>
    <td class="codeLine">    bool hasAnyInfo() const {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1491</td>
    <td class="codeLine">      return !ExitNotTaken.empty() ||</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1491</td>
    <td class="codeLine">      return !ExitNotTaken.empty() ||</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1492</td>
    <td class="codeLine">             !isa<SCEVCouldNotCompute>(getConstantMax());</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1492</td>
    <td class="codeLine">             !isa<SCEVCouldNotCompute>(getConstantMax());</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1493</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1493</td>
    <td class="codeLine">    }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1494</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1494</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1495</td>
    <td class="codeLine">    /// Test whether this BackedgeTakenInfo contains complete information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1495</td>
    <td class="codeLine">    /// Test whether this BackedgeTakenInfo contains complete information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1496</td>
    <td class="codeLine">    bool hasFullInfo() const { return isComplete(); }</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1496</td>
    <td class="codeLine">    bool hasFullInfo() const { return isComplete(); }</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1497</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1498</td>
    <td class="codeLine">    /// Return an expression indicating the exact *backedge-taken*</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1498</td>
    <td class="codeLine">    /// Return an expression indicating the exact *backedge-taken*</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1499</td>
    <td class="codeLine">    /// count of the loop if it is known or SCEVCouldNotCompute</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1499</td>
    <td class="codeLine">    /// count of the loop if it is known or SCEVCouldNotCompute</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1500</td>
    <td class="codeLine">    /// otherwise.  If execution makes it to the backedge on every</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1500</td>
    <td class="codeLine">    /// otherwise.  If execution makes it to the backedge on every</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1501</td>
    <td class="codeLine">    /// iteration (i.e. there are no abnormal exists like exception</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1501</td>
    <td class="codeLine">    /// iteration (i.e. there are no abnormal exists like exception</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1502</td>
    <td class="codeLine">    /// throws and thread exits) then this is the number of times the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1502</td>
    <td class="codeLine">    /// throws and thread exits) then this is the number of times the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1503</td>
    <td class="codeLine">    /// loop header will execute minus one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1503</td>
    <td class="codeLine">    /// loop header will execute minus one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1504</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1504</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1505</td>
    <td class="codeLine">    /// If the SCEV predicate associated with the answer can be different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1505</td>
    <td class="codeLine">    /// If the SCEV predicate associated with the answer can be different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1506</td>
    <td class="codeLine">    /// from AlwaysTrue, we must add a (non null) Predicates argument.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1506</td>
    <td class="codeLine">    /// from AlwaysTrue, we must add a (non null) Predicates argument.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1507</td>
    <td class="codeLine">    /// The SCEV predicate associated with the answer will be added to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1507</td>
    <td class="codeLine">    /// The SCEV predicate associated with the answer will be added to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1508</td>
    <td class="codeLine">    /// Predicates. A run-time check needs to be emitted for the SCEV</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1508</td>
    <td class="codeLine">    /// Predicates. A run-time check needs to be emitted for the SCEV</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1509</td>
    <td class="codeLine">    /// predicate in order for the answer to be valid.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1509</td>
    <td class="codeLine">    /// predicate in order for the answer to be valid.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1510</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1510</td>
    <td class="codeLine">    ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1511</td>
    <td class="codeLine">    /// Note that we should always know if we need to pass a predicate</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1511</td>
    <td class="codeLine">    /// Note that we should always know if we need to pass a predicate</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1512</td>
    <td class="codeLine">    /// argument or not from the way the ExitCounts vector was computed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1512</td>
    <td class="codeLine">    /// argument or not from the way the ExitCounts vector was computed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1513</td>
    <td class="codeLine">    /// If we allowed SCEV predicates to be generated when populating this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1513</td>
    <td class="codeLine">    /// If we allowed SCEV predicates to be generated when populating this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1514</td>
    <td class="codeLine">    /// vector, this information can contain them and therefore a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1514</td>
    <td class="codeLine">    /// vector, this information can contain them and therefore a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1515</td>
    <td class="codeLine">    /// SCEVPredicate argument should be added to getExact.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1515</td>
    <td class="codeLine">    /// SCEVPredicate argument should be added to getExact.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1516</td>
    <td class="codeLine">    const SCEV *getExact(const Loop *L, ScalarEvolution *SE,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1516</td>
    <td class="codeLine">    const SCEV *getExact(const Loop *L, ScalarEvolution *SE,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1517</td>
    <td class="codeLine">                         SmallVector<const SCEVPredicate *, 4> *Predicates = nullptr) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1517</td>
    <td class="codeLine">                         SmallVector<const SCEVPredicate *, 4> *Predicates = nullptr) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1518</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1519</td>
    <td class="codeLine">    /// Return the number of times this loop exit may fall through to the back</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1519</td>
    <td class="codeLine">    /// Return the number of times this loop exit may fall through to the back</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1520</td>
    <td class="codeLine">    /// edge, or SCEVCouldNotCompute. The loop is guaranteed not to exit via</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1520</td>
    <td class="codeLine">    /// edge, or SCEVCouldNotCompute. The loop is guaranteed not to exit via</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1521</td>
    <td class="codeLine">    /// this block before this number of iterations, but may exit via another</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1521</td>
    <td class="codeLine">    /// this block before this number of iterations, but may exit via another</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1522</td>
    <td class="codeLine">    /// block.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1522</td>
    <td class="codeLine">    /// block.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1523</td>
    <td class="codeLine">    const SCEV *getExact(const BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1523</td>
    <td class="codeLine">    const SCEV *getExact(const BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1524</td>
    <td class="codeLine">                         ScalarEvolution *SE) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1524</td>
    <td class="codeLine">                         ScalarEvolution *SE) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1525</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1525</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1526</td>
    <td class="codeLine">    /// Get the constant max backedge taken count for the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1526</td>
    <td class="codeLine">    /// Get the constant max backedge taken count for the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1527</td>
    <td class="codeLine">    const SCEV *getConstantMax(ScalarEvolution *SE) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1527</td>
    <td class="codeLine">    const SCEV *getConstantMax(ScalarEvolution *SE) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1528</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1529</td>
    <td class="codeLine">    /// Get the constant max backedge taken count for the particular loop exit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1529</td>
    <td class="codeLine">    /// Get the constant max backedge taken count for the particular loop exit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1530</td>
    <td class="codeLine">    const SCEV *getConstantMax(const BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1530</td>
    <td class="codeLine">    const SCEV *getConstantMax(const BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1531</td>
    <td class="codeLine">                               ScalarEvolution *SE) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1531</td>
    <td class="codeLine">                               ScalarEvolution *SE) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1532</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1533</td>
    <td class="codeLine">    /// Get the symbolic max backedge taken count for the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1533</td>
    <td class="codeLine">    /// Get the symbolic max backedge taken count for the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1534</td>
    <td class="codeLine">    const SCEV *getSymbolicMax(const Loop *L, ScalarEvolution *SE);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1534</td>
    <td class="codeLine">    const SCEV *getSymbolicMax(const Loop *L, ScalarEvolution *SE);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1535</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1536</td>
    <td class="codeLine">    /// Get the symbolic max backedge taken count for the particular loop exit.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1536</td>
    <td class="codeLine">    /// Get the symbolic max backedge taken count for the particular loop exit.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1537</td>
    <td class="codeLine">    const SCEV *getSymbolicMax(const BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1537</td>
    <td class="codeLine">    const SCEV *getSymbolicMax(const BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1538</td>
    <td class="codeLine">                               ScalarEvolution *SE) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1538</td>
    <td class="codeLine">                               ScalarEvolution *SE) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1539</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1539</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1540</td>
    <td class="codeLine">    /// Return true if the number of times this backedge is taken is either the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1540</td>
    <td class="codeLine">    /// Return true if the number of times this backedge is taken is either the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1541</td>
    <td class="codeLine">    /// value returned by getConstantMax or zero.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1541</td>
    <td class="codeLine">    /// value returned by getConstantMax or zero.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1542</td>
    <td class="codeLine">    bool isConstantMaxOrZero(ScalarEvolution *SE) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1542</td>
    <td class="codeLine">    bool isConstantMaxOrZero(ScalarEvolution *SE) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1543</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1543</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1544</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1545</td>
    <td class="codeLine">  /// Cache the backedge-taken count of the loops for this function as they</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1545</td>
    <td class="codeLine">  /// Cache the backedge-taken count of the loops for this function as they</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1546</td>
    <td class="codeLine">  /// are computed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1546</td>
    <td class="codeLine">  /// are computed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1547</td>
    <td class="codeLine">  DenseMap<const Loop *, BackedgeTakenInfo> BackedgeTakenCounts;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1547</td>
    <td class="codeLine">  DenseMap<const Loop *, BackedgeTakenInfo> BackedgeTakenCounts;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1548</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1549</td>
    <td class="codeLine">  /// Cache the predicated backedge-taken count of the loops for this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1549</td>
    <td class="codeLine">  /// Cache the predicated backedge-taken count of the loops for this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1550</td>
    <td class="codeLine">  /// function as they are computed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1550</td>
    <td class="codeLine">  /// function as they are computed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1551</td>
    <td class="codeLine">  DenseMap<const Loop *, BackedgeTakenInfo> PredicatedBackedgeTakenCounts;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1551</td>
    <td class="codeLine">  DenseMap<const Loop *, BackedgeTakenInfo> PredicatedBackedgeTakenCounts;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1552</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1553</td>
    <td class="codeLine">  /// Loops whose backedge taken counts directly use this non-constant SCEV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1553</td>
    <td class="codeLine">  /// Loops whose backedge taken counts directly use this non-constant SCEV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1554</td>
    <td class="codeLine">  DenseMap<const SCEV *, SmallPtrSet<PointerIntPair<const Loop *, 1, bool>, 4>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1554</td>
    <td class="codeLine">  DenseMap<const SCEV *, SmallPtrSet<PointerIntPair<const Loop *, 1, bool>, 4>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1555</td>
    <td class="codeLine">      BECountUsers;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1555</td>
    <td class="codeLine">      BECountUsers;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1556</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1557</td>
    <td class="codeLine">  /// This map contains entries for all of the PHI instructions that we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1557</td>
    <td class="codeLine">  /// This map contains entries for all of the PHI instructions that we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1558</td>
    <td class="codeLine">  /// attempt to compute constant evolutions for.  This allows us to avoid</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1558</td>
    <td class="codeLine">  /// attempt to compute constant evolutions for.  This allows us to avoid</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1559</td>
    <td class="codeLine">  /// potentially expensive recomputation of these properties.  An instruction</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1559</td>
    <td class="codeLine">  /// potentially expensive recomputation of these properties.  An instruction</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1560</td>
    <td class="codeLine">  /// maps to null if we are unable to compute its exit value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1560</td>
    <td class="codeLine">  /// maps to null if we are unable to compute its exit value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1561</td>
    <td class="codeLine">  DenseMap<PHINode *, Constant *> ConstantEvolutionLoopExitValue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1561</td>
    <td class="codeLine">  DenseMap<PHINode *, Constant *> ConstantEvolutionLoopExitValue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1562</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1563</td>
    <td class="codeLine">  /// This map contains entries for all the expressions that we attempt to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1563</td>
    <td class="codeLine">  /// This map contains entries for all the expressions that we attempt to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1564</td>
    <td class="codeLine">  /// compute getSCEVAtScope information for, which can be expensive in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1564</td>
    <td class="codeLine">  /// compute getSCEVAtScope information for, which can be expensive in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1565</td>
    <td class="codeLine">  /// extreme cases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1565</td>
    <td class="codeLine">  /// extreme cases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1566</td>
    <td class="codeLine">  DenseMap<const SCEV *, SmallVector<std::pair<const Loop *, const SCEV *>, 2>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1566</td>
    <td class="codeLine">  DenseMap<const SCEV *, SmallVector<std::pair<const Loop *, const SCEV *>, 2>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1567</td>
    <td class="codeLine">      ValuesAtScopes;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1567</td>
    <td class="codeLine">      ValuesAtScopes;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1568</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1569</td>
    <td class="codeLine">  /// Reverse map for invalidation purposes: Stores of which SCEV and which</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1569</td>
    <td class="codeLine">  /// Reverse map for invalidation purposes: Stores of which SCEV and which</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1570</td>
    <td class="codeLine">  /// loop this is the value-at-scope of.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1570</td>
    <td class="codeLine">  /// loop this is the value-at-scope of.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1571</td>
    <td class="codeLine">  DenseMap<const SCEV *, SmallVector<std::pair<const Loop *, const SCEV *>, 2>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1571</td>
    <td class="codeLine">  DenseMap<const SCEV *, SmallVector<std::pair<const Loop *, const SCEV *>, 2>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1572</td>
    <td class="codeLine">      ValuesAtScopesUsers;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1572</td>
    <td class="codeLine">      ValuesAtScopesUsers;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1573</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1574</td>
    <td class="codeLine">  /// Memoized computeLoopDisposition results.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1574</td>
    <td class="codeLine">  /// Memoized computeLoopDisposition results.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1575</td>
    <td class="codeLine">  DenseMap<const SCEV *,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1575</td>
    <td class="codeLine">  DenseMap<const SCEV *,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1576</td>
    <td class="codeLine">           SmallVector<PointerIntPair<const Loop *, 2, LoopDisposition>, 2>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1576</td>
    <td class="codeLine">           SmallVector<PointerIntPair<const Loop *, 2, LoopDisposition>, 2>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1577</td>
    <td class="codeLine">      LoopDispositions;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1577</td>
    <td class="codeLine">      LoopDispositions;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1578</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1579</td>
    <td class="codeLine">  struct LoopProperties {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1579</td>
    <td class="codeLine">  struct LoopProperties {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1580</td>
    <td class="codeLine">    /// Set to true if the loop contains no instruction that can abnormally exit</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1580</td>
    <td class="codeLine">    /// Set to true if the loop contains no instruction that can abnormally exit</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1581</td>
    <td class="codeLine">    /// the loop (i.e. via throwing an exception, by terminating the thread</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1581</td>
    <td class="codeLine">    /// the loop (i.e. via throwing an exception, by terminating the thread</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1582</td>
    <td class="codeLine">    /// cleanly or by infinite looping in a called function).  Strictly</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1582</td>
    <td class="codeLine">    /// cleanly or by infinite looping in a called function).  Strictly</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1583</td>
    <td class="codeLine">    /// speaking, the last one is not leaving the loop, but is identical to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1583</td>
    <td class="codeLine">    /// speaking, the last one is not leaving the loop, but is identical to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1584</td>
    <td class="codeLine">    /// leaving the loop for reasoning about undefined behavior.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1584</td>
    <td class="codeLine">    /// leaving the loop for reasoning about undefined behavior.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1585</td>
    <td class="codeLine">    bool HasNoAbnormalExits;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1585</td>
    <td class="codeLine">    bool HasNoAbnormalExits;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1586</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1586</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1587</td>
    <td class="codeLine">    /// Set to true if the loop contains no instruction that can have side</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1587</td>
    <td class="codeLine">    /// Set to true if the loop contains no instruction that can have side</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1588</td>
    <td class="codeLine">    /// effects (i.e. via throwing an exception, volatile or atomic access).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1588</td>
    <td class="codeLine">    /// effects (i.e. via throwing an exception, volatile or atomic access).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1589</td>
    <td class="codeLine">    bool HasNoSideEffects;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1589</td>
    <td class="codeLine">    bool HasNoSideEffects;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1590</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1590</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1591</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1591</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1592</td>
    <td class="codeLine">  /// Cache for \c getLoopProperties.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1592</td>
    <td class="codeLine">  /// Cache for \c getLoopProperties.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1593</td>
    <td class="codeLine">  DenseMap<const Loop *, LoopProperties> LoopPropertiesCache;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1593</td>
    <td class="codeLine">  DenseMap<const Loop *, LoopProperties> LoopPropertiesCache;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1594</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1595</td>
    <td class="codeLine">  /// Return a \c LoopProperties instance for \p L, creating one if necessary.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1595</td>
    <td class="codeLine">  /// Return a \c LoopProperties instance for \p L, creating one if necessary.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1596</td>
    <td class="codeLine">  LoopProperties getLoopProperties(const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1596</td>
    <td class="codeLine">  LoopProperties getLoopProperties(const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1597</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1598</td>
    <td class="codeLine">  bool loopHasNoSideEffects(const Loop *L) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1598</td>
    <td class="codeLine">  bool loopHasNoSideEffects(const Loop *L) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1599</td>
    <td class="codeLine">    return getLoopProperties(L).HasNoSideEffects;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1599</td>
    <td class="codeLine">    return getLoopProperties(L).HasNoSideEffects;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1600</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1600</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1601</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1602</td>
    <td class="codeLine">  /// Compute a LoopDisposition value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1602</td>
    <td class="codeLine">  /// Compute a LoopDisposition value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1603</td>
    <td class="codeLine">  LoopDisposition computeLoopDisposition(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1603</td>
    <td class="codeLine">  LoopDisposition computeLoopDisposition(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1604</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1605</td>
    <td class="codeLine">  /// Memoized computeBlockDisposition results.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1605</td>
    <td class="codeLine">  /// Memoized computeBlockDisposition results.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1606</td>
    <td class="codeLine">  DenseMap<</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1606</td>
    <td class="codeLine">  DenseMap<</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1607</td>
    <td class="codeLine">      const SCEV *,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1607</td>
    <td class="codeLine">      const SCEV *,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1608</td>
    <td class="codeLine">      SmallVector<PointerIntPair<const BasicBlock *, 2, BlockDisposition>, 2>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1608</td>
    <td class="codeLine">      SmallVector<PointerIntPair<const BasicBlock *, 2, BlockDisposition>, 2>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1609</td>
    <td class="codeLine">      BlockDispositions;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1609</td>
    <td class="codeLine">      BlockDispositions;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1610</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1610</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1611</td>
    <td class="codeLine">  /// Compute a BlockDisposition value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1611</td>
    <td class="codeLine">  /// Compute a BlockDisposition value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1612</td>
    <td class="codeLine">  BlockDisposition computeBlockDisposition(const SCEV *S, const BasicBlock *BB);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1612</td>
    <td class="codeLine">  BlockDisposition computeBlockDisposition(const SCEV *S, const BasicBlock *BB);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1613</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1614</td>
    <td class="codeLine">  /// Stores all SCEV that use a given SCEV as its direct operand.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1614</td>
    <td class="codeLine">  /// Stores all SCEV that use a given SCEV as its direct operand.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1615</td>
    <td class="codeLine">  DenseMap<const SCEV *, SmallPtrSet<const SCEV *, 8> > SCEVUsers;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1615</td>
    <td class="codeLine">  DenseMap<const SCEV *, SmallPtrSet<const SCEV *, 8> > SCEVUsers;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1616</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1617</td>
    <td class="codeLine">  /// Memoized results from getRange</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1617</td>
    <td class="codeLine">  /// Memoized results from getRange</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1618</td>
    <td class="codeLine">  DenseMap<const SCEV *, ConstantRange> UnsignedRanges;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1618</td>
    <td class="codeLine">  DenseMap<const SCEV *, ConstantRange> UnsignedRanges;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1619</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1620</td>
    <td class="codeLine">  /// Memoized results from getRange</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1620</td>
    <td class="codeLine">  /// Memoized results from getRange</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1621</td>
    <td class="codeLine">  DenseMap<const SCEV *, ConstantRange> SignedRanges;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1621</td>
    <td class="codeLine">  DenseMap<const SCEV *, ConstantRange> SignedRanges;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1622</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1623</td>
    <td class="codeLine">  /// Used to parameterize getRange</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1623</td>
    <td class="codeLine">  /// Used to parameterize getRange</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1624</td>
    <td class="codeLine">  enum RangeSignHint { HINT_RANGE_UNSIGNED, HINT_RANGE_SIGNED };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1624</td>
    <td class="codeLine">  enum RangeSignHint { HINT_RANGE_UNSIGNED, HINT_RANGE_SIGNED };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1625</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1626</td>
    <td class="codeLine">  /// Set the memoized range for the given SCEV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1626</td>
    <td class="codeLine">  /// Set the memoized range for the given SCEV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1627</td>
    <td class="codeLine">  const ConstantRange &setRange(const SCEV *S, RangeSignHint Hint,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1627</td>
    <td class="codeLine">  const ConstantRange &setRange(const SCEV *S, RangeSignHint Hint,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1628</td>
    <td class="codeLine">                                ConstantRange CR) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1628</td>
    <td class="codeLine">                                ConstantRange CR) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1629</td>
    <td class="codeLine">    DenseMap<const SCEV *, ConstantRange> &Cache =</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1629</td>
    <td class="codeLine">    DenseMap<const SCEV *, ConstantRange> &Cache =</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1630</td>
    <td class="codeLine">        Hint == HINT_RANGE_UNSIGNED ? UnsignedRanges : SignedRanges;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1630</td>
    <td class="codeLine">        Hint == HINT_RANGE_UNSIGNED ? UnsignedRanges : SignedRanges;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1631</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1632</td>
    <td class="codeLine">    auto Pair = Cache.try_emplace(S, std::move(CR));</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1632</td>
    <td class="codeLine">    auto Pair = Cache.try_emplace(S, std::move(CR));</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1633</td>
    <td class="codeLine">    if (!Pair.second)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1633</td>
    <td class="codeLine">    if (!Pair.second)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1634</td>
    <td class="codeLine">      Pair.first->second = std::move(CR);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1634</td>
    <td class="codeLine">      Pair.first->second = std::move(CR);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1635</td>
    <td class="codeLine">    return Pair.first->second;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1635</td>
    <td class="codeLine">    return Pair.first->second;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1636</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1636</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1637</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1638</td>
    <td class="codeLine">  /// Determine the range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1638</td>
    <td class="codeLine">  /// Determine the range for a particular SCEV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1639</td>
    <td class="codeLine">  /// NOTE: This returns a reference to an entry in a cache. It must be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1639</td>
    <td class="codeLine">  /// NOTE: This returns a reference to an entry in a cache. It must be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1640</td>
    <td class="codeLine">  /// copied if its needed for longer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1640</td>
    <td class="codeLine">  /// copied if its needed for longer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1641</td>
    <td class="codeLine">  const ConstantRange &getRangeRef(const SCEV *S, RangeSignHint Hint,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1641</td>
    <td class="codeLine">  const ConstantRange &getRangeRef(const SCEV *S, RangeSignHint Hint,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1642</td>
    <td class="codeLine">                                   unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1642</td>
    <td class="codeLine">                                   unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1643</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1644</td>
    <td class="codeLine">  /// Determine the range for a particular SCEV, but evaluates ranges for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1644</td>
    <td class="codeLine">  /// Determine the range for a particular SCEV, but evaluates ranges for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1645</td>
    <td class="codeLine">  /// operands iteratively first.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1645</td>
    <td class="codeLine">  /// operands iteratively first.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1646</td>
    <td class="codeLine">  const ConstantRange &getRangeRefIter(const SCEV *S, RangeSignHint Hint);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1646</td>
    <td class="codeLine">  const ConstantRange &getRangeRefIter(const SCEV *S, RangeSignHint Hint);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1647</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1648</td>
    <td class="codeLine">  /// Determines the range for the affine SCEVAddRecExpr {\p Start,+,\p Step}.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1648</td>
    <td class="codeLine">  /// Determines the range for the affine SCEVAddRecExpr {\p Start,+,\p Step}.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1649</td>
    <td class="codeLine">  /// Helper for \c getRange.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1649</td>
    <td class="codeLine">  /// Helper for \c getRange.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1650</td>
    <td class="codeLine">  ConstantRange getRangeForAffineAR(const SCEV *Start, const SCEV *Step,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1650</td>
    <td class="codeLine">  ConstantRange getRangeForAffineAR(const SCEV *Start, const SCEV *Step,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1651</td>
    <td class="codeLine">                                    const APInt &MaxBECount);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1651</td>
    <td class="codeLine">                                    const APInt &MaxBECount);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1652</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1653</td>
    <td class="codeLine">  /// Determines the range for the affine non-self-wrapping SCEVAddRecExpr {\p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1653</td>
    <td class="codeLine">  /// Determines the range for the affine non-self-wrapping SCEVAddRecExpr {\p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1654</td>
    <td class="codeLine">  /// Start,+,\p Step}<nw>.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1654</td>
    <td class="codeLine">  /// Start,+,\p Step}<nw>.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1655</td>
    <td class="codeLine">  ConstantRange getRangeForAffineNoSelfWrappingAR(const SCEVAddRecExpr *AddRec,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1655</td>
    <td class="codeLine">  ConstantRange getRangeForAffineNoSelfWrappingAR(const SCEVAddRecExpr *AddRec,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1656</td>
    <td class="codeLine">                                                  const SCEV *MaxBECount,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1656</td>
    <td class="codeLine">                                                  const SCEV *MaxBECount,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1657</td>
    <td class="codeLine">                                                  unsigned BitWidth,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1657</td>
    <td class="codeLine">                                                  unsigned BitWidth,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1658</td>
    <td class="codeLine">                                                  RangeSignHint SignHint);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1658</td>
    <td class="codeLine">                                                  RangeSignHint SignHint);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1659</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1659</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1660</td>
    <td class="codeLine">  /// Try to compute a range for the affine SCEVAddRecExpr {\p Start,+,\p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1660</td>
    <td class="codeLine">  /// Try to compute a range for the affine SCEVAddRecExpr {\p Start,+,\p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1661</td>
    <td class="codeLine">  /// Step} by "factoring out" a ternary expression from the add recurrence.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1661</td>
    <td class="codeLine">  /// Step} by "factoring out" a ternary expression from the add recurrence.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1662</td>
    <td class="codeLine">  /// Helper called by \c getRange.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1662</td>
    <td class="codeLine">  /// Helper called by \c getRange.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1663</td>
    <td class="codeLine">  ConstantRange getRangeViaFactoring(const SCEV *Start, const SCEV *Step,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1663</td>
    <td class="codeLine">  ConstantRange getRangeViaFactoring(const SCEV *Start, const SCEV *Step,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1664</td>
    <td class="codeLine">                                     const APInt &MaxBECount);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1664</td>
    <td class="codeLine">                                     const APInt &MaxBECount);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1665</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1666</td>
    <td class="codeLine">  /// If the unknown expression U corresponds to a simple recurrence, return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1666</td>
    <td class="codeLine">  /// If the unknown expression U corresponds to a simple recurrence, return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1667</td>
    <td class="codeLine">  /// a constant range which represents the entire recurrence.  Note that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1667</td>
    <td class="codeLine">  /// a constant range which represents the entire recurrence.  Note that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1668</td>
    <td class="codeLine">  /// *add* recurrences with loop invariant steps aren't represented by</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1668</td>
    <td class="codeLine">  /// *add* recurrences with loop invariant steps aren't represented by</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1669</td>
    <td class="codeLine">  /// SCEVUnknowns and thus don't use this mechanism.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1669</td>
    <td class="codeLine">  /// SCEVUnknowns and thus don't use this mechanism.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1670</td>
    <td class="codeLine">  ConstantRange getRangeForUnknownRecurrence(const SCEVUnknown *U);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1670</td>
    <td class="codeLine">  ConstantRange getRangeForUnknownRecurrence(const SCEVUnknown *U);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1671</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1672</td>
    <td class="codeLine">  /// We know that there is no SCEV for the specified value.  Analyze the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1672</td>
    <td class="codeLine">  /// We know that there is no SCEV for the specified value.  Analyze the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1673</td>
    <td class="codeLine">  /// expression recursively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1673</td>
    <td class="codeLine">  /// expression recursively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1674</td>
    <td class="codeLine">  const SCEV *createSCEV(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1674</td>
    <td class="codeLine">  const SCEV *createSCEV(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1675</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1676</td>
    <td class="codeLine">  /// We know that there is no SCEV for the specified value. Create a new SCEV</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1676</td>
    <td class="codeLine">  /// We know that there is no SCEV for the specified value. Create a new SCEV</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1677</td>
    <td class="codeLine">  /// for \p V iteratively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1677</td>
    <td class="codeLine">  /// for \p V iteratively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1678</td>
    <td class="codeLine">  const SCEV *createSCEVIter(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1678</td>
    <td class="codeLine">  const SCEV *createSCEVIter(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1679</td>
    <td class="codeLine">  /// Collect operands of \p V for which SCEV expressions should be constructed</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1679</td>
    <td class="codeLine">  /// Collect operands of \p V for which SCEV expressions should be constructed</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1680</td>
    <td class="codeLine">  /// first. Returns a SCEV directly if it can be constructed trivially for \p</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1680</td>
    <td class="codeLine">  /// first. Returns a SCEV directly if it can be constructed trivially for \p</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1681</td>
    <td class="codeLine">  /// V.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1681</td>
    <td class="codeLine">  /// V.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1682</td>
    <td class="codeLine">  const SCEV *getOperandsToCreate(Value *V, SmallVectorImpl<Value *> &Ops);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1682</td>
    <td class="codeLine">  const SCEV *getOperandsToCreate(Value *V, SmallVectorImpl<Value *> &Ops);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1683</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1684</td>
    <td class="codeLine">  /// Provide the special handling we need to analyze PHI SCEVs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1684</td>
    <td class="codeLine">  /// Provide the special handling we need to analyze PHI SCEVs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1685</td>
    <td class="codeLine">  const SCEV *createNodeForPHI(PHINode *PN);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1685</td>
    <td class="codeLine">  const SCEV *createNodeForPHI(PHINode *PN);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1686</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1687</td>
    <td class="codeLine">  /// Helper function called from createNodeForPHI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1687</td>
    <td class="codeLine">  /// Helper function called from createNodeForPHI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1688</td>
    <td class="codeLine">  const SCEV *createAddRecFromPHI(PHINode *PN);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1688</td>
    <td class="codeLine">  const SCEV *createAddRecFromPHI(PHINode *PN);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1689</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1690</td>
    <td class="codeLine">  /// A helper function for createAddRecFromPHI to handle simple cases.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1690</td>
    <td class="codeLine">  /// A helper function for createAddRecFromPHI to handle simple cases.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1691</td>
    <td class="codeLine">  const SCEV *createSimpleAffineAddRec(PHINode *PN, Value *BEValueV,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1691</td>
    <td class="codeLine">  const SCEV *createSimpleAffineAddRec(PHINode *PN, Value *BEValueV,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1692</td>
    <td class="codeLine">                                            Value *StartValueV);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1692</td>
    <td class="codeLine">                                            Value *StartValueV);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1693</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1694</td>
    <td class="codeLine">  /// Helper function called from createNodeForPHI.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1694</td>
    <td class="codeLine">  /// Helper function called from createNodeForPHI.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1695</td>
    <td class="codeLine">  const SCEV *createNodeFromSelectLikePHI(PHINode *PN);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1695</td>
    <td class="codeLine">  const SCEV *createNodeFromSelectLikePHI(PHINode *PN);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1696</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1697</td>
    <td class="codeLine">  /// Provide special handling for a select-like instruction (currently this</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1697</td>
    <td class="codeLine">  /// Provide special handling for a select-like instruction (currently this</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1698</td>
    <td class="codeLine">  /// is either a select instruction or a phi node).  \p Ty is the type of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1698</td>
    <td class="codeLine">  /// is either a select instruction or a phi node).  \p Ty is the type of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1699</td>
    <td class="codeLine">  /// instruction being processed, that is assumed equivalent to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1699</td>
    <td class="codeLine">  /// instruction being processed, that is assumed equivalent to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1700</td>
    <td class="codeLine">  /// "Cond ? TrueVal : FalseVal".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1700</td>
    <td class="codeLine">  /// "Cond ? TrueVal : FalseVal".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1701</td>
    <td class="codeLine">  std::optional<const SCEV *></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1701</td>
    <td class="codeLine">  std::optional<const SCEV *></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1702</td>
    <td class="codeLine">  createNodeForSelectOrPHIInstWithICmpInstCond(Type *Ty, ICmpInst *Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1702</td>
    <td class="codeLine">  createNodeForSelectOrPHIInstWithICmpInstCond(Type *Ty, ICmpInst *Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1703</td>
    <td class="codeLine">                                               Value *TrueVal, Value *FalseVal);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1703</td>
    <td class="codeLine">                                               Value *TrueVal, Value *FalseVal);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1704</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1705</td>
    <td class="codeLine">  /// See if we can model this select-like instruction via umin_seq expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1705</td>
    <td class="codeLine">  /// See if we can model this select-like instruction via umin_seq expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1706</td>
    <td class="codeLine">  const SCEV *createNodeForSelectOrPHIViaUMinSeq(Value *I, Value *Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1706</td>
    <td class="codeLine">  const SCEV *createNodeForSelectOrPHIViaUMinSeq(Value *I, Value *Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1707</td>
    <td class="codeLine">                                                 Value *TrueVal,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1707</td>
    <td class="codeLine">                                                 Value *TrueVal,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1708</td>
    <td class="codeLine">                                                 Value *FalseVal);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1708</td>
    <td class="codeLine">                                                 Value *FalseVal);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1709</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1710</td>
    <td class="codeLine">  /// Given a value \p V, which is a select-like instruction (currently this is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1710</td>
    <td class="codeLine">  /// Given a value \p V, which is a select-like instruction (currently this is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1711</td>
    <td class="codeLine">  /// either a select instruction or a phi node), which is assumed equivalent to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1711</td>
    <td class="codeLine">  /// either a select instruction or a phi node), which is assumed equivalent to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1712</td>
    <td class="codeLine">  ///   Cond ? TrueVal : FalseVal</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1712</td>
    <td class="codeLine">  ///   Cond ? TrueVal : FalseVal</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1713</td>
    <td class="codeLine">  /// see if we can model it as a SCEV expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1713</td>
    <td class="codeLine">  /// see if we can model it as a SCEV expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1714</td>
    <td class="codeLine">  const SCEV *createNodeForSelectOrPHI(Value *V, Value *Cond, Value *TrueVal,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1714</td>
    <td class="codeLine">  const SCEV *createNodeForSelectOrPHI(Value *V, Value *Cond, Value *TrueVal,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1715</td>
    <td class="codeLine">                                       Value *FalseVal);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1715</td>
    <td class="codeLine">                                       Value *FalseVal);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1716</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1717</td>
    <td class="codeLine">  /// Provide the special handling we need to analyze GEP SCEVs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1717</td>
    <td class="codeLine">  /// Provide the special handling we need to analyze GEP SCEVs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1718</td>
    <td class="codeLine">  const SCEV *createNodeForGEP(GEPOperator *GEP);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1718</td>
    <td class="codeLine">  const SCEV *createNodeForGEP(GEPOperator *GEP);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1719</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1720</td>
    <td class="codeLine">  /// Implementation code for getSCEVAtScope; called at most once for each</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1720</td>
    <td class="codeLine">  /// Implementation code for getSCEVAtScope; called at most once for each</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1721</td>
    <td class="codeLine">  /// SCEV+Loop pair.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1721</td>
    <td class="codeLine">  /// SCEV+Loop pair.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1722</td>
    <td class="codeLine">  const SCEV *computeSCEVAtScope(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1722</td>
    <td class="codeLine">  const SCEV *computeSCEVAtScope(const SCEV *S, const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1723</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1724</td>
    <td class="codeLine">  /// Return the BackedgeTakenInfo for the given loop, lazily computing new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1724</td>
    <td class="codeLine">  /// Return the BackedgeTakenInfo for the given loop, lazily computing new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1725</td>
    <td class="codeLine">  /// values if the loop hasn't been analyzed yet. The returned result is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1725</td>
    <td class="codeLine">  /// values if the loop hasn't been analyzed yet. The returned result is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1726</td>
    <td class="codeLine">  /// guaranteed not to be predicated.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1726</td>
    <td class="codeLine">  /// guaranteed not to be predicated.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1727</td>
    <td class="codeLine">  BackedgeTakenInfo &getBackedgeTakenInfo(const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1727</td>
    <td class="codeLine">  BackedgeTakenInfo &getBackedgeTakenInfo(const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1728</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1729</td>
    <td class="codeLine">  /// Similar to getBackedgeTakenInfo, but will add predicates as required</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1729</td>
    <td class="codeLine">  /// Similar to getBackedgeTakenInfo, but will add predicates as required</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1730</td>
    <td class="codeLine">  /// with the purpose of returning complete information.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1730</td>
    <td class="codeLine">  /// with the purpose of returning complete information.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1731</td>
    <td class="codeLine">  const BackedgeTakenInfo &getPredicatedBackedgeTakenInfo(const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1731</td>
    <td class="codeLine">  const BackedgeTakenInfo &getPredicatedBackedgeTakenInfo(const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1732</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1733</td>
    <td class="codeLine">  /// Compute the number of times the specified loop will iterate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1733</td>
    <td class="codeLine">  /// Compute the number of times the specified loop will iterate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1734</td>
    <td class="codeLine">  /// If AllowPredicates is set, we will create new SCEV predicates as</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1734</td>
    <td class="codeLine">  /// If AllowPredicates is set, we will create new SCEV predicates as</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1735</td>
    <td class="codeLine">  /// necessary in order to return an exact answer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1735</td>
    <td class="codeLine">  /// necessary in order to return an exact answer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1736</td>
    <td class="codeLine">  BackedgeTakenInfo computeBackedgeTakenCount(const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1736</td>
    <td class="codeLine">  BackedgeTakenInfo computeBackedgeTakenCount(const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1737</td>
    <td class="codeLine">                                              bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1737</td>
    <td class="codeLine">                                              bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1738</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1739</td>
    <td class="codeLine">  /// Compute the number of times the backedge of the specified loop will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1739</td>
    <td class="codeLine">  /// Compute the number of times the backedge of the specified loop will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1740</td>
    <td class="codeLine">  /// execute if it exits via the specified block. If AllowPredicates is set,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1740</td>
    <td class="codeLine">  /// execute if it exits via the specified block. If AllowPredicates is set,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1741</td>
    <td class="codeLine">  /// this call will try to use a minimal set of SCEV predicates in order to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1741</td>
    <td class="codeLine">  /// this call will try to use a minimal set of SCEV predicates in order to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1742</td>
    <td class="codeLine">  /// return an exact answer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1742</td>
    <td class="codeLine">  /// return an exact answer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1743</td>
    <td class="codeLine">  ExitLimit computeExitLimit(const Loop *L, BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1743</td>
    <td class="codeLine">  ExitLimit computeExitLimit(const Loop *L, BasicBlock *ExitingBlock,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1744</td>
    <td class="codeLine">                             bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1744</td>
    <td class="codeLine">                             bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1745</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1746</td>
    <td class="codeLine">  /// Return a symbolic upper bound for the backedge taken count of the loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1746</td>
    <td class="codeLine">  /// Return a symbolic upper bound for the backedge taken count of the loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1747</td>
    <td class="codeLine">  /// This is more general than getConstantMaxBackedgeTakenCount as it returns</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1747</td>
    <td class="codeLine">  /// This is more general than getConstantMaxBackedgeTakenCount as it returns</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1748</td>
    <td class="codeLine">  /// an arbitrary expression as opposed to only constants.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1748</td>
    <td class="codeLine">  /// an arbitrary expression as opposed to only constants.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1749</td>
    <td class="codeLine">  const SCEV *computeSymbolicMaxBackedgeTakenCount(const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1749</td>
    <td class="codeLine">  const SCEV *computeSymbolicMaxBackedgeTakenCount(const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1750</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1751</td>
    <td class="codeLine">  // Helper functions for computeExitLimitFromCond to avoid exponential time</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1751</td>
    <td class="codeLine">  // Helper functions for computeExitLimitFromCond to avoid exponential time</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1752</td>
    <td class="codeLine">  // complexity.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1752</td>
    <td class="codeLine">  // complexity.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1753</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1754</td>
    <td class="codeLine">  class ExitLimitCache {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1754</td>
    <td class="codeLine">  class ExitLimitCache {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1755</td>
    <td class="codeLine">    // It may look like we need key on the whole (L, ExitIfTrue,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1755</td>
    <td class="codeLine">    // It may look like we need key on the whole (L, ExitIfTrue,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1756</td>
    <td class="codeLine">    // ControlsOnlyExit, AllowPredicates) tuple, but recursive calls to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1756</td>
    <td class="codeLine">    // ControlsOnlyExit, AllowPredicates) tuple, but recursive calls to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1757</td>
    <td class="codeLine">    // computeExitLimitFromCondCached from computeExitLimitFromCondImpl only</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1757</td>
    <td class="codeLine">    // computeExitLimitFromCondCached from computeExitLimitFromCondImpl only</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1758</td>
    <td class="codeLine">    // vary the in \c ExitCond and \c ControlsOnlyExit parameters.  We remember</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1758</td>
    <td class="codeLine">    // vary the in \c ExitCond and \c ControlsOnlyExit parameters.  We remember</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1759</td>
    <td class="codeLine">    // the initial values of the other values to assert our assumption.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1759</td>
    <td class="codeLine">    // the initial values of the other values to assert our assumption.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1760</td>
    <td class="codeLine">    SmallDenseMap<PointerIntPair<Value *, 1>, ExitLimit> TripCountMap;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1760</td>
    <td class="codeLine">    SmallDenseMap<PointerIntPair<Value *, 1>, ExitLimit> TripCountMap;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1761</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1762</td>
    <td class="codeLine">    const Loop *L;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1762</td>
    <td class="codeLine">    const Loop *L;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1763</td>
    <td class="codeLine">    bool ExitIfTrue;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1763</td>
    <td class="codeLine">    bool ExitIfTrue;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1764</td>
    <td class="codeLine">    bool AllowPredicates;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1764</td>
    <td class="codeLine">    bool AllowPredicates;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1765</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1766</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1766</td>
    <td class="codeLine">  public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1767</td>
    <td class="codeLine">    ExitLimitCache(const Loop *L, bool ExitIfTrue, bool AllowPredicates)</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1767</td>
    <td class="codeLine">    ExitLimitCache(const Loop *L, bool ExitIfTrue, bool AllowPredicates)</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1768</td>
    <td class="codeLine">        : L(L), ExitIfTrue(ExitIfTrue), AllowPredicates(AllowPredicates) {}</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">1768</td>
    <td class="codeLine">        : L(L), ExitIfTrue(ExitIfTrue), AllowPredicates(AllowPredicates) {}</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1769</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1769</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1770</td>
    <td class="codeLine">    std::optional<ExitLimit> find(const Loop *L, Value *ExitCond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1770</td>
    <td class="codeLine">    std::optional<ExitLimit> find(const Loop *L, Value *ExitCond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1771</td>
    <td class="codeLine">                                  bool ExitIfTrue, bool ControlsOnlyExit,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1771</td>
    <td class="codeLine">                                  bool ExitIfTrue, bool ControlsOnlyExit,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1772</td>
    <td class="codeLine">                                  bool AllowPredicates);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1772</td>
    <td class="codeLine">                                  bool AllowPredicates);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1773</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1774</td>
    <td class="codeLine">    void insert(const Loop *L, Value *ExitCond, bool ExitIfTrue,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1774</td>
    <td class="codeLine">    void insert(const Loop *L, Value *ExitCond, bool ExitIfTrue,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1775</td>
    <td class="codeLine">                bool ControlsOnlyExit, bool AllowPredicates,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1775</td>
    <td class="codeLine">                bool ControlsOnlyExit, bool AllowPredicates,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1776</td>
    <td class="codeLine">                const ExitLimit &EL);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1776</td>
    <td class="codeLine">                const ExitLimit &EL);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1777</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1777</td>
    <td class="codeLine">  };</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1778</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1779</td>
    <td class="codeLine">  using ExitLimitCacheTy = ExitLimitCache;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1779</td>
    <td class="codeLine">  using ExitLimitCacheTy = ExitLimitCache;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1780</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1781</td>
    <td class="codeLine">  ExitLimit computeExitLimitFromCondCached(ExitLimitCacheTy &Cache,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1781</td>
    <td class="codeLine">  ExitLimit computeExitLimitFromCondCached(ExitLimitCacheTy &Cache,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1782</td>
    <td class="codeLine">                                           const Loop *L, Value *ExitCond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1782</td>
    <td class="codeLine">                                           const Loop *L, Value *ExitCond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1783</td>
    <td class="codeLine">                                           bool ExitIfTrue,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1783</td>
    <td class="codeLine">                                           bool ExitIfTrue,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1784</td>
    <td class="codeLine">                                           bool ControlsOnlyExit,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1784</td>
    <td class="codeLine">                                           bool ControlsOnlyExit,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1785</td>
    <td class="codeLine">                                           bool AllowPredicates);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1785</td>
    <td class="codeLine">                                           bool AllowPredicates);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1786</td>
    <td class="codeLine">  ExitLimit computeExitLimitFromCondImpl(ExitLimitCacheTy &Cache, const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1786</td>
    <td class="codeLine">  ExitLimit computeExitLimitFromCondImpl(ExitLimitCacheTy &Cache, const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1787</td>
    <td class="codeLine">                                         Value *ExitCond, bool ExitIfTrue,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1787</td>
    <td class="codeLine">                                         Value *ExitCond, bool ExitIfTrue,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1788</td>
    <td class="codeLine">                                         bool ControlsOnlyExit,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1788</td>
    <td class="codeLine">                                         bool ControlsOnlyExit,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1789</td>
    <td class="codeLine">                                         bool AllowPredicates);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1789</td>
    <td class="codeLine">                                         bool AllowPredicates);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1790</td>
    <td class="codeLine">  std::optional<ScalarEvolution::ExitLimit> computeExitLimitFromCondFromBinOp(</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1790</td>
    <td class="codeLine">  std::optional<ScalarEvolution::ExitLimit> computeExitLimitFromCondFromBinOp(</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1791</td>
    <td class="codeLine">      ExitLimitCacheTy &Cache, const Loop *L, Value *ExitCond, bool ExitIfTrue,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1791</td>
    <td class="codeLine">      ExitLimitCacheTy &Cache, const Loop *L, Value *ExitCond, bool ExitIfTrue,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1792</td>
    <td class="codeLine">      bool ControlsOnlyExit, bool AllowPredicates);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1792</td>
    <td class="codeLine">      bool ControlsOnlyExit, bool AllowPredicates);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1793</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1793</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1794</td>
    <td class="codeLine">  /// Compute the number of times the backedge of the specified loop will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1794</td>
    <td class="codeLine">  /// Compute the number of times the backedge of the specified loop will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1795</td>
    <td class="codeLine">  /// execute if its exit condition were a conditional branch of the ICmpInst</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1795</td>
    <td class="codeLine">  /// execute if its exit condition were a conditional branch of the ICmpInst</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1796</td>
    <td class="codeLine">  /// ExitCond and ExitIfTrue. If AllowPredicates is set, this call will try</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1796</td>
    <td class="codeLine">  /// ExitCond and ExitIfTrue. If AllowPredicates is set, this call will try</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1797</td>
    <td class="codeLine">  /// to use a minimal set of SCEV predicates in order to return an exact</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1797</td>
    <td class="codeLine">  /// to use a minimal set of SCEV predicates in order to return an exact</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1798</td>
    <td class="codeLine">  /// answer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1798</td>
    <td class="codeLine">  /// answer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1799</td>
    <td class="codeLine">  ExitLimit computeExitLimitFromICmp(const Loop *L, ICmpInst *ExitCond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1799</td>
    <td class="codeLine">  ExitLimit computeExitLimitFromICmp(const Loop *L, ICmpInst *ExitCond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1800</td>
    <td class="codeLine">                                     bool ExitIfTrue,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1800</td>
    <td class="codeLine">                                     bool ExitIfTrue,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1801</td>
    <td class="codeLine">                                     bool IsSubExpr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1801</td>
    <td class="codeLine">                                     bool IsSubExpr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1802</td>
    <td class="codeLine">                                     bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1802</td>
    <td class="codeLine">                                     bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1803</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1804</td>
    <td class="codeLine">  /// Variant of previous which takes the components representing an ICmp</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1804</td>
    <td class="codeLine">  /// Variant of previous which takes the components representing an ICmp</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1805</td>
    <td class="codeLine">  /// as opposed to the ICmpInst itself.  Note that the prior version can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1805</td>
    <td class="codeLine">  /// as opposed to the ICmpInst itself.  Note that the prior version can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1806</td>
    <td class="codeLine">  /// return more precise results in some cases and is preferred when caller</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1806</td>
    <td class="codeLine">  /// return more precise results in some cases and is preferred when caller</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1807</td>
    <td class="codeLine">  /// has a materialized ICmp.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1807</td>
    <td class="codeLine">  /// has a materialized ICmp.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1808</td>
    <td class="codeLine">  ExitLimit computeExitLimitFromICmp(const Loop *L, ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1808</td>
    <td class="codeLine">  ExitLimit computeExitLimitFromICmp(const Loop *L, ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1809</td>
    <td class="codeLine">                                     const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1809</td>
    <td class="codeLine">                                     const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1810</td>
    <td class="codeLine">                                     bool IsSubExpr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1810</td>
    <td class="codeLine">                                     bool IsSubExpr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1811</td>
    <td class="codeLine">                                     bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1811</td>
    <td class="codeLine">                                     bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1812</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1813</td>
    <td class="codeLine">  /// Compute the number of times the backedge of the specified loop will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1813</td>
    <td class="codeLine">  /// Compute the number of times the backedge of the specified loop will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1814</td>
    <td class="codeLine">  /// execute if its exit condition were a switch with a single exiting case</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1814</td>
    <td class="codeLine">  /// execute if its exit condition were a switch with a single exiting case</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1815</td>
    <td class="codeLine">  /// to ExitingBB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1815</td>
    <td class="codeLine">  /// to ExitingBB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1816</td>
    <td class="codeLine">  ExitLimit computeExitLimitFromSingleExitSwitch(const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1816</td>
    <td class="codeLine">  ExitLimit computeExitLimitFromSingleExitSwitch(const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1817</td>
    <td class="codeLine">                                                 SwitchInst *Switch,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1817</td>
    <td class="codeLine">                                                 SwitchInst *Switch,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1818</td>
    <td class="codeLine">                                                 BasicBlock *ExitingBB,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1818</td>
    <td class="codeLine">                                                 BasicBlock *ExitingBB,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1819</td>
    <td class="codeLine">                                                 bool IsSubExpr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1819</td>
    <td class="codeLine">                                                 bool IsSubExpr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1820</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1821</td>
    <td class="codeLine">  /// Compute the exit limit of a loop that is controlled by a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1821</td>
    <td class="codeLine">  /// Compute the exit limit of a loop that is controlled by a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1822</td>
    <td class="codeLine">  /// "(IV >> 1) != 0" type comparison.  We cannot compute the exact trip</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1822</td>
    <td class="codeLine">  /// "(IV >> 1) != 0" type comparison.  We cannot compute the exact trip</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1823</td>
    <td class="codeLine">  /// count in these cases (since SCEV has no way of expressing them), but we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1823</td>
    <td class="codeLine">  /// count in these cases (since SCEV has no way of expressing them), but we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1824</td>
    <td class="codeLine">  /// can still sometimes compute an upper bound.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1824</td>
    <td class="codeLine">  /// can still sometimes compute an upper bound.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1825</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1825</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1826</td>
    <td class="codeLine">  /// Return an ExitLimit for a loop whose backedge is guarded by `LHS Pred</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1826</td>
    <td class="codeLine">  /// Return an ExitLimit for a loop whose backedge is guarded by `LHS Pred</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1827</td>
    <td class="codeLine">  /// RHS`.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1827</td>
    <td class="codeLine">  /// RHS`.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1828</td>
    <td class="codeLine">  ExitLimit computeShiftCompareExitLimit(Value *LHS, Value *RHS, const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1828</td>
    <td class="codeLine">  ExitLimit computeShiftCompareExitLimit(Value *LHS, Value *RHS, const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1829</td>
    <td class="codeLine">                                         ICmpInst::Predicate Pred);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1829</td>
    <td class="codeLine">                                         ICmpInst::Predicate Pred);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1830</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1831</td>
    <td class="codeLine">  /// If the loop is known to execute a constant number of times (the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1831</td>
    <td class="codeLine">  /// If the loop is known to execute a constant number of times (the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1832</td>
    <td class="codeLine">  /// condition evolves only from constants), try to evaluate a few iterations</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1832</td>
    <td class="codeLine">  /// condition evolves only from constants), try to evaluate a few iterations</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1833</td>
    <td class="codeLine">  /// of the loop until we get the exit condition gets a value of ExitWhen</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1833</td>
    <td class="codeLine">  /// of the loop until we get the exit condition gets a value of ExitWhen</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1834</td>
    <td class="codeLine">  /// (true or false).  If we cannot evaluate the exit count of the loop,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1834</td>
    <td class="codeLine">  /// (true or false).  If we cannot evaluate the exit count of the loop,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1835</td>
    <td class="codeLine">  /// return CouldNotCompute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1835</td>
    <td class="codeLine">  /// return CouldNotCompute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1836</td>
    <td class="codeLine">  const SCEV *computeExitCountExhaustively(const Loop *L, Value *Cond,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1836</td>
    <td class="codeLine">  const SCEV *computeExitCountExhaustively(const Loop *L, Value *Cond,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1837</td>
    <td class="codeLine">                                           bool ExitWhen);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1837</td>
    <td class="codeLine">                                           bool ExitWhen);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1838</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1838</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1839</td>
    <td class="codeLine">  /// Return the number of times an exit condition comparing the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1839</td>
    <td class="codeLine">  /// Return the number of times an exit condition comparing the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1840</td>
    <td class="codeLine">  /// value to zero will execute.  If not computable, return CouldNotCompute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1840</td>
    <td class="codeLine">  /// value to zero will execute.  If not computable, return CouldNotCompute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1841</td>
    <td class="codeLine">  /// If AllowPredicates is set, this call will try to use a minimal set of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1841</td>
    <td class="codeLine">  /// If AllowPredicates is set, this call will try to use a minimal set of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1842</td>
    <td class="codeLine">  /// SCEV predicates in order to return an exact answer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1842</td>
    <td class="codeLine">  /// SCEV predicates in order to return an exact answer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1843</td>
    <td class="codeLine">  ExitLimit howFarToZero(const SCEV *V, const Loop *L, bool IsSubExpr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1843</td>
    <td class="codeLine">  ExitLimit howFarToZero(const SCEV *V, const Loop *L, bool IsSubExpr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1844</td>
    <td class="codeLine">                         bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1844</td>
    <td class="codeLine">                         bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1845</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1846</td>
    <td class="codeLine">  /// Return the number of times an exit condition checking the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1846</td>
    <td class="codeLine">  /// Return the number of times an exit condition checking the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1847</td>
    <td class="codeLine">  /// value for nonzero will execute.  If not computable, return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1847</td>
    <td class="codeLine">  /// value for nonzero will execute.  If not computable, return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1848</td>
    <td class="codeLine">  /// CouldNotCompute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1848</td>
    <td class="codeLine">  /// CouldNotCompute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1849</td>
    <td class="codeLine">  ExitLimit howFarToNonZero(const SCEV *V, const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1849</td>
    <td class="codeLine">  ExitLimit howFarToNonZero(const SCEV *V, const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1850</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1851</td>
    <td class="codeLine">  /// Return the number of times an exit condition containing the specified</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1851</td>
    <td class="codeLine">  /// Return the number of times an exit condition containing the specified</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1852</td>
    <td class="codeLine">  /// less-than comparison will execute.  If not computable, return</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1852</td>
    <td class="codeLine">  /// less-than comparison will execute.  If not computable, return</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1853</td>
    <td class="codeLine">  /// CouldNotCompute.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1853</td>
    <td class="codeLine">  /// CouldNotCompute.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1854</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1854</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1855</td>
    <td class="codeLine">  /// \p isSigned specifies whether the less-than is signed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1855</td>
    <td class="codeLine">  /// \p isSigned specifies whether the less-than is signed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1856</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1856</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1857</td>
    <td class="codeLine">  /// \p ControlsOnlyExit is true when the LHS < RHS condition directly controls</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1857</td>
    <td class="codeLine">  /// \p ControlsOnlyExit is true when the LHS < RHS condition directly controls</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1858</td>
    <td class="codeLine">  /// the branch (loops exits only if condition is true). In this case, we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1858</td>
    <td class="codeLine">  /// the branch (loops exits only if condition is true). In this case, we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1859</td>
    <td class="codeLine">  /// use NoWrapFlags to skip overflow checks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1859</td>
    <td class="codeLine">  /// use NoWrapFlags to skip overflow checks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1860</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1860</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1861</td>
    <td class="codeLine">  /// If \p AllowPredicates is set, this call will try to use a minimal set of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1861</td>
    <td class="codeLine">  /// If \p AllowPredicates is set, this call will try to use a minimal set of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1862</td>
    <td class="codeLine">  /// SCEV predicates in order to return an exact answer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1862</td>
    <td class="codeLine">  /// SCEV predicates in order to return an exact answer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1863</td>
    <td class="codeLine">  ExitLimit howManyLessThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1863</td>
    <td class="codeLine">  ExitLimit howManyLessThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1864</td>
    <td class="codeLine">                             bool isSigned, bool ControlsOnlyExit,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1864</td>
    <td class="codeLine">                             bool isSigned, bool ControlsOnlyExit,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1865</td>
    <td class="codeLine">                             bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1865</td>
    <td class="codeLine">                             bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1866</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1867</td>
    <td class="codeLine">  ExitLimit howManyGreaterThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1867</td>
    <td class="codeLine">  ExitLimit howManyGreaterThans(const SCEV *LHS, const SCEV *RHS, const Loop *L,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1868</td>
    <td class="codeLine">                                bool isSigned, bool IsSubExpr,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1868</td>
    <td class="codeLine">                                bool isSigned, bool IsSubExpr,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1869</td>
    <td class="codeLine">                                bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1869</td>
    <td class="codeLine">                                bool AllowPredicates = false);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1870</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1870</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1871</td>
    <td class="codeLine">  /// Return a predecessor of BB (which may not be an immediate predecessor)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1871</td>
    <td class="codeLine">  /// Return a predecessor of BB (which may not be an immediate predecessor)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1872</td>
    <td class="codeLine">  /// which has exactly one successor from which BB is reachable, or null if</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1872</td>
    <td class="codeLine">  /// which has exactly one successor from which BB is reachable, or null if</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1873</td>
    <td class="codeLine">  /// no such block is found.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1873</td>
    <td class="codeLine">  /// no such block is found.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1874</td>
    <td class="codeLine">  std::pair<const BasicBlock *, const BasicBlock *></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1874</td>
    <td class="codeLine">  std::pair<const BasicBlock *, const BasicBlock *></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1875</td>
    <td class="codeLine">  getPredecessorWithUniqueSuccessorForBB(const BasicBlock *BB) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1875</td>
    <td class="codeLine">  getPredecessorWithUniqueSuccessorForBB(const BasicBlock *BB) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1876</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1877</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1877</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1878</td>
    <td class="codeLine">  /// whenever the given FoundCondValue value evaluates to true in given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1878</td>
    <td class="codeLine">  /// whenever the given FoundCondValue value evaluates to true in given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1879</td>
    <td class="codeLine">  /// Context. If Context is nullptr, then the found predicate is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1879</td>
    <td class="codeLine">  /// Context. If Context is nullptr, then the found predicate is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1880</td>
    <td class="codeLine">  /// everywhere. LHS and FoundLHS may have different type width.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1880</td>
    <td class="codeLine">  /// everywhere. LHS and FoundLHS may have different type width.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1881</td>
    <td class="codeLine">  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1881</td>
    <td class="codeLine">  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1882</td>
    <td class="codeLine">                     const Value *FoundCondValue, bool Inverse,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1882</td>
    <td class="codeLine">                     const Value *FoundCondValue, bool Inverse,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1883</td>
    <td class="codeLine">                     const Instruction *Context = nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1883</td>
    <td class="codeLine">                     const Instruction *Context = nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1884</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1885</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1885</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1886</td>
    <td class="codeLine">  /// whenever the given FoundCondValue value evaluates to true in given</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1886</td>
    <td class="codeLine">  /// whenever the given FoundCondValue value evaluates to true in given</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1887</td>
    <td class="codeLine">  /// Context. If Context is nullptr, then the found predicate is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1887</td>
    <td class="codeLine">  /// Context. If Context is nullptr, then the found predicate is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1888</td>
    <td class="codeLine">  /// everywhere. LHS and FoundLHS must have same type width.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1888</td>
    <td class="codeLine">  /// everywhere. LHS and FoundLHS must have same type width.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1889</td>
    <td class="codeLine">  bool isImpliedCondBalancedTypes(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1889</td>
    <td class="codeLine">  bool isImpliedCondBalancedTypes(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1890</td>
    <td class="codeLine">                                  const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1890</td>
    <td class="codeLine">                                  const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1891</td>
    <td class="codeLine">                                  ICmpInst::Predicate FoundPred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1891</td>
    <td class="codeLine">                                  ICmpInst::Predicate FoundPred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1892</td>
    <td class="codeLine">                                  const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1892</td>
    <td class="codeLine">                                  const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1893</td>
    <td class="codeLine">                                  const Instruction *CtxI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1893</td>
    <td class="codeLine">                                  const Instruction *CtxI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1894</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1895</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1895</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1896</td>
    <td class="codeLine">  /// whenever the condition described by FoundPred, FoundLHS, FoundRHS is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1896</td>
    <td class="codeLine">  /// whenever the condition described by FoundPred, FoundLHS, FoundRHS is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1897</td>
    <td class="codeLine">  /// true in given Context. If Context is nullptr, then the found predicate is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1897</td>
    <td class="codeLine">  /// true in given Context. If Context is nullptr, then the found predicate is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1898</td>
    <td class="codeLine">  /// true everywhere.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1898</td>
    <td class="codeLine">  /// true everywhere.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1899</td>
    <td class="codeLine">  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1899</td>
    <td class="codeLine">  bool isImpliedCond(ICmpInst::Predicate Pred, const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1900</td>
    <td class="codeLine">                     ICmpInst::Predicate FoundPred, const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1900</td>
    <td class="codeLine">                     ICmpInst::Predicate FoundPred, const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1901</td>
    <td class="codeLine">                     const SCEV *FoundRHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1901</td>
    <td class="codeLine">                     const SCEV *FoundRHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1902</td>
    <td class="codeLine">                     const Instruction *Context = nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1902</td>
    <td class="codeLine">                     const Instruction *Context = nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1903</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1903</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1904</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1904</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1905</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1905</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1906</td>
    <td class="codeLine">  /// true in given Context. If Context is nullptr, then the found predicate is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1906</td>
    <td class="codeLine">  /// true in given Context. If Context is nullptr, then the found predicate is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1907</td>
    <td class="codeLine">  /// true everywhere.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1907</td>
    <td class="codeLine">  /// true everywhere.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1908</td>
    <td class="codeLine">  bool isImpliedCondOperands(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1908</td>
    <td class="codeLine">  bool isImpliedCondOperands(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1909</td>
    <td class="codeLine">                             const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1909</td>
    <td class="codeLine">                             const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1910</td>
    <td class="codeLine">                             const SCEV *FoundRHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1910</td>
    <td class="codeLine">                             const SCEV *FoundRHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1911</td>
    <td class="codeLine">                             const Instruction *Context = nullptr);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1911</td>
    <td class="codeLine">                             const Instruction *Context = nullptr);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1912</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1913</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1913</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1914</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1914</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1915</td>
    <td class="codeLine">  /// true. Here LHS is an operation that includes FoundLHS as one of its</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1915</td>
    <td class="codeLine">  /// true. Here LHS is an operation that includes FoundLHS as one of its</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1916</td>
    <td class="codeLine">  /// arguments.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1916</td>
    <td class="codeLine">  /// arguments.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1917</td>
    <td class="codeLine">  bool isImpliedViaOperations(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1917</td>
    <td class="codeLine">  bool isImpliedViaOperations(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1918</td>
    <td class="codeLine">                              const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1918</td>
    <td class="codeLine">                              const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1919</td>
    <td class="codeLine">                              const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1919</td>
    <td class="codeLine">                              const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1920</td>
    <td class="codeLine">                              unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1920</td>
    <td class="codeLine">                              unsigned Depth = 0);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1921</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1921</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1922</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1922</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1923</td>
    <td class="codeLine">  /// Use only simple non-recursive types of checks, such as range analysis etc.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1923</td>
    <td class="codeLine">  /// Use only simple non-recursive types of checks, such as range analysis etc.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1924</td>
    <td class="codeLine">  bool isKnownViaNonRecursiveReasoning(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1924</td>
    <td class="codeLine">  bool isKnownViaNonRecursiveReasoning(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1925</td>
    <td class="codeLine">                                       const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1925</td>
    <td class="codeLine">                                       const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1926</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1927</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1927</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1928</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1928</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1929</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1929</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1930</td>
    <td class="codeLine">  bool isImpliedCondOperandsHelper(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1930</td>
    <td class="codeLine">  bool isImpliedCondOperandsHelper(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1931</td>
    <td class="codeLine">                                   const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1931</td>
    <td class="codeLine">                                   const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1932</td>
    <td class="codeLine">                                   const SCEV *FoundRHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1932</td>
    <td class="codeLine">                                   const SCEV *FoundRHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1933</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1934</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1934</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1935</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1935</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1936</td>
    <td class="codeLine">  /// true.  Utility function used by isImpliedCondOperands.  Tries to get</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1936</td>
    <td class="codeLine">  /// true.  Utility function used by isImpliedCondOperands.  Tries to get</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1937</td>
    <td class="codeLine">  /// cases like "X `sgt` 0 => X - 1 `sgt` -1".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1937</td>
    <td class="codeLine">  /// cases like "X `sgt` 0 => X - 1 `sgt` -1".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1938</td>
    <td class="codeLine">  bool isImpliedCondOperandsViaRanges(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1938</td>
    <td class="codeLine">  bool isImpliedCondOperandsViaRanges(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1939</td>
    <td class="codeLine">                                      const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1939</td>
    <td class="codeLine">                                      const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1940</td>
    <td class="codeLine">                                      const SCEV *FoundRHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1940</td>
    <td class="codeLine">                                      const SCEV *FoundRHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1941</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1942</td>
    <td class="codeLine">  /// Return true if the condition denoted by \p LHS \p Pred \p RHS is implied</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1942</td>
    <td class="codeLine">  /// Return true if the condition denoted by \p LHS \p Pred \p RHS is implied</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1943</td>
    <td class="codeLine">  /// by a call to @llvm.experimental.guard in \p BB.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1943</td>
    <td class="codeLine">  /// by a call to @llvm.experimental.guard in \p BB.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1944</td>
    <td class="codeLine">  bool isImpliedViaGuard(const BasicBlock *BB, ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1944</td>
    <td class="codeLine">  bool isImpliedViaGuard(const BasicBlock *BB, ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1945</td>
    <td class="codeLine">                         const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1945</td>
    <td class="codeLine">                         const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1946</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1947</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1947</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1948</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1948</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1949</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1949</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1950</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1950</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1951</td>
    <td class="codeLine">  /// This routine tries to rule out certain kinds of integer overflow, and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1951</td>
    <td class="codeLine">  /// This routine tries to rule out certain kinds of integer overflow, and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1952</td>
    <td class="codeLine">  /// then tries to reason about arithmetic properties of the predicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1952</td>
    <td class="codeLine">  /// then tries to reason about arithmetic properties of the predicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1953</td>
    <td class="codeLine">  bool isImpliedCondOperandsViaNoOverflow(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1953</td>
    <td class="codeLine">  bool isImpliedCondOperandsViaNoOverflow(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1954</td>
    <td class="codeLine">                                          const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1954</td>
    <td class="codeLine">                                          const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1955</td>
    <td class="codeLine">                                          const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1955</td>
    <td class="codeLine">                                          const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1956</td>
    <td class="codeLine">                                          const SCEV *FoundRHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1956</td>
    <td class="codeLine">                                          const SCEV *FoundRHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1957</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1957</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1958</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1958</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1959</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1959</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1960</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1960</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1961</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1961</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1962</td>
    <td class="codeLine">  /// This routine tries to weaken the known condition basing on fact that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1962</td>
    <td class="codeLine">  /// This routine tries to weaken the known condition basing on fact that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1963</td>
    <td class="codeLine">  /// FoundLHS is an AddRec.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1963</td>
    <td class="codeLine">  /// FoundLHS is an AddRec.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1964</td>
    <td class="codeLine">  bool isImpliedCondOperandsViaAddRecStart(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1964</td>
    <td class="codeLine">  bool isImpliedCondOperandsViaAddRecStart(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1965</td>
    <td class="codeLine">                                           const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1965</td>
    <td class="codeLine">                                           const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1966</td>
    <td class="codeLine">                                           const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1966</td>
    <td class="codeLine">                                           const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1967</td>
    <td class="codeLine">                                           const SCEV *FoundRHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1967</td>
    <td class="codeLine">                                           const SCEV *FoundRHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1968</td>
    <td class="codeLine">                                           const Instruction *CtxI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1968</td>
    <td class="codeLine">                                           const Instruction *CtxI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1969</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1969</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1970</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1970</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1971</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1971</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1972</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1972</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1973</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1973</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1974</td>
    <td class="codeLine">  /// This routine tries to figure out predicate for Phis which are SCEVUnknown</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1974</td>
    <td class="codeLine">  /// This routine tries to figure out predicate for Phis which are SCEVUnknown</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1975</td>
    <td class="codeLine">  /// if it is true for every possible incoming value from their respective</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1975</td>
    <td class="codeLine">  /// if it is true for every possible incoming value from their respective</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1976</td>
    <td class="codeLine">  /// basic blocks.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1976</td>
    <td class="codeLine">  /// basic blocks.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1977</td>
    <td class="codeLine">  bool isImpliedViaMerge(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1977</td>
    <td class="codeLine">  bool isImpliedViaMerge(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1978</td>
    <td class="codeLine">                         const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1978</td>
    <td class="codeLine">                         const SCEV *LHS, const SCEV *RHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1979</td>
    <td class="codeLine">                         const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1979</td>
    <td class="codeLine">                         const SCEV *FoundLHS, const SCEV *FoundRHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1980</td>
    <td class="codeLine">                         unsigned Depth);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1980</td>
    <td class="codeLine">                         unsigned Depth);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1981</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1981</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1982</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1982</td>
    <td class="codeLine">  /// Test whether the condition described by Pred, LHS, and RHS is true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1983</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1983</td>
    <td class="codeLine">  /// whenever the condition described by Pred, FoundLHS, and FoundRHS is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1984</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1984</td>
    <td class="codeLine">  /// true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1985</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1985</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1986</td>
    <td class="codeLine">  /// This routine tries to reason about shifts.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1986</td>
    <td class="codeLine">  /// This routine tries to reason about shifts.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1987</td>
    <td class="codeLine">  bool isImpliedCondOperandsViaShift(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1987</td>
    <td class="codeLine">  bool isImpliedCondOperandsViaShift(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1988</td>
    <td class="codeLine">                                     const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1988</td>
    <td class="codeLine">                                     const SCEV *RHS, const SCEV *FoundLHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1989</td>
    <td class="codeLine">                                     const SCEV *FoundRHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1989</td>
    <td class="codeLine">                                     const SCEV *FoundRHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1990</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1990</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1991</td>
    <td class="codeLine">  /// If we know that the specified Phi is in the header of its containing</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1991</td>
    <td class="codeLine">  /// If we know that the specified Phi is in the header of its containing</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1992</td>
    <td class="codeLine">  /// loop, we know the loop executes a constant number of times, and the PHI</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1992</td>
    <td class="codeLine">  /// loop, we know the loop executes a constant number of times, and the PHI</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1993</td>
    <td class="codeLine">  /// node is just a recurrence involving constants, fold it.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1993</td>
    <td class="codeLine">  /// node is just a recurrence involving constants, fold it.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1994</td>
    <td class="codeLine">  Constant *getConstantEvolutionLoopExitValue(PHINode *PN, const APInt &BEs,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1994</td>
    <td class="codeLine">  Constant *getConstantEvolutionLoopExitValue(PHINode *PN, const APInt &BEs,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1995</td>
    <td class="codeLine">                                              const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1995</td>
    <td class="codeLine">                                              const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1996</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1997</td>
    <td class="codeLine">  /// Test if the given expression is known to satisfy the condition described</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1997</td>
    <td class="codeLine">  /// Test if the given expression is known to satisfy the condition described</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1998</td>
    <td class="codeLine">  /// by Pred and the known constant ranges of LHS and RHS.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1998</td>
    <td class="codeLine">  /// by Pred and the known constant ranges of LHS and RHS.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">1999</td>
    <td class="codeLine">  bool isKnownPredicateViaConstantRanges(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">1999</td>
    <td class="codeLine">  bool isKnownPredicateViaConstantRanges(ICmpInst::Predicate Pred,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2000</td>
    <td class="codeLine">                                         const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2000</td>
    <td class="codeLine">                                         const SCEV *LHS, const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2001</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2002</td>
    <td class="codeLine">  /// Try to prove the condition described by "LHS Pred RHS" by ruling out</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2002</td>
    <td class="codeLine">  /// Try to prove the condition described by "LHS Pred RHS" by ruling out</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2003</td>
    <td class="codeLine">  /// integer overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2003</td>
    <td class="codeLine">  /// integer overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2004</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2004</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2005</td>
    <td class="codeLine">  /// For instance, this will return true for "A s< (A + C)<nsw>" if C is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2005</td>
    <td class="codeLine">  /// For instance, this will return true for "A s< (A + C)<nsw>" if C is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2006</td>
    <td class="codeLine">  /// positive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2006</td>
    <td class="codeLine">  /// positive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2007</td>
    <td class="codeLine">  bool isKnownPredicateViaNoOverflow(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2007</td>
    <td class="codeLine">  bool isKnownPredicateViaNoOverflow(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2008</td>
    <td class="codeLine">                                     const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2008</td>
    <td class="codeLine">                                     const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2009</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2010</td>
    <td class="codeLine">  /// Try to split Pred LHS RHS into logical conjunctions (and's) and try to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2010</td>
    <td class="codeLine">  /// Try to split Pred LHS RHS into logical conjunctions (and's) and try to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2011</td>
    <td class="codeLine">  /// prove them individually.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2011</td>
    <td class="codeLine">  /// prove them individually.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2012</td>
    <td class="codeLine">  bool isKnownPredicateViaSplitting(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2012</td>
    <td class="codeLine">  bool isKnownPredicateViaSplitting(ICmpInst::Predicate Pred, const SCEV *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2013</td>
    <td class="codeLine">                                    const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2013</td>
    <td class="codeLine">                                    const SCEV *RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2014</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2014</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2015</td>
    <td class="codeLine">  /// Try to match the Expr as "(L + R)<Flags>".</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2015</td>
    <td class="codeLine">  /// Try to match the Expr as "(L + R)<Flags>".</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2016</td>
    <td class="codeLine">  bool splitBinaryAdd(const SCEV *Expr, const SCEV *&L, const SCEV *&R,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2016</td>
    <td class="codeLine">  bool splitBinaryAdd(const SCEV *Expr, const SCEV *&L, const SCEV *&R,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2017</td>
    <td class="codeLine">                      SCEV::NoWrapFlags &Flags);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2017</td>
    <td class="codeLine">                      SCEV::NoWrapFlags &Flags);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2018</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2019</td>
    <td class="codeLine">  /// Forget predicated/non-predicated backedge taken counts for the given loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2019</td>
    <td class="codeLine">  /// Forget predicated/non-predicated backedge taken counts for the given loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2020</td>
    <td class="codeLine">  void forgetBackedgeTakenCounts(const Loop *L, bool Predicated);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2020</td>
    <td class="codeLine">  void forgetBackedgeTakenCounts(const Loop *L, bool Predicated);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2021</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2022</td>
    <td class="codeLine">  /// Drop memoized information for all \p SCEVs.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2022</td>
    <td class="codeLine">  /// Drop memoized information for all \p SCEVs.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2023</td>
    <td class="codeLine">  void forgetMemoizedResults(ArrayRef<const SCEV *> SCEVs);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2023</td>
    <td class="codeLine">  void forgetMemoizedResults(ArrayRef<const SCEV *> SCEVs);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2024</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2025</td>
    <td class="codeLine">  /// Helper for forgetMemoizedResults.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2025</td>
    <td class="codeLine">  /// Helper for forgetMemoizedResults.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2026</td>
    <td class="codeLine">  void forgetMemoizedResultsImpl(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2026</td>
    <td class="codeLine">  void forgetMemoizedResultsImpl(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2027</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2027</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2028</td>
    <td class="codeLine">  /// Iterate over instructions in \p Worklist and their users. Erase entries</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2028</td>
    <td class="codeLine">  /// Iterate over instructions in \p Worklist and their users. Erase entries</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2029</td>
    <td class="codeLine">  /// from ValueExprMap and collect SCEV expressions in \p ToForget</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2029</td>
    <td class="codeLine">  /// from ValueExprMap and collect SCEV expressions in \p ToForget</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2030</td>
    <td class="codeLine">  void visitAndClearUsers(SmallVectorImpl<Instruction *> &Worklist,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2030</td>
    <td class="codeLine">  void visitAndClearUsers(SmallVectorImpl<Instruction *> &Worklist,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2031</td>
    <td class="codeLine">                          SmallPtrSetImpl<Instruction *> &Visited,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2031</td>
    <td class="codeLine">                          SmallPtrSetImpl<Instruction *> &Visited,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2032</td>
    <td class="codeLine">                          SmallVectorImpl<const SCEV *> &ToForget);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2032</td>
    <td class="codeLine">                          SmallVectorImpl<const SCEV *> &ToForget);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2033</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2034</td>
    <td class="codeLine">  /// Erase Value from ValueExprMap and ExprValueMap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2034</td>
    <td class="codeLine">  /// Erase Value from ValueExprMap and ExprValueMap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2035</td>
    <td class="codeLine">  void eraseValueFromMap(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2035</td>
    <td class="codeLine">  void eraseValueFromMap(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2036</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2036</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2037</td>
    <td class="codeLine">  /// Insert V to S mapping into ValueExprMap and ExprValueMap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2037</td>
    <td class="codeLine">  /// Insert V to S mapping into ValueExprMap and ExprValueMap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2038</td>
    <td class="codeLine">  void insertValueToMap(Value *V, const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2038</td>
    <td class="codeLine">  void insertValueToMap(Value *V, const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2039</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2040</td>
    <td class="codeLine">  /// Return false iff given SCEV contains a SCEVUnknown with NULL value-</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2040</td>
    <td class="codeLine">  /// Return false iff given SCEV contains a SCEVUnknown with NULL value-</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2041</td>
    <td class="codeLine">  /// pointer.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2041</td>
    <td class="codeLine">  /// pointer.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2042</td>
    <td class="codeLine">  bool checkValidity(const SCEV *S) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2042</td>
    <td class="codeLine">  bool checkValidity(const SCEV *S) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2043</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2044</td>
    <td class="codeLine">  /// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2044</td>
    <td class="codeLine">  /// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2045</td>
    <td class="codeLine">  /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}.  This is</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2045</td>
    <td class="codeLine">  /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}.  This is</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2046</td>
    <td class="codeLine">  /// equivalent to proving no signed (resp. unsigned) wrap in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2046</td>
    <td class="codeLine">  /// equivalent to proving no signed (resp. unsigned) wrap in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2047</td>
    <td class="codeLine">  /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2047</td>
    <td class="codeLine">  /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2048</td>
    <td class="codeLine">  /// (resp. `SCEVZeroExtendExpr`).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2048</td>
    <td class="codeLine">  /// (resp. `SCEVZeroExtendExpr`).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2049</td>
    <td class="codeLine">  template <typename ExtendOpTy></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2049</td>
    <td class="codeLine">  template <typename ExtendOpTy></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2050</td>
    <td class="codeLine">  bool proveNoWrapByVaryingStart(const SCEV *Start, const SCEV *Step,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2050</td>
    <td class="codeLine">  bool proveNoWrapByVaryingStart(const SCEV *Start, const SCEV *Step,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2051</td>
    <td class="codeLine">                                 const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2051</td>
    <td class="codeLine">                                 const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2052</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2053</td>
    <td class="codeLine">  /// Try to prove NSW or NUW on \p AR relying on ConstantRange manipulation.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2053</td>
    <td class="codeLine">  /// Try to prove NSW or NUW on \p AR relying on ConstantRange manipulation.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2054</td>
    <td class="codeLine">  SCEV::NoWrapFlags proveNoWrapViaConstantRanges(const SCEVAddRecExpr *AR);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2054</td>
    <td class="codeLine">  SCEV::NoWrapFlags proveNoWrapViaConstantRanges(const SCEVAddRecExpr *AR);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2055</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2056</td>
    <td class="codeLine">  /// Try to prove NSW on \p AR by proving facts about conditions known  on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2056</td>
    <td class="codeLine">  /// Try to prove NSW on \p AR by proving facts about conditions known  on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2057</td>
    <td class="codeLine">  /// entry and backedge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2057</td>
    <td class="codeLine">  /// entry and backedge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2058</td>
    <td class="codeLine">  SCEV::NoWrapFlags proveNoSignedWrapViaInduction(const SCEVAddRecExpr *AR);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2058</td>
    <td class="codeLine">  SCEV::NoWrapFlags proveNoSignedWrapViaInduction(const SCEVAddRecExpr *AR);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2059</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2060</td>
    <td class="codeLine">  /// Try to prove NUW on \p AR by proving facts about conditions known on</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2060</td>
    <td class="codeLine">  /// Try to prove NUW on \p AR by proving facts about conditions known on</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2061</td>
    <td class="codeLine">  /// entry and backedge.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2061</td>
    <td class="codeLine">  /// entry and backedge.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2062</td>
    <td class="codeLine">  SCEV::NoWrapFlags proveNoUnsignedWrapViaInduction(const SCEVAddRecExpr *AR);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2062</td>
    <td class="codeLine">  SCEV::NoWrapFlags proveNoUnsignedWrapViaInduction(const SCEVAddRecExpr *AR);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2063</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2064</td>
    <td class="codeLine">  std::optional<MonotonicPredicateType></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2064</td>
    <td class="codeLine">  std::optional<MonotonicPredicateType></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2065</td>
    <td class="codeLine">  getMonotonicPredicateTypeImpl(const SCEVAddRecExpr *LHS,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2065</td>
    <td class="codeLine">  getMonotonicPredicateTypeImpl(const SCEVAddRecExpr *LHS,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2066</td>
    <td class="codeLine">                                ICmpInst::Predicate Pred);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2066</td>
    <td class="codeLine">                                ICmpInst::Predicate Pred);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2067</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2067</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2068</td>
    <td class="codeLine">  /// Return SCEV no-wrap flags that can be proven based on reasoning about</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2068</td>
    <td class="codeLine">  /// Return SCEV no-wrap flags that can be proven based on reasoning about</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2069</td>
    <td class="codeLine">  /// how poison produced from no-wrap flags on this value (e.g. a nuw add)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2069</td>
    <td class="codeLine">  /// how poison produced from no-wrap flags on this value (e.g. a nuw add)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2070</td>
    <td class="codeLine">  /// would trigger undefined behavior on overflow.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2070</td>
    <td class="codeLine">  /// would trigger undefined behavior on overflow.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2071</td>
    <td class="codeLine">  SCEV::NoWrapFlags getNoWrapFlagsFromUB(const Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2071</td>
    <td class="codeLine">  SCEV::NoWrapFlags getNoWrapFlagsFromUB(const Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2072</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2073</td>
    <td class="codeLine">  /// Return a scope which provides an upper bound on the defining scope of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2073</td>
    <td class="codeLine">  /// Return a scope which provides an upper bound on the defining scope of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2074</td>
    <td class="codeLine">  /// 'S'. Specifically, return the first instruction in said bounding scope.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2074</td>
    <td class="codeLine">  /// 'S'. Specifically, return the first instruction in said bounding scope.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2075</td>
    <td class="codeLine">  /// Return nullptr if the scope is trivial (function entry).</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2075</td>
    <td class="codeLine">  /// Return nullptr if the scope is trivial (function entry).</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2076</td>
    <td class="codeLine">  /// (See scope definition rules associated with flag discussion above)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2076</td>
    <td class="codeLine">  /// (See scope definition rules associated with flag discussion above)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2077</td>
    <td class="codeLine">  const Instruction *getNonTrivialDefiningScopeBound(const SCEV *S);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2077</td>
    <td class="codeLine">  const Instruction *getNonTrivialDefiningScopeBound(const SCEV *S);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2078</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2079</td>
    <td class="codeLine">  /// Return a scope which provides an upper bound on the defining scope for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2079</td>
    <td class="codeLine">  /// Return a scope which provides an upper bound on the defining scope for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2080</td>
    <td class="codeLine">  /// a SCEV with the operands in Ops.  The outparam Precise is set if the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2080</td>
    <td class="codeLine">  /// a SCEV with the operands in Ops.  The outparam Precise is set if the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2081</td>
    <td class="codeLine">  /// bound found is a precise bound (i.e. must be the defining scope.)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2081</td>
    <td class="codeLine">  /// bound found is a precise bound (i.e. must be the defining scope.)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2082</td>
    <td class="codeLine">  const Instruction *getDefiningScopeBound(ArrayRef<const SCEV *> Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2082</td>
    <td class="codeLine">  const Instruction *getDefiningScopeBound(ArrayRef<const SCEV *> Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2083</td>
    <td class="codeLine">                                           bool &Precise);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2083</td>
    <td class="codeLine">                                           bool &Precise);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2084</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2085</td>
    <td class="codeLine">  /// Wrapper around the above for cases which don't care if the bound</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2085</td>
    <td class="codeLine">  /// Wrapper around the above for cases which don't care if the bound</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2086</td>
    <td class="codeLine">  /// is precise.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2086</td>
    <td class="codeLine">  /// is precise.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2087</td>
    <td class="codeLine">  const Instruction *getDefiningScopeBound(ArrayRef<const SCEV *> Ops);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2087</td>
    <td class="codeLine">  const Instruction *getDefiningScopeBound(ArrayRef<const SCEV *> Ops);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2088</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2089</td>
    <td class="codeLine">  /// Given two instructions in the same function, return true if we can</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2089</td>
    <td class="codeLine">  /// Given two instructions in the same function, return true if we can</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2090</td>
    <td class="codeLine">  /// prove B must execute given A executes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2090</td>
    <td class="codeLine">  /// prove B must execute given A executes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2091</td>
    <td class="codeLine">  bool isGuaranteedToTransferExecutionTo(const Instruction *A,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2091</td>
    <td class="codeLine">  bool isGuaranteedToTransferExecutionTo(const Instruction *A,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2092</td>
    <td class="codeLine">                                         const Instruction *B);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2092</td>
    <td class="codeLine">                                         const Instruction *B);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2093</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2094</td>
    <td class="codeLine">  /// Return true if the SCEV corresponding to \p I is never poison.  Proving</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2094</td>
    <td class="codeLine">  /// Return true if the SCEV corresponding to \p I is never poison.  Proving</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2095</td>
    <td class="codeLine">  /// this is more complex than proving that just \p I is never poison, since</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2095</td>
    <td class="codeLine">  /// this is more complex than proving that just \p I is never poison, since</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2096</td>
    <td class="codeLine">  /// SCEV commons expressions across control flow, and you can have cases</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2096</td>
    <td class="codeLine">  /// SCEV commons expressions across control flow, and you can have cases</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2097</td>
    <td class="codeLine">  /// like:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2097</td>
    <td class="codeLine">  /// like:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2098</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2098</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2099</td>
    <td class="codeLine">  ///   idx0 = a + b;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2099</td>
    <td class="codeLine">  ///   idx0 = a + b;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2100</td>
    <td class="codeLine">  ///   ptr[idx0] = 100;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2100</td>
    <td class="codeLine">  ///   ptr[idx0] = 100;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2101</td>
    <td class="codeLine">  ///   if (<condition>) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2101</td>
    <td class="codeLine">  ///   if (<condition>) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2102</td>
    <td class="codeLine">  ///     idx1 = a +nsw b;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2102</td>
    <td class="codeLine">  ///     idx1 = a +nsw b;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2103</td>
    <td class="codeLine">  ///     ptr[idx1] = 200;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2103</td>
    <td class="codeLine">  ///     ptr[idx1] = 200;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2104</td>
    <td class="codeLine">  ///   }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2104</td>
    <td class="codeLine">  ///   }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2105</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2105</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2106</td>
    <td class="codeLine">  /// where the SCEV expression (+ a b) is guaranteed to not be poison (and</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2106</td>
    <td class="codeLine">  /// where the SCEV expression (+ a b) is guaranteed to not be poison (and</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2107</td>
    <td class="codeLine">  /// hence not sign-overflow) only if "<condition>" is true.  Since both</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2107</td>
    <td class="codeLine">  /// hence not sign-overflow) only if "<condition>" is true.  Since both</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2108</td>
    <td class="codeLine">  /// `idx0` and `idx1` will be mapped to the same SCEV expression, (+ a b),</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2108</td>
    <td class="codeLine">  /// `idx0` and `idx1` will be mapped to the same SCEV expression, (+ a b),</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2109</td>
    <td class="codeLine">  /// it is not okay to annotate (+ a b) with <nsw> in the above example.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2109</td>
    <td class="codeLine">  /// it is not okay to annotate (+ a b) with <nsw> in the above example.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2110</td>
    <td class="codeLine">  bool isSCEVExprNeverPoison(const Instruction *I);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2110</td>
    <td class="codeLine">  bool isSCEVExprNeverPoison(const Instruction *I);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2111</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2112</td>
    <td class="codeLine">  /// This is like \c isSCEVExprNeverPoison but it specifically works for</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2112</td>
    <td class="codeLine">  /// This is like \c isSCEVExprNeverPoison but it specifically works for</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2113</td>
    <td class="codeLine">  /// instructions that will get mapped to SCEV add recurrences.  Return true</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2113</td>
    <td class="codeLine">  /// instructions that will get mapped to SCEV add recurrences.  Return true</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2114</td>
    <td class="codeLine">  /// if \p I will never generate poison under the assumption that \p I is an</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2114</td>
    <td class="codeLine">  /// if \p I will never generate poison under the assumption that \p I is an</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2115</td>
    <td class="codeLine">  /// add recurrence on the loop \p L.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2115</td>
    <td class="codeLine">  /// add recurrence on the loop \p L.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2116</td>
    <td class="codeLine">  bool isAddRecNeverPoison(const Instruction *I, const Loop *L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2116</td>
    <td class="codeLine">  bool isAddRecNeverPoison(const Instruction *I, const Loop *L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2117</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2118</td>
    <td class="codeLine">  /// Similar to createAddRecFromPHI, but with the additional flexibility of</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2118</td>
    <td class="codeLine">  /// Similar to createAddRecFromPHI, but with the additional flexibility of</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2119</td>
    <td class="codeLine">  /// suggesting runtime overflow checks in case casts are encountered.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2119</td>
    <td class="codeLine">  /// suggesting runtime overflow checks in case casts are encountered.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2120</td>
    <td class="codeLine">  /// If successful, the analysis records that for this loop, \p SymbolicPHI,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2120</td>
    <td class="codeLine">  /// If successful, the analysis records that for this loop, \p SymbolicPHI,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2121</td>
    <td class="codeLine">  /// which is the UnknownSCEV currently representing the PHI, can be rewritten</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2121</td>
    <td class="codeLine">  /// which is the UnknownSCEV currently representing the PHI, can be rewritten</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2122</td>
    <td class="codeLine">  /// into an AddRec, assuming some predicates; The function then returns the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2122</td>
    <td class="codeLine">  /// into an AddRec, assuming some predicates; The function then returns the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2123</td>
    <td class="codeLine">  /// AddRec and the predicates as a pair, and caches this pair in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2123</td>
    <td class="codeLine">  /// AddRec and the predicates as a pair, and caches this pair in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2124</td>
    <td class="codeLine">  /// PredicatedSCEVRewrites.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2124</td>
    <td class="codeLine">  /// PredicatedSCEVRewrites.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2125</td>
    <td class="codeLine">  /// If the analysis is not successful, a mapping from the \p SymbolicPHI to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2125</td>
    <td class="codeLine">  /// If the analysis is not successful, a mapping from the \p SymbolicPHI to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2126</td>
    <td class="codeLine">  /// itself (with no predicates) is recorded, and a nullptr with an empty</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2126</td>
    <td class="codeLine">  /// itself (with no predicates) is recorded, and a nullptr with an empty</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2127</td>
    <td class="codeLine">  /// predicates vector is returned as a pair.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2127</td>
    <td class="codeLine">  /// predicates vector is returned as a pair.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2128</td>
    <td class="codeLine">  std::optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2128</td>
    <td class="codeLine">  std::optional<std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2129</td>
    <td class="codeLine">  createAddRecFromPHIWithCastsImpl(const SCEVUnknown *SymbolicPHI);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2129</td>
    <td class="codeLine">  createAddRecFromPHIWithCastsImpl(const SCEVUnknown *SymbolicPHI);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2130</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2131</td>
    <td class="codeLine">  /// Compute the maximum backedge count based on the range of values</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2131</td>
    <td class="codeLine">  /// Compute the maximum backedge count based on the range of values</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2132</td>
    <td class="codeLine">  /// permitted by Start, End, and Stride. This is for loops of the form</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2132</td>
    <td class="codeLine">  /// permitted by Start, End, and Stride. This is for loops of the form</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2133</td>
    <td class="codeLine">  /// {Start, +, Stride} LT End.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2133</td>
    <td class="codeLine">  /// {Start, +, Stride} LT End.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2134</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2134</td>
    <td class="codeLine">  ///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2135</td>
    <td class="codeLine">  /// Preconditions:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2135</td>
    <td class="codeLine">  /// Preconditions:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2136</td>
    <td class="codeLine">  /// * the induction variable is known to be positive.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2136</td>
    <td class="codeLine">  /// * the induction variable is known to be positive.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2137</td>
    <td class="codeLine">  /// * the induction variable is assumed not to overflow (i.e. either it</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2137</td>
    <td class="codeLine">  /// * the induction variable is assumed not to overflow (i.e. either it</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2138</td>
    <td class="codeLine">  ///   actually doesn't, or we'd have to immediately execute UB)</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2138</td>
    <td class="codeLine">  ///   actually doesn't, or we'd have to immediately execute UB)</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2139</td>
    <td class="codeLine">  /// We *don't* assert these preconditions so please be careful.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2139</td>
    <td class="codeLine">  /// We *don't* assert these preconditions so please be careful.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2140</td>
    <td class="codeLine">  const SCEV *computeMaxBECountForLT(const SCEV *Start, const SCEV *Stride,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2140</td>
    <td class="codeLine">  const SCEV *computeMaxBECountForLT(const SCEV *Start, const SCEV *Stride,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2141</td>
    <td class="codeLine">                                     const SCEV *End, unsigned BitWidth,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2141</td>
    <td class="codeLine">                                     const SCEV *End, unsigned BitWidth,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2142</td>
    <td class="codeLine">                                     bool IsSigned);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2142</td>
    <td class="codeLine">                                     bool IsSigned);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2143</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2144</td>
    <td class="codeLine">  /// Verify if an linear IV with positive stride can overflow when in a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2144</td>
    <td class="codeLine">  /// Verify if an linear IV with positive stride can overflow when in a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2145</td>
    <td class="codeLine">  /// less-than comparison, knowing the invariant term of the comparison,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2145</td>
    <td class="codeLine">  /// less-than comparison, knowing the invariant term of the comparison,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2146</td>
    <td class="codeLine">  /// the stride.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2146</td>
    <td class="codeLine">  /// the stride.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2147</td>
    <td class="codeLine">  bool canIVOverflowOnLT(const SCEV *RHS, const SCEV *Stride, bool IsSigned);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2147</td>
    <td class="codeLine">  bool canIVOverflowOnLT(const SCEV *RHS, const SCEV *Stride, bool IsSigned);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2148</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2149</td>
    <td class="codeLine">  /// Verify if an linear IV with negative stride can overflow when in a</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2149</td>
    <td class="codeLine">  /// Verify if an linear IV with negative stride can overflow when in a</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2150</td>
    <td class="codeLine">  /// greater-than comparison, knowing the invariant term of the comparison,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2150</td>
    <td class="codeLine">  /// greater-than comparison, knowing the invariant term of the comparison,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2151</td>
    <td class="codeLine">  /// the stride.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2151</td>
    <td class="codeLine">  /// the stride.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2152</td>
    <td class="codeLine">  bool canIVOverflowOnGT(const SCEV *RHS, const SCEV *Stride, bool IsSigned);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2152</td>
    <td class="codeLine">  bool canIVOverflowOnGT(const SCEV *RHS, const SCEV *Stride, bool IsSigned);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2153</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2154</td>
    <td class="codeLine">  /// Get add expr already created or create a new one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2154</td>
    <td class="codeLine">  /// Get add expr already created or create a new one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2155</td>
    <td class="codeLine">  const SCEV *getOrCreateAddExpr(ArrayRef<const SCEV *> Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2155</td>
    <td class="codeLine">  const SCEV *getOrCreateAddExpr(ArrayRef<const SCEV *> Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2156</td>
    <td class="codeLine">                                 SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2156</td>
    <td class="codeLine">                                 SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2157</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2158</td>
    <td class="codeLine">  /// Get mul expr already created or create a new one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2158</td>
    <td class="codeLine">  /// Get mul expr already created or create a new one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2159</td>
    <td class="codeLine">  const SCEV *getOrCreateMulExpr(ArrayRef<const SCEV *> Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2159</td>
    <td class="codeLine">  const SCEV *getOrCreateMulExpr(ArrayRef<const SCEV *> Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2160</td>
    <td class="codeLine">                                 SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2160</td>
    <td class="codeLine">                                 SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2161</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2162</td>
    <td class="codeLine">  // Get addrec expr already created or create a new one.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2162</td>
    <td class="codeLine">  // Get addrec expr already created or create a new one.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2163</td>
    <td class="codeLine">  const SCEV *getOrCreateAddRecExpr(ArrayRef<const SCEV *> Ops,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2163</td>
    <td class="codeLine">  const SCEV *getOrCreateAddRecExpr(ArrayRef<const SCEV *> Ops,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2164</td>
    <td class="codeLine">                                    const Loop *L, SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2164</td>
    <td class="codeLine">                                    const Loop *L, SCEV::NoWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2165</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2166</td>
    <td class="codeLine">  /// Return x if \p Val is f(x) where f is a 1-1 function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2166</td>
    <td class="codeLine">  /// Return x if \p Val is f(x) where f is a 1-1 function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2167</td>
    <td class="codeLine">  const SCEV *stripInjectiveFunctions(const SCEV *Val) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2167</td>
    <td class="codeLine">  const SCEV *stripInjectiveFunctions(const SCEV *Val) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2168</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2169</td>
    <td class="codeLine">  /// Find all of the loops transitively used in \p S, and fill \p LoopsUsed.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2169</td>
    <td class="codeLine">  /// Find all of the loops transitively used in \p S, and fill \p LoopsUsed.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2170</td>
    <td class="codeLine">  /// A loop is considered "used" by an expression if it contains</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2170</td>
    <td class="codeLine">  /// A loop is considered "used" by an expression if it contains</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2171</td>
    <td class="codeLine">  /// an add rec on said loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2171</td>
    <td class="codeLine">  /// an add rec on said loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2172</td>
    <td class="codeLine">  void getUsedLoops(const SCEV *S, SmallPtrSetImpl<const Loop *> &LoopsUsed);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2172</td>
    <td class="codeLine">  void getUsedLoops(const SCEV *S, SmallPtrSetImpl<const Loop *> &LoopsUsed);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2173</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2174</td>
    <td class="codeLine">  /// Try to match the pattern generated by getURemExpr(A, B). If successful,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2174</td>
    <td class="codeLine">  /// Try to match the pattern generated by getURemExpr(A, B). If successful,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2175</td>
    <td class="codeLine">  /// Assign A and B to LHS and RHS, respectively.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2175</td>
    <td class="codeLine">  /// Assign A and B to LHS and RHS, respectively.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2176</td>
    <td class="codeLine">  bool matchURem(const SCEV *Expr, const SCEV *&LHS, const SCEV *&RHS);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2176</td>
    <td class="codeLine">  bool matchURem(const SCEV *Expr, const SCEV *&LHS, const SCEV *&RHS);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2177</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2178</td>
    <td class="codeLine">  /// Look for a SCEV expression with type `SCEVType` and operands `Ops` in</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2178</td>
    <td class="codeLine">  /// Look for a SCEV expression with type `SCEVType` and operands `Ops` in</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2179</td>
    <td class="codeLine">  /// `UniqueSCEVs`.  Return if found, else nullptr.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2179</td>
    <td class="codeLine">  /// `UniqueSCEVs`.  Return if found, else nullptr.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2180</td>
    <td class="codeLine">  SCEV *findExistingSCEVInCache(SCEVTypes SCEVType, ArrayRef<const SCEV *> Ops);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2180</td>
    <td class="codeLine">  SCEV *findExistingSCEVInCache(SCEVTypes SCEVType, ArrayRef<const SCEV *> Ops);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2181</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2182</td>
    <td class="codeLine">  /// Get reachable blocks in this function, making limited use of SCEV</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2182</td>
    <td class="codeLine">  /// Get reachable blocks in this function, making limited use of SCEV</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2183</td>
    <td class="codeLine">  /// reasoning about conditions.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2183</td>
    <td class="codeLine">  /// reasoning about conditions.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2184</td>
    <td class="codeLine">  void getReachableBlocks(SmallPtrSetImpl<BasicBlock *> &Reachable,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2184</td>
    <td class="codeLine">  void getReachableBlocks(SmallPtrSetImpl<BasicBlock *> &Reachable,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2185</td>
    <td class="codeLine">                          Function &F);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2185</td>
    <td class="codeLine">                          Function &F);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2186</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2187</td>
    <td class="codeLine">  /// Return the given SCEV expression with a new set of operands.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2187</td>
    <td class="codeLine">  /// Return the given SCEV expression with a new set of operands.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2188</td>
    <td class="codeLine">  /// This preserves the origial nowrap flags.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2188</td>
    <td class="codeLine">  /// This preserves the origial nowrap flags.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2189</td>
    <td class="codeLine">  const SCEV *getWithOperands(const SCEV *S,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2189</td>
    <td class="codeLine">  const SCEV *getWithOperands(const SCEV *S,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2190</td>
    <td class="codeLine">                              SmallVectorImpl<const SCEV *> &NewOps);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2190</td>
    <td class="codeLine">                              SmallVectorImpl<const SCEV *> &NewOps);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2191</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2192</td>
    <td class="codeLine">  FoldingSet<SCEV> UniqueSCEVs;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2192</td>
    <td class="codeLine">  FoldingSet<SCEV> UniqueSCEVs;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2193</td>
    <td class="codeLine">  FoldingSet<SCEVPredicate> UniquePreds;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2193</td>
    <td class="codeLine">  FoldingSet<SCEVPredicate> UniquePreds;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2194</td>
    <td class="codeLine">  BumpPtrAllocator SCEVAllocator;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2194</td>
    <td class="codeLine">  BumpPtrAllocator SCEVAllocator;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2195</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2196</td>
    <td class="codeLine">  /// This maps loops to a list of addrecs that directly use said loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2196</td>
    <td class="codeLine">  /// This maps loops to a list of addrecs that directly use said loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2197</td>
    <td class="codeLine">  DenseMap<const Loop *, SmallVector<const SCEVAddRecExpr *, 4>> LoopUsers;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2197</td>
    <td class="codeLine">  DenseMap<const Loop *, SmallVector<const SCEVAddRecExpr *, 4>> LoopUsers;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2198</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2199</td>
    <td class="codeLine">  /// Cache tentative mappings from UnknownSCEVs in a Loop, to a SCEV expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2199</td>
    <td class="codeLine">  /// Cache tentative mappings from UnknownSCEVs in a Loop, to a SCEV expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2200</td>
    <td class="codeLine">  /// they can be rewritten into under certain predicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2200</td>
    <td class="codeLine">  /// they can be rewritten into under certain predicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2201</td>
    <td class="codeLine">  DenseMap<std::pair<const SCEVUnknown *, const Loop *>,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2201</td>
    <td class="codeLine">  DenseMap<std::pair<const SCEVUnknown *, const Loop *>,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2202</td>
    <td class="codeLine">           std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2202</td>
    <td class="codeLine">           std::pair<const SCEV *, SmallVector<const SCEVPredicate *, 3>>></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2203</td>
    <td class="codeLine">      PredicatedSCEVRewrites;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2203</td>
    <td class="codeLine">      PredicatedSCEVRewrites;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2204</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2205</td>
    <td class="codeLine">  /// Set of AddRecs for which proving NUW via an induction has already been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2205</td>
    <td class="codeLine">  /// Set of AddRecs for which proving NUW via an induction has already been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2206</td>
    <td class="codeLine">  /// tried.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2206</td>
    <td class="codeLine">  /// tried.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2207</td>
    <td class="codeLine">  SmallPtrSet<const SCEVAddRecExpr *, 16> UnsignedWrapViaInductionTried;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2207</td>
    <td class="codeLine">  SmallPtrSet<const SCEVAddRecExpr *, 16> UnsignedWrapViaInductionTried;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2208</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2209</td>
    <td class="codeLine">  /// Set of AddRecs for which proving NSW via an induction has already been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2209</td>
    <td class="codeLine">  /// Set of AddRecs for which proving NSW via an induction has already been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2210</td>
    <td class="codeLine">  /// tried.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2210</td>
    <td class="codeLine">  /// tried.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2211</td>
    <td class="codeLine">  SmallPtrSet<const SCEVAddRecExpr *, 16> SignedWrapViaInductionTried;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2211</td>
    <td class="codeLine">  SmallPtrSet<const SCEVAddRecExpr *, 16> SignedWrapViaInductionTried;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2212</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2213</td>
    <td class="codeLine">  /// The head of a linked list of all SCEVUnknown values that have been</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2213</td>
    <td class="codeLine">  /// The head of a linked list of all SCEVUnknown values that have been</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2214</td>
    <td class="codeLine">  /// allocated. This is used by releaseMemory to locate them all and call</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2214</td>
    <td class="codeLine">  /// allocated. This is used by releaseMemory to locate them all and call</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2215</td>
    <td class="codeLine">  /// their destructors.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2215</td>
    <td class="codeLine">  /// their destructors.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2216</td>
    <td class="codeLine">  SCEVUnknown *FirstUnknown = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2216</td>
    <td class="codeLine">  SCEVUnknown *FirstUnknown = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2217</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2217</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2218</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2219</td>
    <td class="codeLine">/// Analysis pass that exposes the \c ScalarEvolution for a function.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2219</td>
    <td class="codeLine">/// Analysis pass that exposes the \c ScalarEvolution for a function.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2220</td>
    <td class="codeLine">class ScalarEvolutionAnalysis</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2220</td>
    <td class="codeLine">class ScalarEvolutionAnalysis</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2221</td>
    <td class="codeLine">    : public AnalysisInfoMixin<ScalarEvolutionAnalysis> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2221</td>
    <td class="codeLine">    : public AnalysisInfoMixin<ScalarEvolutionAnalysis> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2222</td>
    <td class="codeLine">  friend AnalysisInfoMixin<ScalarEvolutionAnalysis>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2222</td>
    <td class="codeLine">  friend AnalysisInfoMixin<ScalarEvolutionAnalysis>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2223</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2224</td>
    <td class="codeLine">  static AnalysisKey Key;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2224</td>
    <td class="codeLine">  static AnalysisKey Key;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2225</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2226</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2226</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2227</td>
    <td class="codeLine">  using Result = ScalarEvolution;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2227</td>
    <td class="codeLine">  using Result = ScalarEvolution;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2228</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2229</td>
    <td class="codeLine">  ScalarEvolution run(Function &F, FunctionAnalysisManager &AM);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2229</td>
    <td class="codeLine">  ScalarEvolution run(Function &F, FunctionAnalysisManager &AM);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2230</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2230</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2231</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2232</td>
    <td class="codeLine">/// Verifier pass for the \c ScalarEvolutionAnalysis results.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2232</td>
    <td class="codeLine">/// Verifier pass for the \c ScalarEvolutionAnalysis results.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2233</td>
    <td class="codeLine">class ScalarEvolutionVerifierPass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2233</td>
    <td class="codeLine">class ScalarEvolutionVerifierPass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2234</td>
    <td class="codeLine">    : public PassInfoMixin<ScalarEvolutionVerifierPass> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2234</td>
    <td class="codeLine">    : public PassInfoMixin<ScalarEvolutionVerifierPass> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2235</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2235</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2236</td>
    <td class="codeLine">  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2236</td>
    <td class="codeLine">  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2237</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2237</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2238</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2239</td>
    <td class="codeLine">/// Printer pass for the \c ScalarEvolutionAnalysis results.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2239</td>
    <td class="codeLine">/// Printer pass for the \c ScalarEvolutionAnalysis results.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2240</td>
    <td class="codeLine">class ScalarEvolutionPrinterPass</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2240</td>
    <td class="codeLine">class ScalarEvolutionPrinterPass</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2241</td>
    <td class="codeLine">    : public PassInfoMixin<ScalarEvolutionPrinterPass> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2241</td>
    <td class="codeLine">    : public PassInfoMixin<ScalarEvolutionPrinterPass> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2242</td>
    <td class="codeLine">  raw_ostream &OS;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2242</td>
    <td class="codeLine">  raw_ostream &OS;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2243</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2244</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2244</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2245</td>
    <td class="codeLine">  explicit ScalarEvolutionPrinterPass(raw_ostream &OS) : OS(OS) {}</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2245</td>
    <td class="codeLine">  explicit ScalarEvolutionPrinterPass(raw_ostream &OS) : OS(OS) {}</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2246</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2247</td>
    <td class="codeLine">  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2247</td>
    <td class="codeLine">  PreservedAnalyses run(Function &F, FunctionAnalysisManager &AM);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2248</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2248</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2249</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2250</td>
    <td class="codeLine">class ScalarEvolutionWrapperPass : public FunctionPass {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2250</td>
    <td class="codeLine">class ScalarEvolutionWrapperPass : public FunctionPass {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2251</td>
    <td class="codeLine">  std::unique_ptr<ScalarEvolution> SE;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2251</td>
    <td class="codeLine">  std::unique_ptr<ScalarEvolution> SE;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2252</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2253</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2253</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2254</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2254</td>
    <td class="codeLine">  static char ID;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2255</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2256</td>
    <td class="codeLine">  ScalarEvolutionWrapperPass();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2256</td>
    <td class="codeLine">  ScalarEvolutionWrapperPass();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2257</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2258</td>
    <td class="codeLine">  ScalarEvolution &getSE() { return *SE; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2258</td>
    <td class="codeLine">  ScalarEvolution &getSE() { return *SE; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2259</td>
    <td class="codeLine">  const ScalarEvolution &getSE() const { return *SE; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2259</td>
    <td class="codeLine">  const ScalarEvolution &getSE() const { return *SE; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2260</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2261</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2261</td>
    <td class="codeLine">  bool runOnFunction(Function &F) override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2262</td>
    <td class="codeLine">  void releaseMemory() override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2262</td>
    <td class="codeLine">  void releaseMemory() override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2263</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2263</td>
    <td class="codeLine">  void getAnalysisUsage(AnalysisUsage &AU) const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2264</td>
    <td class="codeLine">  void print(raw_ostream &OS, const Module * = nullptr) const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2264</td>
    <td class="codeLine">  void print(raw_ostream &OS, const Module * = nullptr) const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2265</td>
    <td class="codeLine">  void verifyAnalysis() const override;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2265</td>
    <td class="codeLine">  void verifyAnalysis() const override;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2266</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2266</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2267</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2268</td>
    <td class="codeLine">/// An interface layer with SCEV used to manage how we see SCEV expressions</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2268</td>
    <td class="codeLine">/// An interface layer with SCEV used to manage how we see SCEV expressions</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2269</td>
    <td class="codeLine">/// for values in the context of existing predicates. We can add new</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2269</td>
    <td class="codeLine">/// for values in the context of existing predicates. We can add new</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2270</td>
    <td class="codeLine">/// predicates, but we cannot remove them.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2270</td>
    <td class="codeLine">/// predicates, but we cannot remove them.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2271</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2271</td>
    <td class="codeLine">///</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2272</td>
    <td class="codeLine">/// This layer has multiple purposes:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2272</td>
    <td class="codeLine">/// This layer has multiple purposes:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2273</td>
    <td class="codeLine">///   - provides a simple interface for SCEV versioning.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2273</td>
    <td class="codeLine">///   - provides a simple interface for SCEV versioning.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2274</td>
    <td class="codeLine">///   - guarantees that the order of transformations applied on a SCEV</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2274</td>
    <td class="codeLine">///   - guarantees that the order of transformations applied on a SCEV</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2275</td>
    <td class="codeLine">///     expression for a single Value is consistent across two different</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2275</td>
    <td class="codeLine">///     expression for a single Value is consistent across two different</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2276</td>
    <td class="codeLine">///     getSCEV calls. This means that, for example, once we've obtained</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2276</td>
    <td class="codeLine">///     getSCEV calls. This means that, for example, once we've obtained</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2277</td>
    <td class="codeLine">///     an AddRec expression for a certain value through expression</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2277</td>
    <td class="codeLine">///     an AddRec expression for a certain value through expression</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2278</td>
    <td class="codeLine">///     rewriting, we will continue to get an AddRec expression for that</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2278</td>
    <td class="codeLine">///     rewriting, we will continue to get an AddRec expression for that</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2279</td>
    <td class="codeLine">///     Value.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2279</td>
    <td class="codeLine">///     Value.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2280</td>
    <td class="codeLine">///   - lowers the number of expression rewrites.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2280</td>
    <td class="codeLine">///   - lowers the number of expression rewrites.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2281</td>
    <td class="codeLine">class PredicatedScalarEvolution {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2281</td>
    <td class="codeLine">class PredicatedScalarEvolution {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2282</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2282</td>
    <td class="codeLine">public:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2283</td>
    <td class="codeLine">  PredicatedScalarEvolution(ScalarEvolution &SE, Loop &L);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2283</td>
    <td class="codeLine">  PredicatedScalarEvolution(ScalarEvolution &SE, Loop &L);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2284</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2285</td>
    <td class="codeLine">  const SCEVPredicate &getPredicate() const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2285</td>
    <td class="codeLine">  const SCEVPredicate &getPredicate() const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2286</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2287</td>
    <td class="codeLine">  /// Returns the SCEV expression of V, in the context of the current SCEV</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2287</td>
    <td class="codeLine">  /// Returns the SCEV expression of V, in the context of the current SCEV</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2288</td>
    <td class="codeLine">  /// predicate.  The order of transformations applied on the expression of V</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2288</td>
    <td class="codeLine">  /// predicate.  The order of transformations applied on the expression of V</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2289</td>
    <td class="codeLine">  /// returned by ScalarEvolution is guaranteed to be preserved, even when</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2289</td>
    <td class="codeLine">  /// returned by ScalarEvolution is guaranteed to be preserved, even when</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2290</td>
    <td class="codeLine">  /// adding new predicates.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2290</td>
    <td class="codeLine">  /// adding new predicates.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2291</td>
    <td class="codeLine">  const SCEV *getSCEV(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2291</td>
    <td class="codeLine">  const SCEV *getSCEV(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2292</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2293</td>
    <td class="codeLine">  /// Get the (predicated) backedge count for the analyzed loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2293</td>
    <td class="codeLine">  /// Get the (predicated) backedge count for the analyzed loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2294</td>
    <td class="codeLine">  const SCEV *getBackedgeTakenCount();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2294</td>
    <td class="codeLine">  const SCEV *getBackedgeTakenCount();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2295</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2296</td>
    <td class="codeLine">  /// Adds a new predicate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2296</td>
    <td class="codeLine">  /// Adds a new predicate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2297</td>
    <td class="codeLine">  void addPredicate(const SCEVPredicate &Pred);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2297</td>
    <td class="codeLine">  void addPredicate(const SCEVPredicate &Pred);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2298</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2299</td>
    <td class="codeLine">  /// Attempts to produce an AddRecExpr for V by adding additional SCEV</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2299</td>
    <td class="codeLine">  /// Attempts to produce an AddRecExpr for V by adding additional SCEV</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2300</td>
    <td class="codeLine">  /// predicates. If we can't transform the expression into an AddRecExpr we</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2300</td>
    <td class="codeLine">  /// predicates. If we can't transform the expression into an AddRecExpr we</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2301</td>
    <td class="codeLine">  /// return nullptr and not add additional SCEV predicates to the current</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2301</td>
    <td class="codeLine">  /// return nullptr and not add additional SCEV predicates to the current</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2302</td>
    <td class="codeLine">  /// context.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2302</td>
    <td class="codeLine">  /// context.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2303</td>
    <td class="codeLine">  const SCEVAddRecExpr *getAsAddRec(Value *V);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2303</td>
    <td class="codeLine">  const SCEVAddRecExpr *getAsAddRec(Value *V);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2304</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2305</td>
    <td class="codeLine">  /// Proves that V doesn't overflow by adding SCEV predicate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2305</td>
    <td class="codeLine">  /// Proves that V doesn't overflow by adding SCEV predicate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2306</td>
    <td class="codeLine">  void setNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2306</td>
    <td class="codeLine">  void setNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2307</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2308</td>
    <td class="codeLine">  /// Returns true if we've proved that V doesn't wrap by means of a SCEV</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2308</td>
    <td class="codeLine">  /// Returns true if we've proved that V doesn't wrap by means of a SCEV</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2309</td>
    <td class="codeLine">  /// predicate.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2309</td>
    <td class="codeLine">  /// predicate.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2310</td>
    <td class="codeLine">  bool hasNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2310</td>
    <td class="codeLine">  bool hasNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2311</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2312</td>
    <td class="codeLine">  /// Returns the ScalarEvolution analysis used.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2312</td>
    <td class="codeLine">  /// Returns the ScalarEvolution analysis used.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2313</td>
    <td class="codeLine">  ScalarEvolution *getSE() const { return &SE; }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2313</td>
    <td class="codeLine">  ScalarEvolution *getSE() const { return &SE; }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2314</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2315</td>
    <td class="codeLine">  /// We need to explicitly define the copy constructor because of FlagsMap.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2315</td>
    <td class="codeLine">  /// We need to explicitly define the copy constructor because of FlagsMap.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2316</td>
    <td class="codeLine">  PredicatedScalarEvolution(const PredicatedScalarEvolution &);</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2316</td>
    <td class="codeLine">  PredicatedScalarEvolution(const PredicatedScalarEvolution &);</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2317</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2318</td>
    <td class="codeLine">  /// Print the SCEV mappings done by the Predicated Scalar Evolution.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2318</td>
    <td class="codeLine">  /// Print the SCEV mappings done by the Predicated Scalar Evolution.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2319</td>
    <td class="codeLine">  /// The printed text is indented by \p Depth.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2319</td>
    <td class="codeLine">  /// The printed text is indented by \p Depth.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2320</td>
    <td class="codeLine">  void print(raw_ostream &OS, unsigned Depth) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2320</td>
    <td class="codeLine">  void print(raw_ostream &OS, unsigned Depth) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2321</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2321</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2322</td>
    <td class="codeLine">  /// Check if \p AR1 and \p AR2 are equal, while taking into account</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2322</td>
    <td class="codeLine">  /// Check if \p AR1 and \p AR2 are equal, while taking into account</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2323</td>
    <td class="codeLine">  /// Equal predicates in Preds.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2323</td>
    <td class="codeLine">  /// Equal predicates in Preds.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2324</td>
    <td class="codeLine">  bool areAddRecsEqualWithPreds(const SCEVAddRecExpr *AR1,</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2324</td>
    <td class="codeLine">  bool areAddRecsEqualWithPreds(const SCEVAddRecExpr *AR1,</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2325</td>
    <td class="codeLine">                                const SCEVAddRecExpr *AR2) const;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2325</td>
    <td class="codeLine">                                const SCEVAddRecExpr *AR2) const;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2326</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2327</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2327</td>
    <td class="codeLine">private:</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2328</td>
    <td class="codeLine">  /// Increments the version number of the predicate.  This needs to be called</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2328</td>
    <td class="codeLine">  /// Increments the version number of the predicate.  This needs to be called</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2329</td>
    <td class="codeLine">  /// every time the SCEV predicate changes.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2329</td>
    <td class="codeLine">  /// every time the SCEV predicate changes.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2330</td>
    <td class="codeLine">  void updateGeneration();</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2330</td>
    <td class="codeLine">  void updateGeneration();</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2331</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2332</td>
    <td class="codeLine">  /// Holds a SCEV and the version number of the SCEV predicate used to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2332</td>
    <td class="codeLine">  /// Holds a SCEV and the version number of the SCEV predicate used to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2333</td>
    <td class="codeLine">  /// perform the rewrite of the expression.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2333</td>
    <td class="codeLine">  /// perform the rewrite of the expression.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2334</td>
    <td class="codeLine">  using RewriteEntry = std::pair<unsigned, const SCEV *>;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2334</td>
    <td class="codeLine">  using RewriteEntry = std::pair<unsigned, const SCEV *>;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2335</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2336</td>
    <td class="codeLine">  /// Maps a SCEV to the rewrite result of that SCEV at a certain version</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2336</td>
    <td class="codeLine">  /// Maps a SCEV to the rewrite result of that SCEV at a certain version</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2337</td>
    <td class="codeLine">  /// number. If this number doesn't match the current Generation, we will</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2337</td>
    <td class="codeLine">  /// number. If this number doesn't match the current Generation, we will</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2338</td>
    <td class="codeLine">  /// need to do a rewrite. To preserve the transformation order of previous</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2338</td>
    <td class="codeLine">  /// need to do a rewrite. To preserve the transformation order of previous</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2339</td>
    <td class="codeLine">  /// rewrites, we will rewrite the previous result instead of the original</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2339</td>
    <td class="codeLine">  /// rewrites, we will rewrite the previous result instead of the original</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2340</td>
    <td class="codeLine">  /// SCEV.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2340</td>
    <td class="codeLine">  /// SCEV.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2341</td>
    <td class="codeLine">  DenseMap<const SCEV *, RewriteEntry> RewriteMap;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2341</td>
    <td class="codeLine">  DenseMap<const SCEV *, RewriteEntry> RewriteMap;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2342</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2343</td>
    <td class="codeLine">  /// Records what NoWrap flags we've added to a Value *.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2343</td>
    <td class="codeLine">  /// Records what NoWrap flags we've added to a Value *.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2344</td>
    <td class="codeLine">  ValueMap<Value *, SCEVWrapPredicate::IncrementWrapFlags> FlagsMap;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2344</td>
    <td class="codeLine">  ValueMap<Value *, SCEVWrapPredicate::IncrementWrapFlags> FlagsMap;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2345</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2346</td>
    <td class="codeLine">  /// The ScalarEvolution analysis.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2346</td>
    <td class="codeLine">  /// The ScalarEvolution analysis.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2347</td>
    <td class="codeLine">  ScalarEvolution &SE;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2347</td>
    <td class="codeLine">  ScalarEvolution &SE;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2348</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2349</td>
    <td class="codeLine">  /// The analyzed Loop.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2349</td>
    <td class="codeLine">  /// The analyzed Loop.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2350</td>
    <td class="codeLine">  const Loop &L;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2350</td>
    <td class="codeLine">  const Loop &L;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2351</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2352</td>
    <td class="codeLine">  /// The SCEVPredicate that forms our context. We will rewrite all</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2352</td>
    <td class="codeLine">  /// The SCEVPredicate that forms our context. We will rewrite all</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2353</td>
    <td class="codeLine">  /// expressions assuming that this predicate true.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2353</td>
    <td class="codeLine">  /// expressions assuming that this predicate true.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2354</td>
    <td class="codeLine">  std::unique_ptr<SCEVUnionPredicate> Preds;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2354</td>
    <td class="codeLine">  std::unique_ptr<SCEVUnionPredicate> Preds;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2355</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2356</td>
    <td class="codeLine">  /// Marks the version of the SCEV predicate used. When rewriting a SCEV</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2356</td>
    <td class="codeLine">  /// Marks the version of the SCEV predicate used. When rewriting a SCEV</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2357</td>
    <td class="codeLine">  /// expression we mark it with the version of the predicate. We use this to</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2357</td>
    <td class="codeLine">  /// expression we mark it with the version of the predicate. We use this to</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2358</td>
    <td class="codeLine">  /// figure out if the predicate has changed from the last rewrite of the</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2358</td>
    <td class="codeLine">  /// figure out if the predicate has changed from the last rewrite of the</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2359</td>
    <td class="codeLine">  /// SCEV. If so, we need to perform a new rewrite.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2359</td>
    <td class="codeLine">  /// SCEV. If so, we need to perform a new rewrite.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2360</td>
    <td class="codeLine">  unsigned Generation = 0;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2360</td>
    <td class="codeLine">  unsigned Generation = 0;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2361</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2362</td>
    <td class="codeLine">  /// The backedge taken count.</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2362</td>
    <td class="codeLine">  /// The backedge taken count.</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2363</td>
    <td class="codeLine">  const SCEV *BackedgeCount = nullptr;</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2363</td>
    <td class="codeLine">  const SCEV *BackedgeCount = nullptr;</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2364</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2364</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2365</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2366</td>
    <td class="codeLine">template <> struct DenseMapInfo<ScalarEvolution::FoldID> {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2366</td>
    <td class="codeLine">template <> struct DenseMapInfo<ScalarEvolution::FoldID> {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2367</td>
    <td class="codeLine">  static inline ScalarEvolution::FoldID getEmptyKey() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2367</td>
    <td class="codeLine">  static inline ScalarEvolution::FoldID getEmptyKey() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2368</td>
    <td class="codeLine">    ScalarEvolution::FoldID ID(0);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2368</td>
    <td class="codeLine">    ScalarEvolution::FoldID ID(0);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2369</td>
    <td class="codeLine">    return ID;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2369</td>
    <td class="codeLine">    return ID;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2370</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2370</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2371</td>
    <td class="codeLine">  static inline ScalarEvolution::FoldID getTombstoneKey() {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2371</td>
    <td class="codeLine">  static inline ScalarEvolution::FoldID getTombstoneKey() {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2372</td>
    <td class="codeLine">    ScalarEvolution::FoldID ID(1);</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2372</td>
    <td class="codeLine">    ScalarEvolution::FoldID ID(1);</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2373</td>
    <td class="codeLine">    return ID;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2373</td>
    <td class="codeLine">    return ID;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2374</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2374</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2375</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2376</td>
    <td class="codeLine">  static unsigned getHashValue(const ScalarEvolution::FoldID &Val) {</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2376</td>
    <td class="codeLine">  static unsigned getHashValue(const ScalarEvolution::FoldID &Val) {</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2377</td>
    <td class="codeLine">    return Val.computeHash();</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2377</td>
    <td class="codeLine">    return Val.computeHash();</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2378</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2378</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2379</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2380</td>
    <td class="codeLine">  static bool isEqual(const ScalarEvolution::FoldID &LHS,</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2380</td>
    <td class="codeLine">  static bool isEqual(const ScalarEvolution::FoldID &LHS,</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2381</td>
    <td class="codeLine">                      const ScalarEvolution::FoldID &RHS) {</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2381</td>
    <td class="codeLine">                      const ScalarEvolution::FoldID &RHS) {</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2382</td>
    <td class="codeLine">    return LHS == RHS;</td>
    <td class="lineNumber">0</td>
    <td class="lineNumber">2382</td>
    <td class="codeLine">    return LHS == RHS;</td>
    <td class="lineNumber">0</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2383</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2383</td>
    <td class="codeLine">  }</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2384</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2384</td>
    <td class="codeLine">};</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2385</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2386</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2386</td>
    <td class="codeLine">} // end namespace llvm</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2387</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2387</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2388</td>
    <td class="codeLine">#endif // LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2388</td>
    <td class="codeLine">#endif // LLVM_ANALYSIS_SCALAREVOLUTION_H</td>
    <td class="lineNumber">---</td>
  </tr>
  <tr class="mainTr">
    <td class="lineNumber">2389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
    <td class="lineNumber">2389</td>
    <td class="codeLine"></td>
    <td class="lineNumber">---</td>
  </tr>
</table>
    </div>
    <button id="myBtn" onclick="topFunction()" title="Go to top" type="button">Top</button>
    <script src="../Javascript/drop_down.js"></script>
    <script src="../Javascript/top_button.js"></script>
  </body>
</html>